["import sys\n \ninput = sys.stdin.readline\nN = int(input())\nP = list(map(int, input().split()))\n \ntarget = 1\nans = []\ni = 0\nwhile i < N: \n    if P[i] == target:\n        for j in range(i, target-1, -1):\n            P[j], P[j-1] = P[j-1], P[j]\n            ans.append(j)\n    \n        target = i+1\n        # print(\"i\", i, \"target\", target)\n    i += 1\n \n# print(P)\nif len(ans) != N-1:\n    print(-1)\n    return\nfor i in range(N):\n    if P[i] != i+1:\n        print(-1)\n        return\n \nprint(*ans, sep=\"\\n\")", "N = int(input())\nP = list(map(int,input().split()))\nsearch, count, flag, ans, pans = 1, 0, 0, [], []\nfor i in range(N):\n    x = P[i]\n    if x == search:\n        ans += pans[::-1]\n        if i < N-1:\n            if flag == 0:\n                print(-1)\n                return\n            search, count, flag, pans = i+1, 0, 0, []\n            P[i], x = P[i-1], P[i-1]\n        \n    if x != search:\n        if flag == 1:\n            print(-1)\n            return\n        if x > count+search+1:\n            flag = 1\n        pans.append(i+1)\n        count += 1\n        \nprint('\\n'.join(map(str,ans)))", "import sys\nsys.setrecursionlimit(1000000)\nfrom collections import defaultdict, deque, Counter\nfrom itertools import permutations\nfrom math import sqrt, gcd\nfrom functools import reduce\nfrom sys import stdin\nfrom bisect import bisect_right\n\n\ndef get_min(p):\n    n = len(p)\n    ret = [[] for _ in range(n)]\n    for i in reversed(list(range(n))):\n        if i == n - 1:\n            ret[i] = [i, p[i]]\n        elif p[i] < ret[i + 1][1]:\n            ret[i] = [i, p[i]]\n        else:\n            ret[i] = ret[i + 1]\n    return ret\n\ndef solve(n, p):\n    p2 = get_min(p)\n    # print(p2)\n    left = 0\n    ret = []\n    while left < n - 1:\n        if p[left] < p2[left + 1][1]:\n            left += 1\n            continue\n        right, m = p2[left + 1]\n        for i in reversed(list(range(left, right))):\n            p[i], p[i + 1] = p[i + 1], p[i]\n            ret.append(i + 1)\n        for i in range(left, right):\n            if i + 1 != p[i]:\n                return False\n        left = right\n    if len(ret) != n - 1:\n        return False\n    return ret\n\n\n\nn = int(input())\np = list(map(int, input().split()))\nans = solve(n, p)\nif ans:\n    assert len(ans) == n - 1\nif ans:\n    for a in ans:\n        print(a)\nelse:\n    print((-1))\n\n", "import sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef resolve():\n    n = int(input())\n    P = list(map(int, input().split()))\n    D = defaultdict(int)\n    for num in range(n):\n        D[P[num]] = num\n    res = []\n    used = set()\n    for num in range(1, n + 1):\n        idx = D[num]\n        while idx + 1 != num:\n            if idx + 1 > num:\n                swap = P[idx - 1]\n                if idx in used:\n                    print(-1)\n                    return\n                P[idx - 1] = P[idx]\n                P[idx] = swap\n                used.add(idx)\n                res.append(idx)\n            else:\n                swap = P[idx + 1]\n                if idx + 2 in used:\n                    print(-1)\n                    return\n                P[idx + 1] = P[idx]\n                P[idx] = swap\n                used.add(idx + 2)\n                res.append(idx + 2)\n            D[num] = D[swap]\n            D[swap] = idx\n            idx = D[num]\n            if len(used) > n - 1:\n                print(-1)\n                return\n    if len(res) != n - 1:\n        print(-1)\n        return\n\n    print(*res, sep=\"\\n\")\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "n = int(input())\np = list(map(lambda x:int(x)-1,input().split()))\n\nq = [0]*n\nfor i in range(n):\n    q[p[i]] = i\n\nans = []\ni = 0\nwhile i<n:\n    idx = q[i]\n    if i<idx:\n        for j in range(idx-1,i-1,-1):\n            p[j],p[j+1] = p[j+1],p[j]\n            ans.append(str(j+1))\n        i = idx\n    else:\n        i += 1\nif len(ans)==n-1 and all([p[i]==i for i in range(n)]):\n    print(\"\\n\".join(ans))\nelse:\n    print(-1)", "from collections import deque\nimport sys\n\nn = int(input())\np = list(map(int, input().split()))\n\nstack = deque([])\nmemo = [0] * (n-1)\n\nfor i in range(n-1):\n    if p[i] > (i + 1) and p[i+1] < (i + 2):\n        stack.append(i)\n        memo[i] = 1\n\nans = []\n\nwhile stack:\n    i = stack.pop()\n    if memo[i] == 2:\n        # print('p1')\n        print((-1))\n        return\n    p[i], p[i+1] = p[i+1], p[i]\n    memo[i] = 2\n    ans.append(i+1)\n\n    if i > 0 and p[i-1] > i and p[i] < (i+1) and memo[i-1] == 0:\n        stack.append(i-1)\n        memo[i-1] = 1\n\n    if i+2 < n and p[i+1] > (i+2) and p[i+2] < (i+3) and memo[i+1] == 0:\n        stack.append(i+1)\n        memo[i+1] = 1\n\n# print(p)\n# print(ans)\n\nif len(ans) != n-1:\n    # print('p2')\n    print((-1))\n    return\n\nf = 1\n\nfor i in range(n):\n    if p[i] != i+1:\n        f = 0\n        break\n\nif f:\n    for ansi in ans:\n        print(ansi)\nelse:\n    # print('p3')\n    print((-1))\n\n", "n = int(input())\np = list(map(int, input().split()))\n\nans, tmp, res = [], [], []\nlst = [i + 1 for i in range(n)]\nfor i in range(n):\n    if i != 0:\n        tmp.append(i)\n    if p[i] - 1 == len(ans) or i == n - 1:\n        res += [p[i]] + p[len(ans):i - 1]\n        ans += tmp[::-1]\n        tmp = []\n        p[i] = p[i - 1]\n    if i == n - 1:\n        res += [p[i]]\nprint(*(ans if res == lst else[-1]), sep='\\n')\n", "N = int(input())\nP = list(map(int, input().split()))\n\nindexes = [x for x in range(N + 1)]\nfor i in range(N):\n    indexes[P[i]] = i\n\nmoves = {}\nfor i in range(1, N):\n    moves[i] = False\n\nconf = []\nfor i in range(1, N+1):\n    while indexes[i] != i - 1:\n        if moves[indexes[i]] is True:\n            print((-1))\n            return\n        conf.append(indexes[i])\n        moves[indexes[i]] = True\n        \n        a, b = P[indexes[i] - 1], P[indexes[i]]\n        P[indexes[i] - 1], P[indexes[i]] = b, a\n        indexes[b], indexes[a] = indexes[a], indexes[b]\n\nif not all(moves.values()):\n    print((-1))\nelse:\n    print((\"\\n\".join(map(str,conf))))\n\n", "n = int(input())\np = list(map(int,input().split()))\ni = 0\nans = []\ntarget = 1\nwhile i < n:\n    if p[i] == target:\n        for j in range(i,target-1,-1):\n            p[j],p[j-1]= p[j-1],p[j]\n            ans.append(j)\n        target = i+1\n    i += 1\n\nif len(ans)!=n-1:\n    print((-1))\nelif p != [i for i in range(1,n+1)]:\n    print((-1))\nelse:\n    for j in ans:\n        print(j)\n", "def main():\n    N=int(input())\n    pos={}\n    P=list(map(int,input().split()))\n    for i in range(N):\n        pos[P[i]]=i\n    end=N\n    steps=[]\n    while(end>1):\n        if(pos[end]<(end-1)):\n            start=pos[end]\n            for j in range(start,end-1):\n                pos[P[j]]=j+1\n                pos[P[j+1]]=j\n                \n                temp=P[j]\n                P[j]=P[j+1]\n                P[j+1]=temp\n\n                steps.append(j+1)\n            end=start+1\n        elif(pos[end]>(end-1)):\n            break\n        else:\n            end-=1\n    flag=True\n    for i in range(N):\n        if(P[i]!=(i+1)):\n            flag=False\n            break\n    if(flag):\n        if(len(steps)!=(N-1)):\n            print((-1))\n        else:\n            for i in range(len(steps)):\n                print((steps[i]))\n    else:\n        print((-1))\ndef __starting_point():\n    main()\n\n                \n                \n\n__starting_point()", "import numpy as np\ndef main():\n    n = int(input())\n    P = np.fromstring(input(), np.int64, sep=' ')\n    D = np.arange(1, n+1) - P\n    if np.any(D == 0) or D[D > 0].sum() != n-1:\n        print((-1))\n        return\n    if np.any(np.diff(P[D<0]) < 0) or np.any(np.diff(P[D>0]) < 0):\n        print((-1))\n        return\n    for i in np.nonzero(D>0)[0]:\n        j = i\n        for _ in range(D[i]):\n            print(j)\n            j -= 1\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N, *P = map(int, open(0).read().split())\n\nA = []\n\ncur = 1\nfor i in range(N):\n    if P[i] == cur:\n        A += reversed(range(cur, i + 1))\n    elif P[i] != i + 2:\n        if i + 1 == N or P[i + 1] != cur:\n            print(-1)\n            return\n        A += reversed(range(cur, i + 2))\n        P[i + 1] = P[i]\n        cur = i + 2\n\nfor a in A:\n    print(a)", "from collections import deque\nN = int(input())\nP = list(map(int, input().split()))\nif P==list(range(2,N+1))+[1]:\n  print(*list(range(N-1,0,-1)), sep='\\n')\n  return\nans = []\nd = deque([(0,N-1)])\nwhile len(d):\n  left, right = d.popleft()\n  n = right-left+1\n  if n==1:\n    continue\n  if n==2:\n    if P[left]==left+1 and P[right]==right+1:\n      print(-1)\n      break\n    ans.append(left+1)\n    continue\n  min_a = 10**7\n  max_a = -1\n  for i in range(n-1):\n    if min(min_a, P[left+i+1]) == left+1 and max(max_a, P[left+i+1]) == left+1+i:\n      P[left+i], P[left+i+1] = P[left+i+1], P[left+i]\n      d.append((left, left+i))\n      d.append((left+i+1, right))\n      ans.append(left+i+1)\n      break\n    min_a = min(min_a, P[left+i])\n    max_a = max(max_a, P[left+i])\n  else:\n    print(-1)\n    break\nelse:\n  print(*ans, sep='\\n')", "n = int(input())\np = list(map(int, input().split()))\n\nunswapped = [True] * n\nswap_count = 0\nswap_order = []\nnow = 1\n\nfor i in range(1, n):\n    if p[i] == now:\n        for j in range(i, now - 1, -1):\n            if unswapped[j]:\n                unswapped[j] = False\n                swap_count += 1\n                swap_order.append(j)\n                p[j], p[j-1] = p[j-1], p[j]\n            else:\n                print(-1)\n                return\n        now = i + 1\n\nfor i in range(n):\n    if p[i] != i + 1:\n        print(-1)\n        return\n\nif swap_count == n - 1:\n    print(*swap_order, sep=\"\\n\")\nelse:\n    print(-1)", "N=int(input())\n*P, = map(int,input().split())\n \nQ = [0]*(N+1)\nfor i,p in enumerate(P,1):\n    Q[p] = i\n    \nans = []\ni = 1\nwhile(i < N) :\n    j = Q[i]\n    if j<=i:break\n    for k in range(j-1, i-1,-1):\n        ans.append(k)\n        P[k],P[k-1] = P[k-1],P[k]\n    i = j\n\nif len(ans)==N-1:\n    if P == list(range(1,N+1)) :\n        for out in ans:\n            print(out)\n    else :\n        print(-1)\nelse :\n    print(-1)", "import sys\nreadline = sys.stdin.readline\n\nN = int(readline())\nP = list(map(int,readline().split()))\n\n# P[i] > P[i + 1]\u3068\u306a\u3063\u3066\u3044\u308b\u3068\u3053\u308d\u3092\u4ea4\u63db\u3059\u308b\u306e\u3092\u7e70\u308a\u8fd4\u3059\n\n# \u4ea4\u63db\u3067\u304d\u308b\u30ad\u30fc\u306e\u96c6\u5408\n# \u4ea4\u63db\u3067\u304d\u306a\u3044\u30ad\u30fc\u306e\u96c6\u5408\n# \u3092\u6301\u3064\n# \u4ea4\u63db\u3067\u304d\u308b\u30ad\u30fc\u306e\u96c6\u5408\u3092\u4e00\u3064\u898b\u3066\u3001\u4ea4\u63db\u3059\u308b\n# \u4ea4\u63db\u3057\u305f\u7d50\u679ci - 1, i + 1\u304c\u305d\u308c\u305e\u308c\u4ea4\u63db\u53ef\u80fd\u304b\u3092\u78ba\u8a8d\u3059\u308b\n# \u4ea4\u63db\u53ef\u80fd\u304b\u3069\u3046\u304b\u306e\u7d50\u679c\u304c\u5909\u308f\u3063\u3066\u3044\u305f\u3089\u3001\u96c6\u5408\u9593\u3067\u79fb\u52d5\u3092\u884c\u3046\n# \u5168\u3066\u306e\u30ad\u30fc\u304c\u4f7f\u7528\u3055\u308c\u3066\u4e14\u3064P\u304c\u6607\u9806\u306b\u306a\u3063\u3066\u3044\u305f\u3089\u6210\u529f\n\ncan = set()\ncan_not = set()\ndone = set()\nans = []\nfor i in range(N - 1):\n  if P[i] > P[i + 1]:\n    can.add(i)\n  else:\n    can_not.add(i)\n\nfor i in range(N - 1):\n  if len(can) == 0: # \u6240\u8981\u56de\u6570\u306e\u4ea4\u63db\u304c\u3067\u304d\u306a\u3044\n    print(-1)\n    return\n  i = can.pop() # \u8981\u7d20\u3092\u53d6\u308a\u51fa\u3057\n  P[i], P[i + 1] = P[i + 1], P[i] # \u4ea4\u63db\u3059\u308b\n  ans.append(i)\n  done.add(i)\n  # \u3053\u306e\u7d50\u679c\u3001i - 1\u3068i\u304c\u4ea4\u63db\u53ef\u80fd\u306b\u306a\u3063\u3066\u3044\u308b\u304b\u3092\u78ba\u8a8d\u3059\u308b\n  if i - 1 >= 0 and i - 1 not in done:\n    if P[i - 1] > P[i]:\n      if i - 1 not in can:\n        can.add(i - 1)\n        can_not.remove(i - 1)\n    else:\n      if i - 1 in can:\n        can.remove(i - 1)\n        can_not.add(i - 1)\n  if i + 2 < N and i + 1 not in done:\n    if P[i + 1] > P[i + 2]:\n      if i + 1 not in can:\n        can.add(i + 1)\n        can_not.remove(i + 1)\n    else:\n      if i + 1 in can:\n        can.remove(i + 1)\n        can_not.add(i + 1)\n        \n# \u6240\u8981\u56de\u6570\u306e\u4ea4\u63db\u304c\u5b9f\u65bd\u3055\u308c\u305f\u306e\u3067\u3001\u3053\u306e\u6642\u70b9\u3067P\u304c\u6607\u9806\u306b\u306a\u3063\u3066\u3044\u308b\u304b\u3092\u78ba\u8a8d\nfor i in range(N - 1):\n  if P[i] > P[i + 1]:\n    print(-1)\n    return\n    \nfor a in ans:\n  print(a + 1)", "n = int(input())\np = list(map(lambda x:int(x)-1,input().split()))\n\nq = [0]*n\nfor i in range(n):\n    q[p[i]] = i\n\nans = []\ni = 0\nwhile i<n:\n    idx = q[i]\n    if i<idx:\n        for j in range(idx-1,i-1,-1):\n            p[j],p[j+1] = p[j+1],p[j]\n            ans.append(str(j+1))\n        i = idx\n    else:\n        i += 1\nif len(ans)==n-1 and all([p[i]==i for i in range(n)]):\n    print(\"\\n\".join(ans))\nelse:\n    print(-1)", "N = int(input())\nP = list(map(int,input().split()))\nsearch, before, count, flag, ans, pans = 1, 0, 0, 0, [], []\nfor i in range(N):\n    x = P[i]\n    if x == search:\n        if i < N-1 and flag == 0:\n            print(-1)\n            return\n        ans += pans[::-1]\n        before, search, count, flag, pans = search, i+1, 0, 0, []\n        P[i], x = P[i-1], P[i-1]\n    if x != search:\n        if flag == 1:\n            print(-1)\n            return\n        if x == count+search+1:\n            flag = 0\n        if x > count+search+1:\n            flag = 1\n        pans.append(i+1)\n        count += 1\n    #print(i,x,pans)\nprint('\\n'.join(map(str,ans)))", "n=int(input())\np=list(map(int,input().split()))\nans=[]\ntmp=1\nfor i in range(n-1):\n    if p[i]==tmp:\n        for j in range(i, tmp-1, -1):\n            p[j], p[j-1]=p[j-1], p[j]\n            ans.append(j)\n        tmp=i+1\nfor j in range(n-1, tmp-1, -1):\n    p[j], p[j-1]=p[j-1], p[j]\n    ans.append(j)\n\nfor i, p in enumerate(p,1):\n    if i!=p:\n        ans=-1\nif ans==-1:\n    print(ans)\nelse:\n    print(*ans, sep = \"\\n\")", "n = int(input())\np = list(map(int, input().split()))\n\nans, tmp, res = [], [], []\nfor i in range(n):\n    if i != 0:\n        tmp.append(i)\n    if p[i] - 1 == len(ans):\n        res += [p[i]] + p[len(ans):i - 1]\n        ans += tmp[::-1]\n        tmp = []\n        p[i] = p[i - 1]\nelse:\n    res += [p[i]] + p[len(ans):-1]\n    ans += tmp[::-1]\nprint(*(ans if res == [i + 1 for i in range(n)] else[-1]), sep='\\n')\n", "\nicase=0\nif icase==0:\n    n=int(input())\n    p=list(map(int,input().split()))\n\nfor i in range(n):\n    p[i]-=1\n\npo=[0]*n\nfor i in range(n):\n    po[p[i]]=i\n    \ns=[i for i in range(n-1)]\npa=[i for i in range(n)]\n\ns=set(s)\nans=[]\n#print(\"po:\",po)\n#print(p)\n\nyn=\"\"\nfor i in range(n):\n#    print(\"i:\",i,\"po[i]:\",po[i])\n    if po[i]>i:\n        for ii in range(po[i],i,-1):\n#            print(p[ii],p[ii-1])\n            po[p[ii]],po[p[ii-1]]=ii-1,ii\n            p[ii],p[ii-1]=p[ii-1],p[ii]\n#            print(\"ii:\",ii,\"p\",p,\"po:\",po)\n            if ii-1 in s:\n                s.remove(ii-1)\n                ans.append(ii)\n            else:\n                yn=\"no\"\n                break\n            if len(s)==0:\n                break\n    elif po[i]<i:\n        for ii in range(po[i],i,1):\n            po[p[ii]],po[p[ii+1]]=ii+1,ii\n            p[ii],p[ii+1]=p[ii+1],p[ii]\n#            print(\"ii:\",ii,\"p\",p,\"po:\",po)\n#    print(\"i:\",i,p)\n            if ii-1 in s:\n                s.remove(ii-1)\n                ans.append(ii)\n            else:\n                yn=\"no\"\n                break\n            if len(s)==0:\n                break\n    if yn==\"no\" or len(s)==0:\n        break\n    \nif p==pa and len(s)==0:\n    for ansi in ans:\n        print(ansi)\nelse:\n    print((-1))\n    \n", "N = int(input())\nP = list(map(int, input().split()))\nans = []\nleft = 0\nwhile left<N-1:\n  if P[left]==left+1:\n    print(-1)\n    return\n  for i in range(left+1,N):\n    if P[i]==left+1:\n      for j in range(i,left,-1):\n        ans.append(j)\n        P[j-1], P[j] = P[j], P[j-1]\n      new_left = i\n      break\n  for i in range(left, new_left):\n    if P[i]!=i+1:\n      print(-1)\n      return\n  left = new_left\nprint(*ans, sep='\\n')\n", "n = int(input())\np = list(map(int, input().split()))\n\nans, tmp, res = [], [], []\nlst = [i + 1 for i in range(n)]\nfor i in range(n):\n    if i > 0:\n        tmp.append(i)\n    if p[i] - 1 == len(ans) or i == n - 1:\n        res += [p[i]] + p[len(ans):i - 1]\n        ans += tmp[::-1]\n        tmp, p[i] = [], p[i - 1]\nres += [p[i]]\nprint(*(ans if res == lst else[-1]), sep='\\n')\n", "N=int(input())\nP=list(map(int,input().split()))\n\nt = 1\nans = []\nfor i in range(N):\n  if P[i] == t:\n    for j in range(i, t-1, -1):\n      P[j], P[j-1] = P[j-1], P[j]\n      ans.append(j)\n    t = i + 1\n\nfor i in range(N):\n  if i+1 != P[i]:\n    print(-1)\n    return\nif len(ans) == N-1:\n  for x in ans:\n    print(x)\nelse:\n  print(-1)", "import numpy as np\nn = int(input())\np = list(map(int, input().split()))\np=p-np.ones((n,))\nswapped=np.zeros((n-1,))\nnow=0\nnoc=1\n\nfor now in range(0,n-1):\n  for i in range(now,n):\n    if (p[i]==now):\n      if(p[i]<i):\n        for j in range(int(i-1),int(p[i]-1),-1):\n          if swapped[j]!=0:\n            print(-1)\n            return\n          kari=p[j]\n          p[j]=p[j+1]\n          p[j+1]=kari\n          swapped[j]=noc  \n          noc+=1\n      break\nfor i in range(0,n-1):\n  if int(swapped[i])==0:\n    print(-1)\n    return\nfor i in range(0,n-1):\n  print(int(swapped[i])) ", "# swap(ps[right-1], ps[right]), swap(ps[right-2], ps[right-1]), ... swap(ps[left], ps[left+1])\ndef f(left, right, ps, acc):\n    for i in range(right - 1, left - 1, -1):\n        ps[i], ps[i + 1] = ps[i + 1], ps[i]\n        acc.append(i + 1)\n\ndef solve(n, ps, acc):\n    for i in range(n):\n        if ps[i] == i + 1:\n            return False\n\n    cur_number = 1\n    prev_idx = 0\n    cur_idx = 0\n    while cur_idx < n:\n        if ps[cur_idx] == cur_number:\n            f(prev_idx, cur_idx, ps, acc)\n            prev_idx = cur_idx\n            cur_number = cur_idx + 1\n        cur_idx += 1\n\n    for i in range(n):\n        if ps[i] != i + 1:\n            return False\n\n    return True\n\ndef __starting_point():\n    n = int(input())\n    ps = [int(p) for p in input().split()]\n    acc = []\n    if not solve(n, ps, acc):\n        print((-1))\n    else:\n        for line in acc:\n            print(line)\n\n__starting_point()", "n = int(input())\np = list(map(int, input().split()))\n\nans, tmp, res = [], [], []\nfor i in range(n):\n    if i != 0:\n        tmp.append(i)\n    if p[i] - 1 == len(ans):\n        res += [p[i]] + p[len(ans):i - 1]\n        ans += tmp[::-1]\n        tmp = []\n        p[i] = p[i - 1]\nelse:\n    res += [p[i]] + p[len(ans):i - 1]\n    ans += tmp[::-1]\nprint(*(ans if res == [i + 1 for i in range(n)] else[-1]), sep='\\n')\n", "import sys\n \ninput = sys.stdin.readline\nN = int(input())\nP = list(map(int, input().split()))\n \ntarget = 1\nans = []\nfor i in range(N):\n    if P[i] == target:\n        for j in range(i, target-1, -1):\n            P[j], P[j-1] = P[j-1], P[j]\n            ans.append(j)\n    \n        target = i+1\n        # print(\"i\", i, \"target\", target)\n    \n# print(P)\nif len(ans) != N-1:\n    print(-1)\n    return\nfor i in range(N):\n    if P[i] != i+1:\n        print(-1)\n        return\n \nprint(*ans, sep=\"\\n\")", "import sys\n \ninput = sys.stdin.readline\nN = int(input())\nP = list(map(int, input().split()))\n \ntarget = 1\nans = []\ni = 0\nwhile i < N: \n    if P[i] == target:\n        for j in range(i, target-1, -1):\n            P[j], P[j-1] = P[j-1], P[j]\n            ans.append(j)\n    \n        target = i+1\n        # print(\"i\", i, \"target\", target)\n    i += 1\n \n# print(P)\nif len(ans) != N-1:\n    print(-1)\n    return\nfor i in range(N):\n    if P[i] != i+1:\n        print(-1)\n        return\n \nprint(*ans, sep=\"\\n\")", "N = int(input())\nP = list([int(x) - 1 for x in input().split()])\npos = {P[i]: i for i in range(N)}\ncur = 0\nans = []\nfor i in range(N):\n    if pos[i] == i:\n        continue\n    start = pos[i]\n    for j in range(start, cur, -1):\n        ans.append(j)\n        pos[P[j]], pos[P[j - 1]] = pos[P[j - 1]], pos[P[j]]\n        P[j], P[j - 1] = P[j - 1], P[j]\n    cur = max(cur, start)\nif all(i == P[i] for i in range(N)) and cur == N - 1:\n    print((\"\\n\".join(map(str, ans))))\nelse:\n    print((-1))\n", "N = int(input())\nP = list([int(x) - 1 for x in input().split()])\nRP = [0] * N\nfor i, p in enumerate(P):\n    RP[p] = i\n\nused = [False] * N\n\nidx = 0\n\nused = [False] * (N - 1)\nrecord = []\nok = True\n\nwhile ok and idx != N:\n    cur = RP[idx]\n    # print(cur, idx)\n    while ok and cur != idx:\n        if cur > idx:\n            if used[cur - 1]:\n                ok = False\n                break\n            record.append(cur)\n            used[cur - 1] = True\n            RP[idx], RP[P[cur - 1]] = RP[idx] - 1, RP[P[cur - 1]] + 1\n            P[cur], P[cur - 1] = P[cur - 1], P[cur]\n\n            cur -= 1\n        else:\n            if used[cur]:\n                ok = False\n                break\n            record.append(cur + 1)\n            used[cur] = True\n            RP[idx], RP[P[cur + 1]] = RP[idx] + 1, RP[P[cur + 1]] - 1\n            P[cur], P[cur + 1] = P[cur + 1], P[cur]\n\n            cur += 1\n\n        # print(P, RP)\n    idx += 1\n\nif ok and len(record) == N - 1:\n    for ans in record:\n        print(ans)\nelse:\n    print((-1))\n#\n# print(used)\n", "import random\ndef solve(N,P):\n    operation = []\n    target = 1\n    confirmed_start = 0 \n    confirmed_end = -1\n\n    for i in range(N):\n        if P[i] == target:\n            for j in range(i-1, confirmed_start-1, -1): \n                P[j], P[j+1] = P[j+1], P[j]\n                operation.append(j+1)\n            \n            confirmed_end = i\n            for j in range(confirmed_start, confirmed_end):\n                if P[j] != j+1:\n                    print(-1)\n                    return\n            \n            target = i+1\n            confirmed_start = confirmed_end\n\n    if confirmed_end != N-1:\n        print(-1)\n        return\n\n    print(*operation, sep='\\n')\n\ndef __starting_point():\n    # N = 10\n    # nums = list(range(1,N+1))\n    # idx = list(range(N-1))\n    # order = random.sample(idx, len(idx))\n    # for o in order:\n    #     nums[o], nums[o+1] = nums[o+1], nums[o]\n\n    # print(nums)\n    # solve(N, nums)\n\n    N = int(input())\n    P = list(map(int,input().split()))\n    solve(N,P)\n\n__starting_point()", "def solve(n, p):\n    D = {x: i for i, x in enumerate(p)}\n    S = set()\n    ans = []\n    for x in range(1, n+1):\n        for j in range(D[x]-1, x-2, -1):\n            a, b = p[j], p[j+1]\n            p[j+1], p[j] = p[j], p[j+1]\n            D[a], D[b] = D[b], D[a]\n            ans.append(j+1)\n            if j in S:\n                return -1\n            S.add(j)\n    if len(ans) != n-1:\n        return -1\n    return \"\\n\".join(map(str, ans))\n\nn = int(input())\np = list(map(int, input().split()))\nprint(solve(n, p))", "import sys\n \ninput = sys.stdin.readline\nN = int(input())\nP = list(map(int, input().split()))\n \ntarget = 1\nans = []\ni = 0\nwhile i < N: \n    if P[i] == target:\n        for j in range(i, target-1, -1):\n            P[j], P[j-1] = P[j-1], P[j]\n            ans.append(j)\n    \n        target = i+1\n        # print(\"i\", i, \"target\", target)\n    i += 1\n\n# print(P)\nif len(ans) != N-1:\n    print(-1)\n    return\nfor i in range(N):\n    if P[i] != i+1:\n        print(-1)\n        return\n \nprint(*ans, sep=\"\\n\")", "N = int(input())\nA = list(map(int, input().split()))\nfor i in range(N):\n    A[i] -= 1\nX = [0]*N\nfor i in range(N):\n    X[A[i]] = i\nP = [False]*(N-1)\nnow = 0\nF = []\nflg = True\nwhile now < N:\n    if X[now] != now:\n        F.append(X[now])\n        X[now] -= 1\n        if P[X[now]]:\n            flg = False\n            break\n        P[X[now]] = True\n        A[X[now]], A[X[now]+1] = A[X[now]+1], A[X[now]]\n        X[A[X[now]+1]] += 1\n    else:\n        now += 1\nif flg and len(F) == N - 1:\n    for i in range(N-1):\n        print(F[i])\nelse:\n    print(-1)", "def LI():return list(map(int,input().split()))\ndef II():return int(input())\ndef LI():return list(map(int,input().split()))\ndef II():return int(input())\ndef yes():return print(\"Yes\")\ndef no():return print(\"No\")\nINF=float(\"inf\")\nfrom collections import deque, defaultdict, Counter\nfrom heapq import heappop, heappush\nfrom itertools import product, combinations\nfrom functools import reduce, lru_cache\nfrom math import pi, gcd\nfrom decimal import Decimal\n\nmod=998244353\nmod=10**9+7\n\nclass Combination:\n    \"\"\"\n    O(n)\u306e\u524d\u8a08\u7b97\u30921\u56de\u884c\u3046\u3053\u3068\u3067\uff0cO(1)\u3067nCr mod m\u3092\u6c42\u3081\u3089\u308c\u308b\n    n_max = 10**6\u306e\u3068\u304d\u524d\u51e6\u7406\u306f\u7d04950ms (PyPy\u306a\u3089\u7d04340ms, 10**7\u3067\u7d041800ms)\n    \u4f7f\u7528\u4f8b\uff1a\n    comb = Combination(1000000)\n    print(comb(5, 3))  # 10\n    \"\"\"\n    def __init__(self, n_max, mod=10**9+7):\n        self.mod = mod\n        self.modinv = self.make_modinv_list(n_max)\n        self.fac, self.facinv = self.make_factorial_list(n_max)\n\n    def __call__(self, n, r):\n        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n-r] % self.mod\n\n    def make_factorial_list(self, n):\n        # \u968e\u4e57\u306e\u30ea\u30b9\u30c8\u3068\u968e\u4e57\u306emod\u9006\u5143\u306e\u30ea\u30b9\u30c8\u3092\u8fd4\u3059 O(n)\n        # self.make_modinv_list()\u304c\u5148\u306b\u5b9f\u884c\u3055\u308c\u3066\u3044\u308b\u5fc5\u8981\u304c\u3042\u308b\n        fac = [1]\n        facinv = [1]\n        for i in range(1, n+1):\n            fac.append(fac[i-1] * i % self.mod)\n            facinv.append(facinv[i-1] * self.modinv[i] % self.mod)\n        return fac, facinv\n\n    def make_modinv_list(self, n):\n        # 0\u304b\u3089n\u307e\u3067\u306emod\u9006\u5143\u306e\u30ea\u30b9\u30c8\u3092\u8fd4\u3059 O(n)\n        modinv = [0] * (n+1)\n        modinv[1] = 1\n        for i in range(2, n+1):\n            modinv[i] = self.mod - self.mod//i * modinv[self.mod%i] % self.mod\n        return modinv\n\nclass Unionfind:\n    def __init__(self, N):\n        self.p = list(range(N))\n        self.rank = [0] * N\n        self.size = [1] * N\n\n    def root(self, x):\n        if self.p[x] != x:\n            self.p[x] = self.root(self.p[x])\n\n        return self.p[x]\n\n    def same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def unite(self, x, y):\n        u = self.root(x)\n        v = self.root(y)\n\n        if u == v: return\n\n        if self.rank[u] < self.rank[v]:\n            self.p[u] = v\n            self.size[v] += self.size[u]\n            self.size[u] = 0\n        else:\n            self.p[v] = u\n            self.size[u] += self.size[v]\n            self.size[v] = 0\n\n            if self.rank[u] == self.rank[v]:\n                self.rank[u] += 1\n\n    def count(self, x):\n        return self.size[self.root(x)]\n\n\n# \u30d5\u30ec\u30f3\u30ba\u3055\u3093\u306e\u6a21\u7bc4\u56de\u7b54\nclass dsu:\n\tdef __init__(self,n):\n\t\tself.cnt=[1]*n\n\t\tself.root=list(range(n))\n\tdef unite(self,x,y):\n\t\tx=self.root[x]\n\t\ty=self.root[y]\n\t\tif x!=y:\n\t\t\tif self.cnt[x]<self.cnt[y]:\n\t\t\t\tx,y=y,x\n\t\t\tself.cnt[x]+=self.cnt[y]\n\t\t\tself.root[y]=x\n\t\treturn x\n\tdef leader(self,x):\n\t\tif self.root[x]==x:\n\t\t\treturn x\n\t\tself.root[x]=self.leader(self.root[x])\n\t\treturn self.root[x]\n \n\n\nn=II()\np=LI()\n\nans=[]\nansset=set()\nind_list=[-1]*(n+1)\nfor ind,num in enumerate(p):\n    ind_list[num]=ind\nfor i in range(1,n+1):\n    a=ind_list[i]\n\n    while a>i-1:\n        p[a],p[a-1]=p[a-1],p[a]\n        ind_list[p[a]]+=1\n        ans.append(a)\n        if a in ansset:\n            print(-1)\n            return\n        ansset.add(a)\n        a-=1\nif p==list(range(1,n+1)):\n    if len(ans)==n-1:\n        for val in ans:\n            print(val)\n        return\n\nprint(-1)\n    \n    ", "def main():\n  import sys\n  input=sys.stdin.readline\n  n=int(input())\n  p=list(map(int,input().split()))\n  c=[-1]*n\n  for i in range(n):\n    p[i]-=1\n    c[p[i]]=i\n  r=[False]*(n-1)\n  ans=[]\n  for i in range(n):\n    j=c[i]\n    while j!=i:\n      if r[j-1]:\n        print(-1)\n        return\n      ans.append(j)\n      r[j-1]=True\n      p[j-1],p[j]=p[j],p[j-1]\n      c[p[j]]=j\n      c[p[j-1]]=j-1\n      j-=1\n  for i in r:\n    if not i:\n      print(-1)\n      return\n  for i in ans:\n    print(i)\nmain()", "N = int(input())\nP = list(map(int,input().split()))\nsearch, count, flag, ans, pans = 1, 0, 0, [], []\nfor i in range(N):\n    x = P[i]\n    if x == search:\n        ans += pans[::-1]\n        if i < N-1:\n            if flag == 0:\n                print(-1)\n                return\n            search, count, flag, pans = i+1, 0, 0, []\n            P[i], x = P[i-1], P[i-1]\n        \n    if x != search:\n        if flag == 1:\n            print(-1)\n            return\n        if x > count+search+1:\n            flag = 1\n        pans.append(i+1)\n        count += 1\n        \nfor k in ans:\n    print(k)", "n = int(input())\nP = list(map(int, input().rstrip().split(\" \")))\n\nA = [i+1 for i in range(n)]\nB = [1 for i in range(n)]\nstack = []\nisOK = True\n\nfor i, a in enumerate(A):\n    \n    if(isOK == False):\n        break\n    \n    p = P[i]\n    j = (p - 1)\n    \n    while(i+1 <= j):\n        if(B[j] < 0):\n            isOK = False\n            break\n        stack.append(j)\n        B[j] -= 1\n        A[j-1], A[j] = A[j], A[j-1]\n        j -= 1\n\nB[0] = 0\nfor i in range(n):\n    a = A[i]\n    b = B[i]\n    p = P[i]\n    if(a != p) or(b != 0):\n        isOK = False\n\nif(isOK):\n    for i in range(n-1):\n        print(stack.pop())\nelse:\n    print(-1)", "N = int(input())\nP = list(map(lambda x: int(x) - 1, input().split()))\n\nD = [0] * N\n\nfor i in range(N):\n    D[P[i]] = i\n\nlt = 0\nused = [0] * N\nres = []\n\nfor i in range(N):\n    if used[i]:\n        continue\n    if lt > D[i]:\n        print(-1)\n        break\n    rt = D[i]\n    for j in range(lt, rt)[::-1]:\n        D[P[j]], D[P[j + 1]] = D[P[j + 1]], D[P[j]]\n        P[j], P[j + 1] = P[j + 1], P[j]\n        res.append(j + 1)\n    for j in range(lt, rt):\n        used[j] = 1\n    lt = rt\nelse:\n    for i in range(N):\n        if P[i] != i:\n            print(-1)\n            break\n    else:\n        print('\\n'.join(map(str, res)))", "import sys\ndef main(N, P):\n    I = [-1] * N\n    for i, p in enumerate(P): I[p] = i\n    p = 0\n    s = 0\n    ans = []\n    while s < N:\n        i = I[p]\n        if s == i:\n            p += 1\n            s += 1\n            continue\n        for j in range(i, s, -1):\n            ans.append(j)\n        p += 1\n        for j in range(s, i - 1):\n            if P[j] != p:\n                return None\n            p += 1\n        s = i\n        p = s\n        P[i] = P[i - 1]\n        I[P[i]] = i\n    if len(ans) != N - 1:\n        return None\n    return ans\n\ndef __starting_point():\n    input = sys.stdin.readline\n    N = int(input())\n    *P, = [int(x) - 1 for x in input().split()]\n    ans = main(N, P)\n    if ans is None:\n        print((-1))\n    else:\n        for a in ans:\n            print(a)\n\n__starting_point()", "N = int(input())\nP = list(map(int, input().split()))\n\nP_idx = [0 for _ in range(N)]\nfor i in range(N):\n    P_idx[P[i]-1] = i\n\nans = []\ni = 0\nwhile i < N:\n    idx = P_idx[i]\n    if i < idx:\n        for j in range(idx-1, i-1, -1):\n            P[j], P[j+1] = P[j+1], P[j]\n            ans.append(j+1)\n        i = idx\n    else:\n        i += 1\n\ncheck = [i+1 for i in range(N)]\nif P == check and len(ans) == N-1:\n    for i in ans:\n        print(i)\nelse:\n    print((-1))\n", "import sys\n\nsys.setrecursionlimit(10 ** 6)\nn = int(input())\np = list(map(int, input().split()))\npos = [0] * n\nseen = [False] * n\nans = []\nfor i in range(n):\n    p[i] -= 1\n    pos[p[i]] = i\n\nfor i in range(n):\n    if pos[i] == i:\n        continue\n    for j in range(pos[i], i, -1):\n        if seen[j]:\n            print(-1)\n            return\n        seen[j] = True\n        p[j], p[j - 1] = p[j - 1], p[j]\n        pos[p[j]], pos[p[j - 1]] = j, j - 1\n        ans.append(j)\nif len(ans) == n - 1:\n    print(*ans, sep=\"\\n\")\nelse:\n    print(-1)\n", "import sys\ninput = sys.stdin.readline\n\nN = int(input())\nP = list(map(int, input().split()))\nans = []\ntag = 1\nprev = 0\n\nfor i in range(N):\n    if P[i]==tag:\n        for j in range(i-1, prev-1, -1):\n            P[j], P[j+1] = P[j+1], P[j]\n            ans.append(j+1)\n        \n        for j in range(prev, i):\n            if P[j]!=j+1:\n                print(-1)\n                return\n            \n        tag = i+1\n        prev = i\n    \nif len(ans)!=N-1:\n    print(-1)\n    return\n\nfor ans_i in ans:\n    print(ans_i)", "N = int(input())\nA = list(map(int, input().split()))\n\np = []\nfor i in range(1, N + 1):\n    p.append(i)\n\nfor i in range(N):\n    if p[i] == A[i]:\n        print((-1))\n        return\n\nindex = 0\nans = []\nfor i in range(N):\n    if A[i] == index + 1:\n        for j in range(i - 1, index - 1, -1):\n            A[j], A[j + 1] = A[j + 1], A[j]\n            ans.append(j + 1)\n        index = i\n\nfor i in range(len(A)):\n    if i == len(A) - 1:\n        break\n    if A[i] + 1 == A[i + 1]:\n        continue\n    else:\n        print((-1))\n        return\n\nfor i in ans:\n    print(i)\n", "n = int(input())\np = list(map(int, input().split()))\n\nans, tmp, res = [], [], []\nlst = [i + 1 for i in range(n)]\nfor i in range(n):\n    if i != 0:\n        tmp.append(i)\n    if p[i] - 1 == len(ans):\n        res += [p[i]] + p[len(ans):i - 1]\n        ans += tmp[::-1]\n        tmp = []\n        p[i] = p[i - 1]\n    if i == n - 1:\n        res += [p[i]] + p[len(ans):i - 1]\n        ans += tmp[::-1]\nprint(*(ans if res == lst else[-1]), sep='\\n')\n", "n = int(input())\nl = list(map(int, input().split()))\n\nl = [0] + l\n\npos = [0] * (n + 1)\nfor i in range(n + 1):\n    pos[l[i]] = i\n\nans = []\nflag = True\ntmp = n\nwhile tmp > 1:\n    ind = pos[tmp]\n    if ind < tmp:\n        for i in range(ind + 1, tmp):\n            if l[i + 1] != i:\n                flag = False\n                break\n            l[i - 1], l[i] = l[i], l[i - 1]\n            ans.append(i - 1)\n        if flag:\n            l[tmp - 1], l[tmp] = l[tmp], l[tmp - 1]\n            ans.append(tmp - 1)\n            tmp = ind\n        else:\n            break\n    else:\n        flag = False\n        break\n\nif flag:\n    for ele in ans:\n        print(ele)\nelse:\n    print(-1)", "import bisect,collections,copy,heapq,itertools,math,numpy,string,sys\ndef I(): return int(sys.stdin.readline().rstrip())\ndef LI(): return list(map(int,sys.stdin.readline().rstrip().split()))\ndef S(): return sys.stdin.readline().rstrip()\ndef LS(): return list(sys.stdin.readline().rstrip().split())\n\nN = I()\nP = [0]+LI()\nind = {i:0 for i in range(1,N)}\nfor i,p in enumerate(P[1:],1):\n    ind[p] = i\nans = []\nset_ans = set()\nfor i in range(1,N+1):\n    if ind[i]==i:\n        continue\n    while 1:\n        ind_i = ind[i]\n        P[ind_i],P[ind_i-1] = P[ind_i-1],P[ind_i]\n        ind[i] = ind_i-1\n        ind[P[ind_i]] = ind_i\n        if ind_i-1 in set_ans:\n            print((-1))\n            return\n        ans.append(ind_i-1)\n        set_ans.add(ind_i-1)\n        if ind[i]==i:\n            break\nif len(ans)==N-1:\n    for x in ans:\n        print(x)\nelse:\n    print((-1))\n", "N = int(input())\nP = list(map(int,input().split()))\nsearch, before, count, flag, ans, pans = 1, 0, 0, 0, [], []\nfor i in range(N):\n    x = P[i]\n    if x == search:\n        ans += pans[::-1]\n        if i < N-1:\n            if flag == 0:\n                print(-1)\n                return\n            before, search, count, flag, pans = search, i+1, 0, 0, []\n            P[i], x = P[i-1], P[i-1]\n        \n    if x != search:\n        if flag == 1:\n            print(-1)\n            return\n        if x > count+search+1:\n            flag = 1\n        pans.append(i+1)\n        count += 1\n        \nprint('\\n'.join(map(str,ans)))", "n = int(input())\np = list(map(int, input().split()))\nswapped=[0] * (n-1)\nnoc=1\n\nfor now in range(0,n-1):\n  if now>0 and swapped[now-1]==0:\n    print(-1)\n    return\n  for i in range(now,n):\n    if (p[i]-1==now):\n      if(p[i]-1<i):\n        for j in range(i-1,p[i]-2,-1):\n          if swapped[j]!=0:\n            print(-1)\n            return\n          p[j],p[j+1]=p[j+1],p[j]\n          swapped[j]=noc  \n          noc+=1\n      break\nif swapped[n-2]==0:\n  print(-1)\n  return\nfor i in range(0,n-1):\n  print(swapped[i])", "import copy\nN = int(input())\nPo = list(map(int,input().split()))\nP = copy.deepcopy(Po)\npos = [0 for i in range(N+1)]\nfor i in range(N) :\n    pos[P[i]] = i\n\ni = 1\nans = []\nwhile(i < N) :\n    j = pos[i]\n    if j<i : break\n    for k in range(j,i-1,-1) :\n        ans.append(k)\n        P[k-1],P[k] = P[k],P[k-1]\n    i = j+1\nif(len(ans)==N-1 and P == [i+1 for i in range(N)]) :\n    for out in ans :\n        print(out)\nelse :\n    print(-1)", "N = int(input())\nP_list = list(map(int, input().split()))\n\nnow = 1\npre = -1\nans = []\nfor i in range(N):\n    if P_list[i] == now:\n        for j in range(i-1, pre, -1):\n            P_list[j], P_list[j+1] = P_list[j+1], P_list[j]\n            ans.append(j+1)\n        now = i+1\n        pre = i-1\n\nif P_list == sorted(P_list) and len(ans) == N-1:\n        print(*ans, sep='\\n')\nelse:\n    print(-1)", "n=int(input())\nt=list(map(int,input().split()))\nt=[-1]+t\npos=1\nsol=[]\nfor i in range(1,n+1):\n    if t[i]==pos:\n        for j in range(i-1,pos-1,-1):\n            sol.append(j)\n            tmp=t[j]\n            t[j]=t[j+1]\n            t[j+1]=tmp\n        pos=i      \nfor i in range(1,n+1):\n    if t[i]!=i:\n        print((-1))\n        return\nif len(sol)!=n-1:\n    print((-1))\nelse:\n    for i in sol:\n        print(i)\n\n", "n = int(input())\np = list(map(int, input().split()))\n\nans, tmp, res = [], [], []\nlst = [i + 1 for i in range(n)]\nfor i in range(n):\n    if i != 0:\n        tmp.append(i)\n    if p[i] - 1 == len(ans) or i == n - 1:\n        res += [p[i]] + p[len(ans):i - 1]\n        ans += tmp[::-1]\n        tmp, p[i] = [], p[i - 1]\nres += [p[i]]\nprint(*(ans if res == lst else[-1]), sep='\\n')\n", "import copy\nN = int(input())\nPo = list(map(int,input().split()))\nP = copy.deepcopy(Po)\npos = [0 for i in range(N+1)]\nfor i in range(N) :\n    pos[P[i]] = i+1\n\ni = 1\nans = []\nwhile(i < N) :\n    j = pos[i]\n    if j<=i : break\n    for k in range(j-1,i-1,-1) :\n        ans.append(k)\n        P[k-1],P[k] = P[k],P[k-1]\n    i = j\nif(len(ans)==N-1 and P == [i+1 for i in range(N)]) :\n    for out in ans :\n        print(out)\nelse :\n    print(-1)", "n = int(input())\nl = list(map(int, input().split()))\n\nl = [0] + l\n\npos = [0] * (n + 1)\nfor i in range(n + 1):\n    pos[l[i]] = i\n\nans = []\nflag = True\ntmp = n\nwhile tmp > 1:\n    ind = pos[tmp]\n    if ind < tmp:\n        for i in range(ind + 1, tmp):\n            if l[i + 1] != i:\n                flag = False\n                break\n            pos[l[i - 1]], pos[l[i]] = i, i - 1\n            l[i - 1], l[i] = l[i], l[i - 1]\n            ans.append(i - 1)\n        if flag:\n            pos[l[tmp - 1]], pos[l[tmp]] = tmp, tmp - 1\n            l[tmp - 1], l[tmp] = l[tmp], l[tmp - 1]\n            ans.append(tmp - 1)\n            tmp = ind\n        else:\n            break\n    else:\n        flag = False\n        break\n\nif flag:\n    for ele in ans:\n        print(ele)\nelse:\n    print(-1)", "n=int(input())\np=list(map(int,input().split()))\nans=[]\nkensa=set()\ncount=0\nfor i in range(1,n):\n    j=i\n    while j-1>=0 and  p[j-1]>p[j]:\n        if j in kensa:\n            print(-1)\n            return\n        ans.append(j)\n        kensa.add(j)\n        count+=1\n        p[j-1],p[j]=p[j],p[j-1]\n        j-=1\n    if count>=n:\n        print(-1)\n        return\nif len(ans)==n-1:\n    for j in ans:\n        print(j)\nelse:\n    print(-1)", "N = int(input())\nP = list(map(int,input().split()))\nsearch, before, count, flag, ans, pans = 1, 0, 0, 0, [], []\nfor i in range(N):\n    x = P[i]\n    if x == search:\n        if i < N-1 and flag == 0:\n            print(-1)\n            return\n        ans += pans[::-1]\n        before, search, count, flag, pans = search, i+1, 0, 0, []\n        P[i], x = P[i-1], P[i-1]\n    if x != search:\n        if flag == 1:\n            print(-1)\n            return\n        if x == count+search+1:\n            flag = 0\n        if x > count+search+1:\n            flag = 1\n        pans.append(i+1)\n        count += 1\n    #print(i,x,pans)\nprint('\\n'.join(map(str,ans)))", "N=int(input())\nP=list(map(int,input().split()))\nans=[]\nl,r=0,0\nfor i in range(N):\n  if P[i]==r+1:\n    r=i\n    for j in range(r,l,-1):\n      P[j-1],P[j]=P[j],P[j-1]\n      ans.append(j)\n    l=r\n  \nif P!=sorted(P) or len(ans)!=N-1:\n  print(-1);return\nprint(*ans,sep=\"\\n\")", "N = int(input())\nP = list(map(int, input().split()))\n\nbef = 1\nans = []\nfor i in range(N):\n    # find bef\n    if P[i] == bef:\n        for j in range(i, bef - 1, -1):\n            # Move bef to it's postion with serial swapping from i to bef-1\n            P[j], P[j-1] = P[j-1], P[j]\n            ans.append(j)\n        # update bef to min updatable position owner\n        bef = i + 1\n\nif len(ans) != (N-1) or P != sorted(P):\n    # not using entire swap or unsorted without duplicate\n    print('-1')\nelse:\n    print('\\n'.join(map(str, ans)))", "N = int(input())\nP_list = list(map(int, input().split()))\n\nnow = 1\npre = -1\nans = []\nfor i in range(N):\n    if P_list[i] == now:\n        for j in range(i-1, pre, -1):\n            P_list[j], P_list[j+1] = P_list[j+1], P_list[j]\n            ans.append(j+1)\n        now = i+1\n        pre = i-1\n\nif P_list == sorted(P_list) and len(ans) == N-1:\n        print(*ans, sep='\\n')\nelse:\n    print(-1)", "n = int(input())\na = list(map(int, input().split()))\nnow=1\nlast_ind=0\nlis=[]\nans=[]\nfor i in range(n):\n    if a[i]==i+1:\n        print(\"-1\")\n        return\n\ndef check(l):\n    if len(l)==0:\n        return False\n    now=l[0]\n    for i in range(1,len(l)-1):\n        if l[i] < now:\n            return False\n        now=l[i]\n    return True\n\nfor i in range(n):\n    num=a[i]\n    if num==now:\n        if check(lis):\n            cnt=0\n            for j in range(i,last_ind,-1):\n                ans.append(j)\n                lis=[]\n                cnt+=1\n            last_ind=i\n            now+=cnt\n        else:\n            print(\"-1\")\n            return\n    lis.append(num)\n\nif len(ans)!=n-1:\n    print(\"-1\")\n    return\n\nfor i in range(n-1):\n    print(ans[i])", "import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, tan, asin, acos, atan, radians, degrees, log2, gcd\nfrom itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left, insort, insort_left\nfrom heapq import heappush, heappop\nfrom functools import reduce, lru_cache\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\ndef TUPLE(): return tuple(map(int, input().split()))\ndef ZIP(n): return zip(*(MAP() for _ in range(n)))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9 + 7\n#mod = 998244353\n#from decimal import *\n#import numpy as np\n#decimal.getcontext().prec = 10\n\nN = INT()\nP = LIST()\n\nQ = [0]*N \n#Q[i]: i\u306e\u5834\u6240\nfor i, p in enumerate(P):\n\tQ[p-1] = i\n\n#print(Q)\n\ncheck = [0]*N\nans = []\n\nfor i in range(N):\n\tp = Q[i]\n\t#print(\"#\", i, p)\n\tif i < p:\n\t\tfor j in range(p-1, i-1, -1):\n\t\t\tif check[j]:\n\t\t\t\tprint(-1)\n\t\t\t\treturn\n\t\t\tcheck[j] = 1\n\t\t\tans.append(j+1)\n\t\t\tP[j], P[j+1] = P[j+1], P[j]\n\t\t\tQ[P[j]-1] -= 1\n\t\t\tQ[P[j+1]-1] += 1\n\nfor i in range(N-1, -1, -1):\n\tif i > p:\n\t\tfor j in range(p, i):\n\t\t\tif check[j]:\n\t\t\t\tprint(-1)\n\t\t\t\treturn\n\t\t\tcheck[j] = 1\n\t\t\tans.append(j+1)\n\t\t\tP[j], P[j+1] = P[j+1], P[j]\n\t\t\tQ[P[j]-1] -= 1\n\t\t\tQ[P[j+1]-1] += 1\n\t\t\tprint(P, Q, ans)\n\nif len(ans) < N-1:\n\tprint(-1)\nelse:\n\tprint(*ans, sep=\"\\n\")\n\n", "n = int(input())\np = [int(x)-1 for x in input().split()]\nans, used = [],[False]*n\nfor i in range(n):\n    while i > 0 and  p[i-1]>p[i]:\n        if used[i]:\n            print(-1)\n            return\n        else:\n            used[i] = True\n            p[i-1],p[i] = p[i],p[i-1]\n            ans.append(i)\n            i -= 1\nif len(ans)==n-1:\n    print(*ans,sep=\"\\n\")\nelse:\n    print(-1)", "def main():\n  import sys\n  input=sys.stdin.readline\n  n=int(input())\n  p=list(map(int,input().split()))\n  c=[-1]*n\n  for i in range(n):\n    p[i]-=1\n    c[p[i]]=i\n  r=[False]*(n-1)\n  ans=[]\n  for i in range(n):\n    j=c[i]\n    while j!=i:\n      if r[j-1]:\n        print(-1)\n        return\n      ans.append(j)\n      r[j-1]=True\n      p[j-1],p[j]=p[j],p[j-1]\n      c[p[j]]=j\n      c[p[j-1]]=j-1\n      j-=1\n  for i in r:\n    if not i:\n      print(-1)\n      return\n  for i in ans:\n    print(i)\nmain()", "import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, tan, asin, acos, atan, radians, degrees, log2, gcd\nfrom itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left, insort, insort_left\nfrom heapq import heappush, heappop\nfrom functools import reduce, lru_cache\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\ndef TUPLE(): return tuple(map(int, input().split()))\ndef ZIP(n): return zip(*(MAP() for _ in range(n)))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9 + 7\n#mod = 998244353\n#from decimal import *\n#import numpy as np\n#decimal.getcontext().prec = 10\n\nN = INT()\nP = LIST()\n\nQ = [0]*N \nfor i, p in enumerate(P):\n\tQ[p-1] = i\n\ncheck = [0]*N\nans = []\n\nfor i in range(N):\n\tp = Q[i]\n\tif i < p:\n\t\tfor j in range(p-1, i-1, -1):\n\t\t\tif check[j]:\n\t\t\t\tprint(-1)\n\t\t\t\treturn\n\t\t\tcheck[j] = 1\n\t\t\tans.append(j+1)\n\t\t\tP[j], P[j+1] = P[j+1], P[j]\n\t\t\tQ[P[j]-1] -= 1\n\t\t\tQ[P[j+1]-1] += 1\n\nif len(ans) < N-1:\n\tprint(-1)\nelse:\n\tprint(*ans, sep=\"\\n\")\n\n", "n=int(input())\np=list(map(int,input().split()))\nnow=1\nans=[]\nfor i in range(n):\n    if p[i]==now:\n        for j in range(i-1,now-2,-1):\n            p[j],p[j+1]=p[j+1],p[j]\n            ans.append(j+1)\n        now=i+1\nif p!=[i for i in range(1,n+1)] or len(ans)!=n-1:\n    print(-1)\nelse:\n    for i in ans:\n        print(i)", "N, *P = list(map(int,open(0).read().split()))\nsearch, count, flag, ans, pans = 1, 0, 0, [], []\nfor i in range(N):\n    x = P[i]\n    if x == search:\n        ans += pans[::-1]\n        if i < N-1:\n            if flag == 0:\n                print(-1)\n                return\n            search, count, flag, pans = i+1, 0, 0, []\n            P[i], x = P[i-1], P[i-1]\n        \n    if x != search:\n        if flag == 1:\n            print(-1)\n            return\n        if x > count+search+1:\n            flag = 1\n        pans.append(i+1)\n        count += 1\n        \nprint('\\n'.join(map(str,ans)))", "import numpy as np\nn = int(input())\np = list(map(int, input().split()))\nswapped=np.zeros((n-1,))\nnow=0\nnoc=1\n\nfor now in range(0,n-1):\n  for i in range(now,n):\n    if (p[i]-1==now):\n      if(p[i]-1<i):\n        for j in range(i-1,p[i]-2,-1):\n          if swapped[j]!=0:\n            print(-1)\n            return\n          kari=p[j]\n          p[j]=p[j+1]\n          p[j+1]=kari\n          swapped[j]=noc  \n          noc+=1\n      break\nfor i in range(0,n-1):\n  if int(swapped[i])==0:\n    print(-1)\n    return\nfor i in range(0,n-1):\n  print(int(swapped[i])) ", "import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, tan, asin, acos, atan, radians, degrees, log2, gcd\nfrom itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left, insort, insort_left\nfrom heapq import heappush, heappop\nfrom functools import reduce, lru_cache\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\ndef TUPLE(): return tuple(map(int, input().split()))\ndef ZIP(n): return zip(*(MAP() for _ in range(n)))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9 + 7\n#mod = 998244353\n#from decimal import *\n#import numpy as np\n#decimal.getcontext().prec = 10\n\nN = INT()\nP = LIST()\n\nQ = [0]*N \nfor i, p in enumerate(P):\n\tQ[p-1] = i\n\ncheck = [0]*N\nans = []\n\nfor i in range(N):\n\tp = Q[i]\n\tif i < p:\n\t\tfor j in range(p-1, i-1, -1):\n\t\t\tif check[j]:\n\t\t\t\tprint(-1)\n\t\t\t\treturn\n\t\t\tcheck[j] = 1\n\t\t\tans.append(j+1)\n\t\t\tP[j], P[j+1] = P[j+1], P[j]\n\t\t\tQ[P[j]-1], Q[P[j+1]-1] = Q[P[j+1]-1], Q[P[j]-1]\n\nif len(ans) < N-1:\n\tprint(-1)\nelse:\n\tprint(*ans, sep=\"\\n\")\n\n", "import sys\ninput = sys.stdin.readline\n\nN = int(input())\nP = list(map(int, input().split()))\ntage = 1\ns = 0\nans = []\n\nfor i in range(N):\n    if P[i]==tage:\n        for j in range(i-1, s-1, -1):\n            P[j], P[j+1] = P[j+1], P[j]\n            ans.append(j)\n        \n        for j in range(s, i):\n            if P[j]!=j+1:\n                print(-1)\n                return\n        \n        tage = i+1\n        s = i\n\nif len(ans)!=N-1:\n    print(-1)\n    return\n    \nfor ans_i in ans:\n    print(ans_i+1)", "n = int(input())\np = list(map(int,input().split()))\np.insert(0,0)\nt = [0] * (n+1)\nfor i in range(1,n+1):\n    t[p[i]] = i\ni = 1\nf = 1\nans = []\nwhile i < n:\n    if p[i] != f:\n        x = t[f]\n        for j in range(i,x-1):\n            if p[j] != j+1:\n                print(-1)\n                return\n        for j in range(i,x)[::-1]:\n            ans.append(j)\n        p[x] = p[x-1]\n        f = f+(x-i)\n        i = x\n    else:\n        f += 1\n        i += 1\nif len(ans) != n-1:\n    print(-1)\n    return\nfor i in ans:\n    print(i)", "def int_1(n):\n    return int(n)-1\n\nN = int(input())\nP = list(map(int_1,input().split()))\n\nNumber = [0]*N\nfor idx,p in enumerate(P):\n    Number[p]=idx\n\nans =[]\ntarget = 0\nstart = 0\nwhile True:\n    target_idx = Number[target]\n    if target_idx <=start:\n        print((-1))\n        return\n    for idx in range(target_idx-1,start-1,-1):\n        P[idx+1],P[idx]=P[idx],P[idx+1]\n        ans.append(idx)\n    target = target_idx\n    start = target_idx\n    if start == N-1:\n        break\nfor idx,p in enumerate(P):\n    if p!=idx:\n        print((-1))\n        return\nfor an in ans:\n    print((an+1))\n", "n = int(input())\np = list(map(int, input().split()))\n\nans = []\nleft = 1\nMIN = 1\nwhile left < n:\n    # \u5c0f\u3055\u3044\u6570\u304b\u3089\u9806\u306b\u78ba\u5b9a\u3057\u3066\u3044\u304f\n    # \u79fb\u52d5\u524d\u306e\u4f4d\u7f6e\u3088\u308a\u5de6\u306f\u3082\u3046\u52d5\u304b\u305b\u306a\u3044\n    for i in range(left, n):\n        if p[i] == MIN:\n            # \u78ba\u5b9a\u3057\u305f\u6570\u304c\u6b63\u3057\u3044\u4f4d\u7f6e\u306b\u3044\u308b\u304b\n            for j in range(left-1, i-1):\n                MIN = max(MIN, p[j])\n                if p[j] != j+2:\n                    print(-1)\n                    return\n            ans.extend(range(i,left-1,-1))\n            p[i] = p[i-1]\n            break\n    else:\n        print(-1)\n        return\n    left = i+1\n    MIN += 1\nprint(*ans, sep='\\n')", "N=int(input())\nP=list(map(int,input().split()))\n\ndist=[0]*N\nfor i in range(N):\n  dist[i]=i+1-P[i]\n\nans=[]\nlp=1\nfor i in range(N-1):\n    ch=0\n    for j in range(lp-1,N-1):\n      if dist[j]<0 and dist[j+1]>0:\n        ans.append(j+1)\n        dj=dist[j]\n        dist[j]=dist[j+1]-1\n        dist[j+1]=dj+1\n        ch=1\n        lp=j\n        break\n    if ch==0:\n      print(-1)\n      return\n\nfor i in dist:\n  if i!=0:\n    print(-1)\n    return\n\nfor a in ans:\n  print(a)", "N = int(input())\nP = list(map(int, input().split()))\n\nans = []\nd = dict()\nfor i in range(N):\n    d[P[i]] = i\nnum = 1\nleft = 0\ns = set()\nc = 0\nwhile(num <= N):\n    if num in s:\n        if d[num] != num-1:\n            print(-1)\n            return\n    elif d[num] != num-1:\n        left = num - 1\n\n        s.add(num)\n        right = d[num]\n        P[right] = P[right-1]\n        d[P[right]] = right\n        ans.append(right)\n        d[num] = num-1\n        for i in range(right-2, left-1, -1):\n            s.add(P[i])\n            d[P[i]] += 1\n            ans.append(i+1)\n    num += 1\nif len(ans) == N-1:\n    print(*ans, sep='\\n')\nelse:\n    print(-1)\n", "def main():\n  n=int(input())\n  P=[int(x)-1 for x in input().split()]\n  Q=[0]*n\n\n  for i,p in enumerate(P):\n    Q[p]=i\n\n  L,i=[],n-1\n  while i>0:\n    if i==Q[i]:\n      print((-1))\n      return\n    for j in range(Q[i],i):\n      P[j],P[j+1]=P[j+1],P[j]\n      L.append(j+1)\n    for j in range(Q[i]+1,i+1):\n      if P[j]!=j:\n        print((-1))\n        return\n    i=Q[i]\n\n  for l in L:\n    print(l)\n\nmain()\n", "N = int(input())\nP = list(map(int, input().split()))\nans = []\n\nidx = [0]*(N+1)\nfor n in range(N):\n    idx[P[n]] = n\n\ni = 1\nwhile i < N :\n    right = idx[i]\n    left = i-1\n\n    if right == left: \n        i += 1\n    elif right < left: \n        break\n    else:\n        for i in range(right, left, -1):\n            P[i], P[i-1] = P[i-1], P[i]\n            idx[P[i]], idx[P[i-1]] = idx[P[i-1]], idx[P[i]]\n            ans.append(i)\n        i += right - left\n\ncheck = [n+1 for n in range(N)]\nif P == check and len(ans) == N-1 :\n    print(*ans, sep=\"\\n\")\nelse:\n    print(-1)", "N = int(input())\nPlist = list(map(int,input().split()))\nPlace = [0]*(N+1)\nmaxP = max(Plist)\nfor i in range(N):\n    p = Plist[i]\n    Place[p] = i+1\nPlist = [0]+Plist\nans = 0\nNset = []\nNa = set()\nfor i in range(N):\n    maxplace = Place[maxP]\n    while maxplace != maxP:\n        if maxplace not in Na:\n            Place[maxP] += 1\n            a = Plist[maxplace+1]\n            Place[a] -= 1\n            Plist[maxplace] = a\n            Plist[maxplace+1] = maxP\n            Nset.append(maxplace)\n            Na.add(maxplace)\n            maxplace += 1\n        else:\n            ans = -1\n            break\n    maxP -= 1\nif ans == -1:\n    print(ans)\nelse:\n    if len(Nset) == N-1:\n        for n in Nset:\n            print(n)\n    else:\n        print(-1)", "import sys\n \ninput = sys.stdin.readline\nN = int(input())\nP = list(map(int, input().split()))\n \ntarget = 1\nans = []\nfor i in range(N):\n    if P[i] == target:\n        for j in range(i, target-1, -1):\n            P[j], P[j-1] = P[j-1], P[j]\n            ans.append(j)\n    \n        target = i+1\n        # print(\"i\", i, \"target\", target)\n    \n# print(P)\nif len(ans) != N-1:\n    print(-1)\n    return\nfor i in range(N):\n    if P[i] != i+1:\n        print(-1)\n        return\n \nprint(*ans, sep=\"\\n\")"]