["import bisect\n\n\ndef gen_primes(upper_bound):\n    upper_bound += 1\n    t = [0] * (upper_bound)\n    primes = [2]\n    for i in range(3, upper_bound, 2):\n        if t[i]:\n            continue\n        primes.append(i)\n        for j in range(i + i, upper_bound, i):\n            t[j] = 1\n    return primes\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    primes = gen_primes(n + 1)\n    process = list()\n    d = [0] * n\n\n    for i in range(n):\n        d[a[i] - 1] = i\n\n    i = 0\n    while i < n:\n        if a[i] == i + 1:\n            i += 1\n            continue\n        r = d[i]\n        l = r - primes[bisect.bisect(primes, r - i + 1) - 1] + 1\n        a[l], a[r] = a[r], a[l]\n        process.append('{} {}'.format(l + 1, r + 1))\n        d[a[l] - 1] = l\n        d[a[r] - 1] = r\n\n    print(len(process))\n    print('\\n'.join(process))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def prime(n):\n    n += 1\n    p = [False] * n\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        u, v = i * i, 2 * i\n        if not p[i]: p[u :: v] = [True] * ((n - u - 1) // v + 1)\n    p[4 :: 2] = [True] * ((n - 3) // 2)\n    return p\nn = int(input())\nt = list(enumerate(list(map(int, input().split())), 1))\nt.sort(key = lambda x: x[1])\nt = [x[0] for x in t]\nu, v, q = list(range(n + 1)), list(range(n + 1)), []\np = prime(n + 1)\nfor i, j in enumerate(t, 1):\n    while i != u[j]:\n        k = i\n        while p[u[j] - k + 1]: k += 1\n        q.append(str(k) + ' ' + str(u[j]))\n        a, b = u[j], v[k]\n        u[b], u[j], v[a], v[k] = a, k, b, j\nprint(len(q))\nprint('\\n'.join(q))", "from sys import stdin\n_data = iter(stdin.read().split('\\n'))\ninput = lambda: next(_data)\n\nfrom bisect import bisect\nV = 210000\nprimes = []\nis_prime = [True] * V\nis_prime[0] = False\nis_prime[1] = False\nfor i in range(2, V):\n    if is_prime[i]:\n        primes.append(i)\n        for j in range(i + i, V, i):\n            is_prime[j] = False\n\nn = int(input())\na = list(map(int, input().split()))\nra = [0] * n\nfor i in range(n):\n    a[i] -= 1\n    ra[a[i]] = i\n\nbuf = []\np = 0\nwhile p < n:\n    while ra[p] != p:\n        d = ra[p] - p + 1\n        d = primes[bisect(primes, d) - 1] - 1\n        r = ra[p]\n        q = r - d\n        ra[a[q]], ra[a[r]] = ra[a[r]], ra[a[q]]\n        a[q], a[r] = a[r], a[q]\n        buf.append('{} {}'.format(q + 1, r + 1))\n    p += 1\nprint(len(buf))\nprint('\\n'.join(buf))\n", "import bisect\n\n\n\n\n\ndef gen_primes(upper_bound):\n\n    upper_bound += 1\n\n    t = [0] * (upper_bound)\n\n    primes = [2]\n\n    for i in range(3, upper_bound, 2):\n\n        if t[i]:\n\n            continue\n\n        primes.append(i)\n\n        for j in range(i + i, upper_bound, i):\n\n            t[j] = 1\n\n    return primes\n\n\n\ndef main():\n\n    n = int(input())\n\n    a = list(map(int, input().split()))\n\n    primes = gen_primes(n + 1)\n\n    process = list()\n\n    d = [0] * n\n\n\n\n    for i in range(n):\n\n        d[a[i] - 1] = i\n\n\n\n    i = 0\n\n    while i < n:\n\n        if a[i] == i + 1:\n\n            i += 1\n\n            continue\n\n        r = d[i]\n\n        l = r - primes[bisect.bisect(primes, r - i + 1) - 1] + 1\n\n        a[l], a[r] = a[r], a[l]\n\n        process.append('{} {}'.format(l + 1, r + 1))\n\n        d[a[l] - 1] = l\n\n        d[a[r] - 1] = r\n\n\n\n    print(len(process))\n\n    print('\\n'.join(process))\n\n\n\ndef __starting_point():\n\n    main()\n\n\n\n\n\n# Made By Mostafa_Khaled\n\n__starting_point()", "def sieve(n): \n    p = 2\n    while (p * p <= n): \n        if (prime[p] == False): \n            for i in range(p * p, n+1, p): \n                prime[i] = True\n        p += 1\nn = int(input())\nprime = [False for i in range(n+2)] \nprime[0]=1\nprime[1]=1\nsieve(n+1)\nlis = [0]+list(map(int,input().split()))\nind=[0]*(n+1)\nct=0\nfor i in range(1,n+1):\n    ind[lis[i]]=i\n#print(prime,ind)\nans=[]\nfor i in range(1,n+1):\n    j=ind[i]\n    while j>i:\n        t=i\n        while prime[j-t+1]:\n            t+=1\n#        print(j,t)\n        ct+=1\n        ind[lis[j]]=t;ind[lis[t]]=j\n        ans.append([t,j])\n        lis[j],lis[t]=lis[t],lis[j] \n        j=t\nprint(ct)\nfor i in ans:\n    print(*i)           \n\n\n", "def sieve(n): \n    p = 2\n    while (p * p <= n): \n        if (prime[p] == True): \n            for i in range(p * p, n+1, p): \n                prime[i] = False\n        p += 1\nn = int(input())\nprime = [True for i in range(n+2)] \nprime[0]=0\nprime[1]=0\nsieve(n+1)\naa=[0]*(n+1)\nfor i in range(n+1):\n    if prime[i]:\n        aa[i]=i\n    else:\n        aa[i]=aa[i-1]    \nlis = [0]+list(map(int,input().split()))\nind=[0]*(n+1)\nct=0\nfor i in range(1,n+1):\n    ind[lis[i]]=i\nans=[]\nfor i in range(1,n+1):\n    j=ind[i]\n    while j>i:\n        t=i\n        step=aa[j-t+1]-1    \n        ct+=1\n        ind[lis[j-step]]=j;ind[lis[j]]=j-step\n        ans.append([j-step,j])\n        lis[j-step],lis[j]=lis[j],lis[j-step]\n        j-=step\nprint(ct)\nfor i in ans:\n    print(*i)           \n", "import sys\ninput = sys.stdin.readline\nI = lambda : list(map(int,input().split()))\n\nn,=I()\nl=I()\nan=[]\nsv=[0]*(10**5+10)\nfor i in range(2,len(sv)):\n\tif not sv[i]:\n\t\tsv[i]=i\n\t\tfor j in range(2*i,len(sv),i):\n\t\t\tsv[j]=1\nsv[0]=sv[1]=1\nfor i in range(2,len(sv)):\n\tif not sv[i]-1:\n\t\tsv[i]=sv[i-1]\nix=[0]*(n+1)\nfor i in range(n):\n\tix[l[i]]=i\nfor i in range(n):\n\tct=0\n\twhile l[i]!=i+1 and ct<5:\n\t\tcr=ix[i+1]\n\t\tpr=sv[cr-i+1]\n\t\t#print(i,cr,pr)\n\t\tan.append(sorted([cr+1,cr-pr+2]))\n\t\tl[cr],l[cr-pr+1]=l[cr-pr+1],l[cr]\n\t\tix[l[cr]],ix[l[cr-pr+1]]=ix[l[cr-pr+1]],ix[l[cr]]\n\t\tct+=1\nprint(len(an))\nfor i in an:\n\tprint(*i)", "import sys\nimport collections as cc\nimport bisect as bi\ninput=sys.stdin.readline\nI=lambda:list(map(int,input().split()))\npr=[]\nN=10**6+3\nss=[0]*(N)\nss[0]=1\nfor i in range(2,N):\n\tif ss[i]==0:\n\t\tss[i]=i\n\t\tpr.append(i)\n\t\tfor j in range(2*i,N,i):\n\t\t\tss[j]=i\nn,=I()\nl=I()\nf={}\nans=0\nan=[]\nfor i in range(n):\n\tf[l[i]]=i\nfor i in range(n):\n\twhile l[i]!=i+1\t:\n\t\tans+=1\n\t\tnow=f[i+1]\n\t\tdis=now-i+1\n\t\ttemp=bi.bisect(pr,dis)\n\t\ttemp=pr[temp-1]\n\t\t#print(l[i],i+1,temp)\n\t\tf[l[now]],f[l[now-temp+1]]=f[l[now-temp+1]],f[l[now]]\n\t\tl[now-temp+1],l[now]=l[now],l[now-temp+1]\n\t\tan.append([now+1,now-temp+2])\nprint(ans)\nfor i in an:\n\tprint(*i[::-1])\n\n", "import sys\ninput = sys.stdin.readline\nimport bisect\n\nn=int(input())\nA=list(map(int,input().split()))\n\nfor i in range(n):\n    A[i]-=1\n\nx=10**5\nimport math \nL=math.floor(math.sqrt(x)) # \u5e73\u65b9\u6839\u3092\u6c42\u3081\u308b\n\nPrimelist=[i for i in range(x+1)]\nPrimelist[1]=0 # 1\u306f\u7d20\u6570\u3067\u306a\u3044\u306e\u30670\u306b\u3059\u308b.\n \nfor i in Primelist:\n    if i>L:\n        break\n    if i==0:\n        continue\n    for j in range(2*i,x+1,i):\n        Primelist[j]=0\n\nPrimes=[Primelist[j]-1 for j in range(x+1) if Primelist[j]!=0]\n\nA_INV=[-1]*n\nfor i in range(n):\n    A_INV[A[i]]=i\n\nANS=[]\nfor i in range(n):\n\n    j=A_INV[i]\n\n    while j-i:\n        t=bisect.bisect(Primes,j-i)-1\n        sa=Primes[t]\n\n        ANS.append((j-sa,j))\n\n        A_INV[i],A_INV[A[j-sa]]=j-sa,j\n        A[j],A[j-sa]=A[j-sa],A[j]\n\n        j-=sa\n        \nprint(len(ANS))\nfor x,y in ANS:\n    print(x+1,y+1)\n"]