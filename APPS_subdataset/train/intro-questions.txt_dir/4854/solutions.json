["def circum_curvat(points):\n    A, B, C = [complex(*p) for p in points]\n    BC, CA, AB = B - C, C - A, A - B\n    D = 2. * (A.real * BC + B.real * CA + C.real * AB).imag\n    if not D: return D, D\n    U = (abs(A)**2 * BC + abs(B)**2 * CA + abs(C)**2 * AB) / D\n    radius = (abs(BC) * abs(CA) * abs(AB)) / abs(D)\n    return -1j * U, radius\n\ndef count_circles(circles, point):\n    return sum(abs(complex(*point) - center) < radius\n               for center, radius in map(circum_curvat, circles))", "def count_circles(circles, point):\n    return sum(inside(circle_xyr(circle), point) for circle in circles)\n    \ndef inside(xyr, pt):\n    if xyr is None: return False\n    x, y, r = xyr\n    return dist(pt, (x, y)) <= r\n    \ndef circle_xyr(pts):\n    if len(pts) != 3: return None\n\n    m1, c1 = perpbisector(pts[0], pts[1])\n    m2, c2 = perpbisector(pts[0], pts[2])\n    if m1 == m2: return None\n    x, y = (c1, m2*c1 + c2) if m1 is None else (c2, m1*c2 + c1) if m2 is None else ((c2 - c1)/(m1 - m2), m1*(c2 - c1)/(m1 - m2) + c1)\n    return x, y, dist(pts[0], (x, y))\n\ndef perpbisector(a, b):\n    ax, ay = a\n    bx, by = b\n    mpx, mpy = (ax + bx) / 2.0, (ay + by) / 2.0\n    if ax == bx: return 0, mpy\n    if ay == by: return None, mpx\n    m = (ax - bx) / float(by - ay)\n    c = mpy - m * mpx\n    return m, c\n    \ndef dist(a, b):    \n    return round(((a[0] - b[0])**2 + (a[1] - b[1])**2)**0.5, 8)", "def count_circles(list_of_circles, point, count = 0):\n    return sum(1 for circle in list_of_circles if point_in(circle, point))\n    \ndef point_in(points, point):\n    helper = lambda x,y: (-1)**y*(points[(x+1)%3][(y+1)%2] - points[(x+2)%3][(y+1)%2])\n    D = 2*sum(points[i][0]*helper(i,0) for i in range(3))\n    U = [1.0 * sum(sum(points[i][j]**2 for j in range(2))*helper(i,k) for i in range(3))/D for k in range(2)]\n    return compare(point, U, radius(points,D)) if (not invalid(points, D)) else False\n\ncompare = lambda p, U, r: ((distance(U,p) < r) or (abs(r-distance(U,p))/r < 10**-10))\ndistance = lambda p1, p2: ((p2[0] - p1[0])**2 + (p2[1] - p1[1])**2)**0.5\ninvalid = lambda p, D: ((D == 0) or (p[0] == p[1]) or (p[0] == p[2]) or (p[1] == p[2]))\nradius = lambda p, D: distance(p[0],p[1])*distance(p[0],p[2])*distance(p[1],p[2])/abs(D)", "import math\ndef count_circles(loc, point):\n    c=0; px,py=point\n    for i in range (0,len(loc)):\n       circle=circum_curvat(loc[i][0],loc[i][1],loc[i][2])\n       if circle!=False:\n          x,y,r=circle\n          d=((x-px)**2+(y-py)**2)**.5\n          if d<=r+1e-10: c+=1\n    return c\n\ndef circum_curvat(pointA, pointB, pointC):\n    xA,yA=pointA; xB,yB=pointB; xC,yC=pointC\n    if pointA==pointB or pointA==pointC or pointC==pointB: return False\n    x=(xA**2+yA**2)*(yB-yC)+(xB**2+yB**2)*(yC-yA)+(xC**2+yC**2)*(yA-yB)\n    y=(xA**2+yA**2)*(xC-xB)+(xB**2+yB**2)*(xA-xC)+(xC**2+yC**2)*(xB-xA)\n    AB=((xB-xA)**2+(yB-yA)**2)**.5; BC=((xC-xB)**2+(yC-yB)**2)**.5; AC=((xC-xA)**2+(yC-yA)**2)**.5\n    D=2.0*(xA*(yB-yC)+xB*(yC-yA)+xC*(yA-yB))\n    if D==0: return False\n    Ux=x/D; Uy=y/D\n    if D<0: D=-D\n    diam=AB*BC*AC/D\n    return [Ux,Uy,diam]", "def dist(pointA, pointB):\n    return ((pointB[0] - pointA[0])**2 + (pointB[1] - pointA[1])**2)**.5\n\ndef contains(circle, point):\n    return circle and 0 <= circle['r'] - dist(point, circle['c']) <= circle['r'] or abs(circle['r'] - dist(point, circle['c'])) / circle['r'] < 1e-10\n\ndef circum_curvat(points):\n    if len(set(map(tuple, points))) != 3: return None\n    xa, ya, xb, yb, xc, yc = points[0][0], points[0][1], points[1][0], points[1][1], points[2][0], points[2][1]\n    D = 2. * (xa * (yb - yc) + xb * (yc - ya) + xc * (ya - yb))\n    if not D: return None\n    Ux = ((xa**2 + ya**2)*(yb - yc) + (xb**2 + yb**2)*(yc - ya) + (xc**2 + yc**2)*(ya - yb)) / D\n    Uy = ((xa**2 + ya**2)*(xc - xb) + (xb**2 + yb**2)*(xa - xc) + (xc**2 + yc**2)*(xb - xa)) / D\n    rad = dist(points[0], points[1]) * dist(points[1], points[2]) * dist(points[0], points[2]) / abs(D)\n    return {'c': (Ux, Uy), 'r': rad}\n\ndef count_circles(list_of_circles, point):\n    return len(filter(None, (contains(circum_curvat(p), point) for p in list_of_circles)))", "import math\n\ndef get_center_radius(points):\n    x = [pt[0] for pt in points]\n    y = [pt[1] for pt in points]\n    A = x[0]*(y[1]-y[2]) - y[0]*(x[1]-x[2]) + x[1]*y[2] - x[2]*y[1]\n    B = (x[0]**2 + y[0]**2)*(y[2]-y[1]) + (x[1]**2 + y[1]**2)*(y[0]-y[2]) + (x[2]**2 + y[2]**2)*(y[1]-y[0])\n    C = (x[0]**2 + y[0]**2)*(x[1]-x[2]) + (x[1]**2 + y[1]**2)*(x[2]-x[0]) + (x[2]**2 + y[2]**2)*(x[0]-x[1])\n    D = (x[0]**2 + y[0]**2)*(x[2]*y[1]-x[1]*y[2]) + (x[1]**2 + y[1]**2)*(x[0]*y[2]-x[2]*y[0]) + (x[2]**2 + y[2]**2)*(x[1]*y[0]-x[0]*y[1])\n    return -B/(2*A), -C/(2*A), ((B**2+C**2-4*A*D)/(4*A**2))**.5\n\ndef count_circles(list_of_circles, point):\n    counter = 0\n    for circle in list_of_circles:\n        xc, yc, r = get_center_radius(circle)\n        d = math.hypot(xc - point[0], yc - point[1])\n        counter += 1 if d < r or abs(d-r)/r < 10**-10 else 0\n\n    return counter", "import math\n\ndef circum_curvat(pointA, pointB, pointC):\n    #if len({pointA, pointB, pointC})<3:\n    #    return (0,0,0)\n    D = 2*(pointA[0]*(pointB[1]-pointC[1])+pointB[0]*(pointC[1]-pointA[1])+pointC[0]*(pointA[1]-pointB[1]))\n    if abs(D)<1e-10:\n        return (0,0,0)\n    x = ((pointA[0]**2+pointA[1]**2)*(pointB[1]-pointC[1])+\n         (pointB[0]**2+pointB[1]**2)*(pointC[1]-pointA[1])+\n         (pointC[0]**2+pointC[1]**2)*(pointA[1]-pointB[1])\n        )/D\n    y = ((pointA[0]**2+pointA[1]**2)*(pointC[0]-pointB[0])+\n         (pointB[0]**2+pointB[1]**2)*(pointA[0]-pointC[0])+\n         (pointC[0]**2+pointC[1]**2)*(pointB[0]-pointA[0])\n        )/D\n        \n    ab = math.hypot(pointB[0]-pointA[0],pointB[1]-pointA[1])\n    bc = math.hypot(pointB[0]-pointC[0],pointB[1]-pointC[1])\n    ac = math.hypot(pointC[0]-pointA[0],pointC[1]-pointA[1])\n    radius = ab*bc*ac/abs(D)\n    return (x, y, radius)\n\n\ndef count_circles(list_of_circles, point):\n    result = 0\n    for circles in list_of_circles:\n        x,y,r = circum_curvat(*circles)\n        if r-math.hypot(point[0]-x,point[1]-y)>-1e-10:\n            result += 1\n    return result", "from __future__ import division\nfrom numpy import *\n\ndef find_circle(a, b, c):\n    if any(map(array_equal, (a, b, c), (b, c, a))): return\n    (ax, ay), (bx, by), (cx, cy) = a, b, c\n    d = ax * (by - cy) + bx * (cy - ay) + cx * (ay - by) << 1\n    if not d: return\n    t1, t2, t3 = (ax**2 + ay**2), (bx**2 + by**2), (cx**2 + cy**2)\n    x = (t1*(by - cy) + t2*(cy - ay) + t3*(ay - by)) / d\n    y = (t1*(cx - bx) + t2*(ax - cx) + t3*(bx - ax)) / d\n    ab, bc, ca = linalg.norm(a - b), linalg.norm(b - c), linalg.norm(c - a)\n    return x, y, ab*bc*ca / abs(d)\n\ndef count_circles(list_of_circles, point):\n    (px, py), result = point, 0\n    for circle in list_of_circles:\n        if point in circle:\n            result += 1\n        else:\n            res = find_circle(*map(array, circle))\n            result += res and (px - res[0])**2 + (py - res[1])**2 <= res[2]**2\n    return result", "def count_circles(list_of_circles, point):\n    c=0\n    for circle in list_of_circles:\n        (x1,y1),(x2,y2),(x3,y3)=circle[0],circle[1],circle[2]\n        x=(x2**2+y2**2-x1**2-y1**2)*(y3-y1)-(x3**2+y3**2-x1**2-y1**2)*(y2-y1)\n        x/=2.0*((x2-x1)*(y3-y1)-(x3-x1)*(y2-y1))\n        y=(x2**2+y2**2-x1**2-y1**2)*(y3-y1)-2*(x2-x1)*(y3-y1)*x\n        y/=2.0*(y2-y1)*(y3-y1)\n        r=((x1-x)**2+(y1-y)**2)**0.5\n        d=((x-point[0])**2+(y-point[1])**2)**0.5\n        if d<=r or abs(r-d)<=10e-10:\n            c+=1\n    return c", "from math import sqrt, hypot\n\ndef count_circles(list_of_circles, point):\n    \n    count = int(any(point in c for c in list_of_circles))\n    \n    for [[x1, y1], [x2, y2], [x3, y3]] in list_of_circles:\n        A = x1 * (y2 - y3) - y1 * (x2 - x3) + x2 * y3 - x3 * y2\n        B = (x1 * x1 + y1 * y1) * (y3 - y2) + (x2 * x2 + y2 * y2) * (y1 - y3) + (x3 * x3 + y3 * y3) * (y2 - y1)\n        C = (x1 * x1 + y1 * y1) * (x2 - x3) + (x2 * x2 + y2 * y2) * (x3 - x1) + (x3 * x3 + y3 * y3) * (x1 - x2) \n        D = (x1 * x1 + y1 * y1) * (x3 * y2 - x2 * y3) + (x2 * x2 + y2 * y2) * (x1 * y3 - x3 * y1) + (x3 * x3 + y3 * y3) * (x2 * y1 - x1 * y2)\n        [A, B, C, D] = map(float, [A, B, C, D])\n        \n        xc, yc = -B / (2 * A), -C / (2 * A)\n        \n        r = sqrt((B * B + C * C - 4 * A * D) / (4 * A * A))\n        \n        d = hypot(point[0] - xc, point[1] - yc)\n        \n        if d <= r: count += 1\n        \n    return count"]