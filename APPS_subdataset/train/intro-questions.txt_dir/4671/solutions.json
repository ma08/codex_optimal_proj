["def isTree(matrix):\n    visited_nodes = set([0])\n    crossed_edges = set()\n    agenda = [0]\n\n    while agenda:\n        node = agenda.pop()\n        for i in matrix[node]:\n            if (node, i) in crossed_edges: continue \n            if i in visited_nodes: return False\n            agenda.append(i)\n            crossed_edges.add( (i, node) )\n            visited_nodes.add(i)\n    \n    return len(visited_nodes) == len(matrix)", "def isTree(matrix):\n    seen, stack = set(), [0]\n    while stack:\n        node = stack.pop()\n        if node in seen:\n            return False\n        seen.add(node)\n        stack += list(set(matrix[node]) - seen)\n    return len(seen) == len(matrix)", "def isTree(matrix):\n    visited = [False] * len(matrix)\n\n    def traverse(origin, transit):\n        if not visited[transit]:\n            visited[transit] = True\n            return all(traverse(transit, destination) for destination in matrix[transit] if destination != origin)\n        \n    return traverse(None, 0) and all(visited)", "def isTree(matrix):\n    '''depth first search; tree on n vertices has exactly n-1 edges'''\n    vertices = set(range(len(matrix)))\n    stack = [vertices.pop()]\n    while stack:\n        children = {y for y in matrix[stack.pop()] if y in vertices}\n        vertices.difference_update(children)\n        stack.extend(children)\n    return not vertices and sum(map(len,matrix)) == 2 * len(matrix) - 2", "def isTree(Q) :\n    if not len(Q) : return False\n    H = [0] * len(Q)\n    U = [[-1,0]]\n    while len(U) :\n        F,T = U.pop()\n        if H[T] : return False\n        H[T] = 1\n        U += [[T,V] for V in Q[T] if V != F]\n    return len(Q) == sum(H)", "def visit(ad_lst, i, fth=-1, path=[], visited=0):\n    if i in path:\n        return [], -1\n    visited += 1\n    path.append(i)\n    for v in range(0, len(ad_lst[i])):\n        if fth == ad_lst[i][v]:\n            continue\n        path2, v2 = visit(ad_lst, ad_lst[i][v], i, path)\n        if len(path2) == 0:\n            return [], -1\n        path = path2\n        visited += v2\n    return path, visited\n        \ndef isTree(ad_lst):\n    for v in range(0, len(ad_lst)):\n        path, visited = visit(ad_lst, v, -1, [], 0)\n        if len(path) == 0:\n            return False\n        if visited == len(ad_lst):\n            return True\n    return False", "def isTree(matrix):\n    seen = [False] * len(matrix)\n\n    def traverse(from_node, to_node):\n        if not seen[to_node]:\n            seen[to_node] = True\n            for next_node in matrix[to_node]:\n                if next_node != from_node:\n                    if not traverse(to_node, next_node):\n                        return False\n            return True\n        \n    return traverse(None, 0) and all(seen)", "from collections import defaultdict\n\ndef isTree(matrix):\n    graph = defaultdict(set)\n    for node, connections in enumerate(matrix):\n        if not connections:\n            return False\n        for connection in connections:\n            graph[connection].add(node)\n            graph[node].add(connection)\n            \n    N = len(matrix)\n    for node in graph.keys():\n        stack, seen = [node], set()\n        while stack:\n            cur_node = stack.pop()\n            if cur_node in seen:\n                return False\n            seen.add(cur_node)\n            for next_node in graph[cur_node]:\n                if next_node not in seen:\n                    stack.append(next_node)\n        if len(seen) < N:\n            return False\n    return True", "def isTree(m):\n    status = [(e, 0) for e in m[0]]\n    seen = set([0]) if status else set()\n    while status:\n        t, f = status.pop()\n        seen.add(t)\n        for e in m[t]:\n            if e != f:\n                if e in seen:\n                    return False\n                seen.add(e)\n                status.append((e, t))\n    return len(seen) == len(m)", "def s(m, b, e, v):\n    v[b] += 1\n    if v[b] > 1:\n        return v\n    for i in range(len(m[b])):\n        if m[b][i] != e:\n            v = s(m,m[b][i],b,v)\n    return v\n\ndef isTree(m):\n    v = [0]*len(m)\n    v = s(m, 0, -1, v)\n    return v == [1]*len(v)"]