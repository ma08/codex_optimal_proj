["from bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nfrom heapq import heappush,heappop,heapify\nimport math\nfrom collections import *\nfrom functools import reduce,cmp_to_key\nimport sys\ninput = sys.stdin.readline\nM = mod = 998244353\ndef factors(n):return sorted(set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))\ndef inv_mod(n):return pow(n, mod - 2, mod)\n \ndef li():return [int(i) for i in input().rstrip('\\n').split()]\ndef st():return input().rstrip('\\n')\ndef val():return int(input().rstrip('\\n'))\ndef li2():return [i for i in input().rstrip('\\n')]\ndef li3():return [int(i) for i in input().rstrip('\\n')]\n\nfor _ in range(val()):\n    n, k = li()\n    d = defaultdict(set)\n    for i in range(n-1):\n        a, b = li()\n        d[a].add(b)\n        d[b].add(a)\n    thistime = 1\n    he = deque()\n    visited = {}\n    for i in d:\n        if len(d[i]) == 1:\n            visited[i] = 1\n            he.append(i)\n    ans = 0\n    counts = defaultdict(int)\n    # print(he)\n\n    while he:\n        i = he.popleft()\n        for j in list(d[i]):\n            counts[j] += 1\n            d[i].remove(j)\n            d[j].remove(i)\n            if counts[j] == k:\n                thistime = 1\n                ans += 1\n                counts[j] = 0\n                if len(d[j]) == 1:\n                    if j not in visited:he.append(j)\n                    visited[j] = 1\n                    # print(j, he)\n    print(ans)", "import sys\ninput = sys.stdin.readline\nfor f in range(int(input())):\n    n,k=map(int,input().split())\n\n    neig=[0]*n\n    for i in range(n):\n        neig[i]=[0]\n\n    for i in range(n-1):\n        a,b=map(int,input().split())\n        a-=1\n        b-=1\n        neig[a][0]+=1\n        neig[b][0]+=1\n        neig[a].append(b)\n        neig[b].append(a)\n    conleaves=[0]*n\n    for i in range(n):\n        conleaves[i]=[0]\n    goodvertices=[]\n    mx=0\n    for i in range(n):\n        if neig[i][0]==1:\n            if neig[neig[i][1]][0]>0:\n                conleaves[neig[i][1]][0]+=1\n                conleaves[neig[i][1]].append(i)\n                neig[i][0]=0\n                if conleaves[neig[i][1]][0]==k:\n                    goodvertices.append(neig[i][1])\n    while len(goodvertices)>0:\n        v=goodvertices.pop()\n        rem=conleaves[v][0]//k\n        mx+=rem\n        rest=conleaves[v][0]%k\n        conleaves[v]=conleaves[v][0:rest+1]\n        conleaves[v][0]=rest\n        neig[v][0]-=rem*k\n        if neig[v][0]==1:\n            for i in range(1,len(neig[v])):\n                if neig[neig[v][i]][0]>0:\n                    neig[v][0]=0\n                    conleaves[neig[v][i]][0]+=1\n                    conleaves[neig[v][i]].append(v)\n                    if conleaves[neig[v][i]][0]==k:\n                        goodvertices.append(neig[v][i])\n    print(mx)", "def crop_set(s, n):\n    new = set()\n    it = iter(s)\n    for i in range(n):\n        new.add(next(it))\n    return new\n\n\nclass Vertex:\n    __slots__ = (\"vertexes\", \"leaves\", \"graph\")\n\n    def __init__(self, graph):\n        self.vertexes = set()\n        self.leaves = 0\n        self.graph = graph\n\n    def try_to_leave(self):\n        if len(self.vertexes) + self.leaves == 1:\n            if self.vertexes:\n                parent = self.vertexes.pop()\n                parent.vertexes.remove(self)\n                parent.leaves += 1\n                parent.update()\n                self.vertexes.add(parent)\n\n    def update(self):\n        self.graph[self] = self.leaves\n\n\nclass Tree:\n    def __init__(self, n, k):\n        self.k = k\n        self.lc = [set() for _ in range(n // k + 1)]\n        self.dlc = dict()\n        self.max = 0\n\n    def add_vertex(self, v):\n        self.dlc[v] = 0\n        self.lc[0].add(v)\n        v.update()\n\n    def __setitem__(self, key, value):\n        value = value // self.k\n\n        if self.max == self.dlc[key] > value:\n            self.lc[self.max].discard(key)\n            while not self.lc[self.max]:\n                self.max -= 1\n        else:\n            self.lc[self.dlc[key]].discard(key)\n\n        if value > self.max:\n            self.max = value\n        self.dlc[key] = value\n        self.lc[value].add(key)\n\n\ndef to_int_decrement(s):\n    return int(s) - 1\n\n\ndef solve():\n    n, k = list(map(int, input().split()))\n    tree = Tree(n, k)\n    graph = [Vertex(tree) for _ in range(n)]\n\n    for _ in range(n - 1):\n        a, b = list(map(to_int_decrement, input().split()))\n        graph[a].vertexes.add(graph[b])\n        graph[b].vertexes.add(graph[a])\n\n    if k == 1:\n        print(n - 1)\n        return\n\n    for v in graph:\n        tree.add_vertex(v)\n    for v in graph:\n        v.try_to_leave()\n\n    c = 0\n    while tree.max > 0:\n        v = tree.lc[tree.max].pop()\n        c += v.leaves // k\n        v.leaves -= v.leaves // k * k\n        v.try_to_leave()\n        v.update()\n    print(c)\n\n\nfor _ in range(int(input())):\n    solve()\n", "from sys import stdin, stdout\nimport functools\nimport sys,os,math\n\n#sys.setrecursionlimit(10**6)\n\nT = int(input())\n\nfor _ in range(T):\n    N, K = list(map(int, input().split()))\n    DS = [0] * (N + 1)\n    LeafNum = [0] * (N + 1)\n    g = [[] for _ in range(N+1)]\n    for _ in range(N-1):\n        u, v = list(map(int, input().split()))\n        DS[u] += 1\n        DS[v] += 1\n        g[u].append(v)\n        g[v].append(u)\n\n    for u in range(1, N+1):\n        if DS[u] == 1:\n            for v in g[u]:\n                LeafNum[v] += 1\n    \n    if K == 1:\n        print(N - 1)\n        continue\n\n    q = set()\n    for u in range(1, N+1):\n        if LeafNum[u] >= K:\n            q.add(u)\n    \n    ans = 0\n    while len(q) > 0:\n        u = q.pop()\n        nl = LeafNum[u]\n        ans += int(nl / K)\n        LeafNum[u] = nl % K\n        dn = int(nl / K) * K\n        DS[u] -= int(nl / K) * K\n        if DS[u] == 1:\n            for v in g[u]:\n                if DS[v] == 1 and dn > 0:\n                    dn -= 1\n                    continue\n\n                LeafNum[v] += 1\n                if LeafNum[v] >= K and v not in q:\n                    q.add(v)\n    print(ans)\n    \n\n\n\n        \n\n", "def main():\n    from heapq import heapify, heappop, heappush\n    import sys\n    input = sys.stdin.readline\n    for __ in [0]*int(input()):\n        N, K = list(map(int, input().split()))\n\n        G = [[] for _ in [0]*N]\n        deg = [0]*N\n        for _ in [0]*(N-1):\n            a, b = list(map(int, input().split()))\n            a -= 1\n            b -= 1\n            G[a].append(b)\n            G[b].append(a)\n            deg[a] += 1\n            deg[b] += 1\n\n        if K == 1:\n            print(N-1)\n            continue\n\n        leaf = [0]*N\n\n        for v in range(N):\n            if deg[v] == 1:\n                u = G[v][0]\n                leaf[u] += 1\n\n        L = [(-l, v) for v, l in enumerate(leaf) if l >= K]\n        heapify(L)\n\n        ans = 0\n        while L:\n            l, v = heappop(L)\n            if -l != leaf[v]:\n                continue\n            q, r = divmod(-l, K)\n            ans += q\n            leaf[v] = r\n            deg[v] -= K*q\n\n            p = -1\n            cnt = 0\n            for u in G[v]:\n                if deg[u] == 1 and cnt < K*q:\n                    cnt += 1\n                    deg[u] = 0\n                elif deg[u]:\n                    p = u\n                if cnt == K*q and (deg[v] != 1 or p != -1):\n                    break\n\n            if deg[v] == 1:\n                if p != -1:\n                    leaf[p] += 1\n                    if leaf[p] >= K:\n                        heappush(L, (-leaf[p], p))\n        print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def crop_set(s, n):\n    new = set()\n    it = iter(s)\n    for i in range(n):\n        new.add(next(it))\n    return new\n\n\nclass Vertex:\n    __slots__ = (\"vertexes\", \"leaves\", \"graph\")\n\n    def __init__(self, graph):\n        self.vertexes = set()\n        self.leaves = 0\n        self.graph = graph\n\n    def try_to_leave(self):\n        if len(self.vertexes) + self.leaves == 1:\n            if self.vertexes:\n                parent = self.vertexes.pop()\n                parent.vertexes.remove(self)\n                parent.leaves += 1\n                parent.update()\n                self.vertexes.add(parent)\n\n    def update(self):\n        self.graph[self] = self.leaves\n\n\nclass Tree:\n    def __init__(self, n, k):\n        self.k = k\n        self.lc = [set() for _ in range(n // k + 1)]\n        self.dlc = dict()\n        self.max = 0\n\n    def add_vertex(self, v):\n        self.dlc[v] = 0\n        self.lc[0].add(v)\n        v.update()\n\n    def __setitem__(self, key, value):\n        value = value // self.k\n\n        if self.max == self.dlc[key] > value:\n            self.lc[self.max].discard(key)\n            while not self.lc[self.max]:\n                self.max -= 1\n        else:\n            self.lc[self.dlc[key]].discard(key)\n\n        if value > self.max:\n            self.max = value\n        self.dlc[key] = value\n        self.lc[value].add(key)\n\n\ndef to_int_decrement(s):\n    return int(s) - 1\n\n\ndef solve():\n    n, k = map(int, input().split())\n    tree = Tree(n, k)\n    graph = [Vertex(tree) for _ in range(n)]\n\n    for _ in range(n - 1):\n        a, b = map(to_int_decrement, input().split())\n        graph[a].vertexes.add(graph[b])\n        graph[b].vertexes.add(graph[a])\n\n    if k == 1:\n        print(n - 1)\n        return\n\n    for v in graph:\n        tree.add_vertex(v)\n    for v in graph:\n        v.try_to_leave()\n\n    c = 0\n    while tree.max > 0:\n        v = tree.lc[tree.max].pop()\n        c += v.leaves // k\n        v.leaves -= v.leaves // k * k\n        v.try_to_leave()\n        v.update()\n    print(c)\n\n\nfor _ in range(int(input())):\n    solve()", "import sys\n\nsys.setrecursionlimit(10 ** 5)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef MI1(): return map(int1, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef SI(): return sys.stdin.readline()[:-1]\n\nfor _ in range(II()):\n    n,k=MI()\n    to=[[] for _ in range(n)]\n    for _ in range(n-1):\n        u,v=MI1()\n        to[u].append(v)\n        to[v].append(u)\n\n    if k==1:\n        print(n-1)\n        continue\n\n    dp=[0]*n\n    beleaf=[False]*n\n    leaves=[0]*n\n    stack=[(0,-1)]\n    first=[True]*n\n    while stack:\n        u,pu=stack.pop()\n        if first[u]:\n            first[u]=False\n            stack.append((u,pu))\n            for v in to[u]:\n                if v==pu:continue\n                stack.append((v,u))\n        else:\n            dp[u]=leaves[u]//k\n            if pu!=-1 and dp[u]*k+1==len(to[u]):\n                leaves[pu]+=1\n                beleaf[u]=True\n            for v in to[u]:\n                if v==pu:continue\n                dp[u]+=dp[v]\n    \"\"\"\n    print(dp)\n    print(leaves)\n    print(beleaf)\n    \"\"\"\n\n    stack=[(0,-1)]\n    while stack:\n        u,pu=stack.pop()\n        for v in to[u]:\n            if v==pu:continue\n            dp[v]=dp[u]\n            if (leaves[u]-beleaf[v])%k==0 and (leaves[u]-beleaf[v])+1==len(to[u]):\n                leaves[v]+=1\n                if leaves[v]%k==0:dp[v]+=1\n            stack.append((v,u))\n    \"\"\"\n    print(dp)\n    print(leaves)\n    print(beleaf)\n    \"\"\"\n    print(max(dp))\n"]