["is_prime = lambda n: all(n % d for d in range(3, int(n ** .5) + 1, 2))\n\ndef primes_a_p(lower_limit, upper_limit):\n    a_p = []\n    for n in range(lower_limit | 1, upper_limit, 2):\n        for gap in range(30, (upper_limit - n) // 5 + 1, 30):\n            sequence = [n + i * gap for i in range(6)]\n            if all(map(is_prime, sequence)):\n                a_p.append(sequence)\n    return a_p", "limit = 10_000\nsieve = [0]*2 + list(range(2, limit))\nfor i in range(2, limit):\n    for j in range(i*i, limit, i):\n        sieve[j] = 0\n        \nprimes = {i for i in sieve if i}\n\ndef primes_a_p(l, u):\n    li, found = sorted([i for i in primes if l<=i<=u]), []\n    \n    for i, a in enumerate(li):\n        for b in li[i+1:]:\n            diff, tray = b-a, [a, b]\n\n            for _ in range(4):\n                c = tray[-1] + diff\n                if c in primes and c < u:\n                    tray.append(c)\n                    continue\n                break\n                    \n            if len(tray)==6:\n                found.append(tray)\n            \n    return found", "from itertools import combinations, compress\nimport numpy as np\n\ns = np.ones(100000)\ns[:2] = s[2::2] = 0\nfor i in range(3, int(len(s)**0.5)+1, 2):\n    if s[i]:\n        s[i*i::i] = 0\nprimes = list(compress(range(len(s)), s))\n\ndef primes_a_p(lower_limit, upper_limit):\n    xs = primes[np.searchsorted(primes, lower_limit):np.searchsorted(primes, upper_limit)]\n    return [\n        list(range(a, a+6*(b-a), b-a))\n        for a, b in combinations(xs, 2)\n        if all(x <= upper_limit and s[x] for x in range(b+b-a, a+6*(b-a), b-a))\n    ]", "from bisect import *\n\nn=10000\nsieve, PRIMES = [0]*(n+1), []\nfor i in range(2, n+1):\n    if not sieve[i]:\n        PRIMES.append(i) \n        for j in range(i**2, n+1, i): sieve[j] = 1\n        \ndef primes_a_p(low, high):\n    subPrimes = PRIMES[bisect_left(PRIMES,low):bisect_right(PRIMES,high)]\n    ans, sP   = [], set(subPrimes)\n    \n    for i,p in enumerate(subPrimes):\n        for q in subPrimes[i+1:]:\n            d = q-p\n            prog = [p+d*n for n in range(6)]\n            if set(prog) <= sP: ans.append(prog)\n    return ans\n", "LIMIT = 10**4\nsieve = list(range(LIMIT))\nsieve[1] = 0\nprimes = []\nfor n in sieve:\n    if n:\n        primes.append(n)\n        for i in range(n*n, LIMIT, n):\n            sieve[i] = 0\n\ndel sieve\nprimes.remove(2)\n\n\ndef primes_a_p(lower_limit, upper_limit, k=6):\n    primes_list = [ p for p in primes if lower_limit <= p <= upper_limit ]\n    primes_set = set(primes_list)\n    \n    max_scope = (upper_limit - lower_limit) // (k-1)\n    \n    #base_diff = reduce(mul, [ p for p in primes if p <= k ])\n    base_diff = 2 * 3 * 5\n    \n    solutions = []\n    \n    for n in range(1, max_scope // base_diff + 1):\n        diffs = [ n * base_diff * x for x in range(k) ]\n        scope = n * base_diff * (k-1)\n        \n        for p in primes_list:\n            if p + scope > upper_limit:\n                break\n            \n            if { p+d for d in diffs } <= primes_set:\n                solutions.append([ p + d for d in diffs ])\n    \n    return sorted(solutions)", "def primes1(n):\n    sieve = [True] * n\n    for i in range(3,int(n**0.5)+1,2):\n        if sieve[i]:\n            sieve[i*i::2*i]=[False]*((n-i*i-1)//(2*i)+1)\n    return [2] + [i for i in range(3,n,2) if sieve[i]]\n\nlst = primes1(10000)\n\nimport bisect\ndef primes_a_p(lower_limit, upper_limit):\n    lst0 = lst[bisect.bisect_left(lst, lower_limit):bisect.bisect_right(lst,upper_limit)]\n    ans = []\n    for i in range(len(lst0)-5):\n        for j in range(30, upper_limit//5, 30):\n            x = lst0[i]+j\n            if x not in lst0:\n                continue\n            if x > lst0[-1]:\n                break\n            temp = [lst0[i], x]\n            flag = True\n            while len(temp) < 6:\n                x += j\n                if x in lst0:\n                    temp.append(x)\n                else:\n                    flag = False\n                    break\n            if flag == True:\n                ans.append(temp)\n    return ans", "def primes1(n):\n    sieve = [True] * n\n    for i in range(3,int(n**0.5)+1,2):\n        if sieve[i]:\n            sieve[i*i::2*i]=[False]*((n-i*i-1)//(2*i)+1)\n    return [2] + [i for i in range(3,n,2) if sieve[i]]\n\nlst = primes1(10000)\n\nimport bisect\ndef primes_a_p(lower_limit, upper_limit):\n    lst0 = lst[bisect.bisect_left(lst, lower_limit):bisect.bisect_right(lst,upper_limit)]\n    ans = []\n    for i in range(len(lst0)-5):\n        for j in range(30, 1500, 30):\n            x = lst0[i]+j\n            if x not in lst0:\n                continue\n            if x > lst0[-1]:\n                break\n            temp = [lst0[i], x]\n            flag = True\n            while len(temp) < 6:\n                x += j\n                if x in lst0:\n                    temp.append(x)\n                else:\n                    flag = False\n                    break\n            if flag == True:\n                ans.append(temp)\n    return ans\n                 \n", "def sito(m, n):\n    \"\"\"Sito Erastotenesa\"\"\"\n    numbers = [x for x in range(0, n+1)]\n    numbers[0], numbers[1] = False, False\n    primes = {}\n    for i,x in enumerate(numbers):\n        if x:\n            if x >= m:\n                primes[x] = x\n            index = i**2\n            while index < len(numbers):\n                numbers[index] = False\n                index += x\n    return primes\n                \n\ndef primes_a_p(lower_limit, upper_limit):\n    primes = sito(lower_limit, upper_limit)\n    longest_gap = (upper_limit-lower_limit) // 5\n    ap_primes = []\n    for i in list(primes.keys()):\n        for gap in range(2,longest_gap, 2):\n        \n            if primes[i]+5*gap <= upper_limit:\n                check = [primes[i]+n*gap for n in range(0,6)]\n                if any(num not in primes for num in check):\n                    pass\n                else:\n                    ap_primes.append(check)\n    return ap_primes\n", "from math import sqrt\n\ndef primes_a_p(lower_limit, upper_limit):\n    \n    primes = [p for p in prime_sieve(upper_limit + 1) if p >= lower_limit]\n    \n    res = []\n    \n    for k in range(30, upper_limit // 5, 30):\n        terms = [0, k, 2 * k, 3 * k, 4 * k, 5 * k]\n        for p in primes: \n            pp = [t + p for t in terms]\n            \n            if all(t in primes for t in pp): \n                res.append(pp)\n                \n    return sorted(res, key = lambda v: v[0])\n\ndef prime_sieve(n):\n    sieve = [True] * n\n    for i in range(3, int(sqrt(n)) + 1, 2):\n        if sieve[i]:\n            sieve[i * i::2 * i]= [False] * ((n - i * i - 1) // (2 * i) + 1)\n    return [2] + [i for i in range(3, n, 2) if sieve[i]]    "]