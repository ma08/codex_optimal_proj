["def count_find_num(primes, limit):\n    base = eval( '*'.join( map(str, primes) ) )\n    \n    if base > limit:\n        return []\n    \n    results = [base]\n    \n    for p in primes:\n        for num in results:\n            num *= p\n            while num not in results and num <= limit:\n                results += [num]\n                num *= p\n    \n    return [ len(results), max(results) ]", "from functools import reduce\n\ndef count_find_num(primesL, limit):\n    def rec(n, primes):\n        if not primes: return\n        x, (y, *next_primes) = n, primes\n        while x <= limit:\n            if x != n: yield x\n            yield from rec(x, next_primes)\n            x *= y\n    \n    start = reduce(int.__mul__, primesL)\n    if start > limit: return []\n    result = [start] + list(rec(start, primesL))\n    return [len(result), max(result)]", "from functools import reduce\nfrom collections import deque\n\ndef count_find_num(primesL, limit):\n    q = deque()\n    q.append(reduce(lambda x, y: x*y, primesL))\n    Max, Count = 0, 0\n    while len(q)!=0:\n        if q[0] <= limit:\n            Count += 1\n            Max = max(Max, q[0])\n            for i in primesL:\n                if i * q[0] <= limit and i * q[0] not in q:\n                    q.append(i * q[0])\n        q.popleft()\n    return [Count, Max] if Count!=0 and Max!=0 else []", "from functools import reduce\ndef count_find_num(primesL, limit):\n    base_num = reduce((lambda a, b: a * b), primesL, 1)\n    if base_num > limit:\n        return []\n    nums = [base_num]\n    for i in primesL:\n        for n in nums:\n            num = n * i\n            while (num <= limit) and (num not in nums):\n                nums.append(num)\n                num *= i\n\n    return [len(nums), max(nums)]", "def count_find_num(primesL, n):\n    base = 1\n    for p in primesL:\n        base *= p\n    \n    arr = permPrime(base, primesL, n)\n    if(len(arr) == 0):\n        return []\n    return [len(arr), max(arr)]\n    \ndef permPrime(base, primesL, n):\n    if(base > n):\n        return []\n    arr = [base]\n    for p in primesL:\n        arr += permPrime(base * p, primesL, n)   \n    arr = list(set(arr))\n    \n    return arr", "from functools import reduce\nfrom itertools import chain\n\ndef count_find_num(primesL, limit):\n    s = [reduce(lambda a,b: a*b, primesL)]\n    if s[0]>limit: return []\n    r = set(s)\n    while len(s)>0:\n        s = set(chain.from_iterable([p*n for p in primesL if p*n<=limit] for n in s))\n        r |= s\n    return [len(r), max(r)]", "from bisect import insort\nfrom functools import reduce\n\ndef count_find_num(primesL, n):\n    product = reduce(lambda a, b: a * b, primesL)\n    if product > n:\n        return []\n    p = [product]\n    last = None\n    count = 0\n    while p:\n        first = p.pop(0)\n        if first == last:\n            continue\n        count += 1\n        for x in primesL:\n            m = x * first\n            if m <= n:\n                insort(p, m)\n        last = first\n    return [count, last] if count else []", "def multiplyList(myList) : \n      \n    result = 1\n    for x in myList: \n         result = result * x  \n    return result \ndef count_find_num(primesL, limit):\n    base = multiplyList(primesL)\n    primesL.sort()\n    list1 = [base]\n    i = base\n    for i in primesL:\n        for j in list1:\n            d = j\n            while d<limit:\n                d=d*i\n                if d<=limit:\n                    list1.append(d)\n    if len(list1)==1 and list1[0]>limit:\n        return []\n    else:\n        list2 = list(set(list1))\n        return [len(list2),max(list2)]\n", "from functools import reduce\nfrom collections import deque\n\n\ndef count_find_num(primesL, limit):\n    initial_product = reduce(lambda prod, x: prod * x, primesL, 1)\n    if initial_product > limit:\n        return []\n\n    found_numbers = set()\n    queue = deque([initial_product])\n\n    while len(queue) > 0:\n        item = queue.popleft()\n        found_numbers.add(item)\n\n        for p in primesL:\n            prod = p * item\n\n            if prod <= limit:\n                queue.append(prod)\n\n    return [len(found_numbers), max(found_numbers)]\n", "import math\nimport itertools\n\n\ndef count_find_num(primesL, limit):\n    exps = [int(math.log(limit, p))+1 for p in primesL]\n    exps = exps+[2, 2, 2, 2, 2, 2]\n    exps = exps[0:5]\n    primesL = (primesL+[1, 1, 1, 1])[0:5]\n    res = set()\n    for a in range(1, exps[0]):\n        for b in range(1, exps[1]):\n            for c in range(1, exps[2]):\n                for d in range(1, exps[3]):\n                    for e in range(1, exps[4]):\n                        x = (primesL[0]**a*primesL[1]**b*primesL[2]**c *\n                             primesL[3]**d*primesL[4]**e)\n                        if x <= limit:\n                            res.add(x)\n    return [len(res), max(res)] if res else []\n"]