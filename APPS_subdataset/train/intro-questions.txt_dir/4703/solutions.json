["def bar_triang(a, b, c):\n    return [round(sum(x)/3.0, 4) for x in zip(a, b, c)]", "def bar_triang(pointA, pointB, pointC): \n    a = (pointA[0] + pointB[0] + pointC[0]) / 3.0\n    b = (pointA[1] + pointB[1] + pointC[1]) / 3.0\n    return [round(a, 4), round(b, 4)]", "def bar_triang(pointA, pointB, pointC): # points A, B and C will never be aligned\n    return [round((pointA[0] + pointB[0] + pointC[0]) / 3.0, 4), round((pointA[1] + pointB[1] + pointC[1]) / 3.0, 4)]", "def bar_triang(*args):\n    return [round(sum(a) / 3.0, 4) for a in zip(*args)]\n", "bar_triang = lambda *points: [round(sum(point) / 3., 4) for point in zip(*points)]", "from numpy import mean\n\ndef bar_triang(*points):\n    return [round(mean(dim), 4) for dim in zip(*points)]", "def bar_triang(x, y, z):\n    return [round(float(x[0] + y[0] + z[0]) / 3, 4), round(float(x[1] + y[1] + z[1]) / 3, 4)]", "def bar_triang(A, B, C):\n    return [round(sum(axis)/3.0, 4) for axis in zip(A,B,C)]", "def bar_triang(*points):\n  return [round(sum(x) / 3., 4) for x in zip(*points)]", "bar_triang = lambda *p: [round(sum(z)/3., 4) for z in zip(*p)]", "def bar_triang(*pts):\n    return [ round(1.0*sum(ps) / len(pts), 4) for ps in zip(*pts) ]", "def bar_triang(*coords):\n    return [round(1.0 * sum(c) / len(coords), 4) for c in zip(*coords)]", "import numpy as np\n\ndef bar_triang(*points):\n    return np.mean(points, axis=0).round(4).tolist()", "def bar_triang(p1, p2, p3):\n    return [float(\"%2.4f\" % ((p1[0]+p2[0]+p3[0])/3.0)), float(\"%2.4f\" % ((p1[1]+p2[1]+p3[1])/3.0))] ", "bar_triang=lambda *args: [round(sum(a[0] for a in args)/3.0,4), round(sum(a[1] for a in args)/3.0,4)]", "def bar_triang(pointA, pointB, pointC): # points A, B and C will never be aligned\n    # your code here\n    xO = '{:.4f}'.format(float(pointA[0]+pointB[0]+pointC[0])/3)\n    yO = '{:.4f}'.format(float(pointA[1]+pointB[1]+pointC[1])/3)\n    return [float(xO), float(yO)] # coordinated of the barycenter expressed up to four decimals\n                    # (rounded result)\n", "def bar_triang(pa, pb, pc, n=3., r=round):\n    return [r((pa[0]+pb[0]+pc[0])/n,4), r((pa[1]+pb[1]+pc[1])/n,4)]", "def bar_triang(a, b, c): # points A, B and C will never be aligned\n    # your code here\n    x0=   (a[0] +b[0]  +c[0]  )/3\n    y0=       (a[1] +b[1]  +c[1] )/3\n    return [ round(x0,4), round(y0,4) ]", "def bar_triang(a, b, c): # points A, B and C will never be aligned\n    xO=round((a[0]+b[0]+c[0])/3,4)\n    yO=round((a[1]+b[1]+c[1])/3,4)\n    return [xO, yO] # coordinates of the barycenter expressed up to four decimals\n                    # (rounded result)\n", "def bar_triang(pointA, pointB, pointC):\n    x = sum([pointA[0], pointB[0], pointC[0]]) / 3.0\n    y = sum([pointA[1], pointB[1], pointC[1]]) / 3.0\n    return [round(x, 4), round(y, 4)] ", "def bar_triang(pointA, pointB, pointC): # points A, B and C will never be aligned\n    x1, y1 = pointA\n    x2, y2 = pointB\n    x3, y3 = pointC\n    x0 = (x1+x2+x3)/3\n    y0 = (y1+y2+y3)/3\n    return [round(x0,4), round(y0,4)]", "def bar_triang(pointA, pointB, pointC):\n    return [ round(sum(i) / 3 ,4) for i in zip(pointA, pointB, pointC)]", "def bar_triang(A, B, C):\n    xO = round(sum(x[0] for x in (A, B, C)) / 3, 4)\n    yO = round(sum(x[1] for x in (A, B, C)) / 3, 4)\n    return [xO, yO]", "def bar_triang(pointA, pointB, pointC): \n    x_0 = round((pointA[0]+pointB[0]+pointC[0])/3 ,4)\n    y_0 = round((pointA[1]+pointB[1]+pointC[1])/3 ,4)\n    return [x_0, y_0] ", "def bar_triang(pointA, pointB, pointC): # points A, B and C will never be aligned\n    return list(map(lambda x:round(sum(x)/3, 4), zip(pointA, pointB, pointC)))", "def bar_triang(a,b,c):\n    return list(map(lambda p: round(sum(p)/3,4), zip(*(a,b,c))))", "def bar_triang(pointA, pointB, pointC):\n    return [round((pointA[i] + pointB[i] + pointC[i]) / 3, 4) for i in range(2)]", "def bar_triang(pointA, pointB, pointC): # points A, B and C will never be aligned\n    # your code here\n    x0 = (pointA[0]+pointB[0]+pointC[0])/3;\n    y0 = (pointA[1]+pointB[1]+pointC[1])/3;\n    return [round(x0,4), round(y0,4)]", "def bar_triang(pa, pb, pc):\n    xa, ya = pa\n    xb, yb = pb\n    xc, yc = pc\n    xO = round((xa + xb + xc) / 3, 4)\n    yO = round((ya + yb + yc) / 3, 4)\n    return [xO, yO]", "def bar_triang(pointA, pointB, pointC): # points A, B and C will never be aligned\n    xO = round(sum(x[0] for x in [pointA, pointB, pointC])/3,4)\n    yO = round(sum(y[1] for y in [pointA, pointB, pointC])/3,4)\n    return [xO, yO] # coordinates of the barycenter expressed up to four decimals\n                    # (rounded result)\n", "def bar_triang(pointA, pointB, pointC): # points A, B and C will never be aligned\n    mod = lambda indx: round(sum(list([_[indx] for _ in [pointA, pointB, pointC]]))/3, 4)\n    return [mod(0), mod(1)]\n", "import math\ndef bar_triang(a, b, c): # points A, B and C will never be aligned\n    x = round(((a[0] + b[0] + c[0]) / 3), 4)\n    y = round(((a[1] + b[1] + c[1]) / 3), 4)\n    return [x, y]", "def bar_triang(a, b, c):\n    return [round((a[i]+b[i]+c[i])/3,4) for i in range(len(a))]", "def bar_triang(pointA, pointB, pointC):\n    x_bary = round((pointA[0]+pointB[0]+pointC[0])/3, 4)\n    y_bary = round((pointA[1]+pointB[1]+pointC[1])/3, 4)\n    return [x_bary, y_bary]\n", "def bar_triang(a, b, c): \n    x0 = round((a[0]+b[0]+c[0])/3,4)\n    y0 = round((a[1]+b[1]+c[1])/3,4)\n    return [x0,y0]\n", "def bar_triang(A, B, C): # points A, B and C will never be aligned\n    return [round((A[0]+B[0]+C[0])/3,4),round((A[-1]+B[-1]+C[-1])/3,4)]", "def bar_triang(A,B,C): # points A, B and C will never be aligned\n    # your code here\n    return [round((A[0]+B[0]+C[0])/3,4),round((A[1]+B[1]+C[1])/3,4)] # coordinates of the barycenter expressed up to four decimals\n                    # (rounded result)\n", "def bar_triang(p1, p2, p3):\n    return [round((p1[0]+p2[0]+p3[0])/3,4),round((p1[1]+p2[1]+p3[1])/3,4)]", "def bar_triang(pointA, pointB, pointC): # points A, B and C will never be aligned\n    # your code here\n    x = (pointA[0]+pointB[0]+pointC[0])/3\n    y = (pointA[1]+pointB[1]+pointC[1])/3\n    return [round(x*10000)/10000, round(y*10000)/10000]", "def bar_triang(*dots):\n    x_sum = y_sum = 0\n    for d in dots:\n        x_sum += d[0]\n        y_sum += d[1]\n    xO = f'{x_sum/3:.4f}'\n    yO = f'{y_sum/3:.4f}'\n    return [float(xO), float(yO)]", "def bar_triang(a, b, c): # points A, B and C will never be aligned\n    return [round((a[i]+b[i]+c[i])/3, 4) for i in (0, 1) ]", "def bar_triang(pointA, pointB, pointC): # points A, B and C will never be aligned\n    xO = (pointA[0] + pointB[0] + pointC[0]) / 3\n    yO = (pointA[1] + pointB[1] + pointC[1]) / 3\n    xO = round(xO, 4)\n    yO = round(yO, 4)\n    return [xO, yO] # coordinates of the barycenter expressed up to four decimals\n                    # (rounded result)\n", "def bar_triang(pointA, pointB, pointC):\n    x = (pointA[0] + pointB[0] + pointC[0]) / 3\n    y = (pointA[1] + pointB[1] + pointC[1]) / 3\n    return [round(x, 4), round(y, 4)]", "def bar_triang(pA, pB, pC): \n    return [round((pA[0]+pB[0]+pC[0])/3,4), round((pA[1]+pB[1]+pC[1])/3,4)]", "def bar_triang(pointA, pointB, pointC): # points A, B and C will never be aligned\n    # your code here\n    x0=pointA[0]+pointB[0]+pointC[0]\n    y0=pointA[1]+pointB[1]+pointC[1]\n    x0=round(x0/3,4)\n    y0=round(y0/3,4)\n    return [x0, y0] # coordinates of the barycenter expressed up to four decimals\n                    # (rounded result)\n", "def bar_triang(pointA, pointB, pointC): # points A, B and C will never be aligned\n    return [ round(sum(x/3 for x, _ in [pointA, pointB, pointC]), 4),\n        round(sum(y/3 for _, y in [pointA, pointB, pointC]), 4) ]", "def bar_triang(pA, pB, pC):\n    xO = round((pA[0]+pB[0]+pC[0])/3,4)\n    yO = round((pA[1]+pB[1]+pC[1])/3,4)\n    return [xO,yO]", "def bar_triang(pointsA, pointsB, pointsC): \n    return [round((pointsA[0] + pointsB[0] + pointsC[0]) / 3, 4), round((pointsA[1] + pointsB[1] + pointsC[1]) / 3, 4)]", "def bar_triang(A, B, C):\n    x = round((A[0] + B[0] + C[0]) / 3, 4)\n    y = round((A[1] + B[1] + C[1]) / 3, 4)\n    return [x, y]", "def bar_triang(*p): # points A, B and C will never be aligned\n    return list([round(sum(x)/3, 4) for x in zip(*p)]) # coordinates of the barycenter expressed up to four decimals\n                    # (rounded result)\n", "def bar_triang(A, B, C): \n    x0 = (A[0]+B[0]+C[0])/3\n    y0 = (A[1]+B[1]+C[1])/3\n    return [round(x0,4), round(y0,4)] ", "def bar_triang(pointA, pointB, pointC): # points A, B and C will never be aligned\n    #print(pointA[0])\n    x0 = float(f'{(pointA[0] + pointB[0] + pointC[0])/3 : .4f}')\n    y0 = float(f'{(pointA[1] + pointB[1] + pointC[1])/3 : .4f}')\n    return [x0, y0] # coordinates of the barycenter expressed up to four decimals\n                    # (rounded result)\n", "def bar_triang(pointA, pointB, pointC):\n    x,y,lst=0,0,[pointA,pointB,pointC]\n    for i in range(3):\n        x+=lst[i][0]\n        y+=lst[i][1]\n    return [round(x/3,4), round(y/3,4)]", "from statistics import mean\ndef bar_triang(pointA, pointB, pointC): \n    return [round(mean(row),4) for row in zip(pointA,pointB,pointC)]\n", "def bar_triang(A, B, C):\n    xO = (A[0]+B[0]+C[0])/3\n    yO = (A[1]+B[1]+C[1])/3 \n    return [round(xO,4), round(yO,4)] ", "bar_triang=lambda a,b,c:[round((abs(a[0]+b[0])+abs(a[0]+c[0])+abs(b[0]+c[0]))/6,4),round((abs(a[1]+b[1])+abs(a[1]+c[1])+abs(b[1]+c[1]))/6,4)]", "import numpy as np\ndef bar_triang(pointA, pointB, pointC):\n    x0 = np.around((pointA[0] + pointB[0] + pointC[0]) / 3, decimals=4)\n    y0 = np.around((pointA[1] + pointB[1] + pointC[1]) / 3, decimals=4) \n    return [x0, y0]", "def bar_triang(pointA, pointB, pointC): # points A, B and C will never be aligned\n    xa, xb, xc = pointA[0], pointB[0], pointC[0]\n    ya, yb, yc = pointA[1], pointB[1], pointC[1]\n    x = round((xa+xb+xc)/3, 4)\n    y = round((ya+yb+yc)/3, 4)\n    return [x, y]", "bar_triang = lambda A, B, C: [round(sum(i) / 3, 4) for i in zip(A, B, C)]", "def bar_triang(pointA, pointB, pointC): # points A, B and C will never be aligned\n    x1,x2,x3 = pointA[0],pointB[0],pointC[0]\n    y1,y2,y3 = pointA[1],pointB[1],pointC[1]\n    return [round((x1+x2+x3)/3,4),round((y1+y2+y3)/3,4)]", "def bar_triang(pointA, pointB, pointC): # points A, B and C will never be aligned\n    xo = round((pointA[0] + pointB[0] + pointC[0]) / 3, 4)\n    yo = round((pointA[1] + pointB[1] + pointC[1]) / 3, 4)\n    return [xo, yo]", "def bar_triang(pointA, pointB, pointC): # points A, B and C will never be aligned\n    \n    xa, ya = pointA\n    xb, yb = pointB\n    xc, yc = pointC\n    \n    xO = round((xa + xb + xc) / 3, 4)\n    yO = round((ya + yb + yc) / 3, 4)\n  \n    return [xO, yO] # coordinates of the barycenter expressed up to four decimals\n                    # (rounded result)\n", "from typing import List\n\n\ndef bar_triang(a: List[int], b: List[int], c: List[int]) -> List[float]:\n    return [round((a[0] + b[0] + c[0]) / 3, 4), round((a[1] + b[1] + c[1]) / 3, 4)]\n", "def bar_triang(A, B, C): # points A, B and C will never be aligned\n    x0 = round((A[0] + B[0] + C[0])/3,4)\n    y0 = round((A[1] + B[1] + C[1])/3,4)\n    return [x0, y0] # coordinates of the barycenter expressed up to four decimals\n                    # (rounded result)\n", "def bar_triang(pointA, pointB, pointC):\n    return [round(i,4) for i in list(map(lambda x, y, z: (x + y + z) / 3, pointA, pointB, pointC))]", "bar_triang = lambda a,b,c: [round((a[0]+b[0]+c[0])/3,4), round((a[1]+b[1]+c[1])/3,4)]", "def bar_triang(pointA, pointB, pointC): \n    # points A, B and C will never be aligned\n    # coordinates of the barycenter expressed up to four decimals\n    # (rounded result)\n    return [round((pointA[i] + pointB[i] + pointC[i]) / 3, 4) for i in range(2)]\n", "def bar_triang(pointA, pointB, pointC): # points A, B and C will never be aligned\n    xa, ya, xb, yb, xc, yc = pointA + pointB + pointC\n    return [round((xa + xb + xc) / 3, 4), round((ya + yb + yc) / 3, 4)]", "def bar_triang(A, B, C):\n    return [round((A[0]+B[0]+C[0])/3,4), round((A[1]+B[1]+C[1])/3,4)] ", "def bar_triang(pointA, pointB, pointC): # points A, B and C will never be aligned\n    xO, yO = round((pointA[0] + pointB[0] + pointC[0]) / 3, 4), round((pointA[1] + pointB[1] + pointC[1]) / 3, 4)\n    return [xO, yO] # coordinates of the barycenter expressed up to four decimals\n                    # (rounded result)\n", "def bar_triang(a, b, c): # points A, B and C will never be aligned\n    xO = (a[0] + b[0] + c[0]) / 3\n    yO = (a[1] + b[1] + c[1]) / 3\n    return [round(xO, 4), round(yO, 4)] # coordinates of the barycenter expressed up to four decimals\n                    # (rounded result)\n", "def bar_triang(pointA, pointB, pointC):\n    xA, yA = pointA\n    xB, yB = pointB\n    xC, yC = pointC\n    \n    x0 = (xA + xB + xC) / 3\n    y0 = (yA + yB + yC) / 3    \n    \n    return [round(x0, 4), round(y0, 4)]", "def bar_triang(pointA, pointB, pointC): # points A, B and C will never be aligned\n    x0 = (float(pointA[0]) + float(pointB[0]) + float(pointC[0]))/3\n    y0 = (float(pointA[1]) + float(pointB[1]) + float(pointC[1]))/3\n    return [round(x0,4), round(y0,4)] # coordinates of the barycenter expressed up to four decimals\n                    # (rounded result)\n", "def bar_triang(pointA, pointB, pointC): # points A, B and C will never be aligned\n    xO = round((pointA[0] + pointB[0] + pointC[0]) / 3, 4)\n    yO = round((pointA[1] + pointB[1] + pointC[1]) / 3, 4)\n    return [xO, yO] ", "def bar_triang(pointA, pointB, pointC):\n    \n    x0 = (pointA[0] + pointB[0] + pointC[0]) / 3\n    \n    y0 = (pointA[1] + pointB[1] + pointC[1]) / 3\n    \n    return [round(x0,4), round(y0,4)]", "def bar_triang(pointA, pointB, pointC): # points A, B and C will never be aligned\n    xa =  pointA[0]\n    xb =  pointB[0]\n    xc =  pointC[0]\n    ya =  pointA[1]\n    yb =  pointB[1]\n    yc =  pointC[1]\n    xO =  round((xa+xb+xc)/3,4)\n    yO =  round((ya+yb+yc)/3,4)\n    return [xO, yO] # coordinates of the barycenter expressed up to four decimals\n                    # (rounded result)\n", "def bar_triang(pointA, pointB, pointC): # points A, B and C will never be aligned\n    return [round(x/3, 4) for x in [sum(i) for i in zip(pointA, pointB, pointC)]]\n", "def bar_triang(a, b, c): # points A, B and C will never be aligned\n    # your code here\n    return [round((a[0]+b[0]+c[0])/3,4), round((a[1]+b[1]+c[1])/3,4)] # coordinates of the barycenter expressed up to four decimals\n                    # (rounded result)\n", "import numpy as np \ndef bar_triang(pointA, pointB, pointC): # points A, B and C will never be aligned\n    # your code here\n    return [np.round((pointA[0]+pointB[0]+pointC[0])/3,4), np.round((pointA[1]+pointB[1]+pointC[1])/3,4)] # coordinates of the barycenter expressed up to four decimals\n                    # (rounded result)\n", "def bar_triang(pointA, pointB, pointC):\n    [xa,ya] = pointA\n    [xb,yb] = pointB\n    [xc,yc] = pointC\n    return [round((xa+xb+xc)/3,4),round((ya+yb+yc)/3,4)]", "def bar_triang(a, b, c): # points A, B and C will never be aligned\n    x = (a[0] + b[0] + c[0])/3\n    y = (a[1] + b[1] + c[1])/3\n    return [round(x,4),round(y,4)]", "def bar_triang(pointA, pointB, pointC):\n    return list(map(lambda x: round(sum(x) / 3, 4), zip(pointA, pointB, pointC)))", "from statistics import mean\ndef bar_triang(pointA, pointB, pointC):\n    return [round(mean(x), 4) for  x in zip(pointA, pointB, pointC)]", "def bar_triang(pointA, pointB, pointC):\n\n    return([round((a + b + c) / 3, 4)\n           for a, b, c in zip(pointA, pointB, pointC)])", "def bar_triang(*points):\n    center_x = sum(point[0] for point in points) / len(points)\n    center_y = sum(point[1] for point in points) / len(points)\n    return [round(center_x, 4), round(center_y, 4)]", "def bar_triang(A, B, C): # points A, B and C will never be aligned\n    # your code here\n    return [round((A[0] + B[0] + C[0]) / 3, 4), round((A[1] + B[1] + C[1]) / 3, 4)] ", "def bar_triang(pointA, pointB, pointC):\n    x0 = round((pointA[0] + pointB[0] + pointC[0]) / 3, 4)\n    y0 = round((pointA[1] + pointB[1] + pointC[1]) / 3, 4)\n    return [x0, y0]", "def bar_triang(a, b, c): # points A, B and C will never be aligned\n    xO = round((a[0] + b[0] + c[0]) / 3, 4)\n    yO = round((a[1] + b[1] + c[1]) / 3, 4)\n    return [xO, yO]", "def bar_triang(pA, pB, pC):\n    x = round((pA[0] +pB[0] + pC[0]) / 3, 4)\n    y = round((pA[1] +pB[1] + pC[1]) / 3, 4)\n    return [x, y]\n    # Flez\n", "def bar_triang(a, b, c): # points A, B and C will never be aligned\n    return [round((a[0]+b[0]+c[0])/3,4),round((a[1]+b[1]+c[1])/3,4)]", "def bar_triang(a, b, c):\n    xO = (a[0] + b[0] + c[0]) / 3\n    yO = (a[1] + b[1] + c[1]) / 3\n    return [round(xO, 4), round(yO, 4)] ", "def bar_triang(pointA, pointB, pointC):\n    xO = round((pointA[0] + pointB[0] + pointC[0]) / 3, 4)\n    yO = round((pointA[1] + pointB[1] + pointC[1]) / 3, 4)\n    return [xO, yO]", "def bar_triang(A, B, C): # points A, B and C will never be aligned\n    xO = round((A[0] + B[0] + C[0]) / 3, 4)\n    yO = round((A[1] + B[1] + C[1]) / 3, 4)\n    return [xO, yO] # coordinates of the barycenter expressed up to four decimals\n                    # (rounded result)\n", "def bar_triang(pointA, pointB, pointC): # points A, B and C will never be aligned\n    # your code here\n    ax, ay = pointA\n    bx, by = pointB\n    cx, cy = pointC\n    x0 = round((ax + bx + cx) / 3, 4)\n    y0 = round((ay + by + cy) / 3, 4)\n    return [x0, y0] # coordinates of the barycenter expressed up to four decimals\n                    # (rounded result)\n", "def bar_triang(pointA, pointB, pointC): # points A, B and C will never be aligned\n    return [round((pointA[0] + pointB[0] + pointC[0])/3,4),round((pointA[1] + pointB[1] + pointC[1])/3,4)]", "def bar_triang(pointA, pointB, pointC): # points A, B and C will never be aligned\n    # your code here\n    xO = round(1/3 * (pointA[0] + pointB[0] + pointC[0]),4)\n    yO = round(1/3 * (pointA[1] + pointB[1] + pointC[1]),4)\n    return [xO, yO] # coordinates of the barycenter expressed up to four decimals\n                    # (rounded result)\n"]