["def flipping_game(num):\n    current = 0\n    biggest = 0\n    for i in num:\n        current = max(0, current - ( i or -1 ) )\n        biggest = max(biggest, current)\n        \n    return sum(num) + (biggest or -1)", "def flipping_game(num):\n    return max([sum(num) + num[i: j + 1].count(0) - num[i: j + 1].count(1) for i in range(len(num)) for j in range(i, len(num))])", "def flipping_game(a):\n    current = best = 0\n    for n in a:\n        current = max(0, current - (n or -1))\n        best = max(best, current)\n    return sum(a) + (best or -1)", "def flipping_game(num):\n    \n    # Defining possible start and end points, to reduce complexity away from full 0(n^2)\n    poss_start = [i for i,x in enumerate(num) if x==0 and (i==0 or num[i-1]==1)]\n    poss_end = [i for i,x in enumerate(num) if x==0 and (i==len(num)-1 or num[i+1]==1)]\n    \n    # If no start or end available, then every change is for the worse, so one 1 needs to be converted to 0\n    if not poss_start or not poss_end: return sum(num) - 1\n    \n    curmax = 0\n    for st in poss_start:\n        for en in poss_end:\n            curmax = max(curmax,sum(x if (i<st or i>en) else 1-x for i,x in enumerate(num)))\n    return curmax", "def flipping_game(num):\n    if all(num):\n        return len(num) - 1\n    x = 0\n    m = 0\n    for n in num:\n        if n == 0:\n            x += 1\n            m = max(x, m)\n        else:\n            x = max(x-1, 0)\n    return num.count(1) + m", "from itertools import groupby\n\ndef flipping_game(lst):\n    split = [ (k, sum(1 for _ in g)) for k,g in groupby(lst)]\n    zeroes = [i for i,t in enumerate(split) if not t[0]]\n    return max( (sum((k^1 if a<=i<=b else k)*n for i,(k,n) in enumerate(split))\n                          for z,a in enumerate(zeroes)\n                          for b in zeroes[z:]),\n                      default=sum(lst)-1 )", "def flipping_game(num):\n    all_pairs = ((i, j) for i in range(len(num)) for j in range(i + 1, len(num) + 1))\n    ones = (sum(num[:i]) + j - i - sum(num[i:j]) + sum(num[j:]) for i, j in all_pairs)\n    return max(ones) ", "flipping_game=lambda a:sum(a)+max(j-i-2*sum(a[i:j])for j in range(1,len(a)+1)for i in range(j))", "def flipping_game(a):\n    m = 0\n    for i in range(len(a)):\n        for j in range(i,len(a)+1):\n            x = sum(a[:i]) + a[i:j+1].count(0) + sum(a[j+1:])\n            if x > m:\n                m = x\n    return m       ", "def flipping_game(num):\n    if 0 not in num:\n        return len(num)-1\n    elif num==[0]:\n        return 1\n    m=-1\n    for i in range(len(num)-1):\n        for j in range(i+1,len(num)+1):\n            c=num[:i].count(1)+num[i:j].count(0)+num[j:].count(1)\n            if c>m:\n                m=c\n    return m"]