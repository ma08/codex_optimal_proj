["from sys import stdin\nimport math\n\nrgb = 'RGB'\n\nfor query in range(int(stdin.readline())):\n    n, k = list(map(int, stdin.readline().split()))\n    s = stdin.readline()\n\n    ans = math.inf\n    for start in range(3):\n        dp = [0 for i in range(n + 1)] \n        for i in range(n):\n            cur = rgb[(start + i) % len(rgb)]\n            dp[i + 1] = dp[i] + int(s[i] != cur)\n        for i in range(n - k + 1):\n            ans = min(ans, dp[i + k] - dp[i])\n    print(ans)\n\n\n", "from sys import stdin\nfrom collections import deque\nc=int(stdin.readline().strip())\nfor cas in range(c):\n    n,m=list(map(int,stdin.readline().strip().split()))\n    s=deque(stdin.readline().strip())\n    arr=[\"R\",\"G\",\"B\"]\n    ans=n+3\n    for k in range(1):\n\n        for  i in range(3):\n            x=i\n\n            dp=[0 for i in range(n+1)]\n            for j in range(n):\n\n                if s[j]!=arr[x]:\n                    dp[j+1]+=1\n                dp[j+1]+=dp[j]\n                if j+1>=m:\n\n                    ans=min(ans,dp[j+1]-dp[j+1-m])\n                x+=1\n                x=x%3\n\n    print(ans)\n                \n            \n    \n            \n            \n1\n", "import sys\ninput = sys.stdin.readline\n\nq=int(input())\n\nfor testcases in range(q):\n    n,k=list(map(int,input().split()))\n    S=list(input().strip())\n\n    for i in range(n):\n        if S[i]==\"R\":\n            S[i]=0\n        elif S[i]==\"G\":\n            S[i]=1\n        else:\n            S[i]=2\n\n    ANS=1<<50\n\n\n\n    for mod in range(3):\n        SUM=0\n        for i in range(k):\n            if S[i]%3!=(mod+i)%3:\n                SUM+=1\n\n        ANS=min(ANS,SUM)\n\n\n        for i in range(k,n):\n            if S[i-k]!=(mod+(i-k))%3:\n                SUM-=1\n            if S[i]!=(mod+i)%3:\n                SUM+=1\n\n\n\n            ANS=min(ANS,SUM)\n\n    print(ANS)\n\n        \n                \n        \n\n    \n", "import sys\ninput = sys.stdin.readline\nq = int(input())\nfor i in range(q):\n    n, k = map(int, input().split())\n    s = input()\n    R, G, B = 0, 0, 0\n    ans = float('inf')\n    for j in range(n):\n        if j % 3 == 0:\n            if s[j] == 'R':\n                G += 1\n                B += 1\n            elif s[j] == 'G':\n                R += 1\n                B += 1\n            else:\n                R += 1\n                G += 1\n        elif j % 3 == 1:\n            if s[j] == 'R':\n                G += 1\n                R += 1\n            elif s[j] == 'G':\n                G += 1\n                B += 1\n            else:\n                R += 1\n                B += 1\n        else:\n            if s[j] == 'R':\n                R += 1\n                B += 1\n            elif s[j] == 'G':\n                R += 1\n                G += 1\n            else:\n                G += 1\n                B += 1\n        if j >= k - 1:\n            ans = min(ans, R, G, B)\n            if (j - k + 1) % 3 == 0:\n                if s[j - k + 1] == 'R':\n                    G -= 1\n                    B -= 1\n                elif s[j - k + 1] == 'G':\n                    R -= 1\n                    B -= 1\n                else:\n                    R -= 1\n                    G -= 1\n            elif (j - k + 1) % 3 == 1:\n                if s[j - k + 1] == 'R':\n                    G -= 1\n                    R -= 1\n                elif s[j - k + 1] == 'G':\n                    G -= 1\n                    B -= 1\n                else:\n                    R -= 1\n                    B -= 1\n            else:\n                if s[j - k + 1] == 'R':\n                    R -= 1\n                    B -= 1\n                elif s[j - k + 1] == 'G':\n                    R -= 1\n                    G -= 1\n                else:\n                    G -= 1\n                    B -= 1\n\n    print(ans)", "import sys\ninput = sys.stdin.readline\nQ = int(input())\nD = {\"R\":0, \"G\":1, \"B\":2}\nfor _ in range(Q):\n    N, K = list(map(int, input().split()))\n    S = input()\n    mi = K\n    for i in range(3):\n        d = 0\n        for j in range(N):\n            if D[S[j]] != (i+j) % 3:\n                d += 1\n            if j >= K and D[S[j-K]] != (i+j-K) % 3:\n                d -= 1\n            if j >= K-1:\n                mi = min(mi, d)\n    print(mi)\n", "from sys import stdin,stdout\ninput=stdin.readline\nfor _ in range(int(input())):\n    x=10**5\n    n,k=list(map(int,input().split()))\n    s=input()\n    a=10**9\n    ans=[[0]*n for i in range(3)]\n    curr=['R','G','B']\n    for l in range(3):\n        z=l\n        for j in range(n):\n            if s[j]!=curr[z]:\n                ans[l][j]=1\n            z+=1\n            z%=3\n    for i in range(3):\n        ans[i]=[0]+ans[i]\n    for l in range(3):\n        z=l\n        for j in range(1,n+1):\n            ans[l][j]+=ans[l][j-1]\n    for l in range(3):\n        for j in range(1,n-k+2):\n            a=min(a,ans[l][j+k-1]-ans[l][j-1])\n   # print(ans)\n    print(a)\n", "''' CODED WITH LOVE BY SATYAM KUMAR '''\n\nfrom sys import stdin, stdout\nimport cProfile, math\nfrom collections import Counter,defaultdict,deque\nfrom bisect import bisect_left,bisect,bisect_right\nimport itertools\nfrom copy import deepcopy\nfrom fractions import Fraction\nimport sys, threading\nimport operator as op\nfrom functools import reduce\nsys.setrecursionlimit(10**6) # max depth of recursion\nthreading.stack_size(2**27)  # new thread will get stack of such size\nfac_warmup = False\nprintHeap = str()\nmemory_constrained = False\nP = 10**9+7\nimport sys\n\nclass merge_find:\n    def __init__(self,n):\n        self.parent = list(range(n))\n        self.size = [1]*n\n        self.num_sets = n\n        self.lista = [[_] for _ in range(n)]\n    def find(self,a):\n        to_update = []\n        while a != self.parent[a]:\n            to_update.append(a)\n            a = self.parent[a]\n        for b in to_update:\n            self.parent[b] = a\n        return self.parent[a]\n    def merge(self,a,b):\n        a = self.find(a)\n        b = self.find(b)\n        if a==b:\n            return\n        if self.size[a]<self.size[b]:\n            a,b = b,a\n        self.num_sets -= 1\n        self.parent[b] = a\n        self.size[a] += self.size[b]\n        self.lista[a] += self.lista[b]\n    def set_size(self, a):\n        return self.size[self.find(a)]\n    def __len__(self):\n        return self.num_sets\n\ndef display(string_to_print):\n    stdout.write(str(string_to_print) + \"\\n\")\n\ndef primeFactors(n): #n**0.5 complex \n    factors = dict()\n    for i in range(2,math.ceil(math.sqrt(n))+1):  \n        while n % i== 0: \n            if i in factors:\n                factors[i]+=1\n            else: factors[i]=1\n            n = n // i \n    if n>2:\n        factors[n]=1\n    return (factors)\n\ndef all_factors(n):    \n    return set(reduce(list.__add__, \n                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))\n\ndef fibonacci_modP(n,MOD):\n    if n<2: return 1\n    #print (n,MOD)\n    return (cached_fn(fibonacci_modP, (n+1)//2, MOD)*cached_fn(fibonacci_modP, n//2, MOD) + cached_fn(fibonacci_modP, (n-1) // 2, MOD)*cached_fn(fibonacci_modP, (n-2) // 2, MOD)) % MOD\n\ndef factorial_modP_Wilson(n , p): \n    if (p <= n): \n        return 0\n    res = (p - 1) \n    for i in range (n + 1, p): \n        res = (res * cached_fn(InverseEuler,i, p)) % p \n    return res \n\ndef binary(n,digits = 20):\n    b = bin(n)[2:]\n    b = '0'*(digits-len(b))+b\n    return b\n\ndef isprime(n):\n    \"\"\"Returns True if n is prime.\"\"\"\n    if n < 4:\n        return True\n    if n % 2 == 0:\n        return False\n    if n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True\n\ndef generate_primes(n):\n    prime = [True for i in range(n+1)] \n    p = 2\n    while (p * p <= n): \n        if (prime[p] == True): \n            for i in range(p * 2, n+1, p): \n                prime[i] = False\n        p += 1\n    return prime\n\nfactorial_modP = []\ndef warm_up_fac(MOD):\n    nonlocal factorial_modP,fac_warmup\n    if fac_warmup: return\n    factorial_modP= [1 for _ in range(fac_warmup_size+1)]\n    for i in range(2,fac_warmup_size):\n        factorial_modP[i]= (factorial_modP[i-1]*i) % MOD\n    fac_warmup = True\n\ndef InverseEuler(n,MOD):\n    return pow(n,MOD-2,MOD)\n\ndef nCr(n, r, MOD):\n    nonlocal fac_warmup,factorial_modP\n    if not fac_warmup:\n        warm_up_fac(MOD)\n        fac_warmup = True\n    return (factorial_modP[n]*((pow(factorial_modP[r], MOD-2, MOD) * pow(factorial_modP[n-r], MOD-2, MOD)) % MOD)) % MOD\n\ndef test_print(*args):\n    if testingMode:\n        print(args)\n\ndef display_list(list1, sep=\" \"):\n    stdout.write(sep.join(map(str, list1)) + \"\\n\")\n\ndef display_2D_list(li):\n    for i in li:\n        print(i)\ndef prefix_sum(li):\n    sm = 0\n    res = []\n    for i in li:\n        sm+=i\n        res.append(sm)\n    return res\n\ndef get_int():\n    return int(stdin.readline().strip())\n\ndef get_tuple():\n    return map(int, stdin.readline().split())\n\ndef get_list():\n    return list(map(int, stdin.readline().split()))\nimport heapq,itertools\npq = []                         # list of entries arranged in a heap\nentry_finder = {}               # mapping of tasks to entries\nREMOVED = '<removed-task>' \ndef add_task(task, priority=0):\n    'Add a new task or update the priority of an existing task'\n    if task in entry_finder:\n        remove_task(task)\n    count = next(counter)\n    entry = [priority, count, task]\n    entry_finder[task] = entry\n    heapq.heappush(pq, entry)\n\ndef remove_task(task):\n    'Mark an existing task as REMOVED.  Raise KeyError if not found.'\n    entry = entry_finder.pop(task)\n    entry[-1] = REMOVED\n\ndef pop_task():\n    'Remove and return the lowest priority task. Raise KeyError if empty.'\n    while pq:\n        priority, count, task = heapq.heappop(pq)\n        if task is not REMOVED:\n            del entry_finder[task]\n            return task\n    raise KeyError('pop from an empty priority queue')\nmemory = dict()\ndef clear_cache():\n    nonlocal memory\n    memory = dict()\ndef cached_fn(fn, *args):\n    nonlocal memory\n    if args in memory:\n        return memory[args]\n    else:\n        result = fn(*args)\n        memory[args] = result\n        return result\n\ndef ncr (n,r):\n    return math.factorial(n)/(math.factorial(n-r)*math.factorial(r))\ndef binary_serach(i,li):\n    #print(\"Search for \",i)\n    fn = lambda x: li[x]-x//i\n    x = -1\n    b = len(li)\n    while b>=1:\n        #print(b,x)\n        while b+x<len(li) and fn(b+x)>0: #Change this condition 2 to whatever you like\n            x+=b\n        b=b//2\n    return x\n\n# -------------------------------------------------------------- MAIN PROGRAM\nTestCases = True\ntestingMode = False\nfac_warmup_size = 10**5+100\noptimiseForReccursion = False #Can not be used clubbed with TestCases # WHen using recursive functions, use Python 3\nfrom math import factorial\n\ndef main():\n    n, k = get_tuple()\n    st = stdin.readline()\n    li = ['R','G','B']\n\n    for offset in range(3):\n        cnt = 0\n        for i in range(k):\n            if st[i]!=li[(i+offset)%3]:\n                cnt+=1\n        if offset==0: min_cnt = cnt\n        min_cnt = min(min_cnt, cnt)\n        for i in range(k,n):\n            if st[i-k]!=li[(i-k+offset)%3]:\n                cnt-=1\n            if st[i]!=li[(i+offset)%3]:\n                cnt+=1\n            min_cnt = min(min_cnt, cnt)\n    print(min_cnt)\n\n\n\n\n\n\n# --------------------------------------------------------------------- END=\n\n\nif TestCases: \n    for i in range(get_int()): \n        cProfile.run('main()') if testingMode else main() \nelse: (cProfile.run('main()') if testingMode else main()) if not optimiseForReccursion else threading.Thread(target=main).start()", "def main():\n    q = int(input())\n    ans = []\n    for i in range(q):\n        n, k = map(int, input().split())\n        s = input()\n        min_ans = 10 ** 9\n        pr1 = [0]\n        pr2 = [0]\n        pr3 = [0]        \n        for i in range(n):\n            count1 = 0\n            count2 = 0\n            count3 = 0\n            if i % 3 == 0:\n                if s[i] != \"R\":\n                    count1 += 1\n                if s[i] != \"G\":\n                    count2 += 1\n                if s[i] != \"B\":\n                    count3 += 1\n            if i % 3 == 1:\n                if s[i] != \"G\":\n                    count1 += 1\n                if s[i] != \"B\":\n                    count2 += 1\n                if s[i] != \"R\":\n                    count3 += 1 \n            if i % 3 == 2:\n                if s[i] != \"B\":\n                    count1 += 1\n                if s[i] != \"R\":\n                    count2 += 1\n                if s[i] != \"G\":\n                    count3 += 1\n            pr1.append(pr1[-1] + count1)\n            pr2.append(pr2[-1] + count2)\n            pr3.append(pr3[-1] + count3)\n            j = i + 1\n            if j >= k:\n                count1 = pr1[j] - pr1[j - k]\n                count2 = pr2[j] - pr2[j - k]\n                count3 = pr3[j] - pr3[j - k]\n                min_ans = min(min_ans, count1, count2, count3)     \n        ans.append(min_ans)\n    print(*ans, sep=\"\\n\")\n\nmain()", "import sys\ninput = lambda: sys.stdin.readline().strip()\n\nnxt = {'R':'G', 'G':'B', 'B':'R'}\n\nT = int(input())\nfor _ in range(T):\n    n, k = list(map(int, input().split()))\n    s = input()\n    res = []\n    for start in ['R', 'G', 'B']:\n        mis = []\n        cur = start\n        for j in range(k):\n            if s[j]!=cur: mis.append(1)\n            else: mis.append(0)\n            cur = nxt[cur]\n        res.append(sum(mis))\n        for j in range(k, n):\n            res.append(res[-1]+int(s[j]!=cur)-mis[j-k])\n            if s[j]!=cur: mis.append(1)\n            else: mis.append(0)\n            cur = nxt[cur]\n    print(min(res))\n", "import sys\ninput = sys.stdin.readline\nq = int( input() )\nrgb = \"RGB\"\nfor _ in range( q ):\n    n, k = list(map( int, input().split() ))\n    s = input()\n    ans = n\n    for i in range( 3 ):\n        r = [ 0 ]\n        l = i\n        for c in s:\n            r.append( r[ -1 ] + ( 1 if c != rgb[ l ] else 0 ) )\n            l = ( l + 1 ) % 3\n            if len( r ) > k:\n                ans = min( ans, r[ -1 ] - r[ len( r ) - 1 - k ] )\n    print( ans )\n", "import sys\n\nt=int(sys.stdin.readline())\nx='RGB'\ny='GBR'\nz='BRG'\n# x='RGB'\nfor i in range(t):\n    n,k=list(map(int,sys.stdin.readline().strip().split()))\n    a=sys.stdin.readline().strip()\n    xk=x\n    yk=y\n    zk=z\n   \n    op=2001\n    \n    xd=[]\n    yd=[]\n    zd=[]\n    xdc=0\n    ydc=0\n    zdc=0\n    b=a\n    for j in range(k):\n        if(b[j]!=xk[j%3]):\n            xd.append(1)\n            xdc+=1\n        else:\n            xd.append(0)\n            \n        if(b[j]!=yk[j%3]):\n            yd.append(1)\n            ydc+=1\n        else:\n            yd.append(0)\n            \n        if(b[j]!=zk[j%3]):\n            zdc+=1\n            zd.append(1)\n        else:\n            zd.append(0)\n    op=min(xdc,ydc,zdc)\n    \n    for j in range(k,n):\n        # print(b,len(b),j,xk)\n        if(b[j]!=xk[j%3]):\n            xd.append(1)\n            xdc+=1\n        else:\n            xd.append(0)\n            \n        if(b[j]!=yk[j%3]):\n            yd.append(1)\n            ydc+=1\n        else:\n            yd.append(0)\n            \n        if(b[j]!=zk[j%3]):\n            zdc+=1\n            zd.append(1)\n        else:\n            zd.append(0)\n        # print(\"here\")\n        xdc-=xd[j-k]\n        ydc-=yd[j-k]\n        zdc-=zd[j-k]\n        op=min(op,xdc,ydc,zdc)\n    print(op)\n    \n#oh , had been testing with other test case, first had set only x, but then added back y and z :P\n", "import sys\nfor _ in range(int(sys.stdin.readline())):\n    n, k = [int(i) for i in sys.stdin.readline().split()]\n    word = sys.stdin.readline().strip()\n    ans = 0\n    for col in [\"RGB\", \"GBR\", \"BRG\"]:\n        cnt = 0\n        for i in range(k):\n            if word[i] == col[i%3]:\n                cnt += 1\n        mx = cnt\n        for i in range(n-k):\n            if word[i+k] == col[(i+k)%3]:\n                cnt += 1\n            if word[i] == col[i%3]:\n                cnt -= 1\n            if cnt > mx:\n                mx = cnt\n        ans = max(ans, mx)\n    sys.stdout.write(str(k - ans) + \"\\n\")\n\n", "a = int(input())\not = ''\nfor i in range(a):\n    b, c = list(map(int,input().split()))\n    s = input()\n    pref = [0] * (b + 1)\n    pref1 = [0] * (b + 1)\n    pref2 = [0] * (b + 1)\n    n = 'RGB'\n    n1 = 'GBR'\n    n2 = 'BRG'\n    for j in range(b):\n        pref[j + 1] = pref[j]\n        if s[j] != n[j % 3]:\n            pref[j + 1] += 1\n        pref1[j + 1] = pref1[j]\n        if s[j] != n1[j % 3]:\n            pref1[j + 1] += 1\n        pref2[j + 1] = pref2[j]\n        if s[j] != n2[j % 3]:\n            pref2[j + 1] += 1\n    mi = 1000000000\n    #print(*pref)\n    #print(*pref1)\n    #print(*pref2)\n    for j in range(c, b + 1):\n        mi = min(pref[j] - pref[j - c], pref1[j] - pref1[j - c], pref2[j] - pref2[j - c], mi)\n        #print(mi, j)\n    mi = min(pref[-1], pref1[-1], pref2[-1],  mi)\n    ot += str(mi) + '\\n'\nprint(ot)\n", "from heapq import heappush, heappop\nfrom collections import deque, Counter, defaultdict\nimport itertools\nimport sys\n#import bisect\nsys.setrecursionlimit(10**6)\ndef MI():\n    return list(map(int,input().split()))\ndef I():\n    return int(input())\ndef LI():\n    return [int(i) for i in input().split()]\nYN=['YES','NO']\ninput=sys.stdin.readline\n \nq=I()\nfor _ in range(q):\n    \n    n,k=LI()\n    ans=k\n    s=list(input())\n    l='RGB'\n    c=[[0],[0],[0]]\n    \n    for i in range(n):\n        for j in range(3):\n            if s[i]!=l[(i+j)%3]:\n                c[j].append(c[j][-1]+1)\n            else:\n                c[j].append(c[j][-1])\n    \n    #print(c)\n    for i in range(n-k+1):\n        for j in range(3):\n            ans=min(c[j][i+k]-c[j][i],ans)\n    print(ans)\n", "from sys import stdin\n\ninput = stdin.readline\n\nq = int(input())\n\nfor ppppp in range(q):\n    [n, k] = [int(item) for item in input().split(' ')]\n    x = input()\n\n    inf_seq = 'RGB'\n    ptr = 0\n\n    weights = []\n    cost = [0, 0, 0]\n    for i in range(k):\n        dd = [0, 0, 0]\n        for d in range(3):\n            if x[i] != inf_seq[(i + d) % 3]:\n                dd[d] = 1\n                cost[d] += 1\n        weights.append(dd)\n\n    min_changes = min(cost)\n\n    for i in range(k, n):\n        dd = [0, 0, 0]\n        for d in range(3):\n            # remove previous cost\n            cost[d] -= weights[i - k][d]\n\n            if x[i] != inf_seq[(i + d) % 3]:\n                dd[d] = 1\n                cost[d] += 1\n        weights.append(dd)\n        min_changes = min(min_changes, min(cost))\n\n    print(min_changes)\n", "# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\nfrom sys import stdin, stdout\nimport collections\n\nQ = int(input())\nans = [0]*Q\n#s = input()\n#N = len(s)\n#arr = [int(x) for x in stdin.readline().split()]\nfor q in range(Q):\n\n    N,K = [int(x) for x in stdin.readline().split()]\n    s = input()\n    res = N+1\n\n    if N==1 or K==1:\n        #print(0)\n        ans[q] = 0\n        continue\n\n    prefix = [0]*(N+1)\n\n    for k in range(3):\n        if k==0:\n            RGB = 'RGB'\n        if k==1:\n            RGB = 'GBR'\n        if k==2:\n            RGB = 'BRG'\n\n        ssum = 0\n        for i in range(N):\n            letter = RGB[i%3]\n            if s[i]!=letter:\n                ssum += 1\n            prefix[i+1] = ssum\n            if i>=K-1:\n                res = min(res,prefix[i+1] - prefix[i+1-K])\n\n    ans[q] = res\n\nprint(*ans,sep='\\n')", "import sys\ninput=sys.stdin.readline\nq=int(input())\nfor i in range(q):\n    n,k=map(int,input().split())\n    s=input()[:n]\n    if k==1:\n        print(0)\n        continue\n    rgb=[0,0,0]\n    a=1\n    for j,c in enumerate(s):\n        if c==\"R\":\n            rgb[j%3]+=1\n        elif c==\"G\":\n            rgb[(j-1)%3]+=1\n        else:\n            rgb[(j-2)%3]+=1\n        if j+1>=k:\n            a=max(a,max(rgb))\n            t=s[j-k+1]\n            if t==\"R\":\n                rgb[(j-k+1)%3]-=1\n            elif t==\"G\":\n                rgb[(j-k)%3]-=1\n            else:\n                rgb[(j-k-1)%3]-=1\n            if a==k:\n                print(0)\n                break\n    else:\n        print(k-a)", "# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\nfrom sys import stdin, stdout\nimport collections\n\nQ = int(input())\nans = [0]*Q\n#s = input()\n#N = len(s)\n#arr = [int(x) for x in stdin.readline().split()]\nfor q in range(Q):\n\n    N,K = [int(x) for x in stdin.readline().split()]\n    s = input()\n    res = N+1\n\n    if N==1 or K==1:\n        #print(0)\n        ans[q] = 0\n        continue\n\n    prefix = [0]*(N+1)\n\n    for k in range(3):\n        if k==0:\n            RGB = 'RGB'\n        if k==1:\n            RGB = 'GBR'\n        if k==2:\n            RGB = 'BRG'\n\n        ssum = 0\n        for i in range(N):\n            letter = RGB[i%3]\n            if s[i]!=letter:\n                ssum += 1\n            prefix[i+1] = ssum\n            if i>=K-1:\n                res = min(res,prefix[i+1] - prefix[i+1-K])\n\n    ans[q] = res\n\nprint(*ans,sep='\\n')", "def int_list():\n    return  [int(c) for c in input().split()]\n\ndef int1():\n    return int(input())\n\ndef str_list():\n    return [c for c in input().split()]\n\ndef str1():\n    return input()\n\n# start\n\ns1 = (\"RGB\" * 66667)[:-1]\ns2 = (\"GBR\" * 66667)[:-1]\ns3 = (\"BRG\" * 66667)[:-1]\n\nq = int1()\nres = []\n\nfor j in range(q):\n    n, k = int_list()\n    s = str1()\n\n    c1 = []\n    c2 = []\n    c3 = []\n\n    for i in range(n):\n        if s[i] != s1[i]:\n            c1.append(1)\n        else:\n            c1.append(0)\n        if s[i] != s2[i]:\n            c2.append(1)\n        else:\n            c2.append(0)\n        if s[i] != s3[i]:\n            c3.append(1)\n        else:\n            c3.append(0)\n\n    min1 = sum(c1[:k])\n    min2 = sum(c2[:k])\n    min3 = sum(c3[:k])\n\n    cost1 = min1\n    cost2 = min2\n    cost3 = min3\n\n    for i in range(k, n):\n        cost1 += (c1[i] - c1[i-k])\n        cost2 += (c2[i] - c2[i-k])\n        cost3 += (c3[i] - c3[i-k])\n\n        min1 = cost1 if cost1 < min1 else min1\n        min2 = cost2 if cost2 < min2 else min2\n        min3 = cost3 if cost3 < min3 else min3\n\n    res.append(min(min1, min2, min3))\n\nfor result in res:\n    print(result)\n", "q=int(input())\nf=[]\nfor i in range(q):\n    n,k=map(int,input().split())\n    s=input()\n    mi=0\n    num=[0,0,0]\n    for i in range(n):\n        if i%3==0:\n            if s[i]=='R':\n                num[0]+=1\n            elif s[i]=='G':\n                num[1]+=1\n            else:\n                num[2]+=1\n        elif i%3==1:\n            if s[i]=='G':\n                num[0]+=1\n            elif s[i]=='B':\n                num[1]+=1\n            else:\n                num[2]+=1\n        else:\n            if s[i]=='B':\n                num[0]+=1\n            elif s[i]=='R':\n                num[1]+=1\n            else:\n                num[2]+=1\n        if i>=k:\n            if (i-k)%3==0:\n                if s[i-k]=='R':\n                    num[0]-=1\n                elif s[i-k]=='G':\n                    num[1]-=1\n                else:\n                    num[2]-=1\n            elif (i-k)%3==1:\n                if s[i-k]=='G':\n                    num[0]-=1\n                elif s[i-k]=='B':\n                    num[1]-=1\n                else:\n                    num[2]-=1\n            else:\n                if s[i-k]=='B':\n                    num[0]-=1\n                elif s[i-k]=='R':\n                    num[1]-=1\n                else:\n                    num[2]-=1\n        e=max(num)\n        if mi<e:\n            mi=e\n    f+=[k-mi]\nfor i in f:\n    print(i)", "import sys\n \nt = int(input())\nfor _ in range(t):\n    n, k = list(map(int, sys.stdin.readline().split()))\n    s = sys.stdin.readline()\n    d = {}\n    d['R'] = [0,0,0]\n    d['G'] = [0,0,0]\n    d['B'] = [0,0,0]\n    res = 0\n    for i in range(k):\n        d[s[i]][i%3] += 1\n    res = max(d['R'][0] + d['G'][1] + d['B'][2], d['R'][1] + d['G'][2] + d['B'][0], d['R'][2] + d['G'][0] + d['B'][1])\n    for i in range(k, n):\n        d[s[i]][i%3] += 1\n        d[s[i-k]][(i-k)%3] -= 1\n        res = max(res, d['R'][0] + d['G'][1] + d['B'][2], d['R'][1] + d['G'][2] + d['B'][0], d['R'][2] + d['G'][0] + d['B'][1])\n        if res >= k:\n            break\n    print(k-res)\n        \n\n", "from sys import stdin\ninput=stdin.readline\nfor _ in range(int(input())):\n    n,k=map(int,input().split())\n    s=list(input())\n    ans=10**9\n    a=['R','G','B']\n    for l in range(3):\n        x=l\n        dp=[0]*(n+1)\n        cnt=10**9\n        for i in range(n):\n            if s[i]!=a[x]:\n                dp[i+1]=dp[i]+1\n            else: dp[i+1]=dp[i]\n            x=(x+1)%3\n        for i in range(1,n-k+2):\n            cnt=min(cnt,dp[i+k-1]-dp[i-1])\n        ans=min(cnt,ans)\n    print(ans)", "import sys\ndef main():\n    def diff(s,l):\n        ret1 = [0 for k in range(len(s))]\n        for k in range(len(s)):\n            if k%3 == 0 and s[k] != \"R\":\n                ret1[k] = 1\n            if k%3 == 1 and s[k] != \"G\":\n                ret1[k] = 1\n            if k%3 == 2 and s[k] != \"B\":\n                ret1[k] = 1\n        ret2 = [0] * len(s)\n        for k in range(len(s)):\n            if k%3 == 0 and s[k] != \"G\":\n                ret2[k] = 1\n            if k%3 == 1 and s[k] != \"B\":\n                ret2[k] = 1\n            if k%3 == 2 and s[k] != \"R\":\n                ret2[k] = 1\n        ret3 = [0] * len(s)\n        for k in range(len(s)):\n            if k%3 == 0 and s[k] != \"B\":\n                ret3[k] = 1\n            if k%3 == 1 and s[k] != \"R\":\n                ret3[k] = 1\n            if k%3 == 2 and s[k] != \"G\":\n                ret3[k] = 1\n        s1 = [0] * (len(s)+1)\n        s2 = [0] * (len(s)+1)\n        s3 = [0] * (len(s)+1)\n        for k in range(1,n+1):\n            s1[k] = s1[k-1] + ret1[k-1]\n            s2[k] = s2[k-1] + ret2[k-1]\n            s3[k] = s3[k-1] + ret3[k-1]\n        ans = 1000000\n        for k in range(len(s)-l):\n            ans = min(ans,s1[k+l]-s1[k],s2[k+l]-s2[k],s3[k+l]-s3[k])\n        return ans\n    input = sys.stdin.readline\n    q = int(input())\n    for query in range(q):\n        n, k = list(map(int,input().split()))\n        s = input()\n        print(diff(s,k))\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nfor _ in range(int(sys.stdin.readline())):\n    n, k = [int(i) for i in sys.stdin.readline().split()]\n    word = sys.stdin.readline().strip()\n    ans = 0\n    for col in [\"RGB\", \"GBR\", \"BRG\"]:\n        cnt = 0\n        for i in range(k):\n            if word[i] == col[i%3]:\n                cnt += 1\n        mx = cnt\n        for i in range(n-k):\n            if word[i+k] == col[(i+k)%3]:\n                cnt += 1\n            if word[i] == col[i%3]:\n                cnt -= 1\n            if cnt > mx:\n                mx = cnt\n        ans = max(ans, mx)\n    sys.stdout.write(str(k - ans) + \"\\n\")\n\n"]