["# @author \n\nimport sys\n\nclass GCandyBoxHardVersion:\n    def solve(self):\n        q = int(input())\n        for _ in range(q):\n            n = int(input())\n            a = [0] * n\n            f = [0] * n\n            for i in range(n):\n                a[i], f[i] = [int(_) for _ in input().split()]\n\n            d = {key: [0, 0] for key in a}\n            for i in range(n):\n                d[a[i]][f[i]] += 1\n            rev_d = {sum(key): [] for key in list(d.values())}\n            for x in d:\n                rev_d[d[x][0] + d[x][1]] += [d[x]]\n\n            for x in rev_d:\n                rev_d[x].sort(key=lambda item:item[1])\n\n            # print(rev_d)\n\n            cur = max(rev_d)\n            cnt = max(rev_d)\n            nb_candies = 0\n            given_away = 0\n            while 1:\n                if cnt == 0 or cur == 0:\n                    break\n                if cur > cnt:\n                    cur -= 1\n                    continue\n\n                if cnt not in rev_d or not rev_d[cnt]:\n                    cnt -= 1\n                    continue\n\n                mx_f = -1\n                v = -1\n                for max_cnt in range(cur, cnt + 1):\n                    if max_cnt in rev_d and rev_d[max_cnt] and rev_d[max_cnt][-1][1] > mx_f:\n                        v = max_cnt\n                        mx_f = rev_d[max_cnt][-1][1]\n                to_take = rev_d[v].pop()\n                # rev_d[cnt] -= 1\n                nb_candies += cur\n                given_away += min(to_take[1], cur)\n                cur -= 1\n                # rev_d[cnt - cur] += 1\n            print(nb_candies, given_away)\n\nsolver = GCandyBoxHardVersion()\ninput = sys.stdin.readline\n\nsolver.solve()\n", "def addInDict(x, y):\n    nonlocal d, d2\n    if x not in d:\n        d[x] = 0\n    if x not in d2[y]:\n        d2[y][x] = 0\n    d[x] += 1\n    d2[y][x] += 1\n\ndef calcSum1():\n    nonlocal d, d2, d3, d4, d4Keys, s1, s2\n    for kol in d4Keys:\n        for numPart in d4[kol]:\n            kol1 = d[numPart]\n            while kol1 in d3 and kol1 > 0:\n                kol1 -= 1\n            if kol1 > 0:\n                d3[kol1] = 1\n                s1 += kol1\n                s2 += min(kol, kol1)\n                if numPart in d2[0]:\n                    del d2[0][numPart]\n            \n            \ndef calcSum0():\n    nonlocal d, d2, d3, s1, s2\n    for key in d2[0]:\n        kol = d[key]\n        while kol in d3 and kol > 0:\n            kol -= 1\n        if kol > 0:\n            d3[kol] = 1\n            s1 += kol\n\nimport sys\nfor _ in range(int(input())):\n    n = int(sys.stdin.readline())\n    d, d2, d3, d4 = {}, {}, {}, {}\n    d2[0] = {}\n    d2[1] = {}\n    for __ in range(n):\n        a, f = list(map(int, sys.stdin.readline().split()))\n        addInDict(a, f)\n##    print('d=', d)\n##    print('d2=', d2)\n    s1, s2 = 0, 0\n    for i in d2[1]:\n        if d2[1][i] not in d4:\n            d4[d2[1][i]] = {}\n        d4[d2[1][i]][i] = i\n##    print('d4=', d4)\n    d4Keys = list(d4.keys())\n    d4Keys.sort(reverse = True)\n##    print('d4Keys=', d4Keys)\n    \n    calcSum1()\n    calcSum0()\n    print(s1, s2)\n", "import sys\ninput = sys.stdin.readline\nimport heapq\nfrom collections import Counter\n\nQ=int(input())\nfor testcase in range(Q):\n    n=int(input())\n    C=[list(map(int,input().split())) for i in range(n)]\n\n    D=[[0,0] for i in range(n+1)]\n\n    for x,y in C:\n        D[x][0]+=1\n        if y==1:\n            D[x][1]+=1\n\n    W=[]\n    for i in range(n+1):\n        if D[i][0]!=0:\n            W.append((D[i][0],D[i][1]))\n\n    W.sort(reverse=True)\n    W.append((0,0))\n    #print(W)\n\n    C2=Counter([c[0] for c in C])\n    S=sorted(list(C2.values()),reverse=True)\n\n    NOW=10**10\n\n    ANS=[]\n    for s in S:\n        M=min(NOW,s)\n        ANS.append(M)\n        NOW=M-1\n\n        if NOW==0:\n            break\n\n    #print(ANS,sum(ANS))\n\n    H=[]\n    i=0\n    ANS1=0\n    for ans in ANS:\n        while W[i][0]>=ans:\n            heapq.heappush(H,-W[i][1])\n            i+=1\n\n        x=min(ans,-heapq.heappop(H))\n        ANS1+=x\n    print(sum(ANS),ANS1)\n            \n            \n\n        \n\n    \n", "import sys\nfrom collections import Counter\ninput = sys.stdin.readline\nfor _ in range(int(input())):\n    n = int(input())\n    c01 = []\n    c1 = [0]*(n+1)\n\n    for x, y in (list(map(int, input().split())) for _ in range(n)):\n        c01.append(x)\n        if y == 1:\n            c1[x] += 1\n\n    f1cnt = [[] for _ in range(n+1)]\n    cnt01 = Counter(c01)\n    for k, v in list(cnt01.items()):\n        f1cnt[v].append(c1[k])\n\n    ans = 0\n    ansf1 = 0\n\n    for i in range(n, 0, -1):\n        if f1cnt[i]:\n            ans += i\n            f1cnt[i].sort()\n            ansf1 += min(i, f1cnt[i].pop())\n            while f1cnt[i]:\n                f1cnt[i-1].append(f1cnt[i].pop())\n\n    print(ans, ansf1)\n", "import sys\nimport math\nfrom collections import defaultdict,deque\nimport heapq\nq=int(sys.stdin.readline())\nfor _ in range(q):\n\tn=int(sys.stdin.readline())\n\tdic=defaultdict(list)\n\tfor i in range(n):\n\t\ta,b=map(int,sys.stdin.readline().split())\n\t\tif dic[a]==[]:\n\t\t\tdic[a]=[0,0]\n\t\tdic[a][0]+=1\n\t\tdic[a][1]+=(1-b)\n\tans=0\n\tcnt=0\n\t#ind=len(l)-1\n\theap=[]\n\theapq.heapify(heap)\n\tvis=defaultdict(int)\n\tfor i in dic:\n\t\theapq.heappush(heap,[-dic[i][0],dic[i][1]])\n\tmaxlen=n\n\twhile heap and maxlen>0:\n\t\ta,b=heapq.heappop(heap)\n\t\tif vis[-a]==1:\n\t\t\theapq.heappush(heap,[a+1,max(b-1,0)])\n\t\telse:\n\t\t\tvis[-a]=1\n\t\t\tmaxlen=-a-1\n\t\t\tans+=-a\n\t\t\tcnt+=b\n\tprint(ans,ans-cnt)", "# coding: utf-8\n# Your code here!\nfrom collections import defaultdict\nimport sys\nimport heapq\n\n\ndef input(): return sys.stdin.readline()\n\n\ndef solution():\n    n = int(input())\n    candi = [[0, 0] for i in range(n+1)]\n    que = []\n    for i in range(n):\n        taste, youwant = list(map(int, input().split()))\n        if youwant == 1:\n            candi[taste][0] += 1\n        else:\n            candi[taste][1] += 1\n\n    for i in range(n+1):\n        s = sum(candi[i])\n        if s > 0:\n            que.append((-s, -candi[i][0], -candi[i][1]))\n    heapq.heapify(que)\n    ans = 0\n    badcnt = 0\n    border = -que[0][0]\n    stocked = []\n    heapq.heapify(stocked)  # where not still used\n    ording = 0\n    while (que or stocked) and border > 0:\n        ording += 1\n        while que and que[0][0] <= -border:\n            poped_cnt, poped_good_candi, poped_bad_candi = heapq.heappop(que)\n            heapq.heappush(stocked, (poped_good_candi, poped_bad_candi))\n\n        if not stocked:\n            if que:\n                border = -que[0][0]\n            continue\n\n        # print(\"phase: \", ording)\n        # print(\"que: \", que)\n        # print(\"stocked: \", stocked)\n        # print(\"border: \", border)\n        # print(\"\\n\")\n        if stocked:\n            good_candi, bad_candi = heapq.heappop(stocked)\n            good_candi *= -1\n            bad_candi *= -1\n            sums = good_candi + bad_candi\n            if sums < border:\n                ans += sums\n                border = sums - 1\n                badcnt += good_candi\n                continue\n\n            elif sums >= border:\n                ans += border\n                badcnt += min(border, good_candi)\n                border -= 1\n                continue\n\n    print(ans, badcnt)\n\n    return\n\n\ndef main():\n    test = int(input())\n    for i in range(test):\n        solution()\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()"]