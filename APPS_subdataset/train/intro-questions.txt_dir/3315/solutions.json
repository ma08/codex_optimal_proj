["\"\"\"Strongest even number in an interval kata\n\nDefines strongest_even(n, m) which returns the strongest even number in the set\nof integers on the interval [n, m].\n\nConstraints:\n    1. 1 <= n < m < MAX_INT\n\nNote:\n    1. The evenness of zero is need not be defined given the constraints.\n    2. In Python 3, the int type is unbounded. In Python 2, MAX_INT is\n    determined by the platform.\n\nDefinition:\n    A number is said to be more strongly even than another number if the\n    multiplicity of 2 in its prime factorization is higher than in the prime\n    factorization of the other number.\n\"\"\"\nfrom math import log2\n\n\ndef strongest_even(n, m):\n    \"\"\"Returns the strongest even number in the set of integers on interval\n       [n, m].\n    \"\"\"\n\n    #It can be shown that the largest power of 2 on an interval [n, m] will\n    #necessarily be the strongest even number. Check first if the interval\n    #contains a power of 2, by comparing the log2 of the endpoints.\n    if int(log2(m)) > int(log2(n)):\n        return 2**int(log2(m))\n\n    #Modify the endpoints exclude any odd numbers. If the two endpoints are\n    #equal, the original interval contains only a single even number. Return it.\n    n += n % 2\n    m -= m % 2\n    if n == m:\n        return n\n\n    #All optimizations and edge cases are exhausted. Recurse with the\n    #modified endpoints halved, and multiply the result by 2.\n    return 2*strongest_even(n // 2, m // 2)\n", "def strongest_even(n, m):\n    while m & m - 1 >= n:\n        m &= m - 1\n    return m", "def strongest_even(n, m):\n    while True:\n        if m & m - 1 < n: return m\n        m &= m - 1", "from math import log2\n\ndef strongest_even(n, m):\n    b = x = 2**int(log2(m))\n    \n    while not n <= x <= m:\n        b //= 2\n        x = (m // b) * b\n    \n    return x", "def strongest_even(n, m):\n    while n <= m:\n        prev = n\n        n += 1 << strongness(n)\n    return prev\n\ndef strongness(n):\n    return n.bit_length() - len(format(n, 'b').rstrip('0'))", "def strongest_even(n, m):\n    x, y = bin(n)[2:], bin(m)[2:]\n    if len(x) < len(y): return 1 << len(y)-1\n    i = next(i for i in range(len(x)) if x[i] != y[i])\n    res = x[:i] + ('1' if '1' in x[i:] else '0') + '0'*(len(x)-i-1)\n    return int(res, 2)", "def strongest_even(n, m):\n    n = n if n % 2 == 0 else n + 1\n    m = m if m % 2 == 0 else m - 1\n        \n    x = 2\n    \n    while not x * 2 > m:\n        x *= 2\n    \n    if x < n:\n        i, s, a = m, n, x\n        \n        while i >= n:\n            if i % a/2 == 0:\n                s = i\n                i -= a\n                a = x\n                \n            a = a/2 if a/2 > 1 else 2\n            \n        return s\n    else:\n        return x\n       \n", "def strongest_even(n, m):\n    exponent = 1\n    while (m > 2**exponent):\n        exponent += 1\n    \n    if (n <= 2**exponent <= m):\n        return 2**exponent\n\n    while(exponent > 0):\n        exponent -= 1\n        factor = 1\n        while((2**exponent)*factor <= m):\n            if (n <= (2**exponent)*factor <= m):\n                return (2**exponent)*factor\n            factor += 2", "def strongest_even(n, m):\n    pow = 1\n    while pow <= m:\n        pow *= 2\n    if pow/2 <= m and pow/2 >= n:\n        return pow/2\n    else:\n        pow /= 4\n        multiplier = 3\n        while True:\n            multiple = pow * multiplier\n            while multiple <= m:\n                if n <= multiple:\n                    return multiple\n                else:\n                    multiplier += 1\n                    multiple = pow * multiplier\n            pow /= 2\n            multiple = 3\n", "from math import log\nfrom math import floor\n\ndef strongest_even(n,m):\n    a=2**floor(log(m)/log(2));b=1;    \n    while a*b<n or a*b>m:\n        a /= 2;\n        b += 2;\n        while a*b<=m:\n            if a*b>=n:\n                return a*b\n            b +=2\n        \n    return a*b \n#strongest_even(33,47)\n"]