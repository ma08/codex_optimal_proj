["from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1: return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for line, idx, val in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef play_OX_3D(moves):\n    grid, lines = [], winning_lines(4, 3)\n    for m in moves:\n        grid.append(tuple(m))\n        if any(line <= set(grid[-1::-2]) for line in lines):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'", "def checker(board, i, j, k, turn):\n          \n        return all(n == turn for n in board[i][j])                           or \\\n               all(n == turn for n in [m[k] for m in board[i]])              or \\\n               all(board[i][n][n] == turn for n in range(4))                 or \\\n               all(board[i][n][3 - n] == turn for n in range(4))             or \\\n               all(bn[j][k] == turn for bn in board)                         or \\\n               all(board[n][n][n] == turn for n in range(4))                 or \\\n               all(board[n][n][3 - n] == turn for n in range(4))             or \\\n               all(board[n][3 - n][3 - n] == turn for n in range(4))         or \\\n               all(board[n][3 - n][n] == turn for n in range(4))             or \\\n               all(board[n][3 - n][k] == turn for n in range(4))             or \\\n               all(board[n][n][k] == turn for n in range(4))                 or \\\n               all(board[n][j][n] == turn for n in range(4))                 or \\\n               all(board[n][j][3 - n] == turn for n in range(4))\n    \ndef play_OX_3D(moves):\n    board = [[[' ' for _ in range(4)] for _ in range(4)] for _ in range(4)]\n    turn = 'O'\n\n    for ind, (i, j, k) in enumerate(moves, 1):\n        board[i][j][k] = turn\n    \n        if checker(board, i, j, k, turn):\n            return f'{turn} wins after {ind} moves'\n  \n        turn = 'OX'[turn == 'O']\n        \n    return 'No winner'", "def play_OX_3D(moves):\n    d = [], []\n    for n, (x, y, z) in enumerate(moves, 1):\n        c = d[n%2]\n        c += zip(range(13),(x,x,y,x,x,y,y,z,z,x+y,y+x,z+x,x-y),(y,z,z,y+z,y-z,x+z,x-z,x+y,x-y,x+z,y+z,z+y,y-z))\n        if 4 in map(c.count, c):\n            return 'XO'[n%2] + ' wins after %d moves' % n\n    return 'No winner'", "\nlines = [\n    [[0, 0, 0], [0, 0, 1], [0, 0, 2], [0, 0, 3]],\n    [[0, 1, 0], [0, 1, 1], [0, 1, 2], [0, 1, 3]],\n    [[0, 2, 0], [0, 2, 1], [0, 2, 2], [0, 2, 3]],\n    [[0, 3, 0], [0, 3, 1], [0, 3, 2], [0, 3, 3]],\n    [[1, 0, 0], [1, 0, 1], [1, 0, 2], [1, 0, 3]],\n    [[1, 1, 0], [1, 1, 1], [1, 1, 2], [1, 1, 3]],\n    [[1, 2, 0], [1, 2, 1], [1, 2, 2], [1, 2, 3]],\n    [[1, 3, 0], [1, 3, 1], [1, 3, 2], [1, 3, 3]],\n    [[2, 0, 0], [2, 0, 1], [2, 0, 2], [2, 0, 3]],\n    [[2, 1, 0], [2, 1, 1], [2, 1, 2], [2, 1, 3]],\n    [[2, 2, 0], [2, 2, 1], [2, 2, 2], [2, 2, 3]],\n    [[2, 3, 0], [2, 3, 1], [2, 3, 2], [2, 3, 3]],\n    [[3, 0, 0], [3, 0, 1], [3, 0, 2], [3, 0, 3]],\n    [[3, 1, 0], [3, 1, 1], [3, 1, 2], [3, 1, 3]],\n    [[3, 2, 0], [3, 2, 1], [3, 2, 2], [3, 2, 3]],\n    [[3, 3, 0], [3, 3, 1], [3, 3, 2], [3, 3, 3]],\n    [[0, 0, 0], [0, 1, 0], [0, 2, 0], [0, 3, 0]],\n    [[0, 0, 1], [0, 1, 1], [0, 2, 1], [0, 3, 1]],\n    [[0, 0, 2], [0, 1, 2], [0, 2, 2], [0, 3, 2]],\n    [[0, 0, 3], [0, 1, 3], [0, 2, 3], [0, 3, 3]],\n    [[1, 0, 0], [1, 1, 0], [1, 2, 0], [1, 3, 0]],\n    [[1, 0, 1], [1, 1, 1], [1, 2, 1], [1, 3, 1]],\n    [[1, 0, 2], [1, 1, 2], [1, 2, 2], [1, 3, 2]],\n    [[1, 0, 3], [1, 1, 3], [1, 2, 3], [1, 3, 3]],\n    [[2, 0, 0], [2, 1, 0], [2, 2, 0], [2, 3, 0]],\n    [[2, 0, 1], [2, 1, 1], [2, 2, 1], [2, 3, 1]],\n    [[2, 0, 2], [2, 1, 2], [2, 2, 2], [2, 3, 2]],\n    [[2, 0, 3], [2, 1, 3], [2, 2, 3], [2, 3, 3]],\n    [[3, 0, 0], [3, 1, 0], [3, 2, 0], [3, 3, 0]],\n    [[3, 0, 1], [3, 1, 1], [3, 2, 1], [3, 3, 1]],\n    [[3, 0, 2], [3, 1, 2], [3, 2, 2], [3, 3, 2]],\n    [[3, 0, 3], [3, 1, 3], [3, 2, 3], [3, 3, 3]],\n    [[0, 0, 0], [1, 0, 0], [2, 0, 0], [3, 0, 0]],\n    [[0, 0, 1], [1, 0, 1], [2, 0, 1], [3, 0, 1]],\n    [[0, 0, 2], [1, 0, 2], [2, 0, 2], [3, 0, 2]],\n    [[0, 0, 3], [1, 0, 3], [2, 0, 3], [3, 0, 3]],\n    [[0, 1, 0], [1, 1, 0], [2, 1, 0], [3, 1, 0]],\n    [[0, 1, 1], [1, 1, 1], [2, 1, 1], [3, 1, 1]],\n    [[0, 1, 2], [1, 1, 2], [2, 1, 2], [3, 1, 2]],\n    [[0, 1, 3], [1, 1, 3], [2, 1, 3], [3, 1, 3]],\n    [[0, 2, 0], [1, 2, 0], [2, 2, 0], [3, 2, 0]],\n    [[0, 2, 1], [1, 2, 1], [2, 2, 1], [3, 2, 1]],\n    [[0, 2, 2], [1, 2, 2], [2, 2, 2], [3, 2, 2]],\n    [[0, 2, 3], [1, 2, 3], [2, 2, 3], [3, 2, 3]],\n    [[0, 3, 0], [1, 3, 0], [2, 3, 0], [3, 3, 0]],\n    [[0, 3, 1], [1, 3, 1], [2, 3, 1], [3, 3, 1]],\n    [[0, 3, 2], [1, 3, 2], [2, 3, 2], [3, 3, 2]],\n    [[0, 3, 3], [1, 3, 3], [2, 3, 3], [3, 3, 3]],\n    [[0, 0, 0], [0, 1, 1], [0, 2, 2], [0, 3, 3]],\n    [[0, 3, 0], [0, 2, 1], [0, 1, 2], [0, 0, 3]],\n    [[1, 0, 0], [1, 1, 1], [1, 2, 2], [1, 3, 3]],\n    [[1, 3, 0], [1, 2, 1], [1, 1, 2], [1, 0, 3]],\n    [[2, 0, 0], [2, 1, 1], [2, 2, 2], [2, 3, 3]],\n    [[2, 3, 0], [2, 2, 1], [2, 1, 2], [2, 0, 3]],\n    [[3, 0, 0], [3, 1, 1], [3, 2, 2], [3, 3, 3]],\n    [[3, 3, 0], [3, 2, 1], [3, 1, 2], [3, 0, 3]],\n    [[0, 0, 0], [1, 0, 1], [2, 0, 2], [3, 0, 3]],\n    [[3, 0, 0], [2, 0, 1], [1, 0, 2], [0, 0, 3]],\n    [[0, 1, 0], [1, 1, 1], [2, 1, 2], [3, 1, 3]],\n    [[3, 1, 0], [2, 1, 1], [1, 1, 2], [0, 1, 3]],\n    [[0, 2, 0], [1, 2, 1], [2, 2, 2], [3, 2, 3]],\n    [[3, 2, 0], [2, 2, 1], [1, 2, 2], [0, 2, 3]],\n    [[0, 3, 0], [1, 3, 1], [2, 3, 2], [3, 3, 3]],\n    [[3, 3, 0], [2, 3, 1], [1, 3, 2], [0, 3, 3]],\n    [[0, 0, 0], [1, 1, 0], [2, 2, 0], [3, 3, 0]],\n    [[3, 0, 0], [2, 1, 0], [1, 2, 0], [0, 3, 0]],\n    [[0, 0, 1], [1, 1, 1], [2, 2, 1], [3, 3, 1]],\n    [[3, 0, 1], [2, 1, 1], [1, 2, 1], [0, 3, 1]],\n    [[0, 0, 2], [1, 1, 2], [2, 2, 2], [3, 3, 2]],\n    [[3, 0, 2], [2, 1, 2], [1, 2, 2], [0, 3, 2]],\n    [[0, 0, 3], [1, 1, 3], [2, 2, 3], [3, 3, 3]],\n    [[3, 0, 3], [2, 1, 3], [1, 2, 3], [0, 3, 3]],\n    [[0, 0, 0], [1, 1, 1], [2, 2, 2], [3, 3, 3]],\n    [[3, 0, 0], [2, 1, 1], [1, 2, 2], [0, 3, 3]],\n    [[0, 3, 0], [1, 2, 1], [2, 1, 2], [3, 0, 3]],\n    [[3, 3, 0], [2, 2, 1], [1, 1, 2], [0, 0, 3]]\n]\n\n\ndef is_won(moves):\n    for line in lines:\n        if all(x in moves for x in line):\n            return True\n    return False\n\n\ndef play_OX_3D(moves):\n    idx = -1\n    players = [{'name': 'O', 'moves': []}, {'name': 'X', 'moves': []}]\n    for i, mov in enumerate(moves):\n        idx = (idx+1) % 2\n        player = players[idx]\n        player['moves'].append(list(mov))\n        if is_won(player['moves']):\n            return f'{player[\"name\"]} wins after {i+1} moves'\n    return \"No winner\"", "def find_winner(grid):\n    for x in range(4):\n        for y in range(4):\n            if grid[x][y][0] and len({grid[x][y][i] for i in range(4)}) == 1:\n                return grid[x][y][0]\n            if grid[0][x][y] and len({grid[i][x][y] for i in range(4)}) == 1:\n                return grid[0][x][y]\n            if grid[x][0][y] and len({grid[x][i][y] for i in range(4)}) == 1:\n                return grid[x][0][y]\n            if x == 0 and grid[0][y][0] and len({grid[i][y][i] for i in range(4)}) == 1:\n                return grid[0][y][0]\n            if x == 3 and grid[3][y][0] and len({grid[3-i][y][i] for i in range(4)}) == 1:\n                return grid[3][y][0]\n            if y == 0 and grid[x][0][0] and len({grid[x][i][i] for i in range(4)}) == 1:\n                return grid[x][0][0]\n            if y == 3 and grid[x][3][0] and len({grid[x][3-i][i] for i in range(4)}) == 1:\n                return grid[x][3][0]\n    for z in range(4):\n        if grid[0][0][z] and len({grid[i][i][z] for i in range(4)}) == 1:\n            return grid[0][0][z]\n        if grid[3][0][z] and len({grid[3-i][i][z] for i in range(4)}) == 1:\n            return grid[3][0][z]\n    if grid[0][0][0] and len({grid[i][i][i] for i in range(4)}) == 1:\n        return grid[0][0][0]\n    if grid[0][3][0] and len({grid[i][3-i][i] for i in range(4)}) == 1:\n        return grid[0][3][0]\n    if grid[0][0][3] and len({grid[i][i][3-i] for i in range(4)}) == 1:\n        return grid[0][0][3]\n    if grid[0][3][3] and len({grid[i][3-i][3-i] for i in range(4)}) == 1:\n        return grid[0][3][3]\n            \n\ndef play_OX_3D(moves):\n    grid = [[[None for _ in range(4)] for _ in range(4)] for _ in range(4)]\n    \n    players = ['O', 'X']\n    \n    for i, (x, y, z) in enumerate(moves):\n        player = players[i%len(players)]\n        grid[x][y][z] = player\n        winner = find_winner(grid)\n        \n        if winner:\n            return f'{player} wins after {i+1} moves'\n    \n    return 'No winner'\n", "def check_victory(board):\n    size = len(board)\n    \n    depth_sums = [[0] * size for i in range(size)]\n    down_cross_sums = [[0,0] for i in range(size)]\n    side_cross_sums = [[0,0,0,0] for i in range(2)]\n    diag_sums = [\n        [0,0],\n        [0,0]\n    ]\n\n    for z in range(0, size):\n        col_sums = [0] * size\n        front_cross_sums = [0,0]\n        \n        for y in range(0, size):\n            row_sum = 0\n            \n            for x in range(0, size):\n                val = board[z][y][x]\n            \n                row_sum += val\n                col_sums[x] += val\n                depth_sums[y][x] += val\n                \n                if (x == y):\n                    front_cross_sums[0] += val\n                    if (y == z):\n                        diag_sums[0][0] += val\n                    if ((y + z) == (size - 1)):\n                        diag_sums[1][0] += val\n                \n                if (x == z):\n                    down_cross_sums[y][0] += val\n                if ((x + z) == (size - 1)):\n                    down_cross_sums[y][1] += val\n                    \n                if (y == z):\n                    side_cross_sums[0][x] += val\n                if ((y + z) == (size - 1)):\n                    side_cross_sums[1][x] += val\n                \n                if ((x + y) == (size - 1)):\n                    front_cross_sums[1] += val\n                    if (y == z):\n                        diag_sums[0][1] += val\n                    if ((y + z) == (size - 1)):\n                        diag_sums[1][1] += val\n\n                if (row_sum == size\n                    or col_sums[x] == size\n                    or front_cross_sums[0] == size\n                    or front_cross_sums[1] == size\n                    or depth_sums[y][x] == size\n                    or down_cross_sums[y][0] == size\n                    or down_cross_sums[y][1] == size\n                    or side_cross_sums[0][x] == size\n                    or side_cross_sums[1][x] == size\n                    or diag_sums[0][0] == size\n                    or diag_sums[0][1] == size\n                    or diag_sums[1][0] == size\n                    or diag_sums[1][1] == size\n                    ):\n                    return 1\n                \n                if (row_sum == -size\n                    or col_sums[x] == -size\n                    or front_cross_sums[0] == -size\n                    or front_cross_sums[1] == -size\n                    or depth_sums[y][x] == -size\n                    or down_cross_sums[y][0] == -size\n                    or down_cross_sums[y][1] == -size\n                    or side_cross_sums[0][x] == -size\n                    or side_cross_sums[1][x] == -size\n                    or diag_sums[0][0] == -size\n                    or diag_sums[0][1] == -size\n                    or diag_sums[1][0] == -size\n                    or diag_sums[1][1] == -size\n                    ):\n                    return -1\n    \n    return 0\n\n\ndef play_OX_3D(moves):\n    board = [\n        [\n            [0,0,0,0],\n            [0,0,0,0],\n            [0,0,0,0],\n            [0,0,0,0]\n        ],\n        [\n            [0,0,0,0],\n            [0,0,0,0],\n            [0,0,0,0],\n            [0,0,0,0]\n        ],\n        [\n            [0,0,0,0],\n            [0,0,0,0],\n            [0,0,0,0],\n            [0,0,0,0]\n        ],\n        [\n            [0,0,0,0],\n            [0,0,0,0],\n            [0,0,0,0],\n            [0,0,0,0]\n        ],\n    ]\n    \n    move_cnt = 0\n    play_num = 1\n    \n    for move in moves:\n        board[move[2]][move[1]][move[0]] = play_num\n        move_cnt += 1\n        \n        victor = check_victory(board)\n        if (victor >= 1):\n            print(moves)\n            return \"O wins after \" + str(move_cnt) + \" moves\"\n        if (victor <= -1):\n            print(moves)\n            return \"X wins after \" + str(move_cnt) + \" moves\"\n        play_num *= -1\n    \n    print(moves)\n    return \"No winner\"\n", "def print_board(board):\n    for x in board:\n        for y in x:\n            for z in y:\n                print(z,end=' ')\n            print()\n        print()\n\ndef check_if_win(board, x, y, z):\n    diags = [\n    [(0,0,0), (1,1,1), (2,2,2), (3,3,3)],\n    [(0,0,3), (1,1,2), (2,2,1), (3,3,0)],\n    [(0,3,0), (1,2,1), (2,1,2), (3,0,3)],\n    [(0,3,3), (1,2,2), (2,1,1), (3,0,0)],\n    \n    [(0,0,0), (0,1,1), (0,2,2), (0,3,3)],\n    [(0,0,3), (0,1,2), (0,2,1), (0,3,0)],\n    [(1,0,0), (1,1,1), (1,2,2), (1,3,3)],\n    [(1,0,3), (1,1,2), (1,2,1), (1,3,0)],\n    [(2,0,0), (2,1,1), (2,2,2), (2,3,3)],\n    [(2,0,3), (2,1,2), (2,2,1), (2,3,0)],\n    [(3,0,0), (3,1,1), (3,2,2), (3,3,3)],\n    [(3,0,3), (3,1,2), (3,2,1), (3,3,0)]\n    ]\n    \n    for diag in diags:\n        if (x,y,z) in diag:\n            d = []\n            for i,j,k in diag:\n                d.append(board[i][j][k])\n            if diag[0] != '_' and are_the_same(d): return True\n    \n    hold_xy = []\n    hold_yz = []\n    hold_xz = []\n    \n    for i in range(4):\n        hold_xy.append(board[x][y][i])\n        hold_yz.append(board[i][y][z])\n        hold_xz.append(board[x][i][z])\n    \n    if hold_xy[0] != '_' and are_the_same(hold_xy): return True\n    if hold_yz[0] != '_' and are_the_same(hold_yz): return True\n    if hold_xz[0] != '_' and are_the_same(hold_xz): return True\n    \n    return False\n\ndef are_the_same(array):\n    first = array[0]\n    for c in array[1:]:\n        if first != c: return False\n    return True\n\ndef play_OX_3D(moves):\n    P=({},{})\n    for counter,(x,y,z) in enumerate(moves,1):\n        A=(x,x,y,x  ,x  ,y  ,y  ,z  ,z  ,x+y,y+x,z+x,x-y)\n        B=(y,z,z,y+z,y-z,x+z,x-z,x+y,x-y,x+z,y+z,z+y,y-z)\n        C=P[counter%2]\n        for x in zip(range(13),A,B):C[x]=C.get(x,0)+1\n        if 4 in C.values():return'XO'[counter%2]+' wins after %d moves'%counter\n    return'No winner'\n    \ndef play_OX_3DS(moves):\n    turn = 'O'\n    counter = 0\n    board = [[['_' for k in range(4)] for j in range(4)] for i in range(4)]\n    \n    for move in moves:\n        x,y,z = move\n        board[x][y][z] = turn\n        counter += 1\n        \n        if check_if_win(board, x, y, z):\n            return f'{turn} wins after {counter} moves'\n            \n        if turn == 'O':\n            turn = 'X'\n        else:\n            turn = 'O'\n            \n        print_board(board)\n        print(counter)\n    \n    return 'No winner'", "from itertools import chain\n\nORTHO = lambda move, i: lambda c: c[i] == move[i] and c[(i+1)%3] == move[(i+1)%3]\nDIAG = lambda move, i, s: lambda c: c[i] == (c[(i+1)%3] if s else 3-c[(i+1)%3]) and c[(i+2)%3] == move[(i+2)%3]\nCORN = lambda i: lambda c: c[i%3] == c[(i+1)%3] == (3 - c[(i+2)%3] if i else c[(i+2)%3])\n\ndef play_OX_3D(moves):\n    p = 0\n    board = (set(), set())\n    for move in moves:\n      board[p].add(tuple(move))\n      if any(chain(\n        (len(list(filter(ORTHO(move, i), board[p]))) == 4 for i in range(3)),\n        (len(list(filter(DIAG(move, i, s), board[p]))) == 4 for i in range(3) for s in (0,1)),\n        (len(list(filter(CORN(i), board[p]))) == 4 for i in range(3))\n        )):\n        return '{} wins after {} moves'.format(['O','X'][p], sum(map(len,board)))\n      p = 1 - p\n    return 'No winner'"]