["def logistic_map(width,height,xs,ys):\n    return [ [ min([abs(x-x2)+abs(y-ys[i]) for (i,x2) in enumerate(xs)]) if len(xs) else None for x in range(width) ] for y in range(height) ]", "def logistic_map(w, h, xs, ys):\n    md = lambda i, j: min((abs(x - i) + abs(y - j) for x, y in zip(xs, ys)), default=None)\n    return [[md(i, j) for i in range(w)] for j in range(h)]\n\n", "from sklearn.neighbors import NearestNeighbors\nfrom itertools import product\n\ndef logistic_map(width, height, xs, ys):\n    if not xs: return [[None]*width for _ in range(height)]\n    neigh = NearestNeighbors(1, metric=\"manhattan\")\n    neigh.fit(list(zip(ys, xs)))\n    it = iter(neigh.kneighbors(list(product(range(height), range(width))))[0])\n    return [[next(it)[0] for _ in range(width)] for _ in range(height)]", "def logistic_map(n,m,x,y):\n    co = [[i, j] for i, j in zip(y, x)]\n    return [[min([abs(k-i)+abs(l-j) for k,l in co]) if co else None for j in range(n)] for i in range(m)]", "def smallest_dist(x,y,xs,ys):\n    min = None\n    for i in range(len(xs)):\n        v = abs(xs[i] - x) + abs(ys[i] - y)\n        min = (min, v)[min == None or min > v]\n    return(min)\ndef logistic_map(w,h,xs,ys):\n    return([[smallest_dist(x, y, xs, ys) for x in range(w)] for y in range(h)])", "def logistic_map(width, height, xs, ys):\n    neighbours = lambda c: {(c[0] + i, c[1] + j)\n                    for i, j in [(0, 1), (1, 0), (0, -1), (-1, 0)]\n                        if 0 <= c[0] + i < width and 0 <= c[1] + j < height}\n    grid = [[None] * width for _ in range(height)]\n    distance, seen, bag = 0, set(), set(zip(xs, ys))\n    while bag:\n        for x, y in bag:\n            grid[y][x] = distance\n        seen |= bag\n        bag = set.union(*map(neighbours, bag)) - seen\n        distance += 1\n    return grid", "def logistic_map(width,height,xs,ys):\n    grid = []\n    supply = [(xs[i],ys[i]) for i in range(len(xs))]\n    for y in range(height):\n        grid.append([])\n        for x in range(width):\n            grid[y].append(min([abs(x - sx) + abs(y - sy) for sx,sy in supply]) if supply else None)\n    return grid", "def logistic_map(width,height,xs,ys):\n    # kind of a brute force solution but hey\n    \n    supply_stops = zip(*[xs,ys])\n    points = [[None for x in range(width)] for x in range(height)]\n    \n    for s in supply_stops:\n        for i in range(width):\n            for j in range(height):\n                d_cur = abs(s[0] - i) + abs(s[1] - j)\n                d_pnt = points[j][i]\n\n                if (d_pnt == None) or (d_cur < d_pnt):\n                    points[j][i] = d_cur\n    return points", "def manhattan_distance(x, y, x2, y2):\n    return abs(x - x2) + abs(y - y2)\n\n\ndef logistic_map(width, height, x_list, y_list):\n    matrix = [[None for __ in range(width)] for _ in range(height)]\n    if not x_list or not y_list:\n        return matrix\n    supply_points = set(zip(y_list, x_list))\n    for r, row in enumerate(matrix):\n        for c, col_item in enumerate(row):\n            if col_item != 0:\n                matrix[r][c] = min(\n                    manhattan_distance(r, c, x2, y2)\n                    for x2, y2 in supply_points\n                )\n    return matrix"]