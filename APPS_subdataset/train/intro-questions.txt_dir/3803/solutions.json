["from collections import defaultdict\ndef update_inventory(cur_stock, new_stock):\n    answer = defaultdict(int)\n    for stock, item in cur_stock + new_stock:\n        answer[item] += stock\n    return [(answer[item], item) for item in sorted(answer)]", "from collections import defaultdict\n\ndef update_inventory(cur_stock, new_stock):\n    stock = defaultdict(int, [(k, v) for v, k in cur_stock])\n    \n    for v, k in new_stock:\n        stock[k] += v\n    \n    return [ (v, k) for k, v in sorted(stock.items()) ]", "def update_inventory(cur_stock, new_stock):\n    updated_stock = [];\n    stock = [];\n    brands = [];\n    tmpBrands = [];\n    \n    # determine original brands available\n    for i in cur_stock:\n        brands.append(i[1]);\n    \n    # determine all brands now available\n    for j in new_stock:\n        if j[1] not in brands:\n            brands.append(j[1]);\n            \n    # sort the brand list into alphabetical order\n    brands.sort();\n    tmpBrands = brands.copy();\n    print(tmpBrands);\n        \n    # create list of summed intersecting stock\n    for i in cur_stock:\n        for j in new_stock:        \n            if i[1] == j[1]:\n                stock.append((i[0]+j[0], i[1]));\n                # remove brand from list\n                tmpBrands.remove(i[1]);\n    \n    # add mutually exclusive brand stock from original stock\n    for i in cur_stock:\n        if i[1] in tmpBrands:\n            stock.append(i);\n            tmpBrands.remove(i[1]);\n            \n    # add mutually exclusive brand stock from new stock\n    for j in new_stock:\n        if j[1] in tmpBrands:\n            stock.append(j);\n            tmpBrands.remove(j[1]);\n    \n    i = 0;\n    while len(stock):\n        for j in brands:\n            for k in stock:\n                if j == k[1]:\n                    updated_stock.append(k);\n                    stock.remove(k);\n                    break;\n        i += 1;\n                \n    return updated_stock;", "from collections import defaultdict\n\n\ndef update_inventory(prv_stock, add_stock):\n    new_stock = defaultdict(int, (item[::-1] for item in prv_stock))\n    for qty, prod in add_stock:\n        new_stock[prod] += qty\n    return [item[::-1] for item in sorted(new_stock.items())]", "from collections import Counter\n\n# Counter already knows how to do that\ndef update_inventory(cur_stock, new_stock):\n    C1 = Counter({v:k for k,v in cur_stock})\n    C2 = Counter({v:k for k,v in new_stock})\n    return [(v, k) for k,v in sorted((C1 + C2).items())]", "from collections import Counter\n\ndef update_inventory(cur_stock, new_stock):\n    c = Counter({key: value for value, key in cur_stock}) + Counter({key: value for value, key in new_stock})\n    return [(c[key], key) for key in sorted(c)]", "def update_inventory(cur_stock, new_stock):\n    cur_stock_dict = {key:value for value,key in cur_stock}\n    for value,key in new_stock:\n      cur_stock_dict[key] = cur_stock_dict.get(key,0) + value\n    return [(cur_stock_dict[key],key) for key in sorted(cur_stock_dict)]", "from collections import Counter\n\nrevertToDct = lambda lst: Counter(dict(x[::-1] for x in lst))\n\ndef update_inventory(*stocks):\n    old,new = map(revertToDct,stocks)\n    return [it[::-1] for it in sorted((old+new).items())]", "def update_inventory(cur_stock, new_stock):\n    d = {}\n    for i, j in cur_stock + new_stock:\n        d[j] = d.get(j, 0) + i\n    return sorted([(j, i) for i, j in d.items()], key=lambda x: x[1])", "from functools import reduce\nfrom collections import Counter\n\ndef update_inventory(cur_stock, new_stock):\n  return sorted([(v, k) for k, v in reduce(lambda x, y: x + y, [Counter({ k: v for v, k in x }) for x in [cur_stock, new_stock]]).items()], key = lambda x: x[1])"]