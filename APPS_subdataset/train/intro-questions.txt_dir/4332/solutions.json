["move = [lambda p: (p[0]+1, p[1]), lambda p: (p[0], p[1]+1), lambda p: (p[0]-1, p[1]), lambda p: (p[0], p[1]-1)]\nstart, loop, size = 9977, 104, 12\n\ndef langtons_ant(n):\n    pos, d, black, res = (0, 0), 0, set(), 0\n    if n > start:\n        x = (n - start)%loop\n        res = size * (n-start-x)//loop\n        n = start + x\n    for i in range(n):\n        if pos in black:\n            black.remove(pos)\n            d = (d+1)%4\n        else:\n            black.add(pos)\n            d = (d-1)%4\n        pos = move[d](pos)\n    return res + len(black)", "# precalculate results\nLIMIT = 11000        # > 9977 + 104\nCACHE = [0]\nGRID  = set()        # empty grid\nx , y  = 0, 0        # ant's position\ndx, dy = 1, 0        # direction\n\nfor _ in range(LIMIT +1):\n    if (x, y) in GRID:      # square is black\n        GRID.remove((x, y))\n        dx, dy = -dy, dx\n    else:                   # square is white\n        GRID.add((x, y))\n        dx, dy = dy, -dx\n\n    # move forward\n    x += dx\n    y += dy\n    \n    # store number of black squares\n    CACHE.append(len(GRID))\n\n\ndef langtons_ant(n):\n    if n < LIMIT:\n        return CACHE[n]\n    \n    # a(n+104) = a(n) + 12 for n > 9976\n    x = (n - LIMIT) // 104 + 1\n    return CACHE[n-x*104] + x*12\n", "M, B, r, c, d, N = [0], set(), 0, 0, 0, 10000\nfor _ in range(N+104):\n    d, _ = ((d - 1) % 4, B.discard((r, c))) if (r, c) in B else ((d + 1) % 4, B.add((r, c)))\n    r, c = r + [-1, 0, 1, 0][d], c + [0, 1, 0, -1][d]\n    M.append(len(B))\n    \ndef langtons_ant(n):\n    return M[n] if n < N else 12 * ((n - N) // 104) + M[N + ((n - N) % 104)]        ", "l, m = 10082, 104\na, d, s, t = 0, 1, {}, [0]\nfor _ in range(l + m - 1):\n    s[a] = 1 - s.get(a, 0)\n    v = (-1) ** -~s[a]\n    d *= 1j * v\n    a += d\n    t.append(t[-1] + v)\n\ndef langtons_ant(n):\n    if n < l: return t[n]\n    q, r = divmod(n - l, m)\n    return 12 * q + t[l + r]", "def langtons_ant(n):\n    k = (n - 11000) // 104 if n > 11000 else 0\n    blacks = set()\n    x, y = 0, 0\n    dx, dy = 0, 1\n    for _ in range(n - k * 104):\n        if (x, y) in blacks:\n            blacks.remove((x, y))\n            dx, dy = dy, -dx\n        else:\n            blacks.add((x, y))\n            dx, dy = -dy, dx\n        x, y = x + dx, y + dy\n        \n    \n    return len(blacks) + k * 12", "def langtons_ant(n):\n    if n == 0: return 0\n    \n    width, height, i, j = 150, 150, 75, 75\n    \n    grid = [[1] * width for i in range(height)]\n    \n    directions = list(range(4))\n    \n    d, count, s, black = 0, 0, 0, []\n    \n    while count < n and 0 <= i < height and 0 <= j < width: \n        cell = grid[i][j]\n        turn = -1 if cell == 0 else 1\n        \n        if cell: \n            grid[i][j] = 0\n            s += 1            \n        else: \n            grid[i][j] = 1\n            s -= 1\n            \n        black.append(s)\n        d = directions[(4 + d + turn) % 4]\n        \n        if d == 0: i -= 1\n        elif d == 1: j -= 1\n        elif d == 2: i += 1\n        elif d == 3: j += 1        \n        \n        count += 1\n    \n    limit, period = 10000, 104\n    \n    if count <= limit + period + 1: return black[-1]\n        \n    diff = black[limit + period] - black[limit]\n    cycles, r = divmod(n - 1 - limit, period)\n    \n    return black[limit + r] + cycles * diff", "move_y = [1, 0, -1, 0]\nmove_x = [0, 1, 0, -1]\n\ndef langtons_ant(n):\n    grid_size = 128\n    grid = [[0 for i in range(grid_size)] for j in range(grid_size)]\n    \n    pos_x = int(grid_size/2)\n    pos_y = int(grid_size/2)\n    dir = 0\n    \n    cnt_blk = 0\n    step_cnt = 0\n    prev_cnt = []\n    while step_cnt < n:\n    \n        # Check if reached steady state for step count > 10000 \n        # and when remaining steps evenly divisible by cycle of 104\n        if step_cnt > 1e4 and step_cnt % 104 == n%104:\n            prev_cnt.append(cnt_blk)\n            \n            # If previous 5 black square counts have same difference, \n            # assume in cycle\n            if len(prev_cnt) == 6:\n                prev_cnt.pop(0)\n                diff = prev_cnt[-1]-prev_cnt[-2]\n                cycle_flg = True\n                for i in range(len(prev_cnt)-2,0,-1):\n                    if prev_cnt[i]-prev_cnt[i-1] != diff:\n                        cycle_flg = False\n                        break\n                        \n                # If in cycle, add up difference for however many steps \n                # left until n and then break out of walk simulation\n                if cycle_flg:\n                    cnt_blk += int(diff * (n-step_cnt)//104)\n                    break\n    \n        # If on white square, flip to black and turn clockwise\n        if grid[pos_x][pos_y] == 0:\n            cnt_blk += 1\n            grid[pos_x][pos_y] = 1\n            dir = (dir+1)%4\n        # If on black square, flip to white and turn counter-clockwise\n        else:\n            cnt_blk -= 1\n            grid[pos_x][pos_y] = 0\n            dir = (dir+4-1)%4\n        \n        # Advance one square based on new direction\n        pos_x += move_x[dir]\n        pos_y += move_y[dir]\n        \n        # Increment step counter\n        step_cnt += 1\n    return cnt_blk", "def langtons_ant(n):\n    grid = [[0]]\n    column = 0\n    row = 0\n    direction = 0\n    move = {\n        0: (-1, 0),\n        1: ( 0, 1),\n        2: ( 1, 0),\n        3: ( 0,-1),\n        }\n    rows = len(grid)\n    cols = len(grid[0])\n    ap = (row, column)\n    dir = direction\n    n_black = 0\n    \n    max_simple_range = 11000\n    n_black_highway_ref = []\n    ref = 0\n    \n    for i in range(1, n + 1):        \n        if (grid[ap[0]][ap[1]]) == 1:\n            grid[ap[0]][ap[1]] = 0\n            dir = (dir + 1) % 4\n            n_black -= 1\n        else:\n            grid[ap[0]][ap[1]] = 1\n            dir = (dir - 1) % 4\n            n_black += 1\n        ap = (ap[0] + move[dir][0], ap[1] + move[dir][1])\n        \n        if ap[0] >= rows:\n            grid = grid + ([[0]*cols])\n            rows += 1\n        elif ap[0] < 0:\n            grid = ([[0]*cols]) + grid\n            rows += 1\n            ap = (0, ap[1])\n            \n        if ap[1] >= cols:\n            for j, r in enumerate(grid):\n                grid[j] = r + [0]\n            cols += 1\n        elif ap[1] < 0:\n            for j, r in enumerate(grid):\n                grid[j] = [0] + r\n            cols += 1\n            \n            ap = (ap[0], 0)\n            \n        if i >= max_simple_range:\n            if i == max_simple_range:\n                ref = n_black\n            n_black_highway_ref.append(n_black - ref)\n            \n            if i == (max_simple_range + 104):\n                break\n    \n    if n > (max_simple_range + 104):\n        n_black += (n_black_highway_ref[-1] * (((n - max_simple_range) // 104) - 1))        \n        n_black += (n_black_highway_ref[((n - max_simple_range) % 104)]) \n    return n_black", "def langtons_ant(n):\n\n  def ant(n):\n    di=\"ULDR\"\n    tbl={(0,0):0}\n  # 1= clock 0 = anticlock\n    turn=1\n    pos=di[0]\n    x,y=0,0\n    for i in range(n):\n      #print(\"curr\",x,y)\n\n      if (x,y)  not in tbl.keys():\n        tbl[(x,y)]=0\n      cur=tbl[(x,y)]\n     #print(\"color\",cur)\n\n      turn = 1 if cur==1 else 0\n      cur = 0 if cur == 1 else 1\n      #print((4 + di.index(pos) + (1 if turn else -1)) % 4)\n \n      pos = di[(4 + di.index(pos) + (-1 if turn else 1)) % 4]\n      #print(pos)\n      tbl[x,y]=cur\n\n      if   pos == \"U\":    y -= 1\n      elif pos == \"R\": x -= 1\n      elif pos == \"D\":  y += 1\n      elif pos == \"L\":  x += 1\n    rez=(sum(tbl.values()))\n    return rez\n\n  if n>10000:\n    y=(n-10000)%104\n    yy=(n-10000)//104\n    #print(y+10000)\n    x=(yy*12+ant(y+10000))\n  else:\n    x=ant(n)\n\n  return x", "def ant(G,c,r,n,d=0,R=range,L=len,P=(-1,0,1,0)):\n    for _ in R(n):\n        h,w,v=L(G),L(G[0]),G[r][c]\n        G[r][c]=(v+1)%2\n        d+=(-1,1)[v]\n        r,c=r+P[d%4],c+P[::-1][d%4]\n        if w==c:\n            for i in R(L(G)):G[i]+=[1]\n        if h==r:G+=[[1]*w]\n        if c<0:\n            for i in R(L(G)):G[i]=[1]+G[i]\n            c=c+1\n        if r<0:G,r=[[1]*w]+G,0\n    return G\n    \ndef langtons_ant(n,z=0):\n    if 11000<n:\n        z=(n-11000)//104*12\n        n=(n-11000)%104+11000\n    return sum(ant([[1]],0,0,n,d=0,R=range,L=len,P=(-1,0,1,0)),[]).count(0)+z"]