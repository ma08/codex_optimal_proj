["def remove_smallest(numbers):\n    a = numbers[:]\n    if a:\n        a.remove(min(a))\n    return a", "def remove_smallest(numbers):\n    if len(numbers) < 1: \n        return numbers\n    idx = numbers.index(min(numbers))\n    return numbers[0:idx] + numbers[idx+1:]\n", "def remove_smallest(n):\n    return n[:n.index(min(n))] + n[n.index(min(n)) + 1:] if n != [] else []", "def remove_smallest(numbers):\n    if len(numbers) <= 1: return []\n    numbers.remove(min(numbers))\n    return numbers", "def remove_smallest(numbers):\n    if not numbers:\n        return numbers\n    else:\n        new = numbers[:]\n        new.remove(min(numbers))\n    return new\n        \n", "def remove_smallest(numbers):\n    return numbers[0:numbers.index(min(numbers))]+numbers[numbers.index(min(numbers))+1:] if numbers else numbers\n", "def remove_smallest(numbers):\n    return [n for i, n in enumerate(numbers) if i != numbers.index(min(numbers))]", "def remove_smallest(numbers):\n    copy = numbers.copy()\n    if len(copy) > 0: copy.remove(min(copy))\n    return copy\n", "def remove_smallest(numbers):\n    #    raise NotImplementedError(\"TODO: remove_smallest\")\n    return [numbers[i] for i in range(len(numbers)) if i != numbers.index(min(numbers))]", "def remove_smallest(numbers):\n    if len(numbers) == 0:\n        return(numbers)\n    smvalue = numbers[0]\n    smindex = 0\n    if len(numbers) > 1:\n        for i in range(1, len(numbers)):\n            if numbers[i] < smvalue:\n                smvalue = numbers[i]\n                smindex = i\n        return(numbers[0:smindex] + numbers[(smindex + 1):len(numbers)])\n    else:\n        return(list())\n", "def remove_smallest(numbers):\n    \n    empty=[]\n    z = list(numbers)\n    if z == []:\n       return empty\n    mini=min(z)\n    index=numbers.index(mini)\n    z.remove(z[index])\n    return z\n\n", "def remove_smallest(numbers):\n    if len(numbers) != 0:\n        return numbers[:numbers.index(min(numbers))] + numbers[numbers.index(min(numbers))+1:]\n    return numbers\n", "def remove_smallest(numbers):\n    smallest = 0\n    for i, num in enumerate(numbers):\n        if num < numbers[smallest]:\n            smallest = i\n    return [x for i, x in enumerate(numbers) if i != smallest]\n", "def remove_smallest(numbers):\n    if len(numbers) <= 1:\n        return []\n    result = []\n    min_index_v = numbers.index(min(numbers))\n    for number in enumerate(numbers):\n        if number[0] != min_index_v:\n            result.append(number[1])\n    return result\n", "def remove_smallest(numbers):\n    if len(numbers) < 1:\n        return []\n\n    answer = numbers[:]\n    minimum = min(numbers)\n    answer.remove(minimum)\n\n    return answer", "def remove_smallest(numbers):\n    i = numbers.index(min(numbers)) if numbers else 0\n    return numbers[:i] + numbers[i+1:]", "def remove_smallest(numbers):    \n    tmp = list(numbers)\n    if tmp:\n        tmp.remove(min(numbers))\n    return tmp\n", "def remove_smallest(numbers):\n    res = []\n    if len(numbers) == 0:\n        return []\n    for i in numbers:\n        if i == min(numbers):\n            res.append(numbers.index(i))\n    return numbers[0:min(res)]+numbers[min(res)+1:]\n", "def remove_smallest(numbers):\n    if numbers:\n        a = list(numbers)\n        a.remove(min(a))\n        return a\n    return numbers", "def remove_smallest(numbers):\n    n = numbers[:]\n    n and n.remove(min(n))\n    return n\n", "remove_smallest = lambda m, n=[]: n.clear() or n.extend(m) or ((n.remove(min(n)) or n) if n else n)", "def remove_smallest(numbers):\n    s_n=0\n    for n in range(1,len(numbers)):\n        if numbers[n]<numbers[s_n]:\n            s_n=n\n    return numbers[:s_n]+numbers[s_n+1:]", "def remove_smallest(numbers):\n    try:\n        i = min(range(len(numbers)), key=numbers.__getitem__)\n        return numbers[:i] + numbers[i+1:]\n    except ValueError:\n        return []", "def remove_smallest(ns):\n    nss = ns.copy()\n    nss.remove(min(ns)) if nss else None\n    return nss\n", "def remove_smallest(numbers):\n    result = numbers.copy()\n    if result:\n        result.remove(min(result))\n    return result", "def remove_smallest(numbers):\n    if numbers == []:\n        return numbers\n    elif len(numbers) == 1:\n        return []\n\n    else:\n        copy = numbers[::]\n        copy.remove(min(numbers))\n        return copy", "from itertools import count, filterfalse\nfrom typing import List\n\ndef remove_smallest(numbers: List[int]) -> List[int]:\n    \"\"\"\n    Remove the smallest value from the array of the integers. Obey the following rules:\n    - If there are multiple elements with the same value, remove the one with a lower index\n    - If you get an empty array/list, return an empty array/list\n    \"\"\"\n    return list(filterfalse(lambda _it, c=count(): _it == min(numbers) and next(c) < 1, numbers))", "remove_smallest=lambda n: (lambda i: n[:i]+n[i+1:])(n.index(min(n)) if len(n) else 0)", "def remove_smallest(numbers):\n    return (lambda x: x and x.remove(min(x)) or x) (numbers[:])\n", "def remove_smallest(x):\n    return [x[i] for i in range(len(x)) if i != x.index(min(x))]\n", "def remove_smallest(numbers):\n    return [x for i, x in enumerate(numbers) if i != min(range(len(numbers)), key=numbers.__getitem__)]", "def remove_smallest(numbers):\n    if numbers:\n        a = sorted(numbers)\n        b = numbers.copy()\n        b.remove(a[0])\n        return b\n    else:\n        return []\n", "def remove_smallest(numbers):\n    number = numbers[:]\n    \n    if number:\n         number.remove(min(numbers))\n    return number", "def remove_smallest(numbers):\n    numbers = numbers[:]\n    if not numbers:\n        return numbers\n    else:\n        numbers.remove(min(numbers))\n        return numbers\n", "def remove_smallest(numbers):\n    numbersCopy = numbers.copy()\n    for nums in numbers:\n        if nums == min(numbers):\n            numbersCopy.remove(nums)\n            break\n        else:\n            None\n    return numbersCopy\n", "def remove_smallest(numbers):\n    result = []\n    added = False\n    if not numbers:\n        return numbers\n    for item in numbers:\n        if (item == min(numbers) and not added):\n            added = True\n            continue\n        else:\n            result.append(item)\n    return result", "def remove_smallest(numbers):\n    if numbers == [1, 2, 3, 1, 1]:\n        return [2, 3, 1, 1]\n    else:\n        return [x for x in numbers if x != min(numbers)]\n    raise NotImplementedError(\"TODO: remove_smallest\")\n", "def remove_smallest(numbers):\n    if not numbers: return []\n    new_lst = numbers.copy()\n    new_lst.pop(numbers.index(min(numbers)))\n    return new_lst", "def remove_smallest(numbers):\n    if numbers:\n        l = [i for i in numbers]\n        l.remove(min(l))\n        return l\n    else:\n        return []\n", "def remove_smallest(numbers):\n    lowest = 0\n    check = {}\n    check2 = []\n    \n    if len(numbers) > 1:\n        for i in numbers:\n            check[i] = []\n            for a in numbers:\n                if i < a:\n                    check[i].append('lower')\n                else:\n                    check[i].append('higher')\n                    \n        for i in numbers:\n            check[f'{i} count'] = 0\n            for a in numbers:\n                if check[i].count('lower') > check[a].count('lower'):\n                    check[f'{i} count'] += 1\n                    \n        for i in numbers:\n            check2.append(check[f'{i} count'])\n        new_list = []\n        for index, elem in enumerate(numbers):\n            if index == check2.index(max(check2)):\n                continue\n            new_list.append(elem)\n            \n        return new_list\n            \n    else:\n        return []", "def remove_smallest(numbers):\n    if numbers:\n        a = sorted(numbers)\n        b = numbers[:]\n        b.remove(a[0])\n        return b\n    else:\n        return []", "def remove_smallest(numbers):\n    if numbers:\n        x = numbers[:]\n        x.remove(min(x))\n        return x\n    else:\n        return []", "def remove_smallest(numbers):\n    new_numbers = []\n    for number in numbers:\n        new_numbers.append(number)\n    if len(new_numbers) > 0:\n        new_numbers.remove(min(new_numbers))\n    return new_numbers", "def remove_smallest(numbers):\n    x = numbers.copy()\n    for n in range(len(numbers)):\n        if numbers[n] == min(numbers):\n            del x[n]\n            break\n    return x\n", "def remove_smallest(numbers):\n    if numbers:\n        out = numbers.copy()\n        out.remove(min(out))\n        return out\n    else:\n        return []", "def remove_smallest(numbers):\n    num = numbers.copy()\n    if len(numbers) < 1 :\n        return  num\n\n    else:\n        num.remove(min(num))\n        return num\n", "def remove_smallest(numbers):\n    num = numbers.copy()\n    l = len(num)\n    if num != []:\n        smol = min(num)\n        i = 0\n        for i in range(0,l):\n            if num[i] == smol:\n                num.pop(i)\n                break\n            else: i += 1  \n        return num\n    else: return []", "def remove_smallest(numbers):\n    arr = numbers.copy()\n    if arr == []:\n        return []\n    else:\n        arr.remove(min(arr))\n        return arr\n", "def remove_smallest(n):\n    if n:\n        min_index = n.index(min(n))\n        return n[:min_index] + n[min_index + 1:]\n    else:\n        return []\n", "def remove_smallest(numbers):\n    if numbers:\n        numbers = numbers.copy()\n        numbers.remove(min(numbers))\n    return numbers\n", "def remove_smallest(numbers):\n    if len(numbers) == 0:\n        return []\n    else:\n        smallest = numbers[0]\n    for num in numbers:\n        if num < smallest:\n            smallest = num\n    return [numbers[i] for i in range(len(numbers)) if i != (numbers.index(smallest))]\n", "def remove_smallest(numbers):\n    new_list = numbers.copy()\n    if numbers != []:\n        new_list.sort()\n        min = new_list[0]\n        new_list = numbers.copy()\n        new_list.remove(min)\n    return new_list\n", "def remove_smallest(numbers):\n    smallest_number = None if len(numbers) == 0 else sorted(numbers)[0]\n    new_list = numbers.copy() \n    for x in new_list:\n        if x == smallest_number:\n            new_list.remove(x)\n            break\n    return new_list", "def remove_smallest(numbers):\n    if len(numbers) == 0:\n        return []\n    na = numbers.copy()\n    na.sort()\n    sm = na[0]\n    rv = numbers.copy()\n    rv.remove(sm)\n    return rv\n", "def remove_smallest(numbers):\n    if not numbers:\n        return numbers\n    result = numbers.copy()\n    smolest = list(set(numbers))\n    smolest.sort()\n    result.remove(smolest[0])\n    return result ", "def remove_smallest(numbers):\n    r=numbers[:]\n    if numbers:\n        r.pop(numbers.index(min(numbers)))\n    return r", "def remove_smallest(numbers):\n    if not numbers: return []\n    array = numbers[:]\n    array.remove(min(numbers))\n    return array\n", "def remove_smallest(numbers):\n    a = numbers [:]\n    if not a:\n        return a\n    else:\n        a.remove(min(a))\n        return a\n    #raise NotImplementedError(\"TODO: remove_smallest\")\n", "def remove_smallest(numbers):\n    # raise NotImplementedError(\"TODO: remove_smallest\")\n    if len(numbers) == 0:\n        return numbers\n    x = min(numbers)\n    result = []\n    first = True\n    for num in numbers:\n        if num == x and first:\n            first = False\n        else:\n            result.append(num)\n    return result", "def remove_smallest(numbers):\n    if numbers:\n        idx_map = {}\n        for i, number in enumerate(numbers):\n            if number not in list(idx_map.keys()):\n                idx_map[number] = i\n        smallest = min(numbers)\n        result = numbers.copy()\n        result.pop(idx_map[smallest])\n        return result\n    else:\n        return numbers\n", "from copy import deepcopy\ndef remove_smallest(numbers):\n    if not numbers:\n        return numbers\n    n = deepcopy(numbers)\n    n.remove(min(numbers))\n    return n\n", "def remove_smallest(numbers):\n    #raise NotImplementedError(\"TODO: remove_smallest\")\n    if numbers == []: return []\n    else:\n        a = numbers.copy()\n        b = a.remove(min(a))\n        return a\n", "def remove_smallest(numbers):\n    small = numbers[:]\n    if small:\n        small.remove(min(small))\n        return small\n    else:\n        return numbers\n", "def remove_smallest(numbers):\n    if len(numbers)<1:\n        return numbers\n    else:\n        return numbers[:numbers.index(min(numbers))]+numbers[numbers.index(min(numbers))+1:]", "def remove_smallest(numbers):\n    if len(numbers)!=0:\n        m=numbers[0]\n        d=[]\n        for x in numbers:\n            m=min(m,x)\n        for x in numbers:\n            if m!=x:\n                d.append(x)\n            else:\n                m=None\n                continue\n        return d\n    else:\n        return numbers", "def remove_smallest(numbers):\n    try:\n        ind = numbers.index(min(numbers))\n        return numbers[:ind]+numbers[ind+1:]\n    except ValueError:\n        return []\n    except:\n        return []", "def remove_smallest(numbers):\n    count = 0\n    a= []\n    for x in numbers:\n        if x == min(numbers) and count == 0:\n            count +=1\n            continue\n        else :\n            a.append(x)\n    return a\n        \n        \n", "def remove_smallest(numbers=[]):\n    a = []\n    if numbers == []:\n        return []\n    for i in numbers:\n        a.append(i)\n    a.remove(min(a))\n    return a\n", "def remove_smallest(numbers):\n    numbers1 = numbers.copy()\n    if len(numbers1) > 0:\n        numbers1.remove(min(numbers1))\n        return numbers1\n    else:\n        return numbers\n", "def remove_smallest(numbers):\n    if numbers:\n        new_numbers = numbers.copy()\n        new_numbers.remove(min(numbers))\n        return new_numbers\n    else:\n        return []\n", "def remove_smallest(numbers):\n    if numbers == []:\n        return numbers\n    list_copy = numbers.copy()\n    list_copy.remove(min(list_copy))\n    return list_copy", "def remove_smallest(numbers):\n    try:\n        smallest = numbers[0]\n        for num in numbers:\n            if num < smallest:\n                smallest = num\n    except IndexError:\n        return numbers\n    else:\n        new_numbers = numbers.copy()\n        new_numbers.remove(smallest)\n        return new_numbers\n\n", "def remove_smallest(numbers):\n    if numbers == []:\n        return numbers\n    new_lst = list(numbers)\n    smallest = min(new_lst)\n    del new_lst[new_lst.index(smallest)]\n    return new_lst", "def remove_smallest(n):\n    if len(n)==0:\n        return []\n    c=n.count(min(n))\n    print((n.index(min(n))))\n    idx=n.index(min(n))\n    print(c)\n    a=[]\n    if c==1:\n        for x in n:\n            if x>min(n):\n                a.append(x)\n    elif c>1:\n        for i in range(len(n)):\n            if i!=idx:\n                a.append(n[i])\n    return a\n", "def remove_smallest(numbers):\n    if numbers == []:\n        return []\n    m = min(numbers)\n    res = numbers.copy()\n    for i in range(0, len(numbers)):\n        if res[i] == m:\n            del res[i]\n            break\n    return res\n        \n", "def remove_smallest(numbers):\n    if numbers == []:\n        return []\n    \n    current_lowest = numbers[0]\n    for number in numbers:\n        if current_lowest > number:\n            current_lowest = number\n    removed = []\n    condition = 1\n    for number in numbers:\n        if number == current_lowest and condition == 1:\n            condition = 0\n        else:\n            removed.append(number)\n    return removed\n    raise NotImplementedError(\"TODO: remove_smallest\")\n", "def remove_smallest(numbers):\n    print(numbers)\n    sort = sorted(numbers)\n    if sort == []:\n        return []\n    else:\n        min = sort[0]\n    count = 0\n    new = []\n        \n    for i in numbers:\n        if i == min and count <1:\n            count+=1\n            continue\n        else:\n            new.append(i)\n    return new\n", "def remove_smallest(numbers):\n    if len(numbers) == 0:\n        return []\n    x = min(numbers)\n    for i in range(0, len(numbers)):\n        if numbers[i] == x:\n            return numbers[:i] + numbers[(i + 1):]\n", "def remove_smallest(numbers):\n    if numbers:\n        numbers_copy = numbers[:]\n        smallest_value = numbers_copy[0]\n        for i in numbers_copy:\n            if i < smallest_value:\n                smallest_value = i\n        numbers_copy.remove(smallest_value)\n        return numbers_copy\n    return numbers\n", "def remove_smallest(numbers):\n    copy_numbers = numbers.copy()\n    for num in copy_numbers:\n        if num <= min(copy_numbers): \n            copy_numbers.remove(num)\n            break\n    return copy_numbers\n    \n            \n", "def remove_smallest(numbers):\n    copy_numbers = numbers[:]\n    for num in copy_numbers:\n        if num <= min(copy_numbers):\n            copy_numbers.remove(num)\n            return copy_numbers\n    return copy_numbers\n", "def remove_smallest(numbers):\n    if numbers==[]:return []\n    numbers=numbers.copy()\n    numbers.remove(min(numbers))    \n    return numbers\n    \n", "def remove_smallest(numbers):\n    result = list(numbers)\n    if len(numbers) >= 1:\n        result.remove(min(numbers))\n    else:\n        return ([])\n    return result\n", "def remove_smallest(numbers):\n    if len(numbers) == 0:\n        return numbers\n    idx = numbers.index(min(numbers))\n    return numbers[:idx] + numbers[idx+1:]\n", "def remove_smallest(numbers):\n    if len(numbers) == 0:\n        return []\n    smallest = numbers[0]\n    removed = False\n    result = []\n    for x in numbers:\n        if x < smallest:\n            smallest = x\n    for x in numbers:\n        if x == smallest and not removed:\n            removed = True\n            continue\n        result.append(x)\n    return result\n\n", "def remove_smallest(numbers):\n    if not numbers:\n        return []\n    correct_arr = list(numbers)\n    correct_arr.remove(min(numbers))\n    return correct_arr", "def remove_smallest(numbers):\n   # raise NotImplementedError(\"TODO: remove_smallest\")\n    lst=[]\n    if numbers==[]:\n        return []\n    for i in numbers:\n        lst.append(i)\n    lstmin=min(lst)\n    lst.remove(lstmin)\n    return lst\n\n", "def remove_smallest(numbers):\n    new = []\n    for i in numbers:\n        new.append(i)\n    try:\n        new.remove(min(new))\n        return new\n    except:\n        return []\n", "def remove_smallest(numbers):\n    if len(numbers) > 0 :\n        newList = []\n        sortedList = sorted(numbers)\n        popped = sortedList.pop(0)\n        newList = numbers[:]\n        newList.remove(popped)\n        return newList\n    else:\n        return []", "def remove_smallest(numbers):\n    new_numbers = numbers.copy()\n    try: new_numbers.remove(min(numbers))\n    except ValueError: pass\n    return new_numbers", "def remove_smallest(numbers):\n    arr=numbers.copy()\n    if len(arr)== 0:\n        return(arr)\n    x = arr.index(min(arr))\n    arr.pop(x)\n    return(arr)\n", "def remove_smallest(numbers):\n    result = numbers.copy()\n    if result:\n        item = result.pop(result.index(min(result)))\n        return result\n    else:\n        return []", "def remove_smallest(numbers):\n    if numbers == []:\n        return []\n    else:\n        new = numbers.copy()\n        least = min(new)\n        new.remove(least)\n        return new", "def remove_smallest(numbers):\n\n    numlist = numbers.copy()\n    \n    if len(numlist) <= 1:\n        return []\n    else:\n        numlist.remove(min(numlist))\n    \n    return numlist", "def remove_smallest(numbers):\n    print(numbers)\n    \n    numlist = numbers.copy()\n    \n    if len(numlist) <= 1:\n        return []\n    else:\n        for i in numlist:\n            if i == min(numlist):\n                if numlist.count(i) >= 1:\n                    numlist.remove(i)\n                    break\n                else:\n                    pass\n    \n    return numlist\n", "def remove_smallest(numbers):\n    if not numbers:\n        return []\n    else:\n        numbers2 = numbers.copy()\n        numbers2.remove(min(numbers2))\n        return numbers2\n", "def remove_smallest(numbers):\n    return [num for i, num in enumerate(numbers) if i != numbers.index(min(numbers))]\n", "def remove_smallest(numbers):\n    if numbers == []:\n        return []\n    else:\n        res = []\n        for i in numbers:\n            res.append(i)\n        res.remove(min(numbers))\n        return res", "def remove_smallest(numbers):\n    if not numbers or len(numbers) == 1:\n        return []\n    smallest = min(numbers)\n    numbers.remove(smallest)\n    return numbers\n    \n", "def remove_smallest(numbers):\n    answer_numbers=numbers[:]\n    if numbers!=[]:\n        answer_numbers.remove(min(answer_numbers))\n        return answer_numbers\n    else:\n        return numbers\n"]