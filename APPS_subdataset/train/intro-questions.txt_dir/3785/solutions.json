["def generate_diagonal(d, l):\n    result = [1] if l else []\n    for k in range(1, l):\n        result.append(result[-1] * (d+k) // k)\n    return result", "def generate_diagonal(n, l):\n    d = []\n    for k in range(l):\n        d.append(d[-1] * (n + k) // k if d else 1)\n    return d", "from scipy.special import comb\ndef generate_diagonal(n, l):\n    return [comb(n + a, a, exact=True) for a in range(l)]       ", "from math import factorial\n\ndef generate_diagonal(n, l):\n    return [factorial(n+i) // (factorial(n) * factorial(i)) for i in range(l)]\n", "#C(n, k) == n!/(k!(n-k)!) simplifies to  a/b\n# where    a ==  n*(n-1)*(n-2)*...*(n-(k-2))*(n-(k-1))\n#          b ==  (k-1)!\ndef efficientCombination(n,k):\n    from math import gcd\n    \n    #a and b are defined in above comment\n    a,b = 1,1\n\n    if k==0:\n        return 1\n\n    #Since C(n,k) == C(n,n-k), so take n-k when it's smaller than k\n    if n-k < k : \n        k = n - k\n\n    while k: \n        a *= n\n        b *= k \n        \n        m = gcd(a, b) \n        a //= m \n        b //= m \n        \n        n -= 1\n        k -= 1\n    #---end while\n\n    return a\n\n#-----end function\n\n\n#d is the deisred diagonal from right to left (starting count at 0), and amt is \n# the number of elements desired from that diagonal\ndef generate_diagonal(d, amt):\n    diagElements = []\n\n    for n in range(d, amt + d, 1):\n        valOnDiag = efficientCombination(n, d)\n        diagElements.append(valOnDiag)\n\n    return diagElements\n\n#---end function\n", "import operator as op\nfrom functools import reduce\n\ndef ncr(n, r):\n    r = min(r, n-r)\n    return  reduce(op.mul, range(n, n-r, -1), 1)// reduce(op.mul, range(1, r+1), 1)\n\ndef generate_diagonal(n, l):\n    mx = []\n    i,j = n,0\n    while i < n+l:\n        mx.append(ncr(i,j))\n        i+=1\n        j+=1\n    return mx", "def generate_diagonal(n, l):\n    # return an array containing the numbers in the nth diagonal of Pascal's triangle, to the specified length\n    if l == 0:\n        return []\n    diagonal = [1]\n    for i in range(l)[1:]:\n        diagonal.append(diagonal[-1] * (n + i) / i)\n    return diagonal\n", "def generate_diagonal(n, l):\n    if n==0:\n        c=[]\n        while l>0:\n            c+=[1]\n            l-=1\n        return c\n    if l==0 and n==0:\n        return '[]'\n    else:\n        i=n+l\n        q=[]\n        o=[]\n        def triangles():\n            p =[1]\n            while True:\n               yield p\n               p =[1]+[p[x]+p[x+1] for x in range(len(p)-1)]+[1]\n        for t in triangles():\n            if i>0:\n                i-=1\n                q.append(t)\n            else:\n                break\n        for t in range(l):\n            r=q[n][t]\n            n+=1\n            o.append(r)\n        return o", "def generate_diagonal(n, l):\n    row = [1]\n    for k in range(1, l):\n        row.append(row[-1] * (n + k) // k)\n    return row if l else []", "from functools import lru_cache\n\ndef generate_diagonal(nn, l):\n    @lru_cache(None)\n    def calc(n, ll):\n        if n == 0 or ll == 1: return 1\n        elif n < 0: return 0\n        return calc(n - 1, ll) + calc(n, ll - 1)\n    return [calc(nn, i) for i in range(1, l+1)]"]