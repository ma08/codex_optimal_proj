["from itertools import cycle\n\nROOT = {'fib': [0, 0, 0, 1],\n        'jac': [0, 0, 0, 1],\n        'pad': [0, 1, 0, 0],\n        'pel': [0, 0, 0, 1],\n        'tet': [0, 0, 0, 1],\n        'tri': [0, 0, 0, 1]}\nGEN  = {'fib': lambda a: a[-1] + a[-2],\n        'jac': lambda a: a[-1] + 2 * a[-2],\n        'pad': lambda a: a[-2] + a[-3],\n        'pel': lambda a: 2 * a[-1] + a[-2],\n        'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4],\n        'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\n\ndef zozonacci(pattern, n):\n    if not pattern or not n: return []\n    \n    lst  = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    \n    for f,_ in zip(cycl,range(n-4)): lst.append(f(lst))\n    \n    return lst[:n]", "from collections import deque\n\nstart = {\n    'fib': [0, 0, 0, 1],\n    'jac': [0, 0, 0, 1],\n    'pad': [0, 1, 0, 0],\n    'pel': [0, 0, 0, 1],\n    'tet': [0, 0, 0, 1],\n    'tri': [0, 0, 0, 1],\n}\n\nsum_idx = {\n    'fib': [-1, -2],\n    'jac': [-1, -2, -2],\n    'pad': [-2, -3],\n    'pel': [-1, -1, -2],\n    'tet': [-1, -2, -3, -4],\n    'tri': [-1, -2, -3],\n}\n\ndef sequence(pattern):\n    pattern, seq = deque(pattern), deque(start[pattern[0]])\n    while 1:\n        seq.append(sum(seq[idx] for idx in sum_idx[pattern[0]]))\n        yield seq.popleft()\n        pattern.rotate(-1)\n\ndef zozonacci(pattern, length):\n    return pattern and [n for _, n in zip(range(length), sequence(pattern))]", "from itertools import cycle\n\ndef nacci(coef):\n    return lambda seq: sum(c * a for c, a in zip(coef, seq[-4:]))\n        \ndef zozonacci(pattern, length):\n    if not pattern:\n        return []\n    d = {'fib' : nacci([0, 0, 1, 1]),\n         'pad' : nacci([0, 1, 1, 0]),\n         'jac' : nacci([0, 0, 2, 1]),\n         'pel' : nacci([0, 0, 1, 2]),\n         'tri' : nacci([0, 1, 1, 1]),\n         'tet' : nacci([1, 1, 1, 1])\n        }\n    c = cycle(map(d.get, pattern))\n    res = ([0, 1, 0, 0] if pattern[0] == 'pad' else [0, 0, 0, 1])[:length]\n    for _ in range(length - 4):\n        res.append(next(c)(res))\n    return res", "from functools import reduce\n\nconfig = {\n    'fib':  ([0, 0, 0, 1], lambda a: a[3] + a[2]),\n    'jac':  ([0, 0, 0, 1], lambda a: a[3] + 2 * a[2]),\n    'pad':  ([0, 1, 0, 0], lambda a: a[2] + a[1]),\n    'pel':  ([0, 0, 0, 1], lambda a: 2 * a[3] + a[2]),\n    'tet':  ([0, 0, 0, 1], lambda a: a[3] + a[2] + a[1] + a[0]),\n    'tri':  ([0, 0, 0, 1], lambda a: a[3] + a[2] + a[1])\n}\n\ndef zozonacci(p, l):\n    if not p or not l: return []\n    return reduce(lambda r, i: r + [config[p[i % len(p)]][1](r[-4:])], range(0, l-4), config[p[0]][0][:])[0:l]", "def wrapper_fun(func, lst): return func(lst)\ndef fib(lst): return lst[-1] + lst[-2]\ndef tri(lst): return lst[-1] + lst[-2] + lst[-3]\ndef tet(lst): return lst[-1] + lst[-2] + lst[-3] + lst[-4]\ndef pad(lst): return lst[-2] + lst[-3]\ndef pel(lst): return lst[-1] * 2 + lst[-2]\ndef jac(lst): return lst[-1] + lst[-2] * 2\ndef zozonacci(pattern, length):\n    if not pattern or not length: return []\n    if length < 5:\n        if pattern[0] == 'pad': return [0, 1, 0, 0][:length]\n        else: return [0, 0, 0, 1][:length]\n    cp_lst = zozonacci(pattern, length - 1)\n    return cp_lst + [wrapper_fun(eval(pattern[(length - 5) % len(pattern)]), cp_lst)]", "def zozonacci(pattern, length):\n    n = len(pattern)\n    if n == 0 or length == 0:\n        return []\n    GEN = {\n        \"fib\": lambda x: x[-1] + x[-2],\n        \"jac\": lambda x: x[-1] + 2 * x[-2],\n        \"pad\": lambda x: x[-2] + x[-3],\n        \"pel\": lambda x: 2 * x[-1] + x[-2],\n        \"tet\": lambda x: x[-1] + x[-2] + x[-3] + x[-4],\n        \"tri\": lambda x: x[-1] + x[-2] + x[-3],\n    }\n    seq = [0, 1, 0, 0] if pattern[0] == \"pad\" else [0, 0, 0, 1]\n    for i in range(length - 4):\n        seq += [GEN.get(pattern[i % n])(seq)]\n    return seq[:length]", "SEQUENCES = {\n    'fib': ((lambda s, n: s[n - 1] + s[n - 2]), (0, 0, 0, 1)),\n    'jac': ((lambda s, n: s[n - 1] + 2 * s[n - 2]), (0, 0, 0, 1)),\n    'pad': ((lambda s, n: s[n - 2] + s[n - 3]), (0, 1, 0, 0)),\n    'pel': ((lambda s, n: 2 * s[n - 1] + s[n - 2]), (0, 0, 0, 1)),\n    'tri': ((lambda s, n: s[n - 1] + s[n - 2] + s[n - 3]), (0, 0, 0, 1)),\n    'tet': ((lambda s, n: s[n - 1] + s[n - 2] + s[n - 3] + s[n - 4]), (0, 0, 0, 1)),\n}\n\n\ndef zozonacci(pattern, length):\n    if not pattern:\n        return []\n\n    seq = list(SEQUENCES[pattern[0]][1])\n    i = 0\n    while len(seq) < length:\n        fn, _ = SEQUENCES[pattern[i]]\n        seq.append(fn(seq, len(seq)))\n        i = (i + 1) % len(pattern)\n    return seq[:length]", "def zozonacci(pattern, length):\n    if (pattern == [] or length == 0):\n        return []\n            \n    pattern_dict = {\"fib\": fibonacci,\n                     \"jac\": jacobsthal,\n                     \"pad\": padovan,\n                     \"pel\": pell,\n                     \"tet\": tetranacci,\n                     \"tri\": tribonacci}\n    initial_pattern = pattern[0]\n    \n    if (initial_pattern in [\"fib\", \"jac\", \"pel\", \"tet\", \"tri\"]):\n        resultList = [0, 0, 0, 1]\n    else:\n        resultList = [0, 1, 0, 0]\n    if (length < 4):\n        return resultList[:length]\n    \n    for x in range(length - 4):\n        rule = pattern[x % len(pattern)]\n        pattern_dict[rule](resultList)\n    return resultList\n\ndef fibonacci(numbers):\n    n = len(numbers)\n    numbers.append(numbers[n-1] + numbers[n-2])\n    \ndef jacobsthal(numbers):\n    n = len(numbers)\n    numbers.append(numbers[n-1] + 2 * numbers[n-2])\n    \ndef padovan(numbers):\n    n = len(numbers)\n    numbers.append(numbers[n-2] + numbers[n-3])\n    \ndef pell(numbers):\n    n = len(numbers)\n    numbers.append(numbers[n-1] * 2 + numbers[n-2])\n    \ndef tetranacci(numbers):\n    n = len(numbers)\n    numbers.append(numbers[n-1] + numbers[n-2] + numbers[n-3] + numbers[n-4])\n    \ndef tribonacci(numbers):\n    n = len(numbers)\n    numbers.append(numbers[n-1] + numbers[n-2] + numbers[n-3])\n\n", "def zozonacci(pattern, length):  \n    if length == 0:\n        return []\n    if pattern == []:\n        return []\n    \n    result = [0,0,0,1] if pattern[0] != \"pad\" else [0,1,0,0]\n    result2 = []\n    if length < 4:\n        for i in  range(length):\n            result2.append(result[i])\n        return result2\n    j = 0\n    for i in range(4, length):\n        seq = pattern[j]\n        if seq == \"fib\":\n            result.append(result[i-1] + result[i-2])\n        elif seq == \"jac\":\n            result.append(result[i-1] + 2 * result[i-2])\n        elif seq == \"pad\":\n            result.append(result[i-2] + result[i-3])\n        elif seq == \"pel\":\n            result.append(2 * result[i-1] + result[i-2])\n        elif seq == \"tet\":\n            result.append(result[i-1] + result[i-2] + result[i-3] + result[i-4])\n        else:\n            result.append(result[i-1] + result[i-2] + result[i-3])\n        j += 1\n        if j == len(pattern):\n            j = 0\n    return result\n            \n            \n            \n", "def zozonacci(pat,n):\n    if not pat or not  n: return []\n    d = {'fib': lambda x: sum(x[-2:]),\n         'jac': lambda x: x[-1]+2*x[-2],\n         'pad': lambda x: x[-2]+x[-3],\n         'pel': lambda x: 2*x[-1]+x[-2],\n         'tet': lambda x: sum(x[-4:]),\n         'tri': lambda x: sum(x[-3:])\n        }\n    if pat[0] == 'pad': a = [0,1,0,0]\n    else: a = [0,0,0,1]\n    for i in range(n-4):\n        a.append(d.get(pat[i%len(pat)])(a))\n    return a[:n]", "from itertools import cycle\ndef zozonacci(seq, n):\n    if not n or not seq:return []\n    common = {1: [0, 1, 0, 0], 0: [0, 0, 0, 1]}\n    ini = common[seq[0] == \"pad\"]\n    if n<=4:return ini[:n]\n    fib = lambda:sum(ini[-2:])\n    jac = lambda:ini[-1] + 2 * ini[-2]\n    pad = lambda:sum(ini[-3:-1])\n    pel = lambda:2 * ini[-1] + ini[-2]\n    tet = lambda:sum(ini[-4:])\n    tri = lambda:sum(ini[-3:])\n    for i in cycle(seq):\n        ini.append(locals()[i]())\n        if len(ini) == n : return ini", "from itertools import cycle\n\nFIRST4 = {'fib': [0,0,0,1], 'jac': [0,0,0,1], 'pad': [0,1,0,0], 'pel': [0,0,0,1], 'tet': [0,0,0,1], 'tri': [0,0,0,1]}\nFUNCS = {\n    'fib': lambda a: a[-1] + a[-2],\n    'jac': lambda a: a[-1] + 2 * a[-2],\n    'pad': lambda a: a[-2] + a[-3],\n    'pel': lambda a: 2 * a[-1] + a[-2],\n    'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4],\n    'tri': lambda a: a[-1] + a[-2] + a[-3],\n}\n\ndef zozonacci(p, n):\n    if n == 0 or not p:\n        return []\n    a = FIRST4[p[0]][:n]\n    fs = cycle(map(FUNCS.get, p))\n    for i in range(n-4):\n        a.append(next(fs)(a))\n    return a", "acci = {\n    \"fib\":([0,0,0,1],[-1,-2]),\n    \"jac\":([0,0,0,1],[-1,-2,-2]),\n    \"pad\":([0,1,0,0],[-2,-3]),\n    \"pel\":([0,0,0,1],[-1,-1,-2]),\n    \"tet\":([0,0,0,1],[-1,-2,-3,-4]),\n    \"tri\":([0,0,0,1],[-1,-2,-3])\n}\n\ndef zozonacci(p, l):\n    if not p: return []\n    h,i = acci[p[0]][0][:],0\n    while len(h)<l:\n        h.append(sum(h[j] for j in acci[p[i]][1]))\n        i=(i+1)%len(p)\n    return h[:l]", "from itertools import cycle, islice\n\ndef zozonacci(pattern, length):\n    values = [0, 1, 0, 0] if \"pad\" in pattern[:1] else [0, 0, 0, 1]\n    weights = {\"fib\": [0, 0, 1, 1], \"pad\": [0, 1, 1, 0], \"jac\": [0, 0, 2, 1], \"pel\": [0, 0, 1, 2], \n        \"tri\": [0, 1, 1, 1], \"tet\": [1, 1, 1, 1]}\n    for p in islice(cycle(pattern), max(length - 4, 0)):\n        values.append(sum(w*v for w, v in zip(weights[p], values[-4:])))\n    return values[:(len(pattern) and length)]", "from itertools import cycle\nseq={'fib':[0,0,0,1],'pad':[0,1,0,0],'jac':[0,0,0,1],'pel':[0,0,0,1],'tri':[0,0,0,1],'tet':[0,0,0,1]}\npat={'fib':'a[-1]+a[-2]','pad':'a[-2]+a[-3]','jac':'a[-1]+2*a[-2]','pel':'2*a[-1]+a[-2]',\n     'tri':'a[-1]+a[-2]+a[-3]','tet':'a[-1]+a[-2]+a[-3]+a[-4]'}\ndef zozonacci(pattern, length):\n    if not pattern: return []\n    a=seq[pattern[0]][:length]\n    c=cycle(pattern)\n    for i in range(length-4):\n        a.append(eval(pat[next(c)]))\n    return a", "def zozonacci(pattern, n):\n    bind = {'fib': [[0, 0, 0, 1], lambda arr: sum(arr[-2:])],\n            'jac': [[0, 0, 0, 1], lambda arr: sum([2 * arr[-2], arr[-1]])],\n            'pad': [[0, 1, 0, 0], lambda arr: sum([arr[-3], arr[-2]])],\n            'pel': [[0, 0, 0, 1], lambda arr: sum([arr[-2], 2 * arr[-1]])],\n            'tet': [[0, 0, 0, 1], lambda arr: sum(arr[-4:])],\n            'tri': [[0, 0, 0, 1], lambda arr: sum(arr[-3:])]}\n    if not pattern or n == 0:\n        return []\n    res = bind[pattern[0]][0]\n    q, r = divmod(n-len(res), len(pattern))\n    for v in (q * pattern + pattern[:r]):\n        res.append(bind[v][1](res))\n    return res[:n]\n", "def zozonacci(pattern, length):\n    if length == 0 or pattern == []:\n        return []\n    result = {\n        \"fib\": [0, 0, 0, 1],\n        \"jac\": [0, 0, 0, 1],\n        \"pad\": [0, 1, 0, 0],\n        \"pel\": [0, 0, 0, 1],\n        \"tet\": [0, 0, 0, 1],\n        \"tri\": [0, 0, 0, 1]\n    }[pattern[0]]\n    if length < 4:\n        result = result[:length]\n        return result\n    i = 0\n    j = 4\n    while len(result) < length:\n        r = {\n            \"fib\": result[j - 1] + result[j - 2],\n            \"jac\": result[j - 1] + 2 * result[j - 2],\n            \"pad\": result[j - 2] + result[j - 3],\n            \"pel\": 2 * result[j - 1] + result[j - 2],\n            \"tet\": result[j - 1] + result[j - 2] + result[j - 3] + result[j - 4],\n            \"tri\": result[j - 1] + result[j - 2] + result[j - 3]\n        }[pattern[i]]\n        result.append(r)\n        i = (i + 1) % len(pattern)\n        j += 1\n    return result", "from itertools import cycle\ndef zozonacci(pattern, length):\n    if not pattern or not length:return []\n    \n    fib=lambda lst:sum(lst[-2:])\n    jac=lambda lst:lst[-1]+2*lst[-2]\n    pad=lambda lst:lst[-2]+lst[-3]\n    pel=lambda lst:2*lst[-1]+lst[-2]\n    tet=lambda lst:sum(lst[-4:])\n    tri=lambda lst:sum(lst[-3:])\n    \n    FIRST={\"fib\":[0,0,0,1],\"jac\":[0,0,0,1],\"pad\":[0,1,0,0],\"pel\":[0,0,0,1],\"tri\":[0,0,0,1],\"tet\":[0,0,0,1]}\n    NEXT={\"fib\":fib,\"jac\":jac,\"pad\":pad,\"pel\":pel,\"tet\":tet,\"tri\":tri}\n    \n    seq=FIRST[pattern[0]]\n    pattern=cycle(pattern)\n    \n    for i in range(length-4):\n        seq.append(NEXT[next(pattern)](seq))\n    \n    return seq[:length]", "def fibonacci(array,\n              index):\n\n    return array[index - 1] + array[index - 2]\n\n\ndef jacobsthal(array,\n               index):\n\n    return array[index - 1] + 2 * array[index - 2]\n\n\ndef padovan(array,\n            index):\n\n    return array[index - 2] + array[index - 3]\n\n\ndef pell(array,\n         index):\n\n    return 2 * array[index - 1] + array[index - 2]\n\n\ndef tetranacci(array,\n               index):\n\n    return array[index - 1] + array[index - 2] + array[index - 3] + array[index - 4]\n\n\ndef tribonacci(array,\n               index):\n\n    return array[index - 1] + array[index - 2] + array[index - 3]  \n\n\nMAP = {\"fib\": fibonacci,\n       \"jac\": jacobsthal,\n       \"pad\": padovan,\n       \"pel\": pell,\n       \"tet\": tetranacci,\n       \"tri\": tribonacci}\n\n\ndef initialize(pattern):\n\n    if (pattern[0] == \"pad\"):\n\n        return [0,\n                1,\n                0,\n                0]\n    else:\n\n        return [0,\n                0,\n                0,\n                1]\n\n\ndef zozonacci(pattern,\n              length):\n\n    result = []\n    if (not (len(pattern) and\n             length)):\n\n        return result\n\n    result = initialize(pattern)\n    if (length <= 4):\n\n        return result[:length]\n\n    index = 4\n    while (len(result) < length):\n        for sequence in pattern:\n            current = MAP[sequence](result,\n                                    index)\n            result.append(current)\n            index += 1\n            if (len(result) == length):\n                break\n\n    return result\n", "from itertools import cycle\n\ndef zozonacci(p,n):\n    \n    if not p or not n: return []\n    \n    formula={\"fib\":lambda : a[-1]+a[-2],\n         \"jac\":lambda : a[-1]+2*a[-2],\n         \"pad\":lambda : a[-2]+a[-3],\n         \"pel\":lambda : 2*a[-1]+a[-2],\n         \"tet\":lambda : sum(a[-i] for i in range(1,5)),\n         \"tri\":lambda : sum(a[-i] for i in range(1,4))\n        }\n \n    a=[0,1,0,0] if p[0]==\"pad\" else [0,0,0,1]\n    \n    if n<=4: return a[:n]\n    \n    i=0\n    p=cycle(p)\n    \n    while i<n-4:    \n        a.append(formula[next(p)]())\n        i+=1\n        \n    return a    \n        \n"]