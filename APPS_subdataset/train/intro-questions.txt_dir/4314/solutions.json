["def chess_bishop_dream(b,p,d,k):\n    yq,yr=divmod(p[0]+k*d[0],2*b[0])\n    xq,xr=divmod(p[1]+k*d[1],2*b[1])\n    return [min(yr, 2*b[0]-yr-1), min(xr, 2*b[1]-xr-1)]", "chess_bishop_dream=lambda b,p,d,k:[c-abs((q+k*e)%(2*c)-c+.5)-.5for c,q,e in zip(b,p,d)]", "def chess_bishop_dream(board_size, init_position, init_direction, k):\n    l, (m, n), (x, y), (dx, dy) = 0, board_size, init_position, init_direction\n    while k:\n        k -= 1; l += 1; x += dx; y += dy\n        if x < 0 or x == m: dx = -dx; x += dx\n        if y < 0 or y == n: dy = -dy; y += dy\n        if [x, y] == init_position and [dx, dy] == init_direction: k %= l\n    return [x, y]", "def chess_bishop_dream(b,p,d,k):\n    yq,yr=divmod(p[0]+k*d[0],b[0])\n    xq,xr=divmod(p[1]+k*d[1],b[1])\n    if yq<0:\n        yq=-yq\n        yr=b[0]-yr-1\n    if xq<0:\n        xq=-xq\n        xr=b[1]-xr-1\n    return [(b[0]-yr-1 if yq%2==(d[0]>0) else yr),(b[1]-xr-1 if xq%2==(d[1]>0) else xr)]\n", "def chess_bishop_dream(bs, init_pos, init_dir, k):\n    \n    pos, dir = init_pos[:], init_dir[:]\n    n, start = k, (init_pos, init_dir)\n    while n:\n        pos = [x+dx for x,dx in zip(pos, dir)]\n        for i in range(2):\n            if not (0 <= pos[i] < bs[i]):\n                dir[i] *= -1\n                pos[i] = [0, bs[i]-1][ pos[i]>0 ]\n        n -= 1\n        if start == (pos, dir): n %= k-n\n        \n    return pos", "chess_bishop_dream=lambda b,p,d,k:[(lambda q,r:[r,c-r-1][q%2])(*divmod(q+k*e,c))for c,q,e in zip(b,p,d)]", "def chess_bishop_dream(board_size, init_position, init_direction, k):\n    (h, w), (i, j), (di, dj) = board_size, init_position, init_direction\n    (qi, ri), (qj, rj) = divmod(i + di * k, h), divmod(j + dj * k, w)\n    return [h - 1 - ri if qi % 2 else ri, w - 1 - rj if qj % 2 else rj]", "def chess_bishop_dream(board_size, pos, dir, k):\n  k %= ((board_size[0])*(board_size[1])*2)\n  steps = 0\n  while steps < k:\n      print(pos,steps,k,dir)\n      rows_to_go = pos[0] if dir[0] == -1 else (board_size[0] - pos[0] - 1)\n      cols_to_go = pos[1] if dir[1] == -1 else (board_size[1] - pos[1] - 1)\n      n = min(rows_to_go, cols_to_go, k - steps)\n      steps += n\n      pos = [pos[0] + n*dir[0], pos[1] + n*dir[1]]\n      if steps == k:\n          break\n      next_pos = [pos[0] + dir[0], pos[1] + dir[1]]\n      valid_row = (0 <= next_pos[0] < board_size[0])\n      valid_col = (0 <= next_pos[1] < board_size[1])\n      if valid_col:\n          dir[0] *= -1\n          pos[1] = next_pos[1] \n      elif valid_row:\n          dir[1] *= -1\n          pos[0] = next_pos[0] \n      else:\n          dir[0] *= -1\n          dir[1] *= -1\n      steps += 1\n  return pos", "def chess_bishop_dream(board_size, init_position, init_direction, k):\n    m,n=board_size\n    x,y=init_position\n    dx,dy=init_direction\n    r=[[x,y]]\n    while(True):\n        x,y=x+dx,y+dy\n        if not (0<=x<m):\n            x+=-dx\n            dx=-dx\n        if not (0<=y<n):\n            y+=-dy\n            dy=-dy\n        r.append([x,y])\n        if len(r)>2 and r[:2]==r[-2:]:\n            break\n    r=r[:-2]\n    return r[k%len(r)]", "def chess_bishop_dream(size, init_pos, init_dir, k):\n    pos = init_pos.copy()\n    dir = init_dir.copy()\n    i = k\n    while i > 0:\n        check = [0 <= pos[0]+dir[0] < size[0],0 <= pos[1]+dir[1] < size[1]]\n        pos[0] += dir[0]*check[0]\n        pos[1] += dir[1]*check[1]\n        dir[0] *= int((int(check[0])-0.5)*2)\n        dir[1] *= int((int(check[1])-0.5)*2)\n        i -= 1\n        if pos == init_pos and dir == init_dir:\n            i %= k-i\n    return pos"]