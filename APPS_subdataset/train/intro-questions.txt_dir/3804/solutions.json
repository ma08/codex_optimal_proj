["# precalculate results\nresults = {}\nn, digits = 1, 0\nwhile digits <= 1000:\n    digits = len(str(sum( x**(n-x+1) for x in range(1, n) )))\n    if digits not in results:\n        results[digits] = n\n    n += 1\n\n\ndef min_length_num(digits, max_num): \n    n = results.get(digits, 0)\n    return [True, n+1] if n and n < max_num else [False, -1]", "save = []\n\ndef min_length_num(num_dig, ord_max): \n    for i in range(ord_max):\n        if i == len(save):\n            save.append(len(str(sum((j+1)**(i-j) for j in range(i)))))\n        if save[i] == num_dig:\n            return [True, i+1]\n    return [False, -1]", "def sequence(n):\n  for i in range(n):\n    s = range(i+1)\n    j = i+1\n    tot = 0\n    while j > 0:\n      for k in s:\n        tot += k**j\n        j -= 1\n      break\n    yield tot\n\nnumbers = [i for i in sequence(1000)]\n\ndef min_length_num(num_dig, ord_max): \n  n = 1\n  for k in numbers[:ord_max]:\n    if len(str(k)) == num_dig: return [True, n]\n    elif len(str(k)) > num_dig: break\n    n +=1\n  return [False, -1]", "def S(n):\n    s=0\n    for i in range(1,n):\n        s=s+ i**(n-i)\n    return s\nx=[ len( str(S(n))) for n in range(1000)]\n\ndef min_length_num(num_dig, ord_max): \n    y=x[1:ord_max+1]\n    if not num_dig in y:\n        return [False,-1]\n\n    for i in range(len(y)+1):\n        if y[i]>=num_dig:\n            return [ True, i+1]\n            \n    \n    \n    \n    \n\n", "nums = {}\n\ndef helper():\n    nums[1] = '0'\n    nums[2] = '1'\n    for i in range(1001):\n        exp, suma = 1, 0\n        for j in range(i, 0, -1):\n            suma += j ** exp\n            exp += 1\n        nums[i] = str(suma)\n\ndef min_length_num(num_dig, ord_max):\n    if not nums:\n        helper()\n    for num in range(1, ord_max):\n        if len(nums[num]) == num_dig:\n            return [True, num + 1]\n    return [False, -1]", "def check(m):\n    a = list(range(1, m+1))\n    b = a[::-1]\n    c = 0\n    for x, y in zip(a, b):\n        c += x**y\n    return str(c)\n        \nlst = [1,1] +[len(check(i)) for i in range(2, 1001)]\n\ndef min_length_num(num_dig, ord_max):\n    arr = lst[:ord_max]\n    if num_dig in arr:\n        return [True, arr.index(num_dig)+1]\n    return [False, -1]", "d = {**{0:0,1:1},**{i+1:sum(k ** (i - k + 1) for k in range(1, i))+i for i in range(2, 1000)}}\ndef min_length_num(dn, n): \n    for k,l in d.items():\n        if k > n : return [0,-1]\n        if len(str(l)) == dn : return [1,k]\n    return [0,-1]", "import math\nbox = []\nfor n in range(1001)[1:]:\n    box.append(int(math.log10(sum(map(lambda x,y: x**y, list(range(n+1)), sorted(list(range(n+1)), reverse = True)))))+1)\n\ndef min_length_num(num, ord_max):\n        floor = 0\n        roof = ord_max\n        while floor <=roof:\n            mid = (roof+floor)//2\n            if box[mid] > num:\n                roof = mid - 1\n            elif box[mid] < num:\n                floor = mid + 1\n            elif box[mid-1] == num:\n                    floor -=1\n                    roof -=1\n            else:\n                return [True, mid+1]\n        else:\n            return [False, -1]\n", "r=[0]\ndef min_length_num(num_dig, ord_max): \n    for n in range(1,ord_max+1):\n        if n<len(r):\n            s=r[n]\n        else:\n            s=0\n            for i in range(1,n):\n                s+=i**(n-i)\n            r.append(s)\n        if len(str(s))==num_dig:\n            return [True,n]\n        elif len(str(s))>num_dig:\n            return [False,-1]\n    return [False,-1]", "def min_length_num(num_dig, ord_max):\n    result = results.get(num_dig, 0)\n    return [True, result + 1] if result and result < ord_max else [False, -1]\n\nresults = {}\nn = 1\ndigit = 0\nwhile digit < 1000:\n    digit = len(str(sum(x**(n - x + 1) for x in range(1, n))))\n    if digit not in results:\n        results[digit] = n\n    n += 1\n"]