["from itertools import product\n\nBOARD = set(map(\"\".join,product(\"ABCDEFGH\", \"12345678\")))\n\ndef available_moves(position):\n    if isinstance(position, str) and position in BOARD :\n\n        return sorted(p for p in BOARD-{position}  \n                      if abs(ord(p[0])-ord(position[0])) == abs(int(p[1]) - int(position[1])) \n                      or position[0]==p[0]\n                      or p[1]==position[1] )\n\n    return []\n", "columns = 'ABCDEFGH'\n\ndef available_moves(position):\n    if not (isinstance(position, str) and len(position) == 2):\n        return []\n    c0, r0 = position\n    if not ('A' <= c0 <= 'H' and '1' <= r0 <= '8'):\n        return []\n    c, r = columns.index(c0), int(r0) - 1\n    xs = {(i, r) for i in range(8)}\n    xs |= {(c, i) for i in range(8)}\n    xs |= {(i, r+c-i) for i in range(8) if 0 <= r+c-i < 8}\n    xs |= {(i, r+i-c) for i in range(8) if 0 <= r+i-c < 8}\n    xs.remove((c,r))\n    return [f'{columns[c]}{r+1}' for c, r in sorted(xs)]", "board = {f\"{c}{n}\" for c in \"ABCDEFGH\" for n in \"12345678\"}\n\ndef available_moves(position):\n    if not isinstance(position, str) or position not in board:\n        return []\n    (x, y), = ((ord(c) - 65, int(n) - 1) for c, n in (position,))\n    moves = lambda n: ((x, n), (n, y), (x - n, y - n), (x + n, y - n), (x - n, y + n), (x + n, y + n))\n    result = {f\"{chr(i + 65)}{j + 1}\" for n in range(8) for i, j in moves(n)}\n    return sorted(board & result - {position})", "from itertools import chain, count, takewhile\nimport re\n\ndef available_moves(position):\n    \n    if not isinstance(position,str) or not re.match(r'[A-H][1-8]$', position): return []\n    \n    def converter(g): return (chr(x+65)+chr(y+49) for x,y in g)\n    \n    def genTargetedPos(dx,dy):\n        return converter(takewhile(lambda p: 0<=p[0]<8 and 0<=p[1]<8,\n                                   ( (X+n*dx, Y+n*dy) for n in count(1))))\n    \n    X, Y = ord(position[0])-65, int(position[1])-1\n    return sorted(chain(*( genTargetedPos(dx,dy) for dx in range(-1,2) for dy in range(-1,2) if dx or dy)))", "from_pos = lambda s: (ord(s[0])-65, int(s[1])-1)\nto_pos = lambda i,j: f\"{chr(i+65)}{j+1}\"\n\ndef available_moves(position):\n    # That part is always just annoying\n    if not (isinstance(position, str)\n            and len(position) == 2\n            and position[0] in \"ABCDEFGH\"\n            and position[1] in \"12345678\"): return []\n    \n    (x, y), res = from_pos(position), []\n    for k,l in ((0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)):\n        i, j = y+k, x+l\n        while 0 <= i < 8 and 0 <= j < 8:\n            res.append(to_pos(j, i))\n            i, j = i+k, j+l\n    return sorted(res)", "Dict = {'A': 0, 'B': 1, 'C': 2, 'D': 3, 'E': 4, 'F': 5, 'G': 6, 'H': 7}\n\n\ndef toCoord(position):\n    if type(position) != str:\n        return []\n    if position[0] in Dict and (1 <= int(position[1]) <= 8):\n        return (Dict[position[0]], int(position[1]) - 1)\n\n\ndef fromCoord(position):\n    return chr(64 + position[0] + 1) + str(position[1] + 1)\n\n\ndef available_moves(position):\n    try:\n        if type(position) == str and len(position) == 2 and 65 <= ord(position[0]) <= 90:\n            moves = []\n            position = toCoord(position)\n            if position == []:\n                return moves\n            if 0 <= position[0] <= 7 and 0 <= position[1] <= 7:\n                i = 1\n                for x in range(8):\n                    if (x, position[1]) != position:\n                        moves.append(fromCoord((x, position[1])))\n\n                for y in range(8):\n                    if (position[0], y) != position:\n                        moves.append(fromCoord((position[0], y)))\n\n                for i in range(1, max(max((7 - position[0]), (position[0])),max((7 - position[1], position[1]))) + 1):\n                    if 0 <= position[0] + i <= 7 and 0 <= position[1] + i <= 7:\n                        moves.append(fromCoord((position[0] + i, position[1] + i)))\n\n                    if 0 <= position[0] + i <= 7 and 0 <= position[1] - i <= 7:\n                        moves.append(fromCoord((position[0] + i, position[1] - i)))\n\n                    if 0 <= position[0] - i <= 7 and 0 <= position[1] + i <= 7:\n                        moves.append(fromCoord((position[0] - i, position[1] + i)))\n\n                    if 0 <= position[0] - i <= 7 and 0 <= position[1] - i <= 7:\n                        moves.append(fromCoord((position[0] - i, position[1] - i)))\n\n                return sorted(moves)\n            return []\n        return []\n    except TypeError:\n         return []\nprint(available_moves(\"D8\"))", "def Horizontal(position):\n    R = position[1];\n    HorizontalMoves = [\"A\"+R, \"B\"+R, \"C\"+R, \"D\"+R, \"E\"+R, \"F\"+R, \"G\"+R, \"H\"+R];\n    possible = list(filter(lambda x:(x!=position),HorizontalMoves));\n    return possible;\n\ndef Vertical(position):\n    F = position[0]; #Current file of the queen's position\n    VerticalMoves = [F+str(1), F+str(2), F+str(3), F+str(4), F+str(5), F+str(6), F+str(7), F+str(8)];\n    #VerticalMoves.remove(position);\n    p = list(filter(lambda y:(y!=position),VerticalMoves));\n    return p;\n\n\ndef TRtBL (position): #top being 8th rank and bottom being 1st rank R=>HFile, L=>A file\n    moves = []; #intialize an array for all moves in this diag\n    num = int(position[1]); #rank of the position (1-8)\n    ASC_Letter = ord(position[0]); #gives ascii value of the \"File\" of queen position\n    Up = num;\n    Down = num;\n    TempLetter = ASC_Letter;\n    TempLetter2 = ASC_Letter;\n    while TempLetter<72 and Up<8:\n        if position[0] == \"H\" or Up==8:\n            break;\n        TempLetter = TempLetter + 1;\n        Up = Up + 1;\n        moves.append(chr(TempLetter) + str(Up)); #stores coordinate to moves\n    while TempLetter2>65 and Down>0:\n        if position[0] == \"A\" or Down == 1:\n            break;\n        TempLetter2 = TempLetter2 - 1;\n        Down = Down - 1;\n        moves.append(chr(TempLetter2) + str(Down));\n    return moves;\n\ndef TLtBR (position):   #top being 8th rank and bottom being 1st rank R=>HFile, L=>A file\n    moves = []; #intialize an array for all moves in this diag\n    num = int(position[1]); #rank of the position (1-8)\n    ASC_Letter = ord(position[0]); #gives ascii value of the \"File\" of queen position\n    Up = num;\n    Down = num;\n    TempLetter = ASC_Letter;\n    TempLetter2 = ASC_Letter;\n    while TempLetter<72 and Down>1:\n        if position[0] == \"H\":\n            break;\n        TempLetter = TempLetter + 1;\n        Down = Down - 1;\n        moves.append(chr(TempLetter) + str(Down)); #stores coordinate to moves\n    while TempLetter2>65 and Up<8:\n        if position[0] == \"A\":\n                break;\n        TempLetter2 = TempLetter2 - 1;\n        Up = Up + 1;\n        moves.append(chr(TempLetter2) + str(Up));\n    return moves;\ndef available_moves(position):\n    answer = [];\n    if not position:\n        return answer;\n    if not isinstance(position,str):\n        return answer;\n    if len(position) != 2:\n        return answer;\n    if int(position[1]) < 1 or int(position[1]) > 8:\n        return answer;\n    if position[0].isdigit():\n        return answer;\n    if ord(position[0])>72:\n        return answer;\n    '#now the function calls the 4 subfunctions(vertical,horizont,TLtBR,TRtBL)'\n    '# After all possible moves have been added a simple sorting function can be returned to '\n    '# give the final array in alphabetical order'\n    answer.extend(Horizontal(position));\n    answer.extend(Vertical(position));\n    answer.extend(TLtBR(position));\n    answer.extend(TRtBL(position));\n    answer.sort();\n    return answer;", "board = {f\"{c}{n}\" for c in \"ABCDEFGH\" for n in \"12345678\"}\n\ndef available_moves(position):\n    if not isinstance(position, str) or position not in board:\n        return []\n    (x, y), = ((ord(c), ord(n)) for c, n in (position,))\n    moves = lambda m: ((x, m + 49), (m + 65, y), (x - m, y - m), (x + m, y - m), (x - m, y + m), (x + m, y + m))\n    result = {f\"{chr(i)}{chr(j)}\" for m in range(8) for i, j in moves(m)}\n    return sorted(board & result - {position})", "def available_moves(pos):\n    if type(pos)!=str or pos[0] not in 'ABCDEFGH' or pos[1:] not in '12345678':return []\n    i, j = int(pos[1]) - 1, 'ABCDEFGH'.index(pos[0])\n    final = sorted(set([f\"{i}{pos[1]}\"for i in 'ABCDEFGH']+[f\"{pos[0]}{i}\"for i in range(1, 9)]+find(i,j)+find(i,j,1,-1)))\n    final.remove(pos)\n    return final\ndef find(x, y, o=1, p=1,A = lambda a, b: f\"{'ABCDEFGH'[a]}{b + 1}\"):\n        while 0 <= x <= 7 and 0 <= y <= 7 : x -= o ; y -= p\n        x += o ; y += p ; li = []\n        while 0 <= x < 8 and 0 <= y < 8:\n            li.append(A(y, x)) ; x += o ; y += p\n        return li", "def available_moves(position):\n    result = []\n    try:\n        letter = position[0]\n        number = int(position[1:])\n        if number < 1 or number > 8:\n            return result\n        if ord(letter) < 65 or ord(letter) > 72:\n            return result\n        for i in range(65, 73):\n            for j in range(1, 9):\n                if chr(i) == letter:\n                    result.append(letter + str(j))\n                elif j == number:\n                    result.append(chr(i) + str(number))\n                elif abs(j - number) == abs(i - ord(letter)):\n                    result.append(chr(i) + str(j))\n        result.remove(position)\n    except Exception:\n        pass\n    return result"]