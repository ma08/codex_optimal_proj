["def array_manip(array):\n    return [min([a for a in array[i+1:] if a > array[i]], default=-1) for i in range(len(array))]", "def array_manip(array):\n    return [min((r for r in array[i:] if r > n), default=-1) for i, n in enumerate(array, 1)]\n", "# This is O(n\u00b2), it's a bad solution\n# You can do it in O(n*log(n)) but I'm too lazy for now\ndef array_manip(array):\n    return [min(filter(lambda y: y > x, array[i+1:]), default=-1) for i,x in enumerate(array)]", "def array_manip(array):\n    return [min((j for j in array[i+1:] if j > array[i]), default=-1) for i in range(len(array))]", "def array_manip(array):\n    return [\n        min((x for x in array[i:] if x > n), default=-1)\n        for i, n in enumerate(array)]", "def array_manip(array):\n    res = []\n    for i, n in enumerate(array):\n        try:\n            res.append(min([x for x in array[i+1:] if x > n]))\n        except ValueError:\n            res.append(-1)\n    return res", "array_manip=lambda a:[min([m for m in a[i+1:]if m>n]or[-1])for i,n in enumerate(a)]", "def array_manip(array):\n    result = []\n    for i in range(len(array)):\n        try:\n            cr = array[i]\n            mm = sorted(x for x in array[i+1:] if x > cr)[0]\n            result.append(mm)\n        except:\n            result.append(-1)\n    return result", "def array_manip(array):\n    return [min(filter(lambda a: a > array[i], array[i+1:]), default=-1) for i in range(len(array))]", "class BinaryTree:\n    def __init__(self, value, left=None, right=None, parent=None):\n        self.value = value\n        self.left = left\n        self.right = right\n        self.parent = parent\n        \n    def __str__(self):\n        if self.left or self.right:\n            s = \"(\" + str(self.value)\n            sl = self.left or '#'\n            sr = self.right or '#'\n            for l in str(sl).split(\"\\n\"):\n                s += \"\\n  \" + l\n            for l in str(sr).split(\"\\n\"):\n                s += \"\\n  \" + l\n            return s + \")\"\n        else:\n            return f\"{self.value}\"\n\n    def add(self, val):\n        if val < self.value:\n            if self.left:\n                return self.left.add(val)\n            else:\n                self.left = BinaryTree(val, parent=self)\n                return self.left\n        elif val > self.value:\n            if self.right:\n                return self.right.add(val)\n            else:\n                self.right = BinaryTree(val, parent=self)\n                return self.right\n        elif val == self.value:\n            return self\n    \n    def leftmost(self):\n        x = self\n        while x.left:\n            x = x.left\n        return x\n\n    def nxt(self):\n        if self.right:\n            return self.right.leftmost().value\n        else:\n            x = self.parent\n            while x and x.value < self.value:\n                x = x.parent\n            if x:\n                return x.value\n            \n        return -1\n\ndef array_manip(array):\n    if not array:\n        return []\n    \n    result = []\n    b = BinaryTree(array[-1])\n    \n    for item in reversed(array):\n        result.append(b.add(item).nxt())\n        \n    return result[::-1]\n    \n"]