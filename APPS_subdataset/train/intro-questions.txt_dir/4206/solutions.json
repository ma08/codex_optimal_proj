["from functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef three_details(n):\n    if n <= 3: return n==3\n    q, r = divmod(n, 2)\n    return three_details(q) + three_details(q+r)", "from functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef three_details(n):\n    if n in (3,5,7):\n        return 1\n    elif n < 6:\n        return 0\n    q, r = divmod(n, 2)\n    if r:\n        return three_details(q) + three_details(q+1)\n    else:\n        return three_details(q) * 2", "from math import log2\n\ndef three_details(n):\n    i = int(log2(n))\n    return min(abs(n - 2**p) for p in (i, i + 1))", "def three_details(n):\n    u = 2 ** n.bit_length()\n    return n - u // 2 if n <= 3 * u // 4 else u - n", "from math import ceil\nfrom functools import lru_cache\nthree_details = lru_cache(None)(lambda n:int(n==3) if n<=3 else three_details(ceil(n/2)) + three_details(n//2))", "three_details=lambda n:(lambda l:min(n%2**l,-n%2**l))(int(__import__('math').log2(n)))", "def three_details(n):\n    if n==3: return 1\n    if n<5: return 0\n    if n%2==0:\n        return 2*three_details(n//2)\n    else:\n        return three_details(n//2)+three_details(n//2+1)\n", "def three_details(n):\n    p=2**n.bit_length()\n    return (p-abs(4*n-3*p))//4\n", "ready = [0,0,0,1]\n\ndef f(x):\n    if x<len(ready): return ready[x]\n    else: return f(x//2) + f(x//2 + x%2)\n\nfor i in range(4,100001):\n    ready.append(f(i))\n\n\ndef three_details(n):\n    if n < 100000: return ready[n]\n    else: return three_details(n//2) + three_details(n//2 +n%2)", "from functools import lru_cache\n\n\n@lru_cache()\ndef three_details(n, count=0):\n    even, odd = n//2, n//2 + n%2\n    if n == 3:\n        return 1\n    elif n < 3:\n        return 0\n    return three_details(n-even) + three_details(n-odd)"]