["CRITERIA = (str.islower, str.isupper, str.isdigit)\n\ndef password(s):\n    return len(s)>7 and all( any(map(f,s)) for f in CRITERIA)", "import re\n\ndef password(s):\n    return bool(re.match(r'(?=.*[A-Z])(?=.*[a-z])(?=.*\\d).{8}', s))", "import re \n\ndef password(string):\n    patterns = (r'[A-Z]', r'[a-z]', r'[0-9]', r'.{8,}')\n    return all([re.search(pattern, string) for pattern in patterns])", "def password(candidate):\n    \"\"\"Returns True if 'candidate' password possesses arbitrary properties that do more than\n       good for security of the users' accounts. It is probably accompanied by a password \n       field in which paste is disabled. Notice that a maximum character length is not specified.\n       This is so we can silently truncate the users' passwords before hashing and storing\n       them so that when they attempt to log in later, they have to guess how many characters\n       we truncated. We might also do this differently on different clients so the same password\n       works in some instances and fails in others. We will also impliment all this client side, \n       so the validation is easily defeated by anyone willing to monkey with our client-side script.\n       Then we will add 'security questions' based on publicly available information, allowing\n       anyone to sidestep authentication with a basic search.\n       \n       Otherwise, False.\n    \"\"\"\n       \n    if not len(candidate) >= 8:\n        return False\n    if not any(char.islower() for char in candidate):\n        return False\n    if not any(char.isupper() for char in candidate):\n        return False\n    if not any(char.isdigit() for char in candidate):\n        return False\n    return True ", "def password(string):\n    if len(string) >= 8:\n        check = 0\n        for c in string:\n            if   c.isupper(): check |= 1\n            elif c.islower(): check |= 2\n            elif c.isdigit(): check |= 4\n            if check == 7: return True\n    return False", "def password(s):\n    return  any(c.isupper() for c in s) and \\\n            any(c.islower() for c in s) and \\\n            any(c.isdigit() for c in s) and \\\n            len(s)>7", "import re\ndef password(string):\n    \n    return bool(re.match(\"^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d).{8,}$\",string))", "def lenfilt(func, seq):\n    return len(list(filter(func, seq)))\n\ndef assrt(seq):\n    funcs = [str.isupper, str.islower, str.isdigit, str]\n    nums = [0, 0, 0, 7]\n    return [lenfilt(i, seq) > j for i, j in zip(funcs, nums)]\n\ndef password(string):\n    return all(assrt(string))", "def password(string):\n    #your code here\n    k1 = k2 = k3 = 0\n    if len(string) < 8:\n        return False\n    \n    for i in string:\n        if i.islower():\n            k1 = 1\n    for i in string:\n        if i.isupper():\n            k2 = 1\n    for i in string:\n        if i.isdigit():\n            k3 = 1\n    if k1 == k2 == k3 == 1:\n        return True\n    else:\n        return False", "def password(string):\n  rules = [lambda s: any(x.isupper() for x in s),\n          lambda s: any(x.islower() for x in s),  \n          lambda s: any(x.isdigit() for x in s),\n          lambda s: len(s) >= 8\n          ]\n          \n  if all(rule(string) for rule in rules):\n    return True\n  else:\n    return False"]