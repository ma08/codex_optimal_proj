["def traffic_lights(road, n):\n    lightsIdx = [ (i, 6*(c!='G')) for i,c in enumerate(road) if c in 'RG' ]\n    car, ref  = road.find('C'), road.replace('C','.')\n    mut, out  = list(ref), [road]\n    \n    for turn in range(1,n+1):\n    \n        for i,delta in lightsIdx:                                  # Update all lights\n            state = (delta+turn) % 11\n            mut[i] = 'G' if state<5 else 'O' if state==5 else 'R'\n        \n        car += car+1>=len(road) or mut[car+1] in '.G'              # Move the car if possible (even if outside of the road)\n        \n        if car<len(road): old, mut[car] = mut[car], 'C'            # Update, archive, then restore the road state\n        out.append(''.join(mut))\n        if car<len(road): mut[car] = old\n        \n    return out\n", "from itertools import cycle \n\ndef traffic_lights(road, n):\n    light1 = iter(cycle( 'RRRRRGGGGGO' ))\n    light2 = iter(cycle( 'GGGGGORRRRR' ))\n    \n    traffic , car = [], -1\n     \n    for _ in range(n+1):\n        temp, RL, GL = [], next(light1), next(light2)\n        for i in range(len(road)):\n            temp.append( { 'R':RL, 'G':GL }.get(road[i], '.') ) \n        if car<len(temp)-1 and  temp[car+1] in 'RO': car -=1\n        car +=1 \n        if car<len(temp): temp[car] = 'C'\n        traffic.append(''.join(temp))\n    return traffic", "def traffic_lights(road, n):\n    light_cycle = {\"R\": \"RRRRRGGGGGO\", \"G\": \"GGGGGORRRRR\"}\n    lights = {pos: light_cycle[light] for pos, light in enumerate(road) if light in light_cycle}\n    car, result = 0, [road]\n    for state in range(1 , n + 1):\n        if car+1 not in lights or lights[car+1][state%11] not in \"OR\":\n            car += 1\n        result.append(\"\".join(\"C\" if pos == car else lights[pos][state%11] if pos in lights else \".\" for pos in range(len(road))))\n    return result   ", "def light_changes_iter(n, *args):\n    '''\n    n - no. iterations\n    args is a pattern in a form of tuple\n    stores the iterations where lights must be changed\n    '''\n    iteration = 0\n    tup = () \n    while True:\n        for x in args:\n            iteration += x\n            tup += (iteration,) #append tuple\n            if max(tup) > n:\n                return tup[:-1] #pop out last element, it is above last iteration\n\ndef shift_lights(road_state, init_state):\n    '''\n    current road_state\n    initial_state - list with the indexes of the initial light state\n    current_pos - current position of the car to be updated\n    pos_index - position of the car\n    '''\n    temp = road_state.split(\" \") #string to list\n    \n    #only updates the positions correspondent to the initial signal\n    #change current_pos if the car is in the same position as a signal\n    for index in init_state: \n        if temp[0][index] == \"O\":\n            temp[0] = temp[0][:index] + \"R\" + temp[0][index+1:]\n\n        elif temp[0][index] == \"G\":\n            temp[0] = temp[0][:index] + \"O\" + temp[0][index+1:]\n\n        elif temp[0][index] == \"R\":\n            temp[0] = temp[0][:index] + \"G\" + temp[0][index+1:]\n\n    return \"\".join(temp)\n \ndef traffic_lights(road_state, n):\n    '''\n    road_state is a list with the initial road state\n    '''\n    road = [] + [road_state] #store road progress in a list\n    road_simulated = \".\" + road_state[1:] #simulates road without car\n    \n    #iterations where light changes if position starts with green, orange, red\n    green = light_changes_iter(n, 5,1,5)\n    orange = light_changes_iter(n, 1,5,5) \n    red = light_changes_iter(n, 5,5,1)\n\n    #store the indexes of initial states of the lights to keep track \n    #how they should change across iterations\n    init_green = [i for i,char in enumerate(road_simulated) if char == \"G\"]\n    init_orange = [i for i,char in enumerate(road_simulated) if char == \"O\"]\n    init_red = [i for i,char in enumerate(road_simulated) if char == \"R\"]\n    \n    #start variables\n    pos_index = 0 #current position of the car\n\n    for ite in range(1,n+1):\n        #update lights according to iteration\n        if ite in green:\n            road_simulated = shift_lights(road_simulated, init_green)\n        if ite in orange:\n            road_simulated = shift_lights(road_simulated, init_orange)\n        if ite in red:\n            road_simulated = shift_lights(road_simulated, init_red)\n        \n        try:\n            #check if car should stop\n            if road_simulated[pos_index + 1] in (\"O\", \"R\"):\n                road_state = road_simulated[:pos_index] + \"C\" + road_simulated[pos_index+1:]\n                road.append(road_state)\n                continue\n            \n            #move the car\n            pos_index += 1\n            road_state = road_simulated[:pos_index] + \"C\" + road_simulated[pos_index+1:]\n            road.append(road_state)\n    \n        except IndexError: #last iteration, car goes out of road\n            road.append(road_simulated)  \n        \n    return road\n", "def traffic_lights(road, n):\n\n    print(road)\n    index_red_init = [i for i,j in enumerate(road) if j =='R']\n    index_green_init = [i for i,j in enumerate(road) if j =='G']\n    index_orange_init = [i for i,j in enumerate(road) if j =='O']\n    print(index_green_init)\n    #print(type(road))\n    road_lst = [i for i in road]\n\n    red_init = 'RRRRRGGGGGO'\n    green_init = 'GGGGGORRRRR'\n    orange_init = 'ORRRRRGGGGG'\n    \n    index_car = 0\n    \n    time = 0\n    count = 0\n    car_index = -1\n    final = []\n    while time <= n and car_index <= len(road) - 1:\n        \n        #if car_index == len(road) - 1:\n            \n        \n        if count >= len(red_init):\n            count = count - len(red_init)\n        for i in index_red_init:\n            road_lst[i] = red_init[count]\n        for i in index_green_init:\n            road_lst[i] = green_init[count]\n        for i in index_orange_init:\n            road_lst[i] = orange_init[count]\n        \n        #print(car_index + 1)\n        \n        if car_index != len(road) - 1:\n        \n            if road_lst[car_index + 1] == 'R':\n                car_index = car_index\n            elif road_lst[car_index + 1] == 'O':\n                car_index = car_index\n            else:\n                car_index += 1\n            road_lst[car_index] = 'C'\n        elif road[-1] == 'R':\n            road_lst[-1] = red_init[count]\n        elif road[-1] == 'G':\n            road_lst[-1] = green_init[count]\n        elif road[-1] == 'O':\n            road_lst[-1] = orange_init[count]\n        else:\n            road_lst[-1] = '.'\n            \n        \n\n        if car_index - 1 in index_red_init:\n            road_lst[car_index - 1] = red_init[count]\n        elif car_index - 1  in index_green_init:\n            road_lst[car_index - 1] = green_init[count]\n        elif car_index - 1  in index_orange_init:\n            road_lst[car_index - 1] = orange_init[count]\n        elif car_index - 1 >= 0:\n            road_lst[car_index - 1] = '.'\n            \n        result = ''.join(road_lst)\n\n        final.append(result)\n        count += 1\n            \n        time += 1\n    \n    return final", "def traffic_lights(road, n):\n    C, D, res = 0, {i:[c, 0] for i,c in enumerate(road) if c in \"GOR\"}, [road]\n    def updateLights():\n        for i, (c, k) in D.items():\n            if c == 'G':\n                if k == 4: D[i] = ('O', 0)\n                else: D[i] = ('G', k+1)\n            elif c == 'O': D[i] = ('R', 0)\n            elif k == 4: D[i] = ('G', 0)\n            else: D[i] = ('R', k+1)\n    for _ in range(n):\n        updateLights()\n        if not (C+1) in D or D[C+1][0] == 'G': C += 1\n        res.append(''.join('C' if i == C else D[i][0] if i in D else '.' for i in range(len(road))))\n    return res", "class TrafficUnit:\n\n    def __init__(self, color):\n        # '.': road\n        # 'R'/'G'/'B': light\n        self.color = color\n        self.t = 0\n\n    def can_pass(self):\n        return self.color is '.' or self.color == 'G'\n\n    def step(self):\n        self.t = (self.t + 1) % 5\n        if self.color == 'G':\n            if self.t == 0:\n                self.color = 'O'\n        elif self.color == 'O':\n            self.color = 'R'\n            self.t = 0\n        elif self.color == 'R':\n            if self.t == 0:\n                self.color = 'G'\n        return self\n\n    def __str__(self):\n        return self.color\n\n\ndef traffic_lights(road, n):\n    def f():\n        car_pos = 0\n        units = [TrafficUnit(c.replace('C', '.')) for c in road + '.']\n        for i in range(n+1):\n            xs = list(map(str, units))\n            if car_pos < len(road):\n                xs[car_pos] = 'C'\n            yield ''.join(xs[:-1])\n            units = [unit.step() for unit in units]\n            if car_pos < len(road) and units[car_pos+1].can_pass():\n                car_pos += 1\n    return list(f())", "def traffic_lights(road, n):\n    k, car, res = 'GGGGGORRRRR', 0, []\n    for i in range(n+1):\n        lights = [k[(k.index(s) + i) % 11] if s in 'ROG' else '.' for s in road]\n        if car < len(road) - 1:\n            if i: car += lights[car+1] not in 'RO'\n            lights[car] = 'C' \n        res.append(''.join(lights))\n    return res\n", "def traffic_lights(road, n):\n    empty = '.'*len(road)\n    r = [road]+[empty]*n\n    l = 10*(5*'G'+'O'+5*'R')\n    for i in range(len(road)):\n        if road[i] in l:\n            for j in range(n+1):\n                r[j] = r[j][:i]+l[j+l.index(road[i])]+r[j][i+1:]\n    for i in range(n):\n        if 'C' in r[i][:-1]:\n            c = r[i][:-1].index('C')\n            if r[i+1][c+1] is 'R' or r[i+1][c+1] is 'O':\n                r[i+1] = r[i+1][:c]+'C'+r[i+1][c+1:]\n            else:\n                r[i+1] = r[i+1][:c+1]+'C'+r[i+1][c+2:]\n    return r\n", "def traffic_lights(road,n):\n    a,b,c = 'GGGGGORRRRR','ORRRRRGGGGG','RRRRRGGGGGO'\n    r,p = [road],0\n    for i in range(1,n+1):\n        t = [a[i%11] if x=='G' else b[i%11] if x=='O' else c[i%11] if x=='R' else x for x in road]\n        if p<len(road)-1:\n            if t[p+1] not in 'RO':\n                p += 1\n                t[p] = 'C'\n            elif t[p+1] in 'RO':\n                t[p] = 'C'\n        t[0] = 'C' if p==0 else '.'\n        r.append(''.join(t))\n    return r"]