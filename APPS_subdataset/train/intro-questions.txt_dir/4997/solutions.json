["cache = {}\ndef sum_div(x):\n    if x not in cache:\n        cache[x] = sum(i for i in range(1, x+1) if x % i == 0)\n    return cache[x]\n\ndef is_required(x):\n    reversed = int(str(x)[::-1])\n    return x != reversed and sum_div(x) == sum_div(reversed)\n\nrequired = [x for x in range(528, 10**4) if is_required(x)]\n\ndef equal_sigma1(nMax):\n    return sum(x for x in required if x <= nMax)\n", "def sigma1(n):\n    ans = 0\n    for i in xrange(1,int(n**0.5) + 1):\n        if n % i == 0:\n            ans += i + n / i\n    return ans if n ** 0.5 % 1 != 0 else ans - int(n ** 0.5)\n\ndef equal_sigma1(n_max):\n    ans = 0\n    for i in xrange(528,n_max+1):\n        j = int(str(i)[::-1])\n        if i != j and sigma1(i) == sigma1(j):ans += i\n    return ans", "import bisect\n\ndef s1(n):\n    result = 0\n    for i in range(1, int(n ** 0.5)+1):\n        q, r = divmod(n, i)\n        if r == 0:\n            result += i\n            if q != i:\n                result += q\n    return result\n\ndup = set()\nfor i in range(10001):\n    ss = str(i)\n    rr = ss[::-1]\n    if ss >= rr:\n        continue\n    if s1(i) == s1(int(rr)):\n        dup.add(i)\n        dup.add(int(rr))\ndup = sorted(dup)\n\ndef equal_sigma1(nMax):\n    return sum(dup[:bisect.bisect(dup, nMax)])", "def sigma1(n):\n    return sum(set(sum(([k, n//k] for k in range(2, int(n**0.5) + 1) if not n % k), [1, n])))\n\ndef equal_sigma1(limit):\n    return sum(n for n in range(limit + 1) if n != int(str(n)[::-1]) and sigma1(n) == sigma1(int(str(n)[::-1])))", "n = 100000\n\ns = list(range(1, n+2))\n\nfor d in range(2, int(n**.5) + 1):\n    for i in range(d*d, n+1, d):\n        s[i] += d\n        s[i] += i//d\n    s[d*d] -= d\n\ndef equal_sigma1(n):\n    return sum(x for x in range(n+1)\n        if str(x) != str(x)[::-1] and s[x] == s[int(str(x)[::-1])])", "import math\n\n\ndef find_sum_of_divisors(number):\n    not_divisible = []\n    sum = 1 + number\n    for div in xrange(2, int(round(math.sqrt(number)+1))):\n        if number % div == 0:\n            sum += div + number/div\n    return sum\n    \n            \ndef equal_sigma1(nMax):\n    checked_numbers = set()\n    found_sum = 0\n    for num in xrange(528, nMax+1):\n        if num in checked_numbers:\n            continue\n            \n        number = str(num)\n        rev_number = number[::-1]\n        rev_num = int(rev_number)\n        \n        checked_numbers.add(num)\n        checked_numbers.add(rev_num)\n        \n        if number == rev_number:\n            continue\n        \n        if find_sum_of_divisors(num) == find_sum_of_divisors(rev_num):\n            found_sum += num + (rev_num if rev_num <= nMax else 0)\n        \n    return found_sum #sum of found numbers", "def sigma(n):\n    r = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            r += i + n // i\n    if n ** 0.5 % 1 != 0: return r \n    else: return r - int(n ** 0.5)\ndef equal_sigma1(nmax):\n    i, s = 2, 0\n    while i <= nmax:\n        rev = int(str(i)[::-1])\n        if i != rev and sigma(i) == sigma(rev):\n            s += i\n        i += 1\n    return s", "# If a sequence has very few elements, it is best to compute enough of it at first\n# And then just iterate over it\nres = [528, 825, 1561, 1651, 4064, 4604, 5346, 6435, 5795, 5975]\n\ndef equal_sigma1(nMax):\n    return sum(x for x in res if x <= nMax)", "f_d=lambda m:sum(set(sum([[i,m//i]for i in range(1,int(m**.5)+1)if m%i==0],[])))\nequal_sigma1=lambda n:sum(set(sum([[i,int(str(i)[::-1])if int(str(i)[::-1])<=n else 0]for i in range(2,n+1)if str(i)!=str(i)[::-1]and f_d(i)==f_d(int(str(i)[::-1]))>0],[])))", "def f(n):\n    r = 1 + n\n    for i in range(2, int(n**0.5) + 1):\n        if not n % i:\n            r += i\n            j = n // i\n            if i != j:\n                r += j\n    return r\n\ns = set()\nfor i in range(528, 10000):\n    j = int(str(i)[::-1])\n    if i != j and f(i) == f(j):\n        s |= {i, j}\n\ndef equal_sigma1(n):\n    return sum(x for x in s if x <= n)"]