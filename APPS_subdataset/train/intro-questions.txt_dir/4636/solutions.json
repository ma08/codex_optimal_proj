["H, W     = 6, 8\nKEYBOARD = [ \"abcde123fghij456klmno789pqrst.@0uvwxyz_/\\u000e \",\n             \"ABCDE123FGHIJ456KLMNO789PQRST.@0UVWXYZ_/\\u000e \",\n             \"^~?!'\\\"()-:;+&%*=<>\u20ac\u00a3$\u00a5\u00a4\\\\[]{},.@\u00a7#\u00bf\u00a1\\u000e\\u000e\\u000e_/\\u000e \"]\nMAP      = [ {c: (i//W, i%W) for i,c in enumerate(KEYBOARD[x])} for x in range(len(KEYBOARD)) ]\n\n\ndef manhattan(*pts):\n    dxy = [abs(z2-z1) for z1,z2 in zip(*pts)]\n    return 1 + sum( min(dz, Z-dz) for dz,Z in zip(dxy, (H,W)) )\n\ndef tv_remote(words):\n    cnt, mod, was = 0, 0, 'a'\n    for c in words:\n        while c not in KEYBOARD[mod]:\n            cnt += manhattan(MAP[mod][was], MAP[mod]['\\u000e'])\n            was = '\\u000e'\n            mod = (mod+1) % 3\n        cnt += manhattan(MAP[mod][was], MAP[mod][c])\n        was  = c\n    return cnt", "M1 = \"abcde123fghij456klmno789pqrst.@0uvwxyz_/\u00b0 \"\nM2 = \"ABCDE123FGHIJ456KLMNO789PQRST.@0UVWXYZ_/\u00b0 \"\nM3 = \"^~?!\\'\\\"()-:;+&%*=<>\u20ac\u00a3$\u00a5\u00a4\\\\[]{},.@\u00a7#\u00bf\u00a1\u00b0\u00b0\u00b0_/\u00b0 \"\n\nD1 = {c:divmod(i, 8) for i,c in enumerate(M1)}\nD2 = {c:divmod(i, 8) for i,c in enumerate(M2)}\nD3 = {c:divmod(i, 8) for i,c in enumerate(M3)}\nD = (D1, D2, D3)\n\ndist = lambda i,j,k,l: min(abs(i-k), 6-abs(i-k)) + min(abs(j-l), 8-abs(j-l)) + 1\n    \ndef tv_remote(words):\n    def rec(c, d, i, j):\n        if c == len(words): return 0\n        tmp = D[d].get(words[c])\n        if tmp: return dist(i, j, *tmp) + rec(c+1, d, *tmp)\n        return dist(i, j, 5, 0) + rec(c, (d+1)%3, 5, 0)\n    return rec(0, 0, 0, 0)", "from collections import namedtuple\nfrom itertools import repeat, cycle\n\nPosition = namedtuple('Position', 'y x')\nshift = Position(5, 0)\n\nremote = (\n    (\n        'a', 'b', 'c', 'd', 'e', '1', '2', '3',\n        'f', 'g', 'h', 'i', 'j', '4', '5', '6',\n        'k', 'l', 'm', 'n', 'o', '7', '8', '9',\n        'p', 'q', 'r', 's', 't', '.', '@', '0',\n        'u', 'v', 'w', 'x', 'y', 'z', '_', '/',\n        '', ' '\n    ),\n    (\n        'A', 'B', 'C', 'D', 'E', '1', '2', '3',\n        'F', 'G', 'H', 'I', 'J', '4', '5', '6',\n        'K', 'L', 'M', 'N', 'O', '7', '8', '9',\n        'P', 'Q', 'R', 'S', 'T', '.', '@', '0',\n        'U', 'V', 'W', 'X', 'Y', 'Z', '_', '/',\n        '', ' '\n    ),\n    (\n        '^', '~', '?', '!', \"'\", '\"', '(', ')',\n        '-', ':', ';', '+', '&', '%', '*', '=',\n        '<', '>', '\u20ac', '\u00a3', '$', '\u00a5', '\u00a4', '\\\\',\n        '[', ']', '{', '}', ',', '.', '@', '\u00a7',\n        '#', '\u00bf', '\u00a1', '', '', '', '_', '/',\n        '', ' '\n    )\n)\n\n\ndef tv_remote(word: str):\n    modes = cycle(remote)\n    prev, mode, button_presses = Position(0, 0), next(modes), 0\n\n    for letter in word:\n        try:\n            i = mode.index(letter)\n\n        except ValueError:\n            button_presses += calc_presses(prev, shift)\n            mode = next(modes)\n            prev = shift\n\n            try:\n                i = mode.index(letter)\n\n            except ValueError:\n                button_presses += 1\n                mode = next(modes)\n                i = mode.index(letter)\n\n        cur = Position(*divmod(i, 8))\n        button_presses += calc_presses(prev, cur)\n        prev = cur\n\n    return button_presses\n\n\ndef calc_presses(pos1: Position, pos2: Position):\n    dif_y, dif_x = abs(pos1.y - pos2.y), abs(pos1.x - pos2.x)\n    return min(dif_y, 6 - dif_y) + min(dif_x, 8 - dif_x) + 1", "def tv_remote(word):\n    shift, kb = coords[\"\u2191\"], 0\n    moves, current = 0, (0, 0)\n    for char in word:\n        target, switch = coords[char.lower()], get_switch(kb, char)\n        if switch:\n            moves, current, kb = moves + switch-1 + distance(current, shift), shift, (kb + switch) % 3\n        moves, current = moves + distance(current, target), target\n    return moves\n\nkb1 = (\"abcde123\", \"fghij456\", \"klmno789\", \"pqrst.@0\", \"uvwxyz_/\", \"\u2191 \")\nkb3 = (\"^~?!'\\\"()\", \"-:;+&%*=\", \"<>\u20ac\u00a3$\u00a5\u00a4\\\\\", \"[]{},.@\u00a7\", \"#\u00bf\u00a1\u00a0\u00a0\u00a0_/\")    \ncoords = {c: (line.index(c), y) for kb in (kb1, kb3) for y, line in enumerate(kb) for c in line}\n\ndef get_switch(kb, char):\n    target = (0 if char.islower() else 1 if char.isupper()\n              else (kb != 2 and kb) if char.isdecimal() else 2 if char not in \".@_/\u2191 \" else kb)\n    return (target - kb) % 3\n\ndef distance(pos1, pos2):\n    d0, d1 = abs(pos2[0] - pos1[0]), abs(pos2[1] - pos1[1])\n    return 1 + min(d0, 8 - d0) + min(d1, 6 - d1)", "def tv_remote(words):\n    kpad=['abcde123fghij456klmno789pqrst.@0uvwxyz_/\u25cb \u263a\u263a\u263a\u263a\u263a',\n    'ABCDE123FGHIJ456KLMNO789PQRST.@0UVWXYZ_/\u25cb \u263a\u263a\u263a\u263a\u263a\u263a',\n    '^~?!\\'\"()-:;+&%*=<>\u20ac\u00a3$\u00a5\u00a4\\\\[]{},.@\u00a7#\u00bf\u00a1\u263a\u263a\u263a_/\u25cb \u263a\u263a\u263a\u263a\u263a\u263a']\n    lenght, coord = [0 for _ in range(2)]\n    lst=list(kpad[0])\n    for i in words:\n        while kpad[0].find(i)==-1:\n            lenght,coord = calculate(lst,'\u25cb',lenght,coord)\n            kpad=kpad[-2:]+kpad[:-2]\n            lst=list(kpad[0])\n        lenght,coord = calculate(lst,i,lenght,coord)\n    return lenght\n\ndef calculate(lst, i, lenght, coord):\n    x=abs(lst.index(i)%8-coord%8)\n    y=abs(lst.index(i)//8-coord//8)\n    lenght += min(x,8-x)+min(y,6-y)+1\n    return [lenght,lst.index(i)]", "KEYPADS = (\n    (\n        'a', 'b', 'c', 'd', 'e', '1', '2', '3',\n        'f', 'g', 'h', 'i', 'j', '4', '5', '6',\n        'k', 'l', 'm', 'n', 'o', '7', '8', '9',\n        'p', 'q', 'r', 's', 't', '.', '@', '0',\n        'u', 'v', 'w', 'x', 'y', 'z', '_', '/',\n        'aA#', 'SP', ' ', ' ', ' ', ' ', ' ', ' ',\n    ),\n    (\n        'A', 'B', 'C', 'D', 'E', '1', '2', '3',\n        'F', 'G', 'H', 'I', 'J', '4', '5', '6',\n        'K', 'L', 'M', 'N', 'O', '7', '8', '9',\n        'P', 'Q', 'R', 'S', 'T', '.', '@', '0',\n        'U', 'V', 'W', 'X', 'Y', 'Z', '_', '/',\n        'aA#', 'SP', ' ', ' ', ' ', ' ', ' ', ' ',\n    ),\n    (\n        '^', '~', '?', '!', '\\'', '\"', '(', ')',\n        '-', ':', ';', '+', '&', '%', '*', '=',\n        '<', '>', '\u20ac', '\u00a3', '$', '\u00a5', '\u00a4', '\\\\',\n        '[', ']', '{', '}', ',', '.', '@', '\u00a7',\n        '#', '\u00bf', '\u00a1', ' ', ' ', ' ', '_', '/',\n        'aA#', 'SP', ' ', ' ', ' ', ' ', ' ', ' ',\n    )\n)\n\nclass Tv:\n    def __init__(self, words):\n        self.words = words\n        self.OK = 1\n        self.MAX_H = 7\n        self.MAX_V = 5\n        self.count = 0\n        self.keypad_pos = 0\n        self.current_pos = (0, 0)\n        self.CHANGE_KEY_IDX = 40\n        \n\n    def count_best_path(self, index: int):\n\n        # coordinates of the letter\n        temp_pos = ((index // 8), (index % 8))\n\n        result = []\n\n        # finding the smallest path movements\n        for current_val, temp_val, max_l in zip(self.current_pos, temp_pos, [self.MAX_V, self.MAX_H]):\n            v_1 = current_val\n            v_2 = current_val\n            count = 0\n\n            while v_1 != temp_val and v_2 != temp_val:\n                v_1 -= 1\n                v_2 += 1\n                if v_1 < 0:\n                    v_1 = max_l\n                if v_2 > max_l:\n                    v_2 = 0\n                count += 1\n\n            result.append(count)\n\n        # update the current position\n        self.current_pos = temp_pos\n\n        # update the count\n        self.count += sum(result) + self.OK\n\n\n    def count_total_moves(self):\n        for letter in self.words:\n\n            letter = 'SP' if letter == ' ' else letter\n            while letter not in KEYPADS[self.keypad_pos]:\n                self.count_best_path(self.CHANGE_KEY_IDX)\n                if self.keypad_pos < 2:\n                    self.keypad_pos += 1\n                else:\n                    self.keypad_pos = 0\n\n            index = KEYPADS[self.keypad_pos].index(letter)\n            self.count_best_path(index)\n        return self.count\n\ndef tv_remote(words):    \n    return Tv(words).count_total_moves()\n\nprint(tv_remote('ciao'))", "def tv_remote(words):\n    page1 = {'a':[0,0],'b':[0,1],'c':[0,2],'d':[0,3],'e':[0,4],'1':[0,5],'2':[0,6],'3':[0,7],\n             'f':[1,0],'g':[1,1],'h':[1,2],'i':[1,3],'j':[1,4],'4':[1,5],'5':[1,6],'6':[1,7],\n             'k':[2,0],'l':[2,1],'m':[2,2],'n':[2,3],'o':[2,4],'7':[2,5],'8':[2,6],'9':[2,7],\n             'p':[3,0],'q':[3,1],'r':[3,2],'s':[3,3],'t':[3,4],'.':[3,5],'@':[3,6],'0':[3,7],\n             'u':[4,0],'v':[4,1],'w':[4,2],'x':[4,3],'y':[4,4],'z':[4,5],'_':[4,6],'/':[4,7],\n             'aA#':[5,0],' ':[5,1]}\n    page2 = {'A':[0,0],'B':[0,1],'C':[0,2],'D':[0,3],'E':[0,4],'1':[0,5],'2':[0,6],'3':[0,7],\n             'F':[1,0],'G':[1,1],'H':[1,2],'I':[1,3],'J':[1,4],'4':[1,5],'5':[1,6],'6':[1,7],\n             'K':[2,0],'L':[2,1],'M':[2,2],'N':[2,3],'O':[2,4],'7':[2,5],'8':[2,6],'9':[2,7],\n             'P':[3,0],'Q':[3,1],'R':[3,2],'S':[3,3],'T':[3,4],'.':[3,5],'@':[3,6],'0':[3,7],\n             'U':[4,0],'V':[4,1],'W':[4,2],'X':[4,3],'Y':[4,4],'Z':[4,5],'_':[4,6],'/':[4,7],\n             'aA#':[5,0],' ':[5,1]}\n    page3 = {'^':[0,0],'~':[0,1],'?':[0,2],'!':[0,3],'\\'':[0,4],'\"':[0,5],'(':[0,6],')':[0,7],\n             '-':[1,0],':':[1,1],';':[1,2],'+':[1,3],'&':[1,4],'%':[1,5],'*':[1,6],'=':[1,7],\n             '<':[2,0],'>':[2,1],'\u20ac':[2,2],'\u00a3':[2,3],'$':[2,4],'\u00a5':[2,5],'\u00a4':[2,6],'\\\\':[2,7],\n             '[':[3,0],']':[3,1],'{':[3,2],'}':[3,3],',':[3,4],'.':[3,5],'@':[3,6],'\u00a7':[3,7],\n             '#':[4,0],'\u00bf':[4,1],'\u00a1':[4,2],'_':[4,6],'/':[4,7],\n             'aA#':[5,0],' ':[5,1]}\n\n    pages = {1:page1,2:page2,3:page3}\n\n    def move_to_page(position,current_page,target_page):\n        moves = shortest_distance(position,[5,0])\n        if current_page == 3:\n            if target_page == 1:\n                moves += 1\n            elif target_page == 2:\n                moves += 2\n        elif current_page == 2:\n            if target_page == 1:\n                moves += 2\n            elif target_page == 3:\n                moves += 1\n        else:\n            moves += target_page - current_page\n        return moves\n\n    def find_page(character):\n        for page in pages:\n            if character in pages[page]:\n                return int(page)\n\n    def shortest_distance(pos1,pos2):\n        moves = 0\n        delta_y = abs(pos2[0]-pos1[0])\n        delta_x = abs(pos2[1]-pos1[1])\n        return min(delta_x,8-delta_x)+min(delta_y,6-delta_y)\n\n    debug = False\n    sequence = list(words)\n    moves = 0\n    position = [0,0]\n    current_page = 1\n\n    for element in sequence:\n        if element not in pages[current_page]:\n            target_page = find_page(element)\n            moves += move_to_page(position,current_page,target_page)\n            position = [5,0]\n            current_page = target_page\n        target_position = pages[current_page][element]\n        moves += shortest_distance(position,target_position)\n        position = target_position\n        moves += 1\n    return moves", "def tv_remote(words: str):\n\n    class Mode:\n        LOWERCASE, UPPERCASE, SYMBOLIC = range(3)\n        mode = LOWERCASE\n\n        def islowercase(self):\n            return self.mode == self.LOWERCASE\n\n        def isuppercase(self):\n            return self.mode == self.UPPERCASE\n\n        def isalphanumeric(self):\n            return self.mode in [self.LOWERCASE, self.UPPERCASE]\n\n        def issymbolic(self):\n            return self.mode == self.SYMBOLIC\n\n        def switch_to_new_mode(self, other):\n            if isinstance(other, int):\n                button_presses = (other - self.mode) % 3\n                self.mode = other\n                return button_presses\n\n    def dist(pos1, pos2):\n        return sum(min(abs(p1-p2), dim - abs(p1-p2)) for p1, p2, dim in zip(pos1, pos2, kb_dims))\n\n    screen_keyboard_alphanumeric = \"abcde123fghij456klmno789pqrst.@0uvwxyz_/\u21d1 \"\n    symbols_map_alphanumeric = {c: (i // 8, i % 8) for i, c in enumerate(screen_keyboard_alphanumeric)}\n    kb_dims = (len(screen_keyboard_alphanumeric) // 8 + 1, 8)\n    screen_keyboard_symbolic = \"^~?!\\'\\\"()-:;+&%*=<>\u20ac\u00a3$\u00a5\u00a4\\[]{},.@\u00a7#\u00bf\u00a1\u03a6\u03a8\u03a9_/\u21d1 \"\n    symbols_map_symbolic = {c: (i // 8, i % 8) for i, c in enumerate(screen_keyboard_symbolic)}\n    common_symbols = \"\".join(set(screen_keyboard_alphanumeric) & set(screen_keyboard_symbolic))\n\n    button_presses = 0\n    cur_position, next_position = (0, 0), (0, 0)\n    mode = Mode()\n\n    words_to_type = []\n    for ch in words:\n        if ch in common_symbols:\n            words_to_type.append(ch.lower())\n\n        elif ch in screen_keyboard_symbolic:\n            words_to_type.append(\"\u21d1\"*mode.switch_to_new_mode(Mode.SYMBOLIC) + ch)\n\n        elif ch.lower() in screen_keyboard_alphanumeric:\n            if ch.isalpha():\n                if ch.islower():\n                    words_to_type.append(\"\u21d1\"*mode.switch_to_new_mode(mode.LOWERCASE) + ch.lower())\n                elif ch.isupper():\n                    words_to_type.append(\"\u21d1\"*mode.switch_to_new_mode(mode.UPPERCASE) + ch.lower())\n            elif not mode.isalphanumeric():\n                words_to_type.append(\"\u21d1\"*mode.switch_to_new_mode(mode.LOWERCASE) + ch)\n            else:\n                words_to_type.append(ch)        # mode.isalphanumeric() and not ch.isalpha()\n\n    words_to_type = \"\".join(words_to_type)\n\n    for ch in words_to_type:\n        if ch in screen_keyboard_alphanumeric:\n            next_position = symbols_map_alphanumeric[ch]\n            button_presses += 1 + dist(cur_position, next_position)\n            cur_position = next_position\n\n        elif ch in screen_keyboard_symbolic:\n            next_position = symbols_map_symbolic[ch]\n            button_presses += 1 + dist(cur_position, next_position)\n            cur_position = next_position\n\n        else:\n            return -1\n\n    return button_presses", "def dist(a, b, w=8, h=6):\n    ay, ax = divmod(a, w)\n    by, bx = divmod(b, w)\n    dx = min((ax - bx) % w, (bx - ax) % w)\n    dy = min((ay - by) % h, (by - ay) % h)\n    return dx + dy\n\ndef tv_remote(words):\n    num_buttons = 0\n\n    presses = []\n    mode = 0\n    keypads = [\n        'abcde123fghij456klmno789pqrst.@0uvwxyz_/\u21e7 \u2013\u2013\u2013\u2013\u2013\u2013',\n        'abcde123fghij456klmno789pqrst.@0uvwxyz_/\u21e7 \u2013\u2013\u2013\u2013\u2013\u2013'.upper(),\n        '^~?!\\'\"()-:;+&%*=<>\u20ac\u00a3$\u00a5\u00a4\\\\[]{},.@\u00a7#\u00bf\u00a1\u2013\u2013\u2013_/\u21e7 \u2013\u2013\u2013\u2013\u2013\u2013'\n    ]\n    for c in words:\n        while True:\n            if c in keypads[mode]:\n                presses.append(keypads[mode].index(c))\n                num_buttons += 1  # OK\n                break\n            mode = (mode + 1) % len(keypads)\n            presses.append(keypads[mode].index('\u21e7'))\n            num_buttons += 1  # OK shift\n\n    cursor = 0\n    for press in presses:\n        print(f'{num_buttons} button moves from {cursor} to {press}')\n        num_buttons += dist(cursor, press)\n        cursor = press\n    \n    return num_buttons", "from typing import Tuple\n\nKEYBOARDS = [\n    [\n        'abcde123',\n        'fghij456',\n        'klmno789',\n        'pqrst.@0',\n        'uvwxyz_/',\n    ],\n    [\n        'ABCDE123',\n        'FGHIJ456',\n        'KLMNO789',\n        'PQRST.@0',\n        'UVWXYZ_/',\n    ],\n    [\n        '^~?!\\'\\\"()',\n        '-:;+&%*=',\n        '<>\u20ac\u00a3$\u00a5\u00a4\\\\',\n        '[]{},.@\u00a7',\n        '#\u00bf\u00a1   _/',\n    ],\n]\n\nPosition = Tuple[int, int]\n\nSPACE = 5, 1\nSWITCH_MODE = 5, 0\n\n\ndef get_pos(mode: int, c: str) -> Position:\n    if c == ' ':\n        return SPACE\n\n    for i, chars in enumerate(KEYBOARDS[mode]):\n        if c in chars:\n            return i, chars.index(c)\n\n\ndef get_diff(a: Position, b: Position) -> int:\n    (x1, y1), (x2, y2) = a, b\n    x, y = abs(x1 - x2), abs(y1 - y2)\n    return min(x, 6 - x) + min(y, 8 - y)\n\n\ndef mode_switch(mode: int, c: str, pos: Position) -> Tuple[int, int, Position]:\n    if c == ' ' or c in ''.join(KEYBOARDS[mode]):\n        return mode, 0, pos\n\n    switches = get_diff(pos, SWITCH_MODE)\n    while c not in ''.join(KEYBOARDS[mode]):\n        switches += 1\n        mode = (mode + 1) % len(KEYBOARDS)\n\n    return mode, switches, SWITCH_MODE\n\n\ndef tv_remote(words: str):\n    total = mode = 0\n    pos = 0, 0\n    for w in words:\n        mode, switches, pos = mode_switch(mode, w, pos)\n        new_pos = get_pos(mode, w)\n        total += switches + get_diff(pos, new_pos) + 1\n        pos = new_pos\n\n    return total"]