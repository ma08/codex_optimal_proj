["def hanoiArray(n):\n    A, B, C = list(range(n, 0, -1)), [], []\n    res = [str([A, C, B])]\n    def rec(n, X, Y, Z):\n        if not n: return\n        rec(n-1, X, Z, Y)\n        Y.append(X.pop())\n        res.append(str([A, C, B]))\n        rec(n-1, Z, Y, X)        \n    rec(n, A, B, C)\n    return '\\n'.join(res)", "from io import StringIO\n\ndef move(n, a, b, c, source, target, auxiliary, output):\n    if n > 0:\n        move(n - 1, a, b, c, source, auxiliary, target, output)\n        target.append(source.pop())\n        print([a, b, c], file=output)\n        move(n - 1, a, b, c, auxiliary, target, source, output)\n\ndef hanoiArray(n):\n    a, b, c = list(range(n, 0, -1)), [], []\n    with StringIO() as output:\n        print([a, b, c], file=output)\n        move(n, a, b, c, a, c, b, output)\n        return output.getvalue().rstrip('\\n')", "m=lambda n,l,a,b,c:n and m(n-1,l,a,c,b)+[l[c].append(l[a].pop())or str(l)]+m(n-1,l,b,a,c)or[]\nhanoiArray=lambda n:(lambda l:str(l)+'\\n'+'\\n'.join(map(str,m(n,l,0,1,2))))([list(range(n,0,-1)),[],[]])", "def maketrans(n, a, b, c):\n  if n == 0: return []\n  return maketrans(n-1, a, c, b) + [[a, b]] + maketrans(n - 1, c, b, a)\n\n\ndef hanoiArray(n):\n    transitions = maketrans(n, 0, 2, 1)\n    state = [[i for i in range(n, 0, -1)], [], []]\n    res = str(state)\n    while transitions:\n        from_peg, to_peg = transitions.pop(0)\n        state[to_peg].append(state[from_peg].pop())\n        res += '\\n' + str(state)\n    return res", "def hanoiArray(n):\n\n  def move(n, source, target, auxiliary):\n      if n > 0:\n          # Move n - 1 disks from source to auxiliary, so they are out of the way\n          move(n - 1, source, auxiliary, target)\n\n          # Move the nth disk from source to target\n          target.append(source.pop())\n\n          # Store new state\n          res.append([A[:], B[:], C[:]])\n\n          # Move the n - 1 disks that we left on auxiliary onto target\n          move(n - 1, auxiliary, target, source)\n          \n  A = list(range(n, 0, -1))\n  B = []\n  C = []\n\n  res = [[A[:], B[:], C[:]]]\n\n  # Initiate call from source A to target C with auxiliary B\n  move(n, A, C, B)\n  return '\\n'.join(map(str, res))", "def hanoiArray(n):\n    initial = [x for x in range(n,0,-1)]\n    tow = [initial,[],[]]\n    ret = str(tow)\n    \n    def move(f,t):\n        nonlocal tow, ret\n        tow[t].append(tow[f].pop())\n        ret = ret + '\\n' + str(tow)\n        \n    def solve(n,f,h,t):\n        if n == 0:\n            pass\n        else:\n            solve(n-1,f,t,h)\n            move(f,t)\n            solve(n-1,h,f,t)\n    \n    solve(n,0,1,2)\n\n    return ret\n    \n", "def Hanoi_Solution(n):\n    # Establish base cases\n    if n == 0:\n        return([[],[],[]])\n    if n == 1:\n        return([[[1],[],[]],[[],[],[1]]])\n    # Setup recursion\n    else:\n        L = len(Hanoi_Solution(n-1))\n        # Move from [[n,..,1],[],[]] to [n,[n-1,...,1],[]] \n        first_half = Hanoi_Solution(n-1)    \n        for i in range(L):\n            # Insert the new number at the beginning in the previous solution\n            first_half[i][0].insert(0,n)\n            # Switch the last two positions in each move\n            temp_1 = first_half[i][2]\n            first_half[i][2] = first_half[i][1]\n            first_half[i][1] = temp_1\n        # Move from [[],[n-1,...,1],[n]] to [[],[],[n,...,1]]\n        second_half = Hanoi_Solution(n-1)\n        for i in range(L):\n            # Insert the new number at the end in the previous solution\n            second_half[i][2].insert(0,n)\n            # Switch the first two positions in each move\n            temp_2 = second_half[i][1]\n            second_half[i][1] = second_half[i][0]\n            second_half[i][0] = temp_2\n        # Join the two halves into a single solution of length 2**n\n        for i in second_half:\n            first_half.append(i)\n        return(first_half)\n\n# Print the solution in the string format suggested\ndef hanoiArray(n):\n    return((''.join(str(i)+'\\n' for i in Hanoi_Solution(n)))[:-1])", "def hanoi(n,a,b):\n    if n==1:\n        return [(a,b)]\n    else:\n        c=3-a-b\n        return hanoi(n-1,a,c)+[(a,b)]+hanoi(n-1,c,b)\n\n\ndef hanoiArray(n):\n    moves=hanoi(n,0,2)\n    towers=[list(range(n,0,-1)),[],[]]\n    ans=[str(towers)]\n    for i,j in moves:\n        towers[j].append(towers[i].pop())\n        ans.append(str(towers))\n    return '\\n'.join(ans)"]