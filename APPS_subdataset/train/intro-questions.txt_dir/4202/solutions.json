["from itertools import combinations\nfrom collections import defaultdict\n\ndef ulam_sequence(u0, u1, n):\n    seq = [u0, u1, u0 + u1]\n    \n    while len(seq) < n:\n        candidates = defaultdict(int)\n        \n        for a, b in combinations(seq, 2):\n            candidates[a + b] += 1\n        \n        for num, pairs in sorted(candidates.items()):\n            if num > seq[-1] and pairs == 1:\n                seq.append(num)\n                break\n    \n    return seq", "import collections\n\n\n\ndef ulam_sequence(u0, u1, n):\n    possible_sums={}\n    \n    sequence = [u0, u1]\n    \n    for _ in range(0,n-2):\n        for term in sequence[:-1]:\n            if term+sequence[-1] in possible_sums.keys():\n                possible_sums[term+sequence[-1]] += 1\n            else:\n                possible_sums[term+sequence[-1]] = 1\n        possible_sums = collections.OrderedDict(sorted(possible_sums.items()))\n        next_term = min([sum for sum in possible_sums.keys() if possible_sums[sum]==1 and sum not in sequence])\n        sequence.append(next_term)\n        \n    return sequence", "def ulam_sequence(u0, u1, n):\n    seq = [u0, u1]\n    for _ in range(n - 2):\n        sums = sorted([seq[i] + seq[j] for i in range(len(seq)) for j in range(i, len(seq)) if i != j])\n        seq.append(next(s for s in sums if sums.count(s) == 1 and s not in seq))\n    return seq", "from collections import Counter\nfrom itertools import combinations\n\ndef ulam_sequence(u0, u1, n):\n    seq = [u0, u1]\n    for i in range(n - 2):\n        c = Counter(a + b for a, b in combinations(seq, 2))\n        x = min(key for key in c if key > seq[-1] and c[key] == 1)\n        seq.append(x)\n    return seq", "import itertools\n\ndef ulam_sequence(u0, u1, n):\n    arr=[u0,u1]\n    temp=u0+u1\n    control=list(map(sum, list(itertools.combinations(arr,2))))\n    while(len(arr)!=n):\n        if(control.count(temp)==1):\n            arr.append(temp)\n            control=list(map(sum, list(itertools.combinations(arr,2))))\n        temp+=1\n    return arr", "from collections import Counter\n\ndef ulam_sequence(u0, u1, n):\n\n    seen, lst = {u0,u1}, [u0,u1]\n    while len(lst) < n:\n    \n        c = Counter(v+w for i,v in enumerate(lst) for w in lst[i+1:] if v+w not in seen)\n        cnd = min(filter(lambda kv: kv[1]==1, c.items()),\n                  key=lambda kv: kv[0])[0]\n                  \n        lst.append(cnd)\n        seen.add(cnd)\n        \n    return lst", "def ulam_sequence(u0, u1, n):\n    \"\"\"\n    Input\n    u0 = first number\n    u1 = second numberr\n    n  = number of elements in sequence\n    \n    Return\n    Ulam Sequence (u0, u1, u2...) with n-terms\n    \"\"\"\n    U = [u0, u1]\n    next_num = u1 + 1\n    while len(U) < n:\n        count = 0\n        index = 0\n        for number in U:\n            if next_num - number in U and number != next_num/2:\n                count += 1\n            if count >= 3:\n                break\n        if count < 3 and count > 0:\n            U.append(next_num)\n        next_num += 1\n    return U", "ulam_sequence=f=lambda u,v,n,l=set():v and(l.clear()or l.update({u,v}))or len(l)>=n and sorted(l)or l.add(next(y for y in range(max(l)+1,2*max(l))if sum(2*x<y and y-x in l for x in l)==1))or f(0,0,n,l)", "def isCandidate(x, seq):\n    count = 0\n    left_pointer = 0\n    right_pointer = len(seq) - 1\n    \n    while left_pointer < right_pointer:\n        left = seq[left_pointer]\n        right = seq[right_pointer]\n        \n        if left + right == x:\n            count += 1\n            if count == 2:\n                return False\n        \n        if left + right > x:\n            right_pointer -= 1\n            left_pointer = 0\n            continue\n            \n        left_pointer += 1\n        \n    return count == 1\n\ndef ulam_sequence(u0, u1, n):\n    seq = [u0, u1]\n    x = u0 + u1\n    while len(seq) < n:\n        if isCandidate(x, seq):\n            seq.append(x)        \n        x += 1\n    return seq", "def ulam_sequence(U,V,Q) :\n    R = [U,V]\n    S = [U + V]\n    while len(R) < Q :\n        while 1 < len(S) and S[-1] == S[-2] :\n            T = S.pop()\n            while T == S[-1] : S.pop()\n        T = S.pop()\n        S.extend(T + V for V in R)\n        R.append(T)\n        S.sort(reverse = True)\n    return R"]