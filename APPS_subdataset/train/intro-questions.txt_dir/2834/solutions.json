["def symmetric_point(p, q):\n    return [2*q[0] - p[0], 2*q[1] - p[1]]", "symmetric_point = lambda p, q: [2 * b - a for a, b in zip(p, q)]", "def symmetric_point(p, q):\n    # your code here\n    p1x = (q[0] - p[0]) + q[0]\n    p1y = (q[1] - p[1]) + q[1]\n    return [p1x, p1y]", "symmetric_point = lambda p,q: [2*q[0] - p[0], 2*q[1] - p[1]]", "def symmetric_point(p, q):\n    #this supposed to be a programing challenge not math\n    return [2*q[0]-p[0], 2*q[1]-p[1]]", "def symmetric_point(p, q):\n    # your code here\n    return [a*2-b for a,b in zip(q,p)]", "def symmetric_point(p, q):\n    return list(b * 2 - a for a, b in zip(p, q))", "def symmetric_point(p, q):\n    dx = q[0] - p[0]\n    dy = q[1] - p[1]\n    return [q[0]+dx, q[1]+dy]", "def symmetric_point(p, q):\n    # your code here\n    return [q[0] + q[0]-p[0], q[1] + q[1] - p[1]]", "def symmetric_point(p, q):\n    return [2 * q[i] - p[i] for i in range(2)]", "def symmetric_point(p, center):\n    px, py = p\n    cx, cy = center\n    return [cx - (px - cx), cy - (py - cy)]\n", "def symmetric_point(p, q):\n    return [2 * q[i] - p[i] for i in range(0,len(p))]", "def symmetric_point(p, q):\n    return [q[i]*2-p[i] for i in range(2)]", "from typing import List\n\ndef symmetric_point(p: List[int], q: List[int]) -> List[int]:\n    \"\"\" Get the symmetric point of point P about Q. \"\"\"\n    return [2 * q[0] - p[0], 2 * q[1] - p[1]]", "def symmetric_point(p, q):\n    result = [p[0],q[0]]\n    if(p[0] > q[0]):\n        result[0] = fromRightToLeft(p[0],q[0])\n    else:\n        result[0] = fromLeftToRight(p[0],q[0])\n    if(p[1] > q[1]):\n        result[1] = fromUpToDown(p[1],q[1])\n    else:\n        result[1] = fromDownToUp(p[1],q[1])\n    return result\ndef fromRightToLeft(p,q):\n    return q-abs(p-q)\ndef fromLeftToRight(p,q):\n    return q+abs(p-q)\ndef fromUpToDown(p,q):\n    return q-abs(p-q)\ndef fromDownToUp(p,q):\n    return q+abs(p-q)", "from operator import sub\ndef symmetric_point(p, q):\n    qp = list(map(sub, p, q))\n    return list(map(sub, q, qp))", "def symmetric_point(p, q):\n    return [b + (b - a) for a, b in zip(p, q)]", "def symmetric_point(p, q):\n    return list(map(lambda a, b: a + b, q, list(map(lambda a, b: b - a, p, q))))\n", "symmetric_point = lambda point, ref : [2 * ref[0] - point[0], 2 * ref[1] - point[1]]", "import numpy as np\ndef symmetric_point(p, q):\n    \n    d = list(np.add(q,np.subtract(q,p)))\n    \n    return d", "symmetric_point = lambda *a: [2 * q - p for p, q in zip(*a)]", "def symmetric_point(p, q):\n    p_1 = []\n    dx = p[0] - q[0]\n    dy = p[1] - q[1]\n    p_1.append(q[0] - dx)\n    p_1.append(q[1] - dy)\n    return p_1", "symmetric_point = lambda p, q: [2 * y -x for x, y in zip(p,q)]\n", "def symmetric_point(p, q):\n    return [2*q[0]-p[0], 2*q[1]-p[1]]\n    \n    \n    \n'''Given two points P and Q, output the symmetric point of point P about Q.\nEach argument is a two-element array of integers representing the point's X and Y coordinates.\nOutput should be in the same format, giving the X and Y coordinates of point P1.'''", "symmetric_point = lambda p, q: [r+r-s for s,r in zip(p, q)]", "def symmetric_point(p, q):\n    distance = q[0]-p[0], q[1]-p[1]\n    symetric = [q[0] + distance[0], q[1] + distance[1]]\n    return symetric", "def symmetric_point(p, q):\n    x1, y1 = p\n    x2, y2 = q\n    x3, y3 = (x2-x1)+x2, (y2-y1) +y2\n    return [x3,y3]", "def symmetric_point(p, q):\n    try:\n        (a,b),(c,d) = p,q\n        x = c-a+c\n        m = (d-b)/(c-a)\n        i = b-m*a\n        return [x,round(m*x+i)]\n    except:\n        return [0,0]", "def symmetric_point(p, q):\n    dist_x = p[0] - q[0]\n    dist_y = p[1] - q[1]\n    return [q[0]-dist_x, q[1]-dist_y]", "def symmetric_point(p, q):\n    distance_to_p_x = p[0] - q[0]\n    distance_to_p_y = p[1] - q[1]\n    \n    return [q[0] - distance_to_p_x, q[1] - distance_to_p_y]", "def symmetric_point(p, q):\n    # your code her\n    \n    return [2*q[0]-p[0],2*q[1]-p[1]]\n", "def symmetric_point(p, q):\n    return [p[0] * - 1 + q[0] * 2, p[1] * - 1 + q[1] * 2]", "def symmetric_point(p, q):\n    pointslist = []\n    difference = q[0] - p[0]\n    newpoint = q[0] + difference\n    difference2 = q[1] - p[1]\n    newpoint2 = q[1] + difference2\n    pointslist.append(newpoint)\n    pointslist.append(newpoint2)\n    return pointslist", "def symmetric_point(p, q):\n    x = [0,0]\n    \n    x[0] = 2 * q[0] - p[0]\n    x[1] = 2 * q[1] - p[1]\n    \n    return x", "def symmetric_point(p, q):\n    x = []\n    x.append(2 * q[0] - p[0])\n    x.append(2 * q[1] - p[1])\n    return x", "def symmetric_point(p, q):\n \n    difference = []\n\n\n    zip_object = zip(p, q)\n    for p, q in zip_object:\n        difference.append(2*q-p)\n   \n    \n    return(difference)", "def symmetric_point(p, q):\n    # q est\u00e1 siempre en medio\n\n    return [(2*q[0]) - p[0], (2*q[1]) - p[1] ]", "def symmetric_point(p, q):\n    x = q[0] - p[0]\n    x = q[0] + x\n    y = q[1] - p[1]\n    y = q[1] + y\n    return [x,y]\n", "def symmetric_point(p, q):\n    d1=q[0]-p[0]\n    d2=q[1]-p[1]\n    return [q[0]+d1, q[1]+d2]", "def symmetric_point(p, q):\n    \n    #Find the difference between midpoint Q and initial point P\n    #Add this difference to the midpoint to find end point P1\n    #Compatible with negative points\n    \n    p1x = q[0]+(q[0]-p[0])\n    p1y = q[1]+(q[1]-p[1])\n    return [p1x,p1y]", "def symmetric_point(p, q):\n    if q[0] > p[0]:\n        x = q[0] + abs(q[0] - p[0])\n    elif q[0] < p[0]:\n        x = q[0] - abs(p[0] - q[0])\n    else:\n        x = p[0]\n    if q[1] > p[1]:\n        y = q[1] + abs(q[1] - p[1])\n    elif q[1] < p[1]:\n        y = q[1] - abs(p[1] - q[1])\n    else:\n        y = p[1]   \n    return [x, y]", "def symmetric_point(p, q):\n    return [ 2*(-p[0]/2 + q[0]) , 2*(-p[1]/2 + q[1]) ]", "def symmetric_point(p, q):\n    new_point = [2*q[0] - p[0], 2*q[1] - p[1]]\n    return new_point", "def symmetric_point(p, q):\n\n    distance = []\n    for a, b in zip(p, q):\n        if a > 0 and b > 0:\n            distance.append(abs(a-b))\n        elif a < 0 and b < 0:\n            distance.append(abs(abs(a)-abs(b)))\n        else:\n            distance.append(abs(a)+abs(b))\n            \n    final_point = []\n    for i, c, d in zip([0, 1],q, distance):\n        if p[i] > 0 and q[i] > 0 or p[i] < 0 and q[i] < 0:\n             if abs(p[i]) < abs(q[i]):\n                 final_point.append(abs(c)+d)               \n             else:\n                 final_point.append(abs(c)-d)\n        else:\n           final_point.append(abs(c)+abs(d))\n            \n        \n    return [x * -1 if q[i] < 0 else x for i, x in enumerate(final_point)]\n", "def symmetric_point(p, q):\n    # your code here\n    r = [2*q[0]-p[0],2*q[1]-p[1]]\n    return r", "symmetric_point=lambda p,q:[-p[0]+2*q[0],-p[1]+2*q[1]]", "def symmetric_point(p, q):\n   return [2 * m - a for a, m in zip(p, q)]", "def symmetric_point(p, q):\n    a = q[0]-abs(p[0]-q[0]) if p[0] > q[0] else q[0]+(q[0]-p[0])\n    b = q[1]-abs(p[1]-q[1]) if p[1] > q[1] else q[1]+(q[1]-p[1])\n    return [a, b]", "def symmetric_point(p, q):\n    return [abs(p[i]-q[i]) + q[i] if p[i]<q[i] else q[i] - abs(p[i]-q[i]) for i in [0,1]]", "def symmetric_point(p, q):\n    # your code here\n    x = q[0] - p[0]\n    y = q[1] - p[1]\n    return [q[0]+x,q[1]+y]", "def symmetric_point(p, q):\n    # your code here\n    a = [0,0]\n    a[0] = q[0] - abs(p[0]-q[0]) if (p[0] > q[0]) else q[0] + abs(p[0]-q[0])\n    a[1] = q[1] - abs(p[1]-q[1]) if p[1] > q[1] else q[1] + abs(p[1]-q[1])    \n    return a", "def symmetric_point(p, q):\n    # your code here\n    q[0]+(q[0]-p[0])\n    return [q[0]+(q[0]-p[0]),q[1]+(q[1]-p[1])]", "def symmetric_point(p, q):\n    # your code here\n    [a,b] = p\n    [c,d] = q\n    p = c - a\n    q = d - b\n    return [c+p,d+q]", "def symmetric_point(p, q):\n    deltax = q[0]-p[0]\n    deltay = q[1]-p[1]\n    p1 = []\n    p1.append(q[0]+deltax)\n    p1.append(q[1]+deltay)\n    return p1", "def symmetric_point(p, q):\n    q[0] += q[0] - p[0]\n    q[1] += q[1] - p[1]\n    return q", "def symmetric_point(p, q):\n\n    return([2 * a - b for a, b in zip(q, p)])\n    \n    # Most elegant way :))\n", "def symmetric_point(p, q):\n\n    return([2 * q[x] - p[x] for x in range(len(q))])", "def symmetric_point(p, q):\n    xnew = q[0] + (q[0] - p[0])\n    ynew = q[1] + (q[1] - p[1])\n    return [xnew, ynew]", "import numpy as np\ndef symmetric_point(p, q):\n    npp = np.array(p)\n    npq = np.array(q)\n    return (npq - npp + npq).tolist()", "def symmetric_point(p, q):\n    xp, yp, xq, yq = p+q\n    xd, yd = abs(xp-xq), abs(yp-yq)\n    return [xq+(xd if xp<xq else -xd), yq+(yd if yp<yq else -yd)]", "def symmetric_point(p, q):\n    # your code here\n    return [(-1)*p[0]+2*q[0],(-1)*(p[1]+(-2)*q[1])]", "def symmetric_point(p, q):\n    # your code here\n    return [\n        q[0] + (q[0] - p[0]),   # x\n        q[1] + (q[1] - p[1]),   # y\n    ]", "def symmetric_point(p, q):\n    vertical_d = q[1] - p[1]\n    horiz_d = q[0] - p[0]\n    vertical_d = vertical_d * -1\n    horiz_d = horiz_d * -1\n    x = q[0] - horiz_d\n    y = q[1] - vertical_d\n    return [x,y]\n", "def symmetric_point(p, q):\n    px, py = p\n    qx, qy = q\n    xdist = px - qx\n    ydist = py - qy\n    return [qx - xdist, qy - ydist]", "def symmetric_point(p, q):\n    x1, y1 = p\n    p1, p2 = q\n\n    x2 = p1*2-x1\n    y2 = p2*2-y1\n    return [x2, y2]", "def symmetric_point(p, q):\n    x1, y1 = p\n    x2, y2 = q\n    return [x2 + x2 - x1, y2 + y2 - y1]", "def symmetric_point(p, q):\n    dx = q[0] - p[0]\n    dy = q[1] - p[1]\n    nx = dx + q[0]\n    ny = dy + q[1]\n    return [nx, ny]", "def symmetric_point(p, q):\n    # your code here\n    return [2*q[i]-p[i] for i in range(len(p))]", "def symmetric_point(p, q):\n    xpos = p[0] < q[0]\n    ypos = p[1] < q[1]\n    xdiff = max(p[0], q[0]) - min(p[0], q[0])\n    ydiff = max(p[1], q[1]) - min(p[1], q[1])\n    if xpos: x = q[0] + xdiff\n    if not xpos: x = q[0] - xdiff\n    if ypos: y = q[1] + ydiff\n    if not ypos: y = q[1] - ydiff\n    return [x, y]", "def symmetric_point(p, q):\n    # your code here\n    return [q[0]*2+p[0]*-1,(q[1]*2)+p[1]*-1]", "def symmetric_point(p, q):\n    arr = []\n    for i in zip(p, q):\n        x = i[1] - i[0]\n        arr.append(i[1] + x)\n    return arr    \n", "def symmetric_point(p, q):\n    c = int(q[0] + (q[0] - p[0]))   \n    d = int(q[1] + (q[1] - p[1]))\n    return [c, d]", "def symmetric_point(p, q):\n    # your code here\n\n    r1 = -(p[0] - q[0] - q[0])\n    r2 = -(p[1] - q[1] - q[1])\n        \n    return [r1, r2]", "def symmetric_point(p, q):\n    return [2 * x[1] - x[0] for x in zip (p, q)]", "def symmetric_point(p, q):\n    P1=[(2*q[0]- p[0]),(2*q[1]-p[1]) ]\n    return P1", "def symmetric_point(p, q):\n    a, b, c, d = p + q\n    return [c * 2 - a, d * 2 - b]", "def symmetric_point(p, q):\n    dist_x = q[0] - p[0]\n    dist_y = q[1] - p[1]\n    \n    p1_x = q[0] + dist_x\n    p2_x = q[1] + dist_y\n    \n    return [p1_x, p2_x]", "def symmetric_point(p, q):\n    x = p[0] - 2*q[0]\n    y = p[1] - 2*q[1]\n    return [-x,-y]    ", "def symmetric_point(p, q):\n    r = []\n    r.append(q[0] - p[0] + q[0])\n    r.append(q[1] - p[1] + q[1])\n    return r", "def symmetric_point(p, q):\n    return [2*q[0]-p[0],2*q[1]-p[1]]\n#Solved on 26th Sept,2019 at 07:07 PM.\n", "def symmetric_point(p, q):\n    if p[0]>q[0]:\n        x0=q[0]-(p[0]-q[0])\n        if p[1]>q[1]:\n            y0=q[1]-(p[1]-q[1])\n            return [x0,y0]\n        else:\n            y0=q[1]-(p[1]-q[1])\n            return [x0,y0]\n    else:\n        x0=q[0]-(p[0]-q[0])\n        if p[1]>q[1]:\n            y0=q[1]-(p[1]-q[1])\n            return [x0,y0]\n        else:\n            y0=q[1]-(p[1]-q[1])\n            return [x0,y0]", "def symmetric_point(a, b):\n    # your code here\n    return [2*b[0]-a[0],2*b[1]-a[1]]", "def symmetric_point(a,b):\n    return([(-a[0]+2*b[0]),(-a[1]+2*b[1])])", "def symmetric_point(p, q):\n    reflected_x = q[0] + (q[0] - p[0])\n\n    try:\n        slope = (q[1] - p[1]) / (q[0] - p[0])\n        b = p[1] - slope * p[0]\n\n        reflected_y = slope * reflected_x + b\n\n    except ZeroDivisionError:\n        reflected_y = p[1]\n\n    return [round(reflected_x), round(reflected_y)]\n", "def symmetric_point(p, q):\n    p2_x = p[0]+2*(q[0]-p[0])\n    p2_y = p[1]+2*(q[1]-p[1])\n    return [p2_x, p2_y]", "def symmetric_point(p, q):\n    a=q[0]-p[0]\n    b=q[1]-p[1]\n    c=a+q[0]\n    d=b+q[1]\n    return [c,d]  #I solved this Kata on  [1-Sept-2019] ^_^ [07:10 AM]...#Hussam'sCodingDiary", "def symmetric_point(p, q):return[2*q[i]-p[i]for i in(0,1)]", "def symmetric_point(p, q):return[q[i]+abs(p[i]-q[i])if p[i]<q[i]else q[i]-abs(p[i]-q[i])if p[i]>q[i]else q[i] for i in (0,1)]", "def symmetric_point(p, q):\n    y=2*q[1]-p[1]\n    x=2*q[0]-p[0]\n    return [x, y]", "import operator\ndef symmetric_point(p, q):\n    return [i*-1+j*2 for i,j in zip(p,q)]", "def symmetric_point(p, q):\n    x1=int(str(p).split(',')[0].split('[')[1])\n    y1=int(str(p).split(',')[1].split(']')[0])\n    x2=int(str(q).split(',')[0].split('[')[1])\n    y2=int(str(q).split(',')[1].split(']')[0])\n    \n    return [x2+(x2-x1), y2+(y2-y1)]", "def symmetric_point(p, q):\n    delta_x, delta_y = abs(q[0] - p[0]), abs(q[1] - p[1])\n    return [\n        q[0] + delta_x if p[0] < q[0] else q[0] - delta_x\n        , q[1] + delta_y if p[1] < q[1] else q[1] - delta_y\n    ]", "def symmetric_point(p, q):\n    return [(-p[0]+2*q[0]),(-p[1]+2*q[1])]", "def symmetric_point(p, q):\n\n# the following equality must be satisfied\n# q -p = q -p' \n\n  p_simx = q[0] -p[0]\n  p_simy = q[1] -p[1]\n\n  return [q[0] -(-p_simx), q[1] -(-p_simy)]\n", "def symmetric_point(p, q):\n    return [y+(y-x) for x, y in zip(p,q)]"]