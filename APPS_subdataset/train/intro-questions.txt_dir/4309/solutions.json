["from itertools import groupby\n\ndef replace(s):\n    queue, rle = {}, [[i, k, len(list(g))] for i, (k, g) in enumerate(groupby(s))]\n    for i, k, l in reversed(rle):\n        if l not in queue: queue[l] = {}\n        queue[l].setdefault(k, []).append(i)\n    for l in queue:\n        while sum(map(bool, queue[l].values())) > 1:\n            for c in queue[l]: rle[queue[l][c].pop()][1] = ' '\n    return ''.join(k * l for i, k, l in rle)", "import re\n\ndef replace(s):\n    dic = {'!': '?', '?': '!'}\n    r = re.findall(r'[!]+|[/?]+', s)\n    for i in r[:]:\n        ii =dic[i[0]] * len(i)\n        if  ii in r:\n            r[r.index(ii)] = ' ' * len(i)    \n    return ''.join(r)", "import itertools as it\nfrom collections import Counter, defaultdict\nfrom functools import reduce\n\ndef tokenize(s):\n    for key, group in it.groupby(s):\n        yield key, len(list(group))\n\ndef gather(tokens, expected_keys = None):\n    stats = defaultdict(Counter)\n    tokens = it.chain(tokens, ((key,0) for key in expected_keys or []))\n    for key, length in tokens:\n        stats[key][length] +=1\n    return stats\n\ndef intersect(*counters, ignored_keys=None):\n    mins = reduce(lambda a, b: a & b, counters)\n    for key in ignored_keys:\n        mins.pop(key, None)\n    return +mins\n    \ndef substitute(tokens, counters, replacement_key):\n    for key, length in tokens:\n        if counters[key][length]:\n            counters[key][length] -= 1\n            yield replacement_key, length\n        else:\n            yield key, length \ndef detokenize(tokens):\n    return ''.join(key * length for key, length in tokens)\n    \ndef replace(s):\n    tokens = list(tokenize(s))\n    stats = gather(tokenize(s), expected_keys='!?')\n    mins = intersect(*list(stats.values()), ignored_keys = [0])\n    replaced_counts = {key: mins.copy() for key in stats}\n    replaced_tokens = substitute(tokens, replaced_counts, ' ')\n    return detokenize(replaced_tokens)\n    \n", "from itertools import groupby\n\ndef replace(stg):\n    g = [\"\".join(s) for _, s in groupby(stg)]\n    l = len(g)\n    for i in range(l):\n        for j in range(i+1, l, 2):\n            if \" \" not in f\"{g[i]}{g[j]}\" and len(g[i]) == len(g[j]):\n                g[i] = g[j] = \" \" * len(g[i])\n    return \"\".join(g)", "from itertools import groupby\nfrom collections import defaultdict\n\ndef replace(s):\n    res, D = [], {'!':defaultdict(list), '?':defaultdict(list)}\n    for i, (k, l) in enumerate(groupby(s)):\n        s = len(list(l))\n        D[k][s].append(i)\n        res.append([k, s])\n    for v, L1 in D['!'].items():\n        L2 = D['?'][v]\n        while L1 and L2:\n            res[L1.pop(0)][0] = ' '\n            res[L2.pop(0)][0] = ' '\n    return ''.join(c*v for c,v in res)", "from itertools import groupby\nfrom collections import defaultdict\n\ntbl = str.maketrans('!?', '?!')\n\ndef replace(s):\n    xs = [''.join(grp) for _, grp in groupby(s)]\n    stacks = defaultdict(list)\n    result = []\n    for i, x in enumerate(xs):\n        stack = stacks[x]\n        if stack:\n            result[stack.pop(0)] = x = ' ' * len(x)\n        else:\n            stacks[x.translate(tbl)].append(i)\n        result.append(x)\n    return ''.join(result)", "from collections import defaultdict, deque\nimport re\n\ndef replace(s):\n    chunks = re.findall(r'!+|\\?+', s)\n    cnts   = defaultdict(deque)\n    for i,c in enumerate(chunks[:]):\n        other = '!?'[c[0]=='!'] * len(c)\n        if cnts[other]:\n            blank = ' '*len(c)\n            chunks[i] = chunks[cnts[other].popleft()] = blank\n        else:\n            cnts[c].append(i)\n    \n    return ''.join(chunks)", "from itertools import groupby\ndef replace(s):\n    g = [\"\".join(j) for i, j in groupby(s)]\n    for i, j in enumerate(g):\n        for k, l in enumerate(g[i+1:], start=i + 1):\n            if len(j) == len(l) and j[0] != l[0] and ' ' not in j+l:\n                g[i] = g[k] = \" \" * len(j) \n                break\n    return \"\".join(g)", "from collections import Counter\nfrom itertools import chain, groupby, repeat, starmap\n\nC2D = {'!': 1, '?': -1}\n\ndef replace(s):\n    gs = [(c, sum(1 for _ in g)) for c, g in groupby(s)]\n    ds = Counter()\n    for c, k in gs:\n        ds[k] += C2D[c]\n    for i in reversed(list(range(len(gs)))):\n        c, k = gs[i]\n        if ds[k] * C2D[c] > 0:\n            ds[k] -= C2D[c]\n        else:\n            gs[i] = ' ', k\n    return ''.join(chain.from_iterable(starmap(repeat, gs)))\n", "import itertools as it\nfrom collections import Counter, defaultdict\nfrom functools import reduce\n\ndef tokenize(string):\n    groups = it.groupby(string)\n    for key, group in groups:\n        yield key, len(list(group))\n        \ndef gather(tokens, expected_keys=None):\n    stats = defaultdict(Counter)\n    tokens = it.chain(tokens, ((key, 0) for key in expected_keys or []))\n    for key, length in tokens:\n        stats[key][length] += 1\n    return stats\n    \ndef intersect(*counters, ignored_keys=None):\n    mins = reduce(lambda a, b: a & b, counters)\n    for key in ignored_keys or []:\n        mins.pop(key, None)\n    return +mins\n    \ndef remove(tokens, counters, replacement_key):\n    for key, length in tokens:\n        if counters[key][length]:\n            counters[key][length] -= 1\n            yield replacement_key, length\n        else:\n            yield key, length\n            \ndef detokenize(tokens):\n    return ''.join(key * length for key, length in tokens)\n\ndef replace(s):\n    tokens = list(tokenize(s))\n    stats = gather(tokens, expected_keys='!?')\n    mins = intersect(*list(stats.values()), ignored_keys=[0])\n    replace_counts = {key: mins.copy()for key in stats}\n    replaced_tokens = remove(tokens, replace_counts, ' ')\n    return detokenize(replaced_tokens)\n    \n"]