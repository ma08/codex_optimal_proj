["class Solution:\n    def hasGroupsSizeX(self, deck: List[int]) -> bool:\n        def findGCD(a,b):\n            if b ==0:\n                return a\n            return findGCD(b, a%b)\n            \n        hash_cards = {}\n        for card in deck:\n            if card in hash_cards:\n                hash_cards[card]+=1\n            else:\n                hash_cards[card]=1\n        value_ = list(hash_cards.values())\n        res = value_[0]\n        for x in value_[1:]:\n            res = findGCD(res,x)\n        if res <2:\n            return False\n        return True\n        \n", "class Solution:\n    def gcd(a,b):\n      if(b%a==0):\n          return a \n      else:  \n        if(a%b==0):\n            return b\n        else:\n          if b>a:\n             return gcd(a,b-a)  \n          else:\n              return gcd(a-b,b)  \n    def hasGroupsSizeX(self, deck: List[int]) -> bool:\n        if(len(deck)==0 or len(deck)==1):\n            return False\n        d=list(set(deck))\n        if(len(d)==1 and len(deck)>=2):\n            return True\n        s=gcd(deck.count(d[0]),deck.count(d[1]))\n        if(s<2):\n            return False\n        for i in range(2,len(d)):\n            if(gcd(s,deck.count(d[i]))<2):\n                return False\n            s=gcd(s,deck.count(d[i]))\n            \n        return True    ", "def gcd (a,b):\n    if (b == 0):\n        return a\n    else:\n         return gcd (b, a % b)\n        \nclass Solution:\n    def hasGroupsSizeX(self, deck: List[int]) -> bool:\n        arr = {}\n        for i in range(len(deck)):\n            if deck[i] in arr:\n                arr[deck[i]] += 1\n            else:\n                arr[deck[i]] = 1\n        list1 = list(arr.values())\n        mi = list1[0]\n        for c in list1[1::]:\n            mi = gcd(mi , c)\n        if mi < 2:\n            return False\n        for i in list(arr.values()):\n            if i % mi != 0:\n                return False\n        return True\n", "class Solution:\n    def gcd(self,a,b):\n        if b == 0:\n            return a\n        else:\n            return gcd(b,a%b)\n    def hasGroupsSizeX(self, deck: List[int]) -> bool:\n\n        hashmap = {}\n        for i in range(len(deck)):\n            try:\n                hashmap[deck[i]] += 1\n            except:\n                hashmap[deck[i]] = 1\n        vals = set(list(hashmap.values()))\n        gcd_val = next(iter(vals))\n        \n        for i in vals:\n            gcd_val = gcd(gcd_val,i)\n            if gcd_val == 1:\n                return False\n        return True    ", "class Solution:\n    \n    def fill(self,A,B):\n        for i in range(len(A)):\n            B[A[i]] +=1\n        return list(filter(lambda a : a != 0,B))\n    \n    def mcd(self,arr):\n        MCD = min(arr)\n        for i in range (1,len(arr)):\n            MCD = math.gcd(MCD,arr[i])\n        return MCD\n            \n    def hasGroupsSizeX(self, deck: List[int]) -> bool:\n        if len(deck) < 2:\n            return False\n        deck.sort()\n        B = [0] * (max(deck) + len(deck))\n        B = self.fill(deck,B)\n        \n        for i in range(len(B)-1):\n            if B[i] == 1 :\n                return False\n            \n        MCD = self.mcd(B)\n        if MCD == 1:\n            return False\n        \n        return True", "class Solution:\n    def hasGroupsSizeX(self, deck: List[int]) -> bool:\n        hashMap = {}\n        boolean = False\n        lenght = len(deck)\n        if lenght < 2:\n            return False\n        \n        def commonFactor(a,b): \n            if(b==0): \n                return a \n            else: \n                return commonFactor(b,a%b) \n        \n        for i in range(lenght):\n            if hashMap.get(deck[i]) is not None:\n                hashMap[deck[i]] = hashMap[deck[i]] + 1\n            else:\n                hashMap[deck[i]] = 1\n                \n        for i in range(lenght):\n            if hashMap[deck[i]] == 1:\n                return False\n            elif i < lenght-1 and commonFactor(hashMap[deck[i]],hashMap[deck[i+1]]) > 1:\n                boolean = True\n            elif i == lenght-1 and commonFactor(hashMap[deck[i]],hashMap[deck[i-1]]) > 1:\n                boolean = True\n            else:\n                return False\n        return boolean", "class Solution:\n    def hasGroupsSizeX(self, deck):\n        count = collections.Counter(deck)\n        N = len(deck)\n        for X in range(2, N+1):\n            if N % X == 0:\n                if all(v % X == 0 for v in count.values()):\n                    return True\n        return False", "class Solution:\n    def commondenominator(self, a, b):\n        temp = b\n        while(temp > 1):\n            #print(\\\"temp:\\\", temp, \\\"a:\\\", a, \\\"b:\\\", b)\n            if a % temp == 0 and b % temp == 0:\n                return temp\n            temp -= 1\n        return -1    \n    def hasGroupsSizeX(self, deck: List[int]) -> bool:\n        if not deck or len(deck) < 2:\n            return False\n        d = dict()\n        for x in deck:\n            if x not in d:\n                d[x] = 1\n            else:\n                d[x] += 1\n        #print(\\\"d:\\\", d)\n        mini = float('inf')\n        ret = 1\n        for x in d: \n            if mini == float('inf'):\n                mini = d[x]\n                continue\n            if d[x] != mini:    \n                ret = self.commondenominator(d[x], mini)\n                #print(\\\"ret:\\\", ret)\n                if ret < 0:\n                    return False\n                else:\n                    mini = ret   \n        #print(\\\"mini:\\\", mini)            \n        return True    \n", "from functools import reduce\nclass Solution:\n    def hasGroupsSizeX(self, deck: List[int]) -> bool:\n        from fractions import gcd\n        vals = list(collections.Counter(deck).values())\n        return reduce(gcd, vals) >=2\n", "class Solution:\n    def hasGroupsSizeX(self, deck: List[int]) -> bool:\n        \n        N = len(deck)\n        \n        if N<=2:\n            if N==1:\n                return False\n            \n            if len(set(deck))==1:\n                return True\n            else:\n                return False\n            \n        cardCount = defaultdict(int)\n        \n        for card in deck:\n            cardCount[card]+=1\n        \n        gcd = list(cardCount.values())[0]\n        \n        for val in list(cardCount.values())[1:]:\n            gcd = math.gcd(gcd,val)\n        \n        return True if gcd>=2 else False\n        \n        \n        \n        \n        \n        \n            \n", "class Solution:\n    def hasGroupsSizeX(self, deck: List[int]) -> bool:\n        from collections import Counter\n        \n        cards = Counter(deck)\n        \n        min_cnt = min(cards.values())\n        \n        for i in range(2, min_cnt+1):\n            divided = [v%i for v in list(cards.values())]\n            if not any(divided):\n                return True\n        \n        return False\n            \n        \n        \n", "class Solution:\n    def hasGroupsSizeX(self, deck: List[int]) -> bool:\n        count = collections.Counter(deck)\n        N = len(deck)\n        for X in range(2, N+1):\n            if N % X == 0:\n                if all(v % X == 0 for v in list(count.values())):\n                    return True\n        return False\n        \n", "from collections import Counter\nclass Solution:\n    def hasGroupsSizeX(self, deck: List[int]) -> bool:\n        if(len(deck) < 2): return False \n        deck_count = Counter(deck)\n        v = set(deck_count.values())\n        min_v = min(v)\n        v_dict = dict()\n        all_factors = set()\n        for num in v :\n            for j in range(2, min_v + 1):\n                if(num % j == 0):\n                    if(num in v_dict): v_dict[num].add(j)\n                    else:\n                        v_dict[num] = set()\n                        v_dict[num].add(j)\n                    all_factors.add(j)\n        if(len(v_dict) != len(v)): return False\n        for i in list(v_dict.values()):\n            all_factors = all_factors.intersection(i)\n        if(len(all_factors) > 0):\n            return True\n        return False\n        \n", "class Solution:\n    def hasGroupsSizeX(self, deck):\n        def gcd(a, b):\n            while b: \n                a, b = b, a % b\n            return a\n        count = [*list(Counter(deck).values())]\n       # print(count)\n        g = count[0]\n        for i in range(len(count)):\n            g = gcd(g, count[i])\n            if g == 1:\n                return False\n        return True\n        \n        \n      #  return reduce(gcd, count) > 1\n", "class Solution:\n    def hasGroupsSizeX(self, deck: List[int]) -> bool:\n        deck1=list(set(deck))\n        len1=[]\n        for j in range(len(deck1)):\n            leny=len([number for number in deck if number ==deck1[j]])\n            len1.append(leny)\n        count=2\n        while(count<=len(deck)):\n            if len(deck)%count==0:\n                ty=len([number for number in len1 if number%count > 0])\n                if ty==0:\n                    return True\n                    break\n            count=count+1\n        return False\n\n", "def gcd (a,b):\n    if (b == 0):\n        return a\n    else:\n         return gcd (b, a % b)\n        \nclass Solution:\n    def hasGroupsSizeX(self, deck: List[int]) -> bool:\n        # arr = {}\n        # for i in range(len(deck)):\n        #     if deck[i] in arr:\n        #         arr[deck[i]] += 1\n        #     else:\n        #         arr[deck[i]] = 1\n        count = list(collections.Counter(deck).values())\n        list1 = list(count)\n        mi = list1[0]\n        for c in list1[1::]:\n            mi = gcd(mi , c)\n        if mi < 2:\n            return False\n        for i in count:\n            if i % mi != 0:\n                return False\n        return True\n", "class Solution:\n    def hasGroupsSizeX(self, deck: List[int]) -> bool:\n        \n        counter=collections.Counter(deck);\n        # check if X>=2\n        \n        for i in counter:\n            if(counter[i]<2):\n                return False\n        cur_gcd=0\n        for i in counter:\n            cur_gcd=gcd(cur_gcd, counter[i])\n        if cur_gcd==1:\n            return False\n        return True\n                \n", "class Solution:\n    def hasGroupsSizeX(self, deck: List[int]) -> bool:\n        \n        count = collections.Counter(deck)\n        \n        val = list(count.values())\n        gcd  =val[0]\n        \n        for i in val[1:]:\n            gcd = math.gcd(i, gcd)\n        \n        #print(gcd)\n        return gcd>=2", "class Solution:\n    def hasGroupsSizeX(self, deck):\n        count = Counter(deck)\n        N = len(deck)\n       # for X in range(2, N+1):\n       #     if N % X == 0:\n       #         if all(v % X == 0 for v in count.values()):\n       #             return True\n        g = lambda X: all(v % X == 0 for v in count.values())\n        f = lambda X: not N % X and g(X)\n        return any(map(f, range(2, N+1)))\n        return False", "class Solution:\n    def fun(m,k,c):\n        for i in k:\n            if len(i)==m:\n                g=len(i)//m\n                c+=g\n            elif len(i)%m==0:\n                c+=len(i)//m\n        return c       \n    def hasGroupsSizeX(self, deck: List[int]) -> bool:\n        deck.sort()\n        l=[]\n        k=[]\n        l.append(deck[0])\n        for i in range(1,len(deck)):\n            if l[-1]!=deck[i]:\n                k.append(l)\n                l=[]\n            l.append(deck[i])\n        k.append(l)\n        k.sort()\n        j=len(k[0])\n        if len(k[-1])==1:\n            return(bool(0))\n        for i in range(2,len(deck)+1):\n            c=0\n            c+=Solution.fun(i,k,c)\n            if len(deck)/i==c:\n                return(bool(1))\n        return(bool(0))       ", "def compute_gcd(a, b):\n    if(b == 0):\n        return a \n    else:\n        return compute_gcd(b, a % b)\n\nclass Solution:\n    def hasGroupsSizeX(self, deck: List[int]) -> bool:\n        max_size = int(1e4 + 1)\n        n = len(deck)\n        freq = [0 for _ in range(max_size)]\n        \n        for i in range(n):\n            freq[deck[i]] += 1\n        \n        gcd = freq[deck[0]]\n        \n        for i in range(max_size):\n            gcd = compute_gcd(gcd, freq[i])\n        \n        if gcd == 1: return False\n        \n        return True", "class Solution:\n    def hasGroupsSizeX(self, deck: List[int]) -> bool:\n        d = collections.Counter(deck)\n        parts = {}\n        #for num in deck: d[num] = d.get(num,0)+1\n        for key in d:\n            m = d[key]\n            if(m==1):return False\n            parts[m] = parts.get(m,0)+1\n            i = 2\n            while(m/i>=2):\n                if(m%i==0):parts[m//i] = parts.get(m//i,0)+1\n                i+=1\n        for key in parts:\n            if(parts[key]==len(d)):return True\n        return False\n", "class Solution:\n    def hasGroupsSizeX(self, deck: List[int]) -> bool:\n        from collections import Counter\n        from math import gcd\n        c=Counter(deck)\n        cur_g=0\n        for i in c.values():\n            cur_g=gcd(cur_g,i)\n        return cur_g>1", "class Solution:\n    def checkMultiple(self, num, maxLCM):\n        d = 2\n        while d <= maxLCM:\n            if num % d == 0:\n                return True\n            d += 1\n        return False\n    \n    def hasGroupsSizeX(self, deck: List[int]) -> bool:\n        intCnt = {}\n        for num in deck:\n            if num not in intCnt:\n                intCnt[num] = 0\n            intCnt[num] += 1\n        i = 1\n        n = len(intCnt)\n        cnts = list(intCnt.values())\n        cnts.sort()\n        leastDiff = None\n        leastCnt = cnts[0]\n        while i < n:\n            curDiff = cnts[i] - cnts[i-1]\n            if leastDiff == None or curDiff < leastDiff:\n                leastDiff = curDiff\n            if cnts[i] < leastCnt:\n                leastCnt = cnts[i]\n            i += 1\n        if leastDiff == 0 or leastDiff == None:\n            leastDiff = leastCnt\n        for num in intCnt:\n            if intCnt[num] < 2 or leastDiff <= 1 or not self.checkMultiple(intCnt[num], leastDiff):\n                return False\n        return True", "class Solution:\n    def hasGroupsSizeX(self, deck: List[int]) -> bool:\n        num = dict()\n        for i in range(len(deck)):\n            if not deck[i] in list(num.keys()):\n                num[deck[i]]=1\n            else:\n                num[deck[i]]+=1\n        \n        minv = 10005\n        for key,value in list(num.items()):\n            if value < minv:\n                minv = value\n                \n        if minv<2:\n            return False\n        \n        possible_share=[]\n        for i in range(2, minv+1): ## !!! max i is minv\n            if minv % i ==0:\n                possible_share.append(i)\n                \n        for i in possible_share:\n            Flag = True\n            for key,value in list(num.items()):\n                if value % i !=0:\n                    Flag = False\n                    break\n            if Flag:\n                return True\n            \n        return False\n", "class Solution:\n    def hasGroupsSizeX(self, deck: List[int]) -> bool:\n        seen = {}\n        for card in deck:\n            if card in seen:\n                seen[card] += 1\n            else:\n                seen[card] = 1\n        \n        for i in range(2, len(deck)+1):\n            if self.helper(seen, i):\n                return True\n\n        return False\n    \n    def helper(self, seen, val):\n        for key,item in list(seen.items()):\n            if item % val != 0:\n                return False\n        return True\n", "class Solution:\n    def hasGroupsSizeX(self, deck: List[int]) -> bool:\n        \n        if len(deck) <= 1:\n            return False\n        \n        dict1 = {}\n        \n        for ele in deck:\n            if ele in dict1:\n                dict1[ele] += 1\n            else:\n                dict1[ele] = 1\n                \n        for i in range(2,len(deck)+1):\n            if all(v%i==0 for v in list(dict1.values())):\n                return True\n            \n        return False\n                    \n", "import collections\n\nclass Solution:\n    def hasGroupsSizeX(self, deck: List[int]) -> bool:\n        \n        if len(deck) <= 1:\n            return False\n        \n        dict1 = collections.Counter(deck)\n        \n        for i in range(2,len(deck)+1):\n            if all(v%i==0 for v in list(dict1.values())):\n                return True\n            \n        return False\n                    \n"]