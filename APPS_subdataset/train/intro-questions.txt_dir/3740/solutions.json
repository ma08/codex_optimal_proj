["def sort_time(arr):\n    arr, s = sorted(arr, key=lambda t: t[0]), []\n    while arr:\n        nextTP = next((i for i,t in enumerate(arr) if not s or t[0] >= s[-1][1]), 0)\n        s.append(arr.pop(nextTP))\n    return s", "def sort_time(arr):\n    arr = sorted(arr, key = lambda x: x[0])\n    out = [[\"\", \"00:00\"]]\n    \n    while arr:\n        i = next((i for i,t in enumerate(arr) if t[0] >= out[-1][1]), None)\n        out.append(arr.pop(i if i else 0))\n\n    return out[1:]", "def sort_time(arr):\n    arr, prv, result = sorted(arr, key=lambda p: p[0]), \"00:00\", []\n    while arr:\n        nxt = next((p for p in arr if p[0] >= prv), arr[0])\n        result.append(nxt)\n        arr.remove(nxt)\n        prv = nxt[1]\n    return result\n\n\n\n\n# more compact but less readable:\n#    while arr:\n#        result.append(arr.pop(next((i for i, p in enumerate(arr) if p[0] >= prv), 0)))\n#        prv = result[-1][1]\n", "\nmins=lambda time: (lambda res: int(res[0])*60+int(res[1]))(time.split(\":\")); dt=lambda a,b: (lambda diff: 1440+diff if diff<0 else diff)(mins(a)-mins(b)); sort_time=lambda arr,last=\"00:00\": [arr[0]] if len(arr)==1 else (lambda arr: [arr[0]]+sort_time(arr[1:],arr[0][1]))(sorted(arr,key=lambda a: dt(a[0],last)))", "from operator import itemgetter\n\ndef sort_time(arr):\n    L = sorted(arr, key=itemgetter(0))\n    result = [L.pop(0)]\n    while L:\n        result.append(L.pop(next((i for i in range(len(L)) if L[i][0] >= result[-1][1]), 0)))\n    return result", "from datetime import datetime, timedelta\n\n\ndef delta(*span):\n    start, end = [datetime.strptime(s, '%H:%M') for s in span]\n    return (end + timedelta(days=1) if start > end else end) - start\n\ndef sort_time(arr):\n    prev = '00:00'\n    xs = list(arr)\n    result = []\n    while xs:\n        i = min(enumerate(xs), key=lambda x: delta(prev, x[1][0]))[0]\n        a, prev = xs.pop(i)\n        result.append([a, prev])\n    return result", "from datetime import datetime, timedelta\n\ndef _parse(s):\n    return \n\ndef delta(*span):\n    start, end = [datetime.strptime(s, '%H:%M') for s in span]\n    return (end + timedelta(days=1) if start > end else end) - start\n\ndef sort_time(arr):\n    prev = '00:00'\n    xs = list(arr)\n    result = []\n    while xs:\n        i = min(enumerate(xs), key=lambda x: delta(prev, x[1][0]))[0]\n        [a, prev] = xs.pop(i)\n        result.append([a, prev])\n    return result", "def sort_time(arr):\n    if len(arr) == 0:\n        return []\n    r_max = '23:59'\n    r_min = '00:00'\n    rr = arr[:]\n    ret = []\n    k = 0\n    for i in range(len(arr)):\n        for j in range(len(rr)):\n            if r_min <= rr[j][0] < r_max:\n                r_max = rr[j][0]\n                k = j\n                if r_max == r_min:\n                    break\n        ret.append(rr[k])        \n        r_min = rr[k][1]\n        r_max = '23:59'\n        rr.pop(k)\n        k == 0\n        if rr and max(rr)[0] < r_min:\n            r_min = min(rr)[0]\n    return ret", "def sort_time(arr):\n    s=sorted(arr,key=lambda x:(x[0],arr.index(x)))\n    r=[s.pop(0)]\n    while(s):\n        if r[-1][1]>s[-1][0]:\n            r.append(s.pop(0))\n            continue\n        for i in range(len(s)):\n            if r[-1][1]<=s[i][0]:\n                r.append(s.pop(i))\n                break\n    return r", "def sort_time(arr):\n    #def to_minutes(t):\n    #    hh,mm = t.split(':')\n    #    return int(hh)*60+int(mm)\n    arr = arr[:]\n    result = []\n    next = min(arr)\n    while True:\n        result.append(next)\n        arr.remove(next)\n        if not arr:\n            break\n        next = None\n        for t in arr:\n            if result[-1][1]<=t[0]:\n                if next is None or next[0]>t[0]:\n                    next = t\n        if next is None:\n            next = min(arr)\n            \n                \n    return result\n"]