["from heapq import *\n\ndef lemming_battle(battlefield, green, blue):\n    hg, hb = ([-v for v in lst] for lst in (green,blue))\n    heapify(hg) ; heapify(hb)\n    \n    while hb and hg:\n        tmp_b,tmp_g = [],[]\n        for _ in range(min(battlefield,len(hg),len(hb))):\n            cmp = heappop(hg) - heappop(hb)\n            if   cmp<0: tmp_g.append(cmp)\n            elif cmp>0: tmp_b.append(-cmp)\n        for lem in tmp_b: heappush(hb,lem)\n        for lem in tmp_g: heappush(hg,lem)\n        \n    winner,lst = (\"Green\", hg) if hg else (\"Blue\", hb)\n    survivors  = ' '.join(str(-v) for v in sorted(lst))\n    \n    return ( \"Green and Blue died\" if not hg and not hb else\n             f\"{winner} wins: {survivors}\" )", "def lemming_battle(battlefield, green, blue):\n    battlefield = min(battlefield, len(green), len(blue))\n    while sum(green) and sum(blue):\n        green, blue = sorted(green, reverse=True), sorted(blue, reverse=True)\n        for i in range(battlefield):\n            green[i], blue[i] = max(0, green[i] - blue[i]), max(0, blue[i] - green[i])\n    if not sum(green) + sum(blue):\n        return \"Green and Blue died\"\n    winner = \"green\" if sum(green) else \"blue\"\n    survivors = \" \".join(str(lemming) for lemming in sorted(locals()[winner], reverse=True) if lemming)\n    return f\"{winner.title()} wins: {survivors}\"", "def lemming_battle(battlefield, green, blue):\n    while True:\n        green, blue = sorted(green, reverse=True), sorted(blue, reverse=True)\n        if not (green or blue): return \"Green and Blue died\"\n        if not green: return \"Blue wins: \" + ' '.join(map(str, blue))\n        if not blue: return \"Green wins: \" + ' '.join(map(str, green))\n        left = min(len(green), len(blue), battlefield)\n        fight = list(map(int.__sub__, green[:left], blue[:left]))\n        green = green[left:] + [x for x in fight if x > 0]\n        blue = blue[left:] + [-x for x in fight if x < 0]", "def fight(green, blue):\n    xs = [(max(g-b, 0), max(b-g, 0)) for g, b in zip(green, blue)]\n    return ([x for x in ys if x] for ys in zip(*xs))\n    \ndef lemming_battle(battlefield, green, blue):\n    while green and blue:\n        green = sorted(green, reverse=True)\n        blue = sorted(blue, reverse=True)\n        n = min(battlefield, len(green), len(blue))\n        green[:n], blue[:n] = fight(green[:n], blue[:n])\n    soldiers = green or blue\n    if soldiers:\n        return '{} wins: {}'.format('Green' if green else 'Blue', ' '.join(map(str, sorted(soldiers, reverse=True))))\n    return 'Green and Blue died'", "def text(green, blue):\n    if green: \n       return \"Green wins: {0}\".format(' '.join(str(x) for x in green))\n    elif blue:\n        return \"Blue wins: {0}\".format(' '.join(str(x) for x in blue))\n    return 'Green and Blue died'\n\n\ndef lemming_battle(battlefield, green, blue):\n    green, blue = sorted(green, reverse=True), sorted(blue, reverse=True)\n    if not green or not blue:\n        return text(green, blue)\n    for i in range(battlefield):\n        try:\n            res = green[i] - blue[i]\n            if res == 0:\n                blue[i] = False\n                green[i] = False\n            elif res > 0:\n                green[i] = res\n                blue[i] = False\n            else:\n                blue[i] = abs(res)\n                green[i] = False\n        except IndexError:\n            break\n    return lemming_battle(battlefield, [x for x in green if x], [x for x in blue if x])\n        \n", "def lemming_battle(N, G, B):\n    while G and B:\n        G.sort()\n        B.sort()\n        current = []\n        for i in range(min(N, len(G), len(B))):\n            current.append(G.pop() - B.pop())\n        while current:\n            x = current.pop()\n            if x: (G if x > 0 else B).append(abs(x))\n    if (not (G or B)): return \"Green and Blue died\"\n    return \"{} wins: {}\".format(\"Green\" if G else \"Blue\", \" \".join(str(x) for x in sorted(G + B, reverse=True)))", "def lemming_battle(k, a, b):\n    a.sort(reverse=True)\n    b.sort(reverse=True)\n    while a and b:\n        for i, j in zip(a[:k], b[:k]):\n            temp = max(i, j)\n            a.remove(i) ; b.remove(j)\n            if i == j : continue\n            if temp == i : a.append(i - j)\n            elif temp == j : b.append(j - i)\n        a.sort(reverse=True) ; b.sort(reverse=True)\n    return [[f\"Green wins: {' '.join(map(str, a))}\", f\"Blue wins: {' '.join(map(str, b))}\"][len(b)>0],\"Green and Blue died\"][len(a)==len(b)]", "import sys\n\nsys.setrecursionlimit(15000)\n\ndef lemming_battle(battlefield, green, blue):\n    green, blue     = [p[::-1] for p in map(sorted, (green, blue))]\n    k               = min(battlefield, len(min(green, blue, key=len)))\n    g, b            = green[:k], blue[:k]\n    a_green, a_blue = [], []\n\n    for a, b in zip(g, b):\n        if abs(a) - abs(b):\n            if a > b:  a_green.append(a - b)\n            else:      a_blue.append(b - a)\n\n    green, blue = sorted(a_green + green[k:], reverse=True), sorted(a_blue + blue[k:], reverse=True)\n\n    if not green + blue: return \"Green and Blue died\"\n    if not blue:         return f\"Green wins: {' '.join(map(str, sorted(green, reverse=1)))}\"\n    if not green:        return f\"Blue wins: {' '.join(map(str, sorted(blue, reverse=1)))}\"\n    else:                return lemming_battle(battlefield, green, blue)\n", "def fight(fields, green, blue):\n    green, blue = sorted(green, reverse=True), sorted(blue, reverse=True)\n    for i in range(min(len(green), len(blue), fields)):\n        soldier_g, soldier_b = green[i], blue[i]\n        if soldier_g > soldier_b:\n            green[i], blue[i] = soldier_g - soldier_b, 0\n        elif soldier_g < soldier_b:\n            green[i], blue[i] = 0, soldier_b - soldier_g\n        else:\n            green[i], blue[i] = 0, 0\n    green, blue = [s for s in green if s > 0], [s for s in blue if s > 0]\n    return green, blue\n                   \n\n\ndef lemming_battle(battlefields, green, blue):\n    while green != [] and blue != []:\n        green, blue = fight(battlefields, green, blue)\n    green, blue = sorted(green, reverse=True), sorted(blue, reverse=True)\n    if green or blue: \n            return ((\"Green\" if green else \"Blue\") + \" wins: \" +\n                \" \".join(str(s) for s in green or blue))\n    return \"Green and Blue died\"", "import heapq\ndef lemming_battle(n, g, b):\n    g = [i*(-1) for i in g]\n    b = [i*(-1) for i in b]\n    heapq.heapify(g)\n    heapq.heapify(b)\n    while g and b:\n        t1, t2 = [], []\n        for _ in range(n):\n            if len(g) == 0 or len(b) == 0:\n                break\n            x = heapq.heappop(g)*(-1)\n            y = heapq.heappop(b)*(-1)\n            if x > y:\n                t1.append(x-y)\n            elif x < y:\n                t2.append(y-x)\n        for i in t1:\n            heapq.heappush(g, (-1)*i)\n        for i in t2:\n            heapq.heappush(b, (-1)*i)\n    if len(g)==0 and len(b)==0:\n        return \"Green and Blue died\"\n    if len(g) == 0:\n        x =' '.join(map(str, map(lambda x: x*(-1), sorted(b))))\n        return 'Blue wins: {}'.format(x)\n    else:\n        x =' '.join(map(str, map(lambda x: x*(-1), sorted(g))))\n        return 'Green wins: {}'.format(x)"]