["def palindrome(num):\n    if not isinstance(num, int) or num < 0:\n        return 'Not valid'\n    s = str(num)\n    return sum(sum(s[i:i+n] == s[i:i+n][::-1] for i in range(len(s)-n+1)) for n in range(2, len(s)+1))\n", "def palindrome(num):\n        \n    if not isinstance(num, int) or num < 0:\n        return \"Not valid\"\n    \n    c, s = 0, '?'+str(num)+'!'\n    for i in range(len(s)-2):\n        if s[i] == s[i+1]:\n            if s[i-1] == s[i+2]: c += 2\n            else: c += 1\n        \n        if s[i] == s[i+2]: c += 1\n        \n    return c", "pal = lambda s: all(a==b for a, b in zip(s[:len(s)//2], s[::-1]))\n\ndef palindrome(num):\n    if type(123)!=type(num) : return 'Not valid' \n    n = str(num)\n    if any(not c.isdigit() for c in n): return 'Not valid'\n    c, l = 0, len(n)\n    for i in range(2, l+1):\n        for j in range(l-i+1):\n            c += pal(n[j:j+i])\n    return c", "from itertools import combinations_with_replacement as combs\n\ndef palindrome(num):\n    is_palindrome = lambda chunk: chunk == chunk[::-1] and len(chunk) > 1\n    s, l = str(num), len(str(num))\n    return len([s[i:j] for i,j in combs(range(l+1), 2) if is_palindrome(s[i:j])]) if isinstance(num, int) and num > 0 else 'Not valid'", "def palindrome(num):\n    if not isinstance(num, int) or num < 0:\n        return \"Not valid\"\n    s = str(num)\n    l = len(s)\n    return sum(1 for p in (s[i:i+1+j] for j in range(1, l) for i in range(l-j)) if p == p[::-1])", "def palindrome(num):\n    cnt = 0\n    if type(num) != int or num < 0:\n        return \"Not valid\" \n    s = str(num)\n    for i in range(len(s) - 1):\n        for j in range(i + 1, len(s)):\n            if s[i : j + 1] == s[i : j + 1][::-1]:\n                cnt += 1\n    return cnt", "def palindrome(num):\n    if type(num) != int or num < 0: return \"Not valid\"\n    s = str(num)\n    count, ls = 0, len(s)\n    for i in range(ls-2):\n        for d in [1,2]:\n            if s[i] == s[i+d]:\n                offset = 1\n                while 0 <= i-offset and i+d+offset < ls and s[i-offset] == s[i+d+offset]:\n                    offset += 1\n                count += offset\n    return count + (ls != 1 and s[-1] == s[-2])", "def palindrome(num):\n    if type(num) is not int or num < 0:\n        return \"Not valid\"\n    if num < 10:\n        return 0\n    \n    counter = 0\n    num = str(num)\n    for i in range(0,len(num)-1):\n        for r in range(i + 2, len(num)+1):\n            if num[i:r] == num[i:r][::-1]:\n                counter += 1    \n    return counter", "def palindrome(n):\n    if not isinstance(n, int) or n < 0:\n        return \"Not valid\"\n    s = str(n)\n    return sum(s[i:j] == s[i:j][::-1]\n               for i in range(len(s) - 1)\n               for j in range(i + 2, len(s) + 1))", "def palindrome(num):\n    return \"Not valid\" if not isinstance(num, int) or num < 0 else 0 if num < 10 else len([c for i, c in enumerate(str(num)[:-1]) if str(num)[i+1] == c or len(str(num)) - i > 3 and str(num)[i+3] == c or len(str(num)) - i > 2 and str(num)[i+2] == c])"]