["import re\nfrom itertools import accumulate\n\n\npatterns = [\n    (re.compile('.*'.join('bug'), flags=re.I), 'Roma'),\n    (re.compile('.*'.join('boom'), flags=re.I), 'Maxim'),\n    (re.compile('.*'.join('edits'), flags=re.I), 'Danik'),\n]\n\ndef memesorting(meme):\n    return next((who for m in accumulate(meme) for pattern, who in patterns if pattern.search(m)), 'Vlad')", "def memesorting(meme):\n    typ  = ('Roma', 'Maxim', 'Danik')\n    what = ('bug',  'boom',  'edits')\n    \n    bug_boom_edits = [list(l[::-1]) for l in what]\n    for c in meme.lower():\n        for i,l in enumerate(bug_boom_edits):\n            if l[-1] == c: l.pop()\n            if not l:\n                return typ[i]\n    else:\n        return 'Vlad'", "import re\n\ndef memesorting(s):\n    f = lambda w: re.search(r\"{}\".format(\".*?\".join(w)), s, re.IGNORECASE)\n    a = [[m.span()[1], i] for i, m in enumerate(f(x) for x in [\"bug\", \"boom\", \"edits\"]) if m]\n    return [\"Roma\", \"Maxim\", \"Danik\"][min(a)[1]] if a else \"Vlad\"", "def memesorting(meme):\n    keys = { 'bug':'', 'boom':'', 'edits':''}\n    for i, l in enumerate(meme.lower()):\n        for key, value in { 'bug':'Roma', 'boom':'Maxim', 'edits':'Danik' }.items():\n            if l == key[len(keys[key])]:\n                keys[key] += l\n                if keys[key] == key:\n                    return value\n    return 'Vlad' ", "def memesorting(s):\n    order_p,p,ini_p,order_c,c,int_c, order_d,d,int_d = {0: 'b', 1: 'u', 2: 'g'},\"\",0,{0: 'b', 1: 'o', 2: 'o', 3: 'm'},\"\",0,{0: 'e', 1: 'd', 2: 'i', 3: 't', 4: 's'},\"\",0\n    for i in s.lower():\n        if i == order_p[ini_p] : p += i ; ini_p += 1\n        if i == order_c[int_c] : c += i ; int_c += 1\n        if i == order_d[int_d] : d += i ; int_d += 1\n        for k in range(3):\n            if [\"bug\", \"boom\", \"edits\"][k] == [p, c, d][k] : return [\"Roma\", \"Maxim\", \"Danik\"][k]\n    return \"Vlad\"", "def memesorting(meme):\n    bug = 'bug'\n    boom = 'boom'\n    edits = 'edits'\n    for i in meme.lower():\n        if i == bug[0]:\n            bug = bug[1:]\n            if len(bug) == 0:\n                return \"Roma\"\n        if i == boom[0]:\n            boom = boom[1:]\n            if len(boom)== 0:\n                return \"Maxim\"\n        if i == edits[0]:\n            edits = edits[1:]\n            if len(edits)== 0:\n                return \"Danik\"\n    return 'Vlad'", "def memesorting(meme):\n    bug, boom ,edits = ['b', 'u', 'g'], ['b', 'o', 'o', 'm'], ['e', 'd', 'i', 't', 's']\n    for ch in meme.lower():\n        if ch == bug[0]:\n            bug.pop(0)\n            if not bug: return 'Roma'\n        if ch == boom[0]:\n            boom.pop(0)\n            if not boom: return 'Maxim'\n        if ch == edits[0]:\n            edits.pop(0)\n            if not edits: return 'Danik'    \n    return 'Vlad'", "def memesorting(meme):\n    print(meme)\n    targets = [\n        ['bug',0,'Roma'],\n        ['boom',0,'Maxim'],\n        ['edits',0,'Danik']]\n    for char in meme:\n        for target in targets:\n            if char.lower() == target[0][target[1]]:\n                target[1] += 1\n                if target[1] == len(target[0]):\n                    return target[2]\n    return 'Vlad'", "import re\nPATTERNS = (('Roma', '.*?'.join(\"bug\")),\n            ('Maxim', '.*?'.join(\"boom\")),\n            ('Danik', '.*?'.join(\"edits\")))\n        \ndef memesorting(meme):\n    result = (float('inf'), \"Vlad\")\n    for name, p in PATTERNS:\n        res = re.search(p, meme, re.IGNORECASE)\n        if res: result = min(result, (res.span()[1], name))\n    return result[1]", "import regex as re\ndef memesorting(meme):\n    meme = meme.lower()\n    print(meme)\n    check = []\n    bug = re.search(r'b.*?u.*?g', meme)\n    if bug is not None:\n        check.append(bug)\n    boom = re.search(r'b.*?o.*?o.*?m', meme)\n    if boom is not None:\n        check.append(boom)\n    edits = re.search(r'e.*?d.*?i.*?t.*?s', meme)\n    if edits is not None:\n        check.append(edits)\n    if check != []:\n        first = min(check, key=lambda match: match.span()[1])\n    else:\n        return 'Vlad'\n        \n    if first.group()[-1] == 'g': return 'Roma'\n    if first.group()[-1] == 's': return 'Danik'\n    else: return 'Maxim'\n    return"]