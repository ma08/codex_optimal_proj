["class Solution:\n    def maxPower(self, s: str) -> int:\n        n = len(s) \n        count = 0\n        res = s[0] \n        cur_count = 1\n  \n        # Traverse string except  \n        # last character \n        for i in range(n): \n          \n            # If current character  \n            # matches with next \n            if (i < n - 1 and \n                s[i] == s[i + 1]): \n                cur_count += 1\n  \n            # If doesn't match, update result \n            # (if required) and reset count \n            else: \n                if cur_count > count: \n                    count = cur_count \n                    res = s[i] \n                cur_count = 1\n        return count \n       \n        \n        \n", "class Solution:\n    def maxPower(self, s: str) -> int:\n        cnt = 0\n        current = s[0]\n        current_cnt = 1\n        for l in s[1:]:\n            if l == current:\n                current_cnt += 1\n            else:\n                if current_cnt > cnt:\n                    cnt = current_cnt\n                current = l\n                current_cnt = 1\n        if current_cnt > cnt:\n            cnt = current_cnt\n        return cnt", "class Solution:\n    def maxPower(self, s: str) -> int:\n\n        count = 0\n        new_count = 0\n        for i,char in enumerate(s):\n\n            print(char)\n            try:\n                if s[i+1] == char:\n                    new_count += 1\n                else:\n                    print('afwww')\n                    if new_count >= count:\n                        count = new_count\n                    new_count = 0\n            except:\n                print('sefesf')\n                if new_count >= count:\n                    print('sfwafawfawfawfawfawf')\n                    count = new_count\n                    new_count = 0\n                break\n\n        return count+1\n", "class Solution:\n    def maxPower(self, s: str) -> int:\n        c = {'power': 1}\n        for i in range(len(s)) :\n            if i == len(s)-1 :\n                break\n            if ord(s[i]) == ord(s[i+1]) :\n                c['power'] += 1\n\n            else:\n                c['new start#%s' % i] = c['power']\n                c['power'] = 1\n        return max(c.values())", "class Solution:\n    def maxPower(self, s: str) -> int:\n        power = 1\n        max_power = 0\n        for idx, i in enumerate(s):\n            if len(s) < 2:\n                return len(s)\n            if idx == 0: \n                pass\n            elif i == s[idx -1]:\n                power += 1\n                print(f' i is {i}, power is {power}')\n            else:\n                print(f' i is {i}, power is {power}')\n                if power > max_power:\n                    max_power = power\n                power = 1\n        return max(power, max_power)", "class Solution:\n    def maxPower(self, s: str) -> int:\n        '''\n            does: given a string s, the power of the string is the maximum length of \n                  a non-empty substring that contains only one unique character.\n            parameters: s\n            returns: the power of the string.\n        '''\n        # initialize the letter to None\n        letter = None\n        # initialize the temporary length and maximum length to 0\n        length = 0\n        max_length = 0\n\n        # loop through the string\n        for i in s:\n\n            # if encountered the same letter, length plus one\n            if i == letter:\n                length += 1\n                # set maximum length to the max of (max_length, length, 1)\n                max_length = max(max_length, length)\n\n            # if encountered a different letter\n            else:\n                # set maximum length to the max of (max_length, length, 1)\n                max_length = max(max_length, length, 1)\n                # reset the length to 0\n                length = 1\n                # reset the target to current letter\n                letter = i\n            print(i, max_length)\n\n        return max_length", "class Solution:\n    def maxPower(self, s: str) -> int:\n        z=[]\n        c=0\n        if len(s)==1:\n            return 1\n        for i in range(len(s)-1):\n            if s[i]==s[i+1]:\n                c=c+1\n            else:\n                z.append(c)\n                c=0\n        z.append(c)\n        return max(z)+1\n", "class Solution:\n    def maxPower(self, s: str) -> int:\n        if len(s) <= 1:\n            return len(s)\n        last_char = s[0]\n        count = 1\n        max_count = 0\n        for c in s[1:]:\n            if c == last_char:\n                count += 1      \n            else:\n                if count > max_count:\n                    max_count = count\n                count =1 \n                \n            last_char =c\n        if count > max_count:\n            max_count = count\n            \n        return max_count\n", "class Solution:\n    def maxPower(self, s: str) -> int:\n        prev = None\n        count = 0\n        max_count = 0\n        for char in s:\n            if char == prev:\n                count +=1\n            else:\n                prev = char\n                count =1\n            max_count = max(max_count,count)\n        return max_count", "class Solution:\n    def maxPower(self, s: str) -> int:\n        \n        seq = 1\n        max_seq = 1\n        \n        for i in range(1, len(s)):\n            \n            if s[i] == s[i-1]:\n                seq += 1\n            else:\n                max_seq = max(max_seq, seq)\n                seq = 1\n                \n        max_seq = max(max_seq, seq)\n        return max_seq\n            \n", "class Solution:\n    def maxPower(self, s: str) -> int:\n        count=0\n        max_count=0\n        previous=None\n        for c in s:\n            if c!=previous:\n                previous=c\n                count=1\n            else:\n                count+=1\n            max_count=max(max_count,count)\n        return max_count", "class Solution:\n    def maxPower(self, s: str) -> int:\n        # Assign variables\n        ans = 0\n        consec_count_per_letter = 1\n        prev_letter = s[0]\n\n        # Return 1 when the length of the input is 1\n        if len(s) == 1:\n            return 1\n\n        # Loop from 1 to the length of the input\n        for i in range(1, len(s)):\n            # If the current letter is the same as the prev letter,\n            # then add 1 to consec_count_per_letter\n            if s[i] == prev_letter:\n                consec_count_per_letter += 1\n            else:\n                consec_count_per_letter = 1\n\n            # Update the prev letter\n            prev_letter = s[i]\n            # Update the answer with a maximum\n            # between the answer and consec_count_per_letter\n            ans = max(ans, consec_count_per_letter)\n\n        return ans\n", "class Solution:\n    def maxPower(self, s: str) -> int:\n        c = 1\n        maxc = c\n        for i in range(len(s)-1): \n            if s[i] == s[i+1]: \n                c +=1\n                maxc = max(maxc, c)\n            else: \n                c = 1\n        \n        return maxc\n", "class Solution:\n    def maxPower(self, s: str) -> int:\n        maxcount  = 1\n        i = 0 \n        while  i < len(s)-1 :\n            count = 1\n            while i < len(s)-1 and s[i] == s[i+1] :\n                i = i +1 \n                count = count +1 \n            if( count > maxcount ) :\n                maxcount = count\n            if ( i <len(s) -1) :\n                i = i+1\n        return maxcount\n    \n                \n"]