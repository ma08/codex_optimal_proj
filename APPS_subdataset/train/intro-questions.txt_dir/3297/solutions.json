["from math import ceil\n\ndef will_it_balance(stick, gnd):\n    gravPt = sum(v*i for i,v in enumerate(stick)) / sum(stick)\n    return gnd[int(gravPt)] == gnd[ceil(gravPt)] == 1", "def will_it_balance(stick, terrain):\n    com = sum(i*w for i,w in enumerate(stick))/sum(stick)\n    return terrain.index(1)<=com<=max(i for i,v in enumerate(terrain) if v==1)", "from scipy.ndimage.measurements import center_of_mass\nfrom math import floor, ceil\nfrom numpy import array\n\ndef will_it_balance(stick, terrain):\n    center = center_of_mass(array(stick))[0]\n    return terrain[floor(center)] and terrain[ceil(center)]", "from math import ceil, floor\n\ndef will_it_balance(stick, terrain):\n    c = sum(i*m for i, m in enumerate(stick, 1)) / sum(stick)\n    a, b = floor(c), ceil(c)\n    return all(x or not (a <= i <= b) for i, x in enumerate(terrain, 1))", "def will_it_balance(stick, terrain):\n    center_of_mass = sum(i * mass for i, mass in enumerate(stick)) / sum(stick)\n    terrain_ones = [i for i, x in enumerate(terrain) if x]\n    left, right = terrain_ones[0], terrain_ones[-1]\n    return left <= center_of_mass <= right", "will_it_balance=lambda a,s:s.index(1)<=sum(i*a[i]for i in range(len(a)))/sum(a)<=len(s)-s[::-1].index(1)-1", "import math\n\ndef will_it_balance(stick, terrain):\n    numerator = 0\n    denominator = 0\n    for index, weight in enumerate(stick):\n        numerator += weight * (index+1)\n        denominator += weight\n    centerOfMass = numerator/denominator\n    centerOfMassLowCoord, centerOfMassHighCoord = math.floor(centerOfMass), math.ceil(centerOfMass)\n    return terrain[centerOfMassLowCoord-1]==1 and terrain[centerOfMassHighCoord-1]==1", "def will_it_balance(stick, terrain):\n    c=0\n    T=[]\n    for i in range(len(stick)):\n        c=c+i*stick[i]\n    m=c/sum(stick)\n    for i in range(len(terrain)):\n        if terrain[i]==1:\n            T.append(i)\n    \n    return (len(T)>=2 and T[0]<=m<=T[-1])  or   (len(T)==1 and T[0]==m )\n", "from operator import mul,add\nfrom functools import reduce\ndef will_it_balance(stick, terrain):\n    masses = enumerate(stick)\n    com = reduce(add,[i*j for i,j in masses])/reduce(add,stick)\n    start = terrain.index(1)\n    end = [l[0] for l in enumerate(terrain) if l[1] == 1][-1]\n    return True if com>= start and com<= end else False", "def will_it_balance(stick, terrain):\n    return terrain.index(1) \\\n           <= sum(m*x for x, m in enumerate(stick)) / sum(stick) \\\n           <= (len(terrain) - 1 - terrain[::-1].index(1))"]