["def isPrime(n):\n    return n==2 or n>2 and n&1 and all(n%p for p in range(3,int(n**.5+1),2))\n\ndef prime_product(n):\n    return next( (x*(n-x) for x in range(n>>1,1,-1) if isPrime(x) and isPrime(n-x)), 0)", "def prime_product(n):\n    def is_prime(n): return n == 2 or n > 2 and n % 2 and all(n % d for d in range(3, int(n ** .5) + 1, 2))\n    for i in range(n//2,1,-1): \n        if is_prime(i) and is_prime(n-i): return i*(n-i)\n    return 0", "def primes_set():\n    primes, sieve = {2}, [True] * 50000\n    for i in range(3, 317, 2):\n        if sieve[i // 2]:\n            sieve[i * i // 2 :: i] = [False] * ((100000 - i * i - 1) // (2 * i) + 1)\n    primes.update((2 * i + 1) for i in range(1, 50000) if sieve[i])\n    return primes\n\nprimes = primes_set()\n\ndef prime_product(n):\n    if n % 2 or n == 4:\n        return (2 * (n - 2)) if (n - 2) in primes else 0\n    m, s = n // 2, n % 4 == 0\n    return next(((m + i) * (m - i) for i in range(s, m, 2) if {m + i, m - i} < primes), 0)", "def prime_product(n):\n    result = 0\n    \n    def is_prime(num):\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n      \n    for i in range(2, n // 2 + 1):\n        if is_prime(i) and is_prime(n - i):\n            result = i * (n - i)\n    return result", "from itertools import compress\nimport numpy as np\nfrom bisect import bisect\n\nxs = np.ones(300000)\nxs[:2] = 0\nxs[4::2] = 0\nfor i in range(3, int(len(xs)**0.5) + 1):\n    if xs[i]:\n        xs[i*i::i] = 0\nprimes = list(compress(range(len(xs)), xs))\n\ndef iter_primes(n):\n    i = bisect(primes, n // 2)\n    for x in range(2, primes[i] + 1):\n        if xs[x] and xs[n-x]:\n            yield x, n-x\n\ndef prime_product(n):\n    return max((a*b for a,b in iter_primes(n)), default=0)", "def prime_product(n, sieve=[False, False, True, True]):\n    for x in range(len(sieve), n+1):\n        sieve.append(x % 2 and all(x % p for p in range(3, int(x ** .5) + 1, 2) if sieve[p]))\n    return next((p * (n - p) for p in range(n//2, 1, -1) if sieve[p] and sieve[n - p]), 0)", "def is_prime(n):\n    if n == 2 or n == 3:\n        return True\n    if n % 2 == 0 or n < 2:\n        return False\n\n    for i in range(3, int(n**0.5)+1, 2):\n        if n % i == 0:\n            return False\n    \n    return True\n\n\ndef prime_product(n):\n    for i in range(n//2+1)[::-1]:\n        if is_prime(i) and is_prime(n - i):\n            return i * (n - i)\n    return 0", "from bisect import bisect\n\n\ndef prime_product(n):\n    bisect_point = bisect(primes, n // 2)\n\n    # If n is odd then pair must be (2, n - 2) or nothing. This is because 2 is the\n    # only even prime and to get an odd number you must add even + odd.\n    if n % 2:\n        return 2 * (n - 2) if n - 2 in prime_set else 0\n\n    # Check half of prime list (starting from the middle). Return product of first pair found.\n    for prime in primes[:bisect_point][::-1]:\n        if n - prime in prime_set:\n            return prime * (n - prime)\n\n    return 0  # Return 0 if no valid pair found.\n\n\ndef get_primes(n):\n    \"\"\"Sieve of Eratosthenes to calculate all primes less than or equal to n.\n\n    Return set of primes.\n    \"\"\"\n    primes = [True] * (n + 1)\n\n    for num in range(2, int(n ** 0.5) + 1):\n        if primes[num]:\n            primes[num * 2::num] = [False] * len(primes[num * 2::num])\n\n    return [i for i, x in enumerate(primes) if x and i > 1]\n\n\n# Calculate all primes up to max but only calculate primes once. Then reference master prime list in all test cases.\nmax_input = 100000\nprimes = get_primes(max_input)\nprime_set = set(primes)", "# generate primes\nLIMIT = 100000\nsieve = [True] * (LIMIT//2)\nfor n in range(3, int(LIMIT**0.5) +1, 2):\n    if sieve[n//2]: sieve[n*n//2::n] = [False] * ((LIMIT-n*n-1)//2//n +1)\nPRIMES_LIST = [2] + [2*i+1 for i in range(1, LIMIT//2) if sieve[i]]\nPRIMES = set(PRIMES_LIST)\ndel sieve\n\n\nfrom  bisect import bisect\n\ndef prime_product(n):\n    if n % 2:\n        return 2*(n-2) if n-2 in PRIMES else 0\n    \n    for p in PRIMES_LIST[:bisect(PRIMES_LIST, n//2)][::-1]:\n        if n-p in PRIMES:\n            return (n-p) * p", "def prime_product(n):\n    def prime(a):\n        if a == 2: return True\n        if a < 2 or a % 2 == 0: return False\n        return not any(a % x == 0 for x in range(3, int(a**0.5) + 1, 2))\n    if (n <= 3):\n        return 0\n    i = n // 2\n    while i > 0:\n        if (prime(n - i) and prime(i)):\n            return (n - i) * i\n        i -= 1\n    return 0"]