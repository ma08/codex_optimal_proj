["def rgb(r, g, b):\n    round = lambda x: min(255, max(x, 0))\n    return (\"{:02X}\" * 3).format(round(r), round(g), round(b))", "def limit(num):\n    if num < 0:\n        return 0\n    if num > 255:\n        return 255\n    return num\n\n\ndef rgb(r, g, b):\n    return \"{:02X}{:02X}{:02X}\".format(limit(r), limit(g), limit(b))", "def rgb(r, g, b):\n    clamp = lambda x: max(0, min(x, 255))\n    return \"%02X%02X%02X\" % (clamp(r), clamp(g), clamp(b))", "def rgb(*args):\n    return ''.join(map(lambda x: '{:02X}'.format(min(max(0, x), 255)), args));", "def rgb(r, g, b):\n    def get_hex(s):\n        if s > 255: s = 255\n        if s < 0: s = 0\n        return hex(s)[2:].upper() if len(hex(s)[2:]) > 1 else \"0\" + hex(s)[2:]\n    return get_hex(r) + get_hex(g) + get_hex(b)\n", "def rgb(r, g, b): \n    return ''.join(['%02X' % max(0, min(x, 255)) for x in [r, g, b]])", "def hex_con(color):\n    hex_dict = '0123456789ABCDEF'\n    d1 = color//16\n    d2 = color%16\n    if d1 > 15:\n        d1 = 15\n        d2 = 15\n    elif d1 < 0:\n        d1 = 0\n        d2 = 0\n    return str(hex_dict[d1]) + str(hex_dict[d2])\n    \n\n\ndef rgb(r, g, b):  \n    R = hex_con(r)\n    G = hex_con(g)\n    B = hex_con(b)\n    return R+G+B", "def rgb(r, g, b):\n    \"\"\"\n    Return hex string representation of ``r,g,b`` values. A saturation \\\nwill be applied to the input values to ensure they are betweem 0 \\\nand 255.\n    \n    :param r: Red channel\n    :type r: int \n    \n    :param g: Green channel\n    :type g: int \n    \n    :param b: Blue channel\n    :type b: int \n    \n    :return: Hex representation.\n    :rtype: str\n    \n    >>> rgb(123,45,67)\n    '7B2D43'\n    >>> rgb(-20,123,456)\n    '007BFF'\n    >>> rgb('no int',123,123)\n    Traceback (most recent call last):\n        ...\n    TypeError: 'r' is not of type int\n    >>> rgb(123,'no int',123)\n    Traceback (most recent call last):\n        ...\n    TypeError: 'g' is not of type int\n    >>> rgb(123,123,'no int')\n    Traceback (most recent call last):\n        ...\n    TypeError: 'b' is not of type int\n    \"\"\"\n    \n    if not type(r).__name__ == 'int':    # python2 does not have instanceof()\n        raise TypeError(\"'r' is not of type int\")\n    if not type(g).__name__ == 'int':    # python2 does not have instanceof()\n        raise TypeError(\"'g' is not of type int\")\n    if not type(b).__name__ == 'int':    # python2 does not have instanceof()\n        raise TypeError(\"'b' is not of type int\")\n    \n    return \"{r:02X}{g:02X}{b:02X}\".format(\n        r=saturate(r),\n        g=saturate(g),\n        b=saturate(b),\n    )\n\n\ndef saturate(x):\n    \"\"\"\n    Saturates an integer ``x`` to be ``0<=x<=255``.\n    \n    :param x: Integer to be saturated\n    :type x: int \n    \n    :return: Saturated integer\n    :rtype: int\n    \n    >>> saturate(345)\n    255\n    >>> saturate(-3)\n    0\n    >>> saturate(123)\n    123\n    >>> saturate(\"no int\")\n    Traceback (most recent call last):\n        ...\n    TypeError: given value is not of type int\n    \"\"\"\n    if not type(x).__name__ == 'int':    # python2 does not have instanceof()\n        raise TypeError(\"given value is not of type int\")\n    \n    x = 0 if x<0 else x\n    x = 255 if x>255 else x\n    \n    return x\n\n\ndef __starting_point():\n    import doctest\n    doctest.testmod()\n__starting_point()", "def rgb(r, g, b):\n    return '{0:02X}{1:02X}{2:02X}'.format(max(min(r, 255), 0), max(min(g, 255), 0), max(min(b, 255), 0))", "def rgb(r, g, b):\n    return \"{:02X}{:02X}{:02X}\".format(clamp(r), clamp(g), clamp(b))\n        \ndef clamp(x): \n    return max(0, min(x, 255))"]