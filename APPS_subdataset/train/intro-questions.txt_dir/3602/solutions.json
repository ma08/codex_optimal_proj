["from itertools import groupby\n\ndef run_length_encoding(s):\n    return [[sum(1 for _ in g), c] for c, g in groupby(s)]", "from itertools import groupby\ndef run_length_encoding(s):\n    return [[len(list(b)), a] for a,b in groupby(s)]", "def run_length_encoding(s):\n  count, prev, lst = 1, '', []\n  for c in s:\n    if c != prev:\n      if prev: lst.append([count, prev])\n      count, prev = 1, c\n    else: count += 1\n  if len(prev) > 0 : lst.append([count, prev])\n  return lst", "from itertools import groupby\ndef run_length_encoding(s):\n  return [[len(list(g)), k] for k, g in groupby(s)]", "import re\ndef run_length_encoding(s):\n    return [[len(l), e] for l, e in re.findall( r'((.)\\2*)', s )]", "from itertools import groupby\nimport re\ndef run_length_encoding(s):\n    return [[len(list(j)),i] for i,j in groupby(s)]\n    return [[len(i),j] for i,j in re.findall(r'((.)\\2*)',s)]", "from itertools import groupby\n\ndef run_length_encoding(s):\n    return [[sum(1 for _ in grp), c] for c, grp in groupby(s)]", "from itertools import groupby\n\ndef run_length_encoding(s):\n  return [[len(list(gp)), x] for x, gp in groupby(s)]", "from re import findall\n\ndef run_length_encoding(string):\n    return [[len(a), b] for a, b  in findall(r\"((.)\\2*)\", string)]\n\n\n\n    #match_runs = r\"((.)\\2*)\"\n    #runs = findall(match_runs, string)\n    #return [[len(run), char] for run, char in runs]\n", "def run_length_encoding(s):\n    result = []\n    if s:\n        prev = s[0]\n        count = 1\n        for ind in range(1, len(s)):\n            if s[ind] == prev:\n                count += 1\n            else:\n                result.append([count, prev])\n                prev = s[ind]\n                count = 1\n        result.append([count, prev])\n    return result\n", "import re\ndef run_length_encoding(s):\n    ls = re.finditer(r'(.)\\1*',s)\n    t = []\n    for i in ls:\n        t.append([i.end()-i.start(),i.group()[0]])\n    return t", "def run_length_encoding(s):\n    rle = []\n    for i, ch in enumerate(s):\n        if i == 0:\n            rle.append([1, ch])\n        else:\n            last_ch = rle[-1][1]\n            if last_ch == ch:\n                new_count = rle[-1][0] + 1\n                rle.pop()\n                rle.append([new_count, ch])\n            else:\n                rle.append([1, ch])\n    return rle", "def run_length_encoding(s):\n    ret = []\n    p = None\n    for c in s:\n        if c == p:\n            ret[-1][0] += 1\n        else:\n            ret.append([1, c])\n            p = c\n    return ret", "def run_length_encoding(s):\n    result = []\n    i = j = 0\n    while i < len(s):\n        while j < len(s) and s[i] == s[j]:\n            j += 1\n        result.append([j-i, s[i]])\n        i = j\n    return result", "def run_length_encoding(string):\n    code = []\n    for c in string:\n        if not code or code[-1][1] != c:\n            code.append([1, c])\n        else:\n            code[-1][0] += 1\n    return code", "from itertools import groupby\ndef run_length_encoding(s):\n    encoded_s = []\n\n    #define key function that returns first char as key\n    key = lambda x: x[0]\n    \n    for k, g in groupby(s, key):\n        encoded_s.append([len(list(g)), k])\n    \n    return encoded_s\n", "def run_length_encoding(s):\n    if len(s) == 0:\n        return []\n    \n    encoded_s = [[1,s[0]]]\n    last_char = s[0]\n    \n    for char in s[1:]:\n        if char == last_char:\n            #increment running count\n            encoded_s[-1][0] = encoded_s[-1][0] + 1\n        else:\n            # start counting new char\n            encoded_s.append([1,char])\n        #update last_char getting ready for next time through the loop\n        last_char = char\n    \n    return encoded_s", "from itertools import groupby\n\ndef run_length_encoding(s):\n    return [[len(x), x[0]] for x in [list(g) for k, g in groupby(s)]]", "def run_length_encoding(s):\n    if len(s) == 0:\n        return []\n    cnt = 1\n    prev = s[0]\n    out = []\n    s = s + \" \"\n    for i in range(len(s) - 1):\n        if s[i + 1] == prev:\n            cnt = cnt + 1\n        else:\n            if cnt > 1:\n                out.append([cnt, prev])\n                cnt = 1\n            else:\n                out.append([1, prev])\n        prev = s[i + 1]\n    return out"]