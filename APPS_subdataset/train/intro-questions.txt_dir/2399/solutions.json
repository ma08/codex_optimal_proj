["from sys import stdin, stdout\nimport functools\nimport sys,os,math\n\n#sys.setrecursionlimit(10**6)\n\nT = int(input())\nfor _ in range(T):\n    N, M = list(map(int, input().split()))\n    DS = [0] * (N + 1)\n    ES = []\n    g = [[] for _ in range(N + 1)]\n    for _ in range(M):\n        t, u, v = list(map(int, input().split()))\n        ES.append([t ,u ,v])\n        if t == 1:\n            DS[u] += 1\n        g[u].append(len(ES) - 1)\n        g[v].append(len(ES) - 1)\n\n    q = []\n    for u in range(1, N+1):\n        if DS[u] == 0:\n            q.append(u)\n\n    while len(q) > 0:\n        u = q.pop()\n        if DS[u] > 0:\n            continue\n\n        for e in g[u]:\n            t, u0, v0 = ES[e]\n            if t == 1:\n                if v0 == u:\n                    DS[u0] -= 1\n                    if DS[u0] == 0:\n                        q.append(u0)\n            elif t == 0:\n                v = v0 if u0 == u else u0\n                ES[e] = [1, v, u]\n    \n    md = max(DS)\n    if md > 0:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        for e in ES:\n            print(e[1], e[2])\n\n        \n\n", "import sys\n# sys.stdin = open(\"in\", \"r\")\n# sys.stdout = open(\"out\", \"w\")\n\n# toposort from pajenegod, AC server: https://discordapp.com/channels/555883512952258563/578670185007808512/708046996207829093\ndef toposort(graph):\n    res = []\n    found = [0] * len(graph)\n    stack = list(range(len(graph)))\n    while stack:\n        node = stack.pop()\n        if node < 0:\n            res.append(~node)\n        elif not found[node]:\n            found[node] = 1\n            stack.append(~node)\n            stack += graph[node]\n\n    # cycle check\n    for node in res:\n        if any(found[nei] for nei in graph[node]):\n            return None\n        found[node] = 0\n\n    return res[::-1]\n\ninp = [int(x) for x in sys.stdin.read().split()]; ii = 0\nt = inp[0]; ii += 1\nfor _ in range(t):\n\tn, m = inp[ii:ii+2]; ii += 2\n\tgraph = [[] for _ in range(n+1)]\n\tundir = []\n\tfor i in range(m):\n\t\ttype, u, v = inp[ii:ii+3]; ii += 3\n\t\tif type == 0:\n\t\t\tundir.append([u, v])\n\t\telse:\n\t\t\tgraph[u].append(v)\n\torder = toposort(graph)\n\tif not order:\n\t\tprint(\"NO\")\n\t\tcontinue\n\tprint(\"YES\")\n\tindex = [0]*(n+1)\n\tfor i in range(n+1):\n\t\tindex[order[i]] = i\n\tfor i in range(n+1):\n\t\tfor u in graph[i]:\n\t\t\tprint(i, u)\n\tfor u, v in undir:\n\t\tif index[u] < index[v]:\n\t\t\tprint(u, v)\n\t\telse:\n\t\t\tprint(v, u)", "\nfrom sys import stdin\nfrom collections import deque\ntt = int(stdin.readline())\n\nfor loop in range(tt):\n\n    Query = []\n    ans = []\n\n    n,m = list(map(int,stdin.readline().split()))\n    lis = [ [] for i in range(n) ]\n    inum = [0] * n\n    ilis = inum\n    index = [None] * n\n\n    for i in range(m):\n\n        st,x,y = list(map(int,stdin.readline().split()))\n        x -= 1\n        y -= 1\n        if st == 1:\n            ilis[y] += 1\n            lis[x].append(y)\n            ans.append((x,y))\n        else:\n            Query.append( (x,y) )\n\n    endnum = 0\n    q = deque([])\n    for i in range(n):\n        if ilis[i] == 0:\n            q.append(i)\n    while len(q) > 0:\n        v = q.popleft()\n        index[v] = endnum\n        endnum += 1\n\n        for nex in lis[v]:\n            inum[nex] -= 1\n            if inum[nex] == 0:\n                q.append(nex)\n\n    if endnum != n:\n        print (\"NO\")\n    else:\n        print (\"YES\")\n        for x,y in Query:\n            if index[x] < index[y]:\n                print(x+1,y+1)\n            else:\n                print(y+1,x+1)\n        for x,y in ans:\n            print(x+1,y+1)\n        \n", "def main():\n    import sys\n    from collections import deque, defaultdict\n    from heapq import heappop, heappush\n    sys.setrecursionlimit(10**9)\n    input = sys.stdin.readline\n    for __ in [0]*int(input()):\n        N, M = list(map(int, input().split()))\n        deg = [0]*N\n        directed = defaultdict(list)\n        undirected = defaultdict(list)\n        for _ in [0]*M:\n            t, a, b = list(map(int, input().split()))\n            a -= 1\n            b -= 1\n            if t:\n                directed[a].append(b)\n                deg[b] += 1\n            else:\n                undirected[a].append(b)\n                undirected[b].append(a)\n\n        q = deque([i for i, d in enumerate(deg) if d == 0])\n        topological = []\n        while q:\n            v = q.popleft()\n            topological.append(v)\n            if v not in directed:\n                continue\n            for u in directed[v]:\n                deg[u] -= 1\n                if deg[u] == 0:\n                    q.append(u)\n        if len(topological) != N:\n            print('NO')\n            continue\n\n        del deg\n\n        print('YES')\n\n        used = [0]*N\n        for v in topological:\n            if v in directed:\n                for u in directed[v]:\n                    print(v+1, u+1)\n            if v in undirected:\n                for u in undirected[v]:\n                    if used[u]:\n                        continue\n                    print(v+1, u+1)\n            used[v] = 1\n\n        del used\n\ndef __starting_point():\n    main()\n\n__starting_point()"]