["from ipaddress import IPv4Address\n\ndef int32_to_ip(int32):\n    return str(IPv4Address(int32))", "def int32_to_ip(int32):\n    return '{}.{}.{}.{}'.format(*int32.to_bytes(4, 'big'))", "from ipaddress import ip_address\n\ndef int32_to_ip(int32):\n    return str(ip_address(int32))", "def int32_to_ip(i):\n    return '.'.join([str(x) for x in [i >> 24 & 0xFF, \n                                      i >> 16 & 0xFF,\n                                      i >> 8 & 0xFF,\n                                      i & 0xFF]])", "import ipaddress\ndef int32_to_ip(int32):\n    return str(ipaddress.IPv4Address(int32))\n", "def int32_to_ip(int32):\n    \"\"\"\n    The solution involves bitwise AND of int32 and a mask that we can shift around.\n    Say we have the number 17194 (0b0100001100101010). This can be divided into 2\n    bytes: 01000011 and 00101010.\n    We can AND this with a byte that is filled with 1s - 255 (0b11111111), shifted\n    left by a certain amount of bytes to get the digits in that byte:\n    01000011 00101010 # 17194\n    11111111 00000000 # 255 << 8\n    01000011 00000000 # 17194 & 255 << 8\n    However, we need to shift this value *back* to get a number within (0,255)\n    inclusive, as required, so shift right by the same amount.\n    \"\"\"\n    first = (int32 & (255 << 24)) >> 24\n    second = (int32 & (255 << 16)) >> 16\n    third = (int32 & (255 << 8)) >> 8\n    fourth = int32 & 255\n    return f\"{first}.{second}.{third}.{fourth}\"", "# convert binary\ndef convert_bin(arr):\n  summa = 0\n  for x,y in enumerate(arr[::-1]):\n    summa = summa + 2**x * int(y)\n  return summa\n  \n  \ndef int32_to_ip(int32):\n\n  n = \"\"\n\n  while int32 > 0:\n    y = str(int32 % 2)\n    n = y + n\n    int32 = int(int32 / 2)\n\n\n  if len(n) != 32: # make 32 bit\n    while len(n) != 32:\n      n = '0' + n\n\n  a = n[:8] # first 8\n  b = n[8:16] # secound 8\n  c = n[16 : 24] # third 8\n  d = n[24 : 32] # fourth 8\n\n  return(str(convert_bin(a))+'.'+str(convert_bin(b))+'.'+str(convert_bin(c))+'.'+str(convert_bin(d)))", "def int32_to_ip(int32):\n    # your code here\n    \n    octets = []\n    octets.append(str( (int32 & 0xFF000000) >> 24))\n    octets.append(str( (int32 & 0x00FF0000) >> 16))\n    octets.append(str(  (int32 & 0x0000FF00) >> 8))\n    octets.append(str(int32 & 0x000000FF))\n    return '.'.join(octets)", "def int32_to_ip(int32):\n  return '.'.join([str(int(bin(int32)[2:].zfill(32)[i:i+8], 2)) for i in range(0, 32, 8)])", "from re import sub\ndef int32_to_ip(int32):\n  return sub(r'(\\d{8})', lambda x: str(int(x.group(), 2))+'.' , '{0:32b}'.format(int32).replace(' ', '0'))[:-1]"]