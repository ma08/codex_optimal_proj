["def pac_man(size, pacman, enemies):\n    px, py = pacman\n    mx, my, Mx, My = -1, -1, size, size\n    for x, y in enemies:\n        if x < px and x > mx: mx = x\n        if y < py and y > my: my = y\n        if x > px and x < Mx: Mx = x\n        if y > py and y < My: My = y\n    return (Mx - mx - 1) * (My - my - 1) - 1", "def pac_man(N, PM, enemies):\n    dims = [[0,N], [0,N]]   # [[minX, maxX], [minY, maxY]]\n    for pos in enemies:\n        for i,x in enumerate(pos):\n            if PM[i] > x: dims[i][0] = max(dims[i][0], x+1)\n            else:         dims[i][1] = min(dims[i][1], x)\n    return (dims[0][1]-dims[0][0]) * (dims[1][1]-dims[1][0]) - 1", "def pac_man(n, pm, enemies):\n    # Build initial grid\n    # O open, P Pacman, E enemy, # Enemy line of sight\n    row = lambda c=\"O\": [c] * n\n    grid = [row() for _ in range(n)]\n    grid[pm[0]][pm[1]] = \"P\"\n    for er, ec in enemies:\n        grid[er] = row(\"#\")\n        grid = [[\"#\" if c == ec else v for c, v in enumerate(r)] for r in grid]\n    for er, ec in enemies:\n        grid[er][ec] = \"E\"\n    \n    # Perform a flood fill detecting O and converting to . starting from PM\n    edges = [pm]\n    count = 0\n    while edges:\n        new_edges = []\n        for er, ec in edges:\n            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                r, c = er + dr, ec + dc\n                if 0 <= r < n and 0 <= c < n:\n                    if grid[r][c] == \"O\":\n                        count += 1\n                        grid[r][c] = \".\"\n                        new_edges.append((r, c))\n        edges = new_edges\n    return count", "def pac_man(N, PM, enemies):\n  borders=[[-1, 0], [0, -1], [-1, N-1], [N-1, -1], [N, 0], [N, N-1], [0, N], [N-1, N]]\n  for n in range(1, N-1):\n      borders.append([-1, n])\n      borders.append([n, -1])\n      borders.append([n, N])\n      borders.append([N, n])\n  ghosts=[]\n  for i in enemies:\n      x=i[0]\n      y=i[1]\n      for n in range(N):\n          ghosts.append([x, n])\n          ghosts.append([n, y])\n  possibilities=[]\n  moved=[PM]\n  while moved != []:\n      moved2=moved\n      moved=[]\n      for i in moved2:\n          x=i[0]\n          y=i[1]\n          mon=[[x, y+1], [x, y-1], [x+1, y], [x-1, y]]\n          for m in mon:\n              if m not in borders and m not in ghosts:\n                  if m not in possibilities and m not in moved and m != PM:\n                      possibilities.append(m)\n                      moved.append(m)\n  return len(possibilities)", "import numpy as np\n\n\ndef count(gamefield, PM , N):\n    gamefield[PM[0], PM[1]] = -1\n    case1 = 0\n    case2 = 0\n    case3 = 0\n    case4 = 0\n#recursive case    \n    if (PM[0] + 1) < N and gamefield[PM[0] + 1, PM[1]] != -1:  \n        case1 = 1 + count(gamefield, [PM[0]+1, PM[1]], N)\n    if (PM[0] - 1) > -1 and gamefield[PM[0] - 1, PM[1]] != -1:\n        case2 =  1 + count(gamefield, [PM[0]-1, PM[1]], N)\n    if (PM[1] + 1) < N and gamefield[PM[0], PM[1] + 1] != -1:\n        case3 = 1 + count(gamefield, [PM[0], PM[1] + 1], N)\n    if (PM[1] - 1) > -1 and gamefield[PM[0], PM[1] - 1] != -1:\n        case4 = 1 + count(gamefield, [PM[0], PM[1] - 1], N)\n    \n    return (case1 + case2 + case3 + case4)\n\n\n\n\n\ndef pac_man(N, PM, enemies):\n  #coding and coding..\n    #base case 1\n    if N == 1:\n        return 0\n    #base case 2\n    if len(enemies) == 0:\n        return (N**2) - 1\n    \n    gamefield = np.ones((N,N))\n    gamefield[PM[0], PM[1]] = 7#PM\n    \n\n    for e in enemies:\n        gamefield[:, e[1]] = -1#enemy\n        gamefield[e[0], :] = -1#enemy\n    print(gamefield)\n    \n  \n    return count(gamefield, PM, N)\n", "from bisect import bisect\n\ndef pac_man(n,p,es):\n    if not es: return n*n-1\n    l=len(es)\n    y,x=list(map(sorted,list(zip(*es))))\n    i=bisect(y,p[0])\n    hy=y[i] if i<l else n\n    ly=y[i-1] if i>0 else -1\n    i=bisect(x,p[1])\n    hx=x[i] if i<l else n\n    lx=x[i-1] if i>0 else -1\n    return (hy-ly-1)*(hx-lx-1)-1\n", "def pac_man(n, pm, enemies):\n    left, right, top, floor = -1, n, -1, n\n    for y, x in enemies:\n        if top < y < pm[0]: \n            top = y\n        if pm[0] < y < floor: \n            floor = y\n        if left < x < pm[1]: \n            left = x\n        if pm[1] < x < right: \n            right = x\n    return (right - left -1) * (floor - top - 1) - 1\n", "def pac_man(N, PM, enemies):\n    if not enemies:\n        return N ** 2 - 1\n    rows = []\n    columns = []\n\n    for i, c in enumerate(enemies):\n        rows.append(c[0])\n        columns.append(c[1])\n    rows = sorted(rows)\n    columns = sorted(columns)\n    PM = list(map(lambda x: x + 1, PM))\n    rows = list(map(lambda x: x + 1, rows))\n    columns = list(map(lambda x: x + 1, columns))\n    rows_less = list(filter(lambda a: a < PM[0], rows))\n    rows_more = list(filter(lambda a: a > PM[0], rows))\n    columns_less = list(filter(lambda a: a < PM[1], columns))\n    columns_more = list(filter(lambda a: a > PM[1], columns))\n    list(rows_more)\n    if not rows_more:\n        rows_more.append(N + 1)\n    if not rows_less:\n        rows_less.append(0)\n    if not columns_more:\n        columns_more.append(N + 1)\n    if not columns_less:\n        columns_less.append(0)\n    y = min(rows_more) - max(rows_less) - 1\n    x = min(columns_more) - max(columns_less) - 1\n\n    return x*y - 1", "from collections import deque\n\ndef pac_man(N, PM, enemies):\n    grid = [[2] * N for i in range(N)]\n    for enemy in enemies:\n        for i in range(N):\n            grid[enemy[0]][i] = \"E\"\n        for j in range(N):\n            grid[j][enemy[1]] = \"E\"\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    queue, ans = deque([tuple(PM)]), 0\n    visited = set()\n    while queue:\n        node = queue.popleft()\n        for dirc in directions:\n            new_pos = (node[0] + dirc[0], node[1] + dirc[1])\n            if 0 <= new_pos[0] < N and 0 <= new_pos[1] < N:\n                if grid[new_pos[0]][new_pos[1]] == 2:\n                    if new_pos not in visited:\n                        ans += 1\n                        visited.add(new_pos)\n                        queue.append(tuple(new_pos))\n    return ans - 1 if ans > 0 else 0", "def pac_man(N, PM, enemies):\n  print(N)\n  print(PM)\n  print(enemies)\n  board = []\n  row = []\n  column = []\n  if enemies == []:\n      return N**2 -1\n  for i in enemies:\n      row.append(PM[1] - i[1])\n      column.append(PM[0] - i[0])\n      \n  rowMinus = [(PM[1] - N) *-1]\n  rowPlus = [PM[1]+1]\n  columnMinus = [(PM[0] - N) *-1]\n  columnPlus = [PM[0]+1]\n  for i in row:\n      if i<0:\n          rowMinus.append(i*-1)\n      else:\n          rowPlus.append(i)    \n  for i in column:\n      if i<0:\n          columnMinus.append(i*-1)\n      else:\n          columnPlus.append(i)\n  \n  ColumnD=(min(rowPlus) + min(rowMinus) -1) \n  RowD = (min(columnPlus) + min(columnMinus) -1) \n  print(\"x\")\n  print(RowD), print(columnPlus), print(columnMinus)\n  print(ColumnD)\n  return ColumnD*RowD -1\n  "]