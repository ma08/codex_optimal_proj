["def socialist_distribution(population, minimum):\n    if minimum > sum(population)//len(population):\n        return []\n    while min(population) < minimum:\n        population[population.index(min(population))] += 1\n        population[population.index(max(population))] -= 1\n    return population\n", "def socialist_distribution(population, minimum):\n    if len(population) * minimum > sum(population):\n        return []\n    \n    while min(population) < minimum:\n        i_max = population.index(max(population))\n        i_min = population.index(min(population))\n        population[i_max] -= 1\n        population[i_min] += 1\n    \n    return population", "def socialist_distribution(pop, minimum):\n    if minimum > sum(pop)//len(pop):\n        return []\n    while min(pop) < minimum:\n        pop[pop.index(min(pop))] += 1\n        pop[pop.index(max(pop))] -= 1\n    return pop", "def socialist_distribution(p, m):\n    if sum(p)/len(p)<m : return []\n    while min(p) < m:\n        p[p.index(min(p))] +=1\n        p[p.index(max(p))] -=1\n    return p", "def socialist_distribution(population, minimum):\n    if sum(population) < minimum * len(population):\n        return []\n    population = population[:]\n    for _ in range(sum(max(minimum - p, 0) for p in population)):\n        population[min(range(len(population)), key=population.__getitem__)] += 1\n        population[max(range(len(population)), key=population.__getitem__)] -= 1\n    return population", "def socialist_distribution(population, minimum):\n    if sum(population) < len(population) * minimum:\n        return []\n    while 1:\n        poor = rich = 0\n        for idx, need in enumerate(population):\n            if need < population[poor]: poor = idx\n            if need > population[rich]: rich = idx\n        if population[poor] >= minimum:\n            return population\n        population[rich] -= 1\n        population[poor] += 1", "socialist_distribution=lambda p, m: [] if sum(p)<m*len(p) else p if all(m<=e for e in p) else (lambda mini, maxi: socialist_distribution(p[:mini]+[p[mini]+1]+p[mini+1:maxi]+[p[maxi]-1]+p[maxi+1:], m) if mini<maxi else socialist_distribution(p[:maxi]+[p[maxi]-1]+p[maxi+1:mini]+[p[mini]+1]+p[mini+1:], m))(p.index(min(p)),p.index(max(p)))", "def socialist_distribution(a, n):\n    m = sum(a)\n    if m < len(a) * n: return []\n    if m == len(a) * n: return [n] * len(a)\n    for i in range(sum(n - x for x in a if x < n)):\n        a[a.index(max(a))] -= 1\n    return [max(x, n) for x in a]", "def socialist_distribution(a, m):\n    new = [i - m for i in a]\n    while any(i > 0 for i in new) or sum(new)==0:   \n        if all((i + m) >= m for i in new) : return [i + m for i in new]\n        new[new.index(max(new))] -= 1\n        new[new.index(min(new))] += 1\n    return []", "def socialist_distribution(population, minimum):\n    if sum(population) < (minimum * len(population)):\n        return []\n    if min(population) >= minimum:\n        return population\n    population[population.index(max(population))] -= 1\n    population[population.index(min(population))] += 1\n    return socialist_distribution(population,minimum)"]