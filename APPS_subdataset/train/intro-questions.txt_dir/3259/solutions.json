["import re\n\nKEYBOARD = \"abcde123fghij456klmno789pqrst.@0uvwxyz_/* \"\nMAP      = {c: (i//8, i%8) for i,c in enumerate(KEYBOARD)}\n\n\ndef manhattan(*pts): return 1 + sum( abs(z2-z1) for z1,z2 in zip(*pts))\n\ndef toggle(m):\n    ups, end = m.group(1), m.group(2)\n    off = '*' * bool(end)\n    return f'*{ups.lower()}{off}{end}'                # Toggle Shift ON if uppercase presents, and then OFF if lowercase after\n\ndef tv_remote(words):\n    reWords = re.sub(r'([A-Z][^a-z]*)([a-z]?)', toggle, words)\n    return sum( manhattan(MAP[was], MAP[curr]) for was,curr in zip('a'+reWords, reWords))\n", "raw = 'abcde123fghij456klmno789pqrst.@0uvwxyz_/'\nlayout = {char: divmod(i, 8) for i, char in enumerate(raw)}\nlayout['SHIFT'] = (5, 0)\nlayout[' '] = (5,1)\n\ndef distance(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1]) + 1\n\n\nclass Keyboard:\n    def __init__(self):\n        self.total = 0\n        self.cap = False\n        self.current = (0,0)\n        \n    def hit_shift(self):\n        self.total += distance(self.current, layout['SHIFT'])\n        self.cap = not self.cap\n        self.current = layout['SHIFT']\n    \n    def next_letter(self, letter):\n        if letter.isupper() and not self.cap:\n            self.hit_shift()\n        elif letter.islower() and self.cap:\n            self.hit_shift()\n        \n        self.total += distance(self.current, layout[letter.lower()])\n        self.current = layout[letter.lower()]\n    \n    def solve(self, word):\n        for char in word:\n            self.next_letter(char)\n\n\ndef tv_remote(words):\n    k = Keyboard()\n    k.solve(words)\n    return k.total\n", "import re\n\ndef tv_remote(words):\n    letters = {c: (x, y)\n        for y, row in enumerate((\n        \"abcde123\",\n        \"fghij456\",\n        \"klmno789\",\n        \"pqrst.@0\",\n        \"uvwxyz_/\",\n        \"\u21e7 \"))\n        for x, c in enumerate(row)}\n    words = re.sub(r'((?:^|[a-z])[^A-Z]*)([A-Z])', r'\\1\u21e7\\2', words)\n    words = re.sub(r'([A-Z][^a-z]*)([a-z])', r'\\1\u21e7\\2', words)\n    words = words.lower()\n    return sum(\n        abs(letters[c1][0] - letters[c2][0]) +\n        abs(letters[c1][1] - letters[c2][1]) + 1\n        for c1, c2 in zip(\"a\" + words, words))", "keyboard = (\"abcde123\", \"fghij456\", \"klmno789\", \"pqrst.@0\", \"uvwxyz_/\", \"# \")\nD = {c:(i,j) for i,row in enumerate(keyboard) for j,c in enumerate(row)}\n\ndef tv_remote(words):\n    i = j = up = res = 0\n    for c in words:\n        if c.isalpha() and c.isupper() != up:\n            k, l = D['#']\n            res += abs(i-k) + abs(j-l) + 1\n            i, j, up = k, l, 1-up\n        k, l = D[c.lower()]\n        res += abs(i-k) + abs(j-l) + 1\n        i, j = k, l\n    return res", "def tv_remote(words):\n    pad = [\"abcde123\", \"fghij456\", \"klmno789\", \"pqrst.@0\", \"uvwxyz_/\", \"S \"]\n    index = {c: (x, y) for x, lst in enumerate(pad) for y, c in enumerate(lst)}\n    res = 0\n    pos = (0, 0)\n    caps = False\n    for char in words:\n        if char.isalpha() and (char.isupper() != caps):\n            res += (abs(pos[0] - index[\"S\"][0]) + abs(pos[1] - index[\"S\"][1])) + 1\n            pos = index[\"S\"]\n            caps = not caps\n        \n        char = char.lower()\n        res += (abs(pos[0] - index[char][0]) + abs(pos[1] - index[char][1])) + 1\n        pos = index[char]\n    return res", "from collections import namedtuple\n\n\ndef tv_remote(word: str):\n    remote = (\n        'a', 'b', 'c', 'd', 'e', '1', '2', '3',\n        'f', 'g', 'h', 'i', 'j', '4', '5', '6',\n        'k', 'l', 'm', 'n', 'o', '7', '8', '9',\n        'p', 'q', 'r', 's', 't', '.', '@', '0',\n        'u', 'v', 'w', 'x', 'y', 'z', '_', '/',\n        '', ' '\n    )\n    Position = namedtuple('Position', 'y x')\n    shift, shift_pressed = Position(5, 0), False\n\n    prev = Position(0, 0)\n    button_presses = 0\n    for letter in word:\n        if letter.isalpha() and letter.isupper() != shift_pressed:\n            button_presses += abs(prev.y - shift.y) + abs(prev.x - shift.x) + 1\n            prev, shift_pressed = shift, not shift_pressed\n\n        cur = Position(*divmod(remote.index(letter.lower()), 8))\n        button_presses += abs(prev.y - cur.y) + abs(prev.x - cur.x) + 1\n        prev = cur\n\n    return button_presses", "def tv_remote(word):\n    caps, cases, shift = coords[\"\u2191\"], (str.isupper, str.islower), 0\n    moves, current = 0, (0, 0)\n    for char in word:\n        target = coords[char.lower()]\n        if cases[shift](char):\n            moves, current = 1 + moves + distance(current, caps), caps\n            shift = 1 - shift\n        moves, current = moves + distance(current, target), target\n    return moves + len(word)\n\nkeyboard = (\"abcde123\", \"fghij456\", \"klmno789\", \"pqrst.@0\", \"uvwxyz_/\", \"\u2191 \")\ncoords = {char: (line.index(char), y) for y, line in enumerate(keyboard) for char in line}\n\ndef distance(pos1, pos2):\n    return abs(pos2[0] - pos1[0]) + abs(pos2[1] - pos1[1])", "def tv_remote(word):\n    matrix = [\n             ['a', 'b', 'c', 'd', 'e', '1', '2', '3'],\n             ['f', 'g', 'h', 'i', 'j', '4', '5', '6'],\n             ['k', 'l', 'm', 'n', 'o', '7', '8', '9'],\n             ['p', 'q', 'r', 's', 't', '.', '@', '0'],\n             ['u', 'v', 'w', 'x', 'y', 'z', '_', '/'],\n             ['aA', ' '],\n             ]\n\n    actions = ([0, 0],)\n    upper_mode = False\n    press_ok = 0\n    func = lambda x, y: (abs(x[0]-y[0]) + abs(x[1]-y[1]))\n\n    for char in word:\n        for i in range(6):\n            if char.lower() in matrix[i]:\n                if char.isupper() and not upper_mode:\n                    actions += ([5, 0],)\n                    upper_mode = True\n                    press_ok += 1\n                    actions += ([i, matrix[i].index(char.lower())],)\n                    press_ok += 1\n                elif char.isupper() and upper_mode:\n                    actions += ([i, matrix[i].index(char.lower())],)\n                    press_ok += 1\n                elif char.islower() and upper_mode:\n                    actions += ([5, 0],)\n                    upper_mode = False\n                    press_ok += 1\n                    actions += ([i, matrix[i].index(char.lower())],)\n                    press_ok += 1\n                elif char.islower() and not upper_mode:\n                    actions += ([i, matrix[i].index(char.lower())],)\n                    press_ok += 1\n                else:\n                    actions += ([i, matrix[i].index(char.lower())],)\n                    press_ok += 1\n\n    return sum([func(i[0], i[1]) for i in list(zip(actions, actions[1:]))]) + press_ok", "def tv_remote(s):\n    d = {y: (i, x) for i, j in enumerate([\"abcde123\", \"fghij456\", \"klmno789\", \"pqrst.@0\", \"uvwxyz_/\", \"# *!$%^&\"]) for x, y in enumerate(j)}\n    does = lambda a, b: (abs(d[a][0] - d[b][0]) + (abs(d[a][1] - d[b][1]))) + 1\n    status, c = False, 0\n    for i, j in zip(s, 'a' + s):\n        t, t1 = i.lower(), j.lower()\n        if i.isupper():\n            if not status : t1, status, c = \"#\", 1, c + does('#', t1)\n        elif i.islower():\n            if status : t1, status, c = '#', 0, c + does('#', t1)\n        c += does(t1, t)       \n    return c", "D = {v:(r, c) for r, row in enumerate('''abcde123 fghij456 klmno789 pqrst.@0 uvwxyz_/'''.split() +['  ']) for c, v in enumerate(row)}\n\ndef tv_remote(words):\n    t, lr, lc, lower = 0, 0, 0, True\n\n    for e in words:\n        if e.isalpha() and lower != e.islower():\n            t, lr, lc = move(t, lr, lc, 5, 0)\n            lower = not lower\n        t, lr, lc = move(t, lr, lc, *D[e.lower()])\n    return t\n    \ndef move(t, lr, lc, r, c):\n    return t + abs(lr - r) + abs(lc - c) + 1, r, c"]