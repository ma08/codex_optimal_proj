["def main():\n    import sys\n    input = sys.stdin.readline\n    \n    def solve():\n        n = int(input())\n        maxx = 10**5\n        minx = -10**5\n        maxy = 10**5\n        miny = -10**5\n        \n        for _ in range(n):\n            x, y, f1, f2, f3, f4 = map(int, input().split())\n            if not f1:\n                minx = max(minx, x)\n            if not f2:\n                maxy = min(maxy, y)\n            if not f3:\n                maxx = min(maxx, x)\n            if not f4:\n                miny = max(miny, y)\n        \n        if minx > maxx or miny > maxy:\n            print(0)\n        else:\n            print(1, minx, miny)\n        \n    \n    for _ in range(int(input())):\n        solve()\n    \n    return 0\n\nmain()", "import sys\ninput = sys.stdin.readline\n\nq=int(input())\n\nfor testcases in range(q):\n    n=int(input())\n    ROBOT=[list(map(int,input().split())) for i in range(n)]\n\n    XMAX=10**5\n    XMIN=-10**5\n    YMAX=10**5\n    YMIN=-10**5\n\n    for x,y,a,b,c,d in ROBOT:\n        if a==0:\n            XMIN=max(XMIN,x)\n        if b==0:\n            YMAX=min(YMAX,y)\n        if c==0:\n            XMAX=min(XMAX,x)\n        if d==0:\n            YMIN=max(YMIN,y)\n\n    #print(XMIN,XMAX,YMIN,YMAX)\n\n    if XMIN>XMAX or YMIN>YMAX:\n        print(0)\n    else:\n        print(1,XMIN,YMIN)\n\n    \n", "y = 10**5\nT = int(input())\nfor _ in range(T):\n  x = [-y, -y, y, y]\n  n = int(input())\n  for _ in range(n):\n    a = list(map(int, input().split()))\n    if not a[2]:\n      x[0] = max(x[0], a[0])\n    if not a[3]:\n      x[3] = min(x[3], a[1])\n    if not a[4]:\n      x[2] = min(x[2], a[0])\n    if not a[5]:\n      x[1] = max(x[1], a[1])\n  if x[0] <= x[2] and x[1] <= x[3]:\n    print(1, x[0], x[1])\n  else:  \n    print(0)\n  \n", "q = int(input())\nfor _ in range(q):\n    n = int(input())\n    lm = dm = -100000\n    rm = um = 100000\n    for _ in range(n):\n        x, y, l, u, r, d = list(map(int, input().split()))\n        if l == 0:\n            lm = max(lm, x)\n        if r == 0:\n            rm = min(rm, x)\n        if u == 0:\n            um = min(um, y)\n        if d == 0:\n            dm = max(dm, y)\n    if lm > rm or um < dm:\n        print(0)\n    else:\n        print(1, lm, dm)\n\n", "import sys\ninput = sys.stdin.readline\n\nQ = int(input())\nfor _ in range(Q):\n    N = int(input())\n    minx, miny, maxx, maxy = -10**5, -10**5, 10**5, 10**5\n    for __ in range(N):\n        X, Y, L, U, R, D = list(map(int, input().split()))\n        if L == 0:\n            minx = max(minx, X)\n        if R == 0:\n            maxx = min(maxx, X)\n        if U == 0:\n            maxy = min(maxy, Y)\n        if D == 0:\n            miny = max(miny, Y)\n    if maxx >= minx and maxy >= miny:\n        print(1, minx, miny)\n    else:\n        print(0)\n\n\n", "from sys import stdin\nc=int(stdin.readline().strip())\nfor cas in range(c):\n    n=int(stdin.readline().strip())\n    s=[list(map(int,stdin.readline().strip().split())) for i in range(n)]\n    mn=-10**5\n    interval=[[mn,-mn],[mn,-mn]]\n    flag=True\n    for i in s:\n        if i[2]==0:\n            if (interval[0][1]<i[0]):\n                flag=False\n                break\n            else:\n                interval[0][0]=max(i[0],interval[0][0])\n        if i[3]==0:\n            if( interval[1][0]>i[1]):\n                flag=False\n                break\n            else:\n                interval[1][1]=min(interval[1][1],i[1])\n        if i[4]==0:\n            if interval[0][0]>i[0]:\n                flag=False\n                break\n            else:\n                interval[0][1]=min(interval[0][1],i[0])\n        if i[5]==0:\n            if interval[1][1]<i[1]:\n                flag=False\n                break\n            else:\n                interval[1][0]=max(interval[1][0],i[1])\n                \n\n    if flag:\n        print(1,interval[0][0],interval[1][0])\n    else:\n        print(0)\n    \n            \n            \n", "for _ in range(int(input())):\n    n = int(input())\n    maxx, minx = 100000, -100000\n    maxy, miny = 100000, -100000\n    for _ in range(n):\n        xi, yi, d, r, u, l = tuple(map(int, input().split()))\n        if d == 0:\n            minx = xi if xi > minx else minx\n        if r == 0:\n            maxy = yi if yi < maxy else maxy\n        if u == 0:\n            maxx = xi if xi < maxx else maxx\n        if l == 0:\n            miny = yi if yi > miny else miny\n    if miny <= maxy and minx <= maxx:\n        print(1, minx, miny)\n    else:\n        print(0)", "import sys\n \nt = int(input())\nfor _ in range(t):\n    n = int(sys.stdin.readline())\n    xMin, xMax, yMin, yMax = -100000, 100000, -100000, 100000\n    x, y = 0, 0\n    res = 1\n    for i in range(n):\n        xi, yi, xMinus, yPlus, xPlus, yMinus = list(map(int, sys.stdin.readline().split()))\n        if xMinus == 0:\n            xMin = max(xi, xMin)\n        if xPlus == 0:\n            xMax = min(xi, xMax)\n        if yMinus == 0:\n            yMin = max(yi, yMin)\n        if yPlus == 0:\n            yMax = min(yi, yMax)\n    if xMin<=xMax and yMin <= yMax:\n        print(1, xMin, yMin)\n    else:\n        print(0)\n \n \n \n## (x\u22121, y)\n## (x, y+1)\n## (x+1, y)\n## (x, y\u22121)\n", "def main():\n    q = int(input())\n    for i in range(q):\n        n = int(input())\n        l_x = -10 ** 5\n        r_x = 10 ** 5\n        l_y = -10 ** 5\n        r_y = 10 ** 5\n        flag = True\n        for i in range(n):\n            x, y, f1, f2, f3, f4 = map(int, input().split())\n            if flag:\n                if f1 == f3 == 0:\n                    if not(x >= l_x and x <= r_x):\n                        flag = False\n                    else:\n                        l_x = x\n                        r_x = x\n                elif f1 == 1 and f3 == 0:\n                    r_x = min(x, r_x)\n                elif f1 == 0 and f3 == 1:\n                    l_x = max(x, l_x)\n                if f2 == f4 == 0:\n                    if not(y >= l_y and y <= r_y):\n                        flag = False\n                    else:\n                        l_y = y\n                        r_y = y\n                elif f2 == 1 and f4 == 0:\n                    l_y = max(y, l_y)\n                elif f2 == 0 and f4 == 1:\n                    r_y = min(y, r_y)\n                if l_x > r_x or l_y > r_y:\n                    flag = False\n        if flag:\n            print(1, l_x, l_y)\n        else:\n            print(0)\n\nmain()", "import math\nimport sys\n\nn = int(sys.stdin.readline().strip())\nfor i in range(n):\n\tn = int(sys.stdin.readline().strip())\n\tmx = -math.inf\n\tpx = math.inf\n\tmy = -math.inf\n\tpy = math.inf\n\t# x, y, mx, py, px, my\n\trobots = [list(map(int, sys.stdin.readline().split())) for x in range(n)]\n\tfor robot in robots:\n\t\tif robot[2] == 0:\n\t\t\tmx = max(robot[0], mx)\n\n\t\tif robot[5] == 0:\n\t\t\tmy = max(robot[1], my)\n\n\t\tif robot[4] == 0:\n\t\t\tpx = min(robot[0], px)\n\n\t\tif robot[3] == 0:\n\t\t\tpy = min(robot[1], py)\n\tif mx > px or my > py:\n\t\tprint(0)\n\telse:\n\t\tprint(1, max(-100000, mx), max(-100000, my))\n", "q = int(input())\nfor i in range(q):\n    n = int(input())\n    rowdown = -10 ** 5\n    rowup = 10 ** 5\n    colmnleft = -10 ** 5\n    colmnright = 10 ** 5\n    for j in range(n):\n        x, y, left, up, right, down = list(map(int, input().split()))\n        if not left:\n            colmnleft = max(colmnleft, x)\n        if not right:\n            colmnright = min(colmnright, x)\n        if not up:\n            rowup = min(rowup, y)\n        if not down:\n            rowdown = max(rowdown, y)\n    if rowdown > rowup or colmnleft > colmnright:\n        print(0)\n    else:\n        print(1, colmnleft, rowdown)\n", "import sys\ninput = lambda: sys.stdin.readline().strip()\n\nT = int(input())\nfor _ in range(T):\n    n = int(input())\n    minx = -(10**5)\n    maxx = 10**5\n    miny = -(10**5)\n    maxy = 10**5\n    for i in range(n):\n        x, y, f1, f2, f3, f4 = list(map(int, input().split()))\n        if f1==0: minx = max(minx, x)\n        if f2==0: maxy = min(maxy, y)\n        if f3==0: maxx = min(maxx, x)\n        if f4==0: miny = max(miny, y)\n    if minx>maxx or miny>maxy: print(0)\n    else:\n        print(1, minx, miny)\n", "from sys import stdin\nfrom math import inf\n\nq = int(stdin.readline())\n\nclass Rect:\n    def __init__(self, x1 = -inf, y1 = -inf, x2 = inf, y2 = inf):\n        if x1 > x2:\n            x1, x2 = x2, x1\n        if y1 > y2:\n            y1, y2 = y2, y1\n\n        self.x1 = x1\n        self.y1 = y1\n        self.x2 = x2\n        self.y2 = y2\n\n    def __str__(self):\n        return \"(%f, %f, %f, %f)\" % (self.x1, self.y1, self.x2, self.y2)\n\ndef intersect(r1, r2):\n    if r1 is None or r2 is None:\n        return None\n    if r1.x2 < r2.x1 or r2.x2 < r1.x1:\n        return None\n    if r1.y2 < r2.y1 or r2.y2 < r1.y1:\n        return None\n    return Rect(max(r1.x1, r2.x1), max(r1.y1, r2.y1), min(r1.x2, r2.x2), min(r1.y2, r2.y2))\n\nfor i in range(q):\n    n = int(stdin.readline())\n\n    inter = Rect()\n    for i in range(n):\n        x, y, f1, f2, f3, f4 = list(map(int, stdin.readline().split()))\n        curRect = Rect()\n        if f1 == 0:\n            curRect.x1 = x\n        if f2 == 0:\n            curRect.y2 = y\n        if f3 == 0:\n            curRect.x2 = x\n        if f4 == 0:\n            curRect.y1 = y\n        inter = intersect(inter, curRect)\n    if inter is None:\n        print(\"0\")\n    else:\n        print(\"1 %d %d\" % (int(max(inter.x1, -10**5)), int(max(inter.y1, -10**5))))\n", "inf = 100000\nfor q in range(int(input())):\n    n = int(input())\n    l,u,r,d = -inf,inf,inf,-inf\n    for i in range(n):\n        x,y,f1,f2,f3,f4 = list(map(int,input().split()))\n        if f1 == 0:\n            l = max(l,x)\n        if f2 == 0:\n            u = min(u,y)\n        if f3 == 0:\n            r = min(r,x)\n        if f4 == 0:\n            d = max(d,y)\n    if d>u or l>r:\n        print(0)\n    else:\n        print(1,l,d)\n\n\n\n", "a = int(input())\nfor i in range(a):\n    d = []\n    b = int(input())\n    for j in range(b):\n        d.append(list(map(int,input().split())))\n    mix = -100000\n    miy = mix\n    maxx = 100000\n    maxy = maxx\n    f = True\n    for j in range(b):\n        x = d[j][0]\n        y = d[j][1]\n        if d[j][2] == 0:\n            if x > maxx:\n                print(0)\n                f = False\n                break\n            mix = max(mix, x)\n        if d[j][3] == 0:\n            if y < miy:\n                print(0)\n                f = False\n                break\n            maxy = min(maxy, y)\n        if d[j][5] == 0:\n            if y > maxy:\n                print(0)\n                f = False\n                break\n            miy = max(miy, y)\n        if d[j][4] == 0:\n            if x < mix:\n                print(0)\n                f = False\n                break\n            maxx = min(maxx, x)\n    if f:\n        print(1, mix, miy)\n", "''' CODED WITH LOVE BY SATYAM KUMAR '''\n\nfrom sys import stdin, stdout\nimport cProfile, math\nfrom collections import Counter,defaultdict,deque\nfrom bisect import bisect_left,bisect,bisect_right\nimport itertools\nfrom copy import deepcopy\nfrom fractions import Fraction\nimport sys, threading\nimport operator as op\nfrom functools import reduce\nsys.setrecursionlimit(10**6) # max depth of recursion\nthreading.stack_size(2**27)  # new thread will get stack of such size\nfac_warmup = False\nprintHeap = str()\nmemory_constrained = False\nP = 10**9+7\nimport sys\n\nclass merge_find:\n    def __init__(self,n):\n        self.parent = list(range(n))\n        self.size = [1]*n\n        self.num_sets = n\n        self.lista = [[_] for _ in range(n)]\n    def find(self,a):\n        to_update = []\n        while a != self.parent[a]:\n            to_update.append(a)\n            a = self.parent[a]\n        for b in to_update:\n            self.parent[b] = a\n        return self.parent[a]\n    def merge(self,a,b):\n        a = self.find(a)\n        b = self.find(b)\n        if a==b:\n            return\n        if self.size[a]<self.size[b]:\n            a,b = b,a\n        self.num_sets -= 1\n        self.parent[b] = a\n        self.size[a] += self.size[b]\n        self.lista[a] += self.lista[b]\n    def set_size(self, a):\n        return self.size[self.find(a)]\n    def __len__(self):\n        return self.num_sets\n\ndef display(string_to_print):\n    stdout.write(str(string_to_print) + \"\\n\")\n\ndef primeFactors(n): #n**0.5 complex \n    factors = dict()\n    for i in range(2,math.ceil(math.sqrt(n))+1):  \n        while n % i== 0: \n            if i in factors:\n                factors[i]+=1\n            else: factors[i]=1\n            n = n // i \n    if n>2:\n        factors[n]=1\n    return (factors)\n\ndef all_factors(n):    \n    return set(reduce(list.__add__, \n                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))\n\ndef fibonacci_modP(n,MOD):\n    if n<2: return 1\n    #print (n,MOD)\n    return (cached_fn(fibonacci_modP, (n+1)//2, MOD)*cached_fn(fibonacci_modP, n//2, MOD) + cached_fn(fibonacci_modP, (n-1) // 2, MOD)*cached_fn(fibonacci_modP, (n-2) // 2, MOD)) % MOD\n\ndef factorial_modP_Wilson(n , p): \n    if (p <= n): \n        return 0\n    res = (p - 1) \n    for i in range (n + 1, p): \n        res = (res * cached_fn(InverseEuler,i, p)) % p \n    return res \n\ndef binary(n,digits = 20):\n    b = bin(n)[2:]\n    b = '0'*(digits-len(b))+b\n    return b\n\ndef isprime(n):\n    \"\"\"Returns True if n is prime.\"\"\"\n    if n < 4:\n        return True\n    if n % 2 == 0:\n        return False\n    if n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True\n\ndef generate_primes(n):\n    prime = [True for i in range(n+1)] \n    p = 2\n    while (p * p <= n): \n        if (prime[p] == True): \n            for i in range(p * 2, n+1, p): \n                prime[i] = False\n        p += 1\n    return prime\n\nfactorial_modP = []\ndef warm_up_fac(MOD):\n    nonlocal factorial_modP,fac_warmup\n    if fac_warmup: return\n    factorial_modP= [1 for _ in range(fac_warmup_size+1)]\n    for i in range(2,fac_warmup_size):\n        factorial_modP[i]= (factorial_modP[i-1]*i) % MOD\n    fac_warmup = True\n\ndef InverseEuler(n,MOD):\n    return pow(n,MOD-2,MOD)\n\ndef nCr(n, r, MOD):\n    nonlocal fac_warmup,factorial_modP\n    if not fac_warmup:\n        warm_up_fac(MOD)\n        fac_warmup = True\n    return (factorial_modP[n]*((pow(factorial_modP[r], MOD-2, MOD) * pow(factorial_modP[n-r], MOD-2, MOD)) % MOD)) % MOD\n\ndef test_print(*args):\n    if testingMode:\n        print(args)\n\ndef display_list(list1, sep=\" \"):\n    stdout.write(sep.join(map(str, list1)) + \"\\n\")\n\ndef display_2D_list(li):\n    for i in li:\n        print(i)\ndef prefix_sum(li):\n    sm = 0\n    res = []\n    for i in li:\n        sm+=i\n        res.append(sm)\n    return res\n\ndef get_int():\n    return int(stdin.readline().strip())\n\ndef get_tuple():\n    return map(int, stdin.readline().split())\n\ndef get_list():\n    return list(map(int, stdin.readline().split()))\nimport heapq,itertools\npq = []                         # list of entries arranged in a heap\nentry_finder = {}               # mapping of tasks to entries\nREMOVED = '<removed-task>' \ndef add_task(task, priority=0):\n    'Add a new task or update the priority of an existing task'\n    if task in entry_finder:\n        remove_task(task)\n    count = next(counter)\n    entry = [priority, count, task]\n    entry_finder[task] = entry\n    heapq.heappush(pq, entry)\n\ndef remove_task(task):\n    'Mark an existing task as REMOVED.  Raise KeyError if not found.'\n    entry = entry_finder.pop(task)\n    entry[-1] = REMOVED\n\ndef pop_task():\n    'Remove and return the lowest priority task. Raise KeyError if empty.'\n    while pq:\n        priority, count, task = heapq.heappop(pq)\n        if task is not REMOVED:\n            del entry_finder[task]\n            return task\n    raise KeyError('pop from an empty priority queue')\nmemory = dict()\ndef clear_cache():\n    nonlocal memory\n    memory = dict()\ndef cached_fn(fn, *args):\n    nonlocal memory\n    if args in memory:\n        return memory[args]\n    else:\n        result = fn(*args)\n        memory[args] = result\n        return result\n\ndef ncr (n,r):\n    return math.factorial(n)/(math.factorial(n-r)*math.factorial(r))\ndef binary_serach(i,li):\n    #print(\"Search for \",i)\n    fn = lambda x: li[x]-x//i\n    x = -1\n    b = len(li)\n    while b>=1:\n        #print(b,x)\n        while b+x<len(li) and fn(b+x)>0: #Change this condition 2 to whatever you like\n            x+=b\n        b=b//2\n    return x\n\n# -------------------------------------------------------------- MAIN PROGRAM\nTestCases = True\ntestingMode = False\nfac_warmup_size = 10**5+100\noptimiseForReccursion = False #Can not be used clubbed with TestCases # WHen using recursive functions, use Python 3\nfrom math import factorial\n\ndef main():\n    n = get_int()\n    minx = -10**5\n    maxx = 10**5\n    miny = -10**5\n    maxy = 10**5\n    for _ in range(n):\n        xi, yi, nx, py, px, ny = get_tuple()\n        if (nx == 0):\n            minx = max(minx, xi)\n        if (ny == 0):\n            miny = max(miny, yi)\n        if (px == 0):\n            maxx = min(maxx, xi)\n        if (py == 0):\n            maxy = min(maxy, yi)\n    if (maxx-minx)>=0 and (maxy-miny)>=0:\n        print(1,minx,miny)\n    else:\n        print(0)\n\n\n\n\n\n\n# --------------------------------------------------------------------- END=\n\n\nif TestCases: \n    for i in range(get_int()): \n        cProfile.run('main()') if testingMode else main() \nelse: (cProfile.run('main()') if testingMode else main()) if not optimiseForReccursion else threading.Thread(target=main).start()", "q = int(input())\nfor _ in range(q):\n    n = int(input())\n    x = []\n    y = []\n    f = []\n    for _ in range(n):\n        temp = tuple(map(int,input().split()))\n        x.append(temp[0])\n        y.append(temp[1])\n        f.append(temp[2:])\n    x_min = y_min = -100000\n    x_max = y_max = 100000\n    for i in range(n):\n        if f[i][0] == 0:x_min = max(x_min,x[i])\n        if f[i][1] == 0:y_max = min(y_max,y[i])\n        if f[i][2] == 0:x_max = min(x_max,x[i])\n        if f[i][3] == 0:y_min = max(y_min,y[i])\n    if x_max < x_min:\n        print(0)\n        continue\n    elif y_max < y_min:\n        print(0)\n        continue\n    else:\n        print('1 %d %d' % (x_min,y_min))\n\n\n", "q = int(input())\nfor i in range(q):\n    n = int(input())\n    l = -100000\n    t = 100000\n    r = 100000\n    b = -100000\n    for j in range(n):\n        x, y, f1, f2, f3, f4 = list(map(int, input().split()))\n        if f1 == 0:\n            if l <= x:\n                l = x\n        if f2 == 0:\n            if t >= y:\n                t = y\n        if f3 == 0:\n            if r >= x:\n                r = x\n        if f4 == 0:\n            if b <= y:\n                b = y\n    cx,cy=None,None\n    ans = 1\n    if l <= r:\n        cx = l\n    else:\n        ans =0\n    if b <= t:\n        cy = b\n    else:\n        ans = 0\n    if ans == 0:\n        print(ans)\n    else:\n        print(ans, cx, cy)\n\n", "inf=10**5\nimport sys\nfor _ in range(int(input())):\n    n=int(sys.stdin.readline())\n    a=[]\n    for i in range(n):\n        a.append(list(map(int,sys.stdin.readline().split())))\n    xl=-inf\n    xh=10**5\n    yl=-inf\n    yh=10**5\n    for i in range(n):\n        if a[i][2]==0:\n            xl=max(xl,a[i][0])\n        else:\n            xl=max(xl,-inf)\n        if a[i][3]==0:\n            yh=min(yh,a[i][1])\n        else:\n            yh=min(yh,10**5)\n            \n        if a[i][4]==0:\n            xh=min(xh,a[i][0])\n        else:\n            xh=min(xh,10**5)\n        if a[i][5]==0:\n            yl=max(yl,a[i][1])\n        else:\n            yl=max(yl,-inf)\n            \n        # print(xl,xh,yl,yh)        \n    if xl<=xh and yl<=yh:\n        print(1,xl,yl)\n    else:\n        print(0)\n"]