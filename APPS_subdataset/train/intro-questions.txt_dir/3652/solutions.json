["def button_sequences(seqR, seqB):\n    pattern, state = '', ''\n    toBool = lambda seq : [i == '1' for i in seq]\n    for red, blue in zip(toBool(seqR), toBool(seqB)):\n        if red and state == 'R' or blue and state == 'B':\n            continue\n        state = 'R' if red else 'B' if blue else ''\n        pattern += state\n    return pattern", "def button_sequences(red, blue):\n    s=''\n    r,b=False,False\n    for i in range(len(red)):\n        if red[i]=='0':\n            r=False\n        if blue[i]=='0':\n            b=False\n        if red[i]=='1' and  not r and not b:\n            r=True\n            s+='R'\n        elif blue[i]=='1' and not r and not b:\n            b=True\n            s+='B'\n    return s", "def button_sequences(seqR, seqB):\n    A, B, res = 1, 1, \"\"\n    for x, y in zip(map(int, seqR), map(int, seqB)):\n        if A and B and x: y = 0\n        if A and x and not y: res += 'R'\n        if B and not x and y: res += 'B'\n        if not (x and y): A, B = not x, not y\n    return res", "def button_sequences(seqR, seqB):\n    state, s = '', ''\n    for r, b in zip([c == '1' for c in seqR], [c == '1' for c in seqB]):\n        if (state == 'R' and not r) or (state == 'B' and not b): state = ''\n        if not state and r :\n            s, state = s + 'R', 'R'\n        elif not state and b: \n            s, state = s + 'B', 'B'\n    return s\n", "from itertools import groupby\n\ndef button_sequences(seq_r, seq_b):\n    pairs = [''.join(pair) for pair in zip(seq_r, seq_b)]\n    blinks = (('' if rb == '00' else 'B' if rb == '01' else 'R' if rb == '10' or prev == '00' else '-')\n              for rb, prev in zip(pairs, ['00'] + pairs))\n    return ''.join(key for key, _ in groupby(x for x in blinks if x != '-'))", "def button_sequences(*seqRB):\n    wasR, wasB, seq = 0, 0, []\n    for r,b in zip(*map(lambda s: map(int,s),seqRB)):\n        what             = 'BR'[r]                                            # Ensure precedence of red button\n        realeaseOneofTwo = wasR+wasB == 2 and r+b == 1 and what != seq[-1]    # Only if the remaining button isn't already archived\n        freshPress       = not (wasR+wasB) and r+b\n        switchButtons    = b+r==1 and (wasR,wasB)==(b,r)\n        \n        if realeaseOneofTwo or freshPress or switchButtons:\n            seq.append(what)\n        wasR,wasB = r,b\n        \n    return ''.join(seq)", "button_sequences=lambda R,B:(lambda r,f:r.sub(r'(.)\\1+',r'\\1',f.reduce(lambda x,y:x+('_'if y==('0','0')else'R'if y==('1','0')else'B'if y==('0','1')else'R'if x[-1:]in['','_','R']else'B'),zip(R,B),'')).replace('_',''))(__import__('re'),__import__('functools'))", "def button_sequences(r, b):\n    r_on, b_on = False, False\n    res = ''\n    for i in range(len(r)):\n        ri, bi = int(r[i]), int(b[i])\n        if not r_on|b_on:\n            if ri:\n                res += 'R'\n                r_on = True\n            elif bi:\n                res += 'B'\n                b_on = True\n        elif r_on:\n            if not ri:\n                r_on = False\n                if bi:\n                    b_on = True\n                    res += 'B'\n        elif b_on:\n            if not bi:\n                b_on = False\n                if ri:\n                    r_on = True\n                    res += 'R'\n    return res", "def button_sequences(seqR, seqB):\n\n    result=\"\"\n    prec_r=\"0\"\n    prec_b=\"0\"\n    \n    seqR=list(seqR)\n    seqB=list(seqB)\n    \n    for r, b in zip (seqR, seqB):\n        if r==b and r==\"1\" and prec_r!=\"1\" and prec_b!=\"1\":\n            result+=\"R\"\n        \n        elif r!=b and r==\"1\" and prec_r!=\"1\":\n            result+=\"R\"\n            \n        elif r!=b and b==\"1\" and prec_b!=\"1\":\n            result+=\"B\"\n            \n        elif prec_r==prec_b and prec_r==\"1\" and r==\"1\" and b!=r and result[len(result)-1]!=\"R\":\n            result+=\"R\"\n            \n        elif prec_r==prec_b and prec_r==\"1\" and b==\"1\" and b!=r and result[len(result)-1]!=\"B\":\n            result+=\"B\"\n        \n        prec_r=r\n        prec_b=b\n    \n    return result\n", "def button_sequences(seqR, seqB):\n    # You may code here\n    seq = ''\n    leds = ['R','B']\n    action = [None,None]\n    for r,b in zip(seqR,seqB):\n        r = int(r)\n        b = int(b)\n        for ind,button in enumerate([r,b]):\n            if button and not action[ind]: action[ind] = 'press'\n            elif button and action[ind]: action[ind] = 'held'\n            elif action[ind] and not button: action[ind] = 'release'\n        for ind in [0,1]:\n            if (action[ind] == 'press') and (action[ind-1] != 'held'): \n                seq += leds[ind]\n                break\n            elif (action[ind] == 'held') and (action[ind-1] == 'release'):\n                if seq[-1] == leds[ind]: continue\n                seq += leds[ind]\n                break\n        \n        \n        if action[0] == 'release': action[0] = None\n        if action[1] == 'release': action[1] = None\n    return seq"]