["def infected_zeroes(s):\n    m=0; l=0\n    for i,n in enumerate(s):\n        if n==0: m=i if l==0 else max(m, (i-l+1)//2); l=i+1\n    return max(m,len(s)-l)", "def infected_zeroes(lst):\n    left, *enclosed, right = \"\".join(str(digit) for digit in lst).split(\"0\")\n    return max(len(left), len(right), *((len(ones) + 1)//2 for ones in enclosed))", "from math import ceil\ndef infected_zeroes(li):\n    zeros = [i for i,j in enumerate(li) if not j]\n    l = [ceil((zeros[i+1]-j-1) / 2) for i,j in enumerate(zeros[:-1])]\n    return max([zeros[0],len(li)-zeros[-1]-1]+l)", "import re\n\ndef infected_zeroes(lst):\n    return max(((len(m)+1)//2 if s and e else len(m) for s,m,e in re.findall(r'(^|0)(1+)(0|$)', ''.join(map(str,lst)).replace(\"0\",\"00\"))), default=0)", "def infected_zeroes(a):\n    zeros = [i for i, n in enumerate(a) if not n]\n    return len(zeros) and max((y - x) // 2 for x, y in\n            zip([-1 - zeros[0]] + zeros, zeros + [2*len(a) -1 - zeros[-1]]))", "from math import ceil\n\n\ndef infected_zeroes(lst):\n    # convert out list to a string for processing and split on \"infected\" zeroes\n    chunks_of_ones = ''.join([str(l) for l in lst]).split('0')\n\n    longest_chunk_of_ones = max([len(c) for c in chunks_of_ones])\n\n    # if our longest run is the starting or ending chunk, num_turns is going to be the length of that chunk\n    # however, all other chunks will be getting infected from both sides, so in those cases we divide by two\n    num_turns = max(len(chunks_of_ones[0]), ceil(longest_chunk_of_ones / 2), len(chunks_of_ones[-1]))\n    \n    return num_turns", "def infected_zeroes(a):\n    s = ''.join(str(e) for e in a)\n    return max([len(w) + 1 for w in s.split('0')] + [s.find('0') * 2, s[::-1].find('0') * 2]) // 2", "def infected_zeroes(lst):\n\n    duzinaNiza = len(lst)\n    if duzinaNiza == 1:\n        return 0\n    result = 0\n    clanNiza = lst[0]\n    br_out = 0\n    i = 0\n    br_poc = 0\n    br_kraj = 0\n\n    while clanNiza == 1 :\n        br_out += 1\n        i += 1\n        clanNiza = lst[i]\n    br_poc = br_out\n\n    clanNiza = lst[duzinaNiza - 1]\n    br_out = 0\n    j = duzinaNiza - 1\n    while clanNiza == 1 :\n        br_out += 1\n        j -= 1\n        clanNiza = lst[j]\n    br_kraj = br_out\n\n    br_in = 0\n    br_sred_par = 0\n    br_sred_nepar = 0\n    for k in range(i+1, j+1) :\n        if lst[k] == 1 :\n            br_in += 1\n        else:\n            if br_in % 2 == 0 :\n                if br_sred_par <= br_in :\n                    br_sred_par = br_in\n                    br_in = 0\n            else:\n                if br_sred_nepar <= br_in :\n                    br_sred_nepar = br_in\n                    br_in = 0\n\n    maxOut = 0\n    maxIn = 0\n    if br_poc > br_kraj :\n        maxOut = br_poc\n    else:\n        maxOut = br_kraj\n    if br_sred_nepar > br_sred_par :\n        maxIn = br_sred_nepar\n    else:\n        maxIn = br_sred_par\n\n    if maxIn % 2 == 0 :\n        if maxIn / 2 >= maxOut :\n            return maxIn//2\n        else:\n            return maxOut\n    else:\n        if maxIn // 2 + 1 >= maxOut : \n            return maxIn//2 + 1\n        else:\n            return maxOut\n\n", "from re import sub\nfrom math import ceil\n\n\ndef infected_zeroes(lst):\n    # convert out list to a string for processing and split on \"infected\" zeroes\n    chunks_of_ones = ''.join([str(l) for l in lst]).split('0')\n\n    longest_chunk_of_ones = max([len(c) for c in chunks_of_ones])\n\n    # if our longest run is the starting or ending chunk, num_turns is going to be the length of that chunk\n    # however, all other chunks will be getting infected from both sides, so in those cases we divide by two\n    num_turns = max(len(chunks_of_ones[0]), ceil(longest_chunk_of_ones / 2), len(chunks_of_ones[-1]))\n    \n    return num_turns", "def infected_zeroes(lst):\n    one = \"\".join(str(d) for d in lst).split(\"0\")\n    return max(len(one[0]), len(one[-1]), *((len(o) + 1)//2 for o in one[1:-1]))"]