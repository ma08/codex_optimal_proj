["from string import ascii_lowercase\nclass Solution:\n    def removeDuplicates(self, S: str) -> str:\n        \n        dup = {2*ch for ch in ascii_lowercase}\n        \n        prev_length = -1\n        \n        while prev_length!=len(S):\n            prev_length = len(S)\n            for d in dup:\n                S = S.replace(d,'')\n        \n        return S", "class Solution:\n    def removeDuplicates(self, S: str) -> str:\n        \n        list1 = []\n        for i in S:\n            if len(list1) > 0:\n                if list1[-1] != i:\n                    list1.append(i)\n                else:\n                    list1 = list1[:-1]\n            else:\n                list1.append(i)\n            \n        result = ''\n        for i in list1:\n            result += i\n            \n        return result", "class Solution:\n    def removeDuplicates(self, S: str) -> str:\n        \n        stack = []\n        \n        for char in S:\n            \n            if char not in stack or char != stack[-1]:\n                stack += [char]\n            \n            else:\n                stack = stack[: -1]\n            #print(stack)\n            \n        return ''.join(stack)\n", "class Solution:\n    def removeDuplicates(self, S: str) -> str:\n        str_2_arr = list(S)\n        while True:\n            tmp_arr = []\n            i = 0\n            while i < len(str_2_arr):\n                if i < len(str_2_arr)-1 and str_2_arr[i] == str_2_arr[i+1]:\n                    i += 2\n                    continue\n                    \n                tmp_arr.append(str_2_arr[i])\n                i += 1\n  \n            if str(tmp_arr) == str(str_2_arr):\n                break\n              \n            str_2_arr =  list(tmp_arr)  \n            tmp_arr = []\n            \n        return ''.join(str_2_arr)\n            \n            \n            \n", "class Solution:\n    def removeDuplicates(self, S: str) -> str:\n        \n        if len(S) == 1:\n            return S\n        \n        stack = []\n        \n        for i in range(len(S)):\n            if len(stack) > 0 and stack[-1] == S[i]:\n                stack.pop()\n            else:\n                stack.append(S[i])\n        \n        return ''.join(stack)", "class Solution:\n    def removeDuplicates(self, S: str) -> str:\n            \n    \n        stack = []\n        for i in S:\n            \n            if len(stack) == 0:\n                stack.append(i)\n                \n            elif i == stack[-1]:\n                stack.pop()\n                \n            else:\n                stack.append(i)\n                \n                \n        return ''.join(stack)", "class Solution:\n    def removeDuplicates(self, S: str) -> str:\n        i = 0\n        while i < len(S) -1:\n            if S[i] != S[i+1]:\n                i += 1\n                continue\n            else:\n                S = S[0:i] + S[i+2:]\n                if i > 0:\n                    i -= 1\n                #print(S)\n        return S\n            \n", "class Solution:\n    def removeDuplicates(self, S: str) -> str:\n        stack = S[0]\n        for i in range(1,len(S)):\n            if len(stack) == 0:\n                stack += S[i]\n            elif stack and stack[-1] != S[i]:\n                stack += S[i]\n            elif stack:\n                stack = stack[:-1]\n        \n        return stack", "class Solution:\n    def removeDuplicates(self, S: str) -> str:\n        i = 0\n        while(i != len(S)-1 and len(S) > 1):\n            if(S[i] == S[i+1]):\n                S = S[:i] + S[i+2:]\n                i = 0 if(not i) else i-1\n            else:\n                i += 1\n        return S\n                \n            \n", "class Solution:\n    def removeDuplicates(self, string: str) -> str:\n        stack=deque()\n        stack.append(string[0])\n        index=0\n        for i in range(1,len(string)):\n            stack.append(string[i])\n            index+=1\n            if stack[index]==stack[index-1] and len(stack)>1:\n                for i in range(2):\n                    if stack:\n                        stack.pop()\n                        index-=1\n        s=''\n        for i in range(len(stack)):\n            s+=stack[i]\n        return (s)\n", "class Solution:\n    def removeDuplicates(self, S: str) -> str:\n        def delete(S,index):\n            S = S[:index]+S[index+1:]\n            return S\n    \n        stack = []\n        stack_top = -1\n        pointer = 0\n        while pointer < len(S):\n            if len(stack) == 0 or S[pointer] != stack[stack_top]:\n                stack.append(S[pointer])\n                pointer+=1\n                stack_top+=1\n            else:\n                S = delete(S,pointer-1)\n                pointer-=1\n                S = delete(S,pointer)\n                stack.pop(-1)\n                stack_top-=1\n        return S", "class Solution:\n    def removeDuplicates(self, S: str) -> str:\n        def delete(S,index):\n            S = S[:index]+S[index+1:]\n            return S\n    \n        stack = []\n        stack_top = len(stack)-1\n        pointer = 0\n        while pointer < len(S):\n            if len(stack) == 0 or S[pointer] != stack[stack_top]:\n                stack.append(S[pointer])\n                pointer+=1\n                stack_top+=1\n            else:\n                S = delete(S,pointer-1)\n                pointer-=1\n                S = delete(S,pointer)\n                stack.pop(-1)\n                stack_top-=1\n        return S", "class Solution:\n    def removeDuplicates(self, S: str) -> str:\n        # use a stack to save char, cnt\n        if not S:\n            return None\n        stack = []\n        for s in S:\n            if len(stack) > 0 and s == stack[-1][0]:\n                stack[-1][1] += 1\n            else:\n                stack.append([s, 1])\n            if stack[-1][1] == 2:\n                stack.pop()\n        return ''.join(char * num for char, num in stack)\n", "class Solution:\n    def removeDuplicates(self, S: str) -> str:\n        ## stack application\n        stack = []\n        for i in S:\n            if not stack:\n                stack.append(i)\n            elif i == stack[-1]:\n                stack.pop()\n            else:\n                stack.append(i)\n        \n        return ''.join(stack)", "class Solution:\n    def removeDuplicates(self, S: str) -> str:\n        temp = len(S)-1\n        temp1 = len(S)-1\n        while True:\n            temp1 = temp\n            if len(S)>=2:\n                i = 0\n                while i<temp:\n                    if S[i] == S[i+1]:\n                        S = S[:i] + S[i+2:]\n                        temp -= 2\n                    i+=1\n            if temp == temp1:\n                return S", "class Solution:\n    def removeDuplicates(self, S: str) -> str:\n        # \u043f\u0440\u0435\u043e\u0431\u0440\u0430\u0437\u043e\u0432\u044b\u0432\u0430\u0435\u043c \u0441\u0442\u0440\u043e\u043a\u0443 \u0432 \u0441\u043f\u0438\u0441\u043e\u043a\n        str_list = []\n        for i in range(len(S)):\n            str_list.append(S[i])\n        \n        # \u0443\u0431\u0438\u0440\u0430\u0435\u043c \u0434\u0443\u0431\u043b\u0438\n        i = 0\n        while i < len(str_list)-1:\n            if str_list[i] == str_list[i+1]:\n                del(str_list[i])\n                del(str_list[i])\n                if i > 0: i -= 1\n            else:\n                i += 1\n        \n        # \u043f\u0440\u0435\u043e\u0431\u0440\u0430\u0437\u043e\u0432\u044b\u0432\u0430\u0435\u043c \u043e\u0431\u0440\u0430\u0442\u043d\u043e \u0432 \u0441\u0442\u0440\u043e\u043a\u0443\n        str_end = ''\n        for i in range(len(str_list)):\n            str_end += str(str_list[i])\n        return str_end\n", "class Solution:\n    def removeDuplicates(self, s: str) -> str:\n        stack = [0]\n        for i in range(len(s)):\n            if s[i] == stack[-1]:\n                stack.pop()\n                continue\n            if s[i] != stack[-1]:\n                stack.append(s[i])\n                \n        res = ''\n        for i in range(1, len(stack)):\n            res+= stack[i]\n            \n        return res", "class Solution:\n    def removeDuplicates(self, s: str) -> str:\n        i = 0\n        while i+1<len(s):\n            if s[i] == s[i+1]:\n                s = s[:i]+s[i+2:]\n                if i>=1:\n                    i-=1\n            else:\n                i+=1\n        return s", "class Solution:\n    def removeDuplicates(self, S: str) -> str:\n        if len(S) <= 1:\n            return S\n        stack = []\n        stack.append(S[0])\n        \n        index = 1\n        while index < len(S):\n            stack.append(S[index])\n            # print(stack)\n            index += 1\n            \n            self.popDups(stack)\n        \n        s = ''\n        for c in stack:\n            s += c\n        \n        return s\n    \n    def popDups(self, stack):\n        \n        to_pop = True\n        while stack and to_pop:\n            this_item = stack.pop()\n            if len(stack) != 0:\n                next_item = stack[-1]\n                if this_item == next_item:\n                    stack.pop()\n                else:\n                    stack.append(this_item)\n                    to_pop = False\n            else:\n                stack.append(this_item)\n                to_pop = False\n        \n        \n        \n        \n        \n        # to_pop = True\n        # while to_pop and stack:\n        #     item = stack.pop()\n        #     if not stack:\n        #         stack.append(item)\n        #         to_pop = False\n        #     else:\n        #         next_item = stack.pop()\n        #         if item != next_item:\n        #             stack.append(next_item)\n        #             stack.append(item)\n        #             to_pop = False                    \n        \n        \n                \n                \n", "class Solution:\n    def removeDuplicates(self, s: str) -> str:\n        i = 0\n        while i<len(s)-1:\n            if s[i] == s[i+1]:\n                s = s[:i]+s[i+2:]\n                if i > 0: \n                    i-=1\n            else:\n                i+=1\n        return s", "class Solution:\n    def removeDuplicates(self, S: str) -> str:\n        while True:\n            counter = 0\n            \n            i = 1\n            remove_list = []\n            while i < len(S):\n                if S[i] == S[i-1]:\n                    counter = 1\n                    remove_list.append(i)\n                    i += 1\n                i += 1\n            for j in range(len(remove_list), 0, -1):\n                idx = remove_list[j-1]\n                if idx == len(S)-1:\n                    S = S[:idx-1]\n                else:\n                    S = S[:idx-1] + S[idx+1:]\n            if counter == 0: break\n        return S", "class Solution:\n    def removeDuplicates(self, S: str) -> str:\n        \n        remove_ls = []\n        start = True\n        tmp = S\n        while start or tmp != S:\n            start = False\n            tmp = S\n            i = 0\n            while i < len(S) - 1:\n                if S[i] == S[i+1]:\n                    if i + 2:\n                        S = S[:i] + S[i+2 :]\n                    else:\n                        S = S[:i]\n                i += 1\n            if tmp == S:\n                break\n            \n        # print(S)\n        return S\n        \n        # return res\n        # print(remove_ls)\n        \n        \n#         remove_ls = []\n#         for i in range(len(S) - 1):\n#             if S[i] == S[i + 1]:\n#                 if i not in remove_ls:\n#                     remove_ls.append(i)\n#                 remove_ls.append(i + 1) \n\n#             if remove_ls == []:\n#                 break\n\n#         res = \\\"\\\"\n#         for i in range(len(S)):\n#             if i not in remove_ls:\n#                 res += S[i]\n#         S = res    \n#         start = False\n", "class Solution:\n    def removeDuplicates(self, S: str) -> str:\n        count = 1\n        S = list(S)\n        while count != 0:\n            x = 0\n            while x < (len(S) - 1):\n                if S[x] == S[x + 1]:\n                    S.pop(x)\n                    S.pop(x)\n                    if x > 0:\n                        x -= 1\n                    count += 1\n                x += 1\n            if count > 1:\n                count = 1\n            else:\n                count = 0\n        return(''.join(S))\n", "class Solution:\n    def removeDuplicates(self, S: str) -> str:\n        st=list(S)\n        ud=1\n        while ud==1:\n            ud=0\n            i=1\n            while i <= len(st)-1:\n                if st[i]==st[i-1]:\n                    st.pop(i)\n                    st.pop(i-1)\n                    ud=1\n                i+=1\n        return ''.join(st)       ", "class Solution:\n    def removeDuplicates(self, S: str) -> str:\n        if len(S) < 2:\n            return S\n        newS = ''\n        count = 1\n        while len(S) > 1:\n            newS = ''\n            chain = False\n            for i in range(1, len(S)):\n                if S[i] != S[i-1]:\n                    if not chain:\n                        newS += S[i-1]\n                    else:\n                        if count % 2 == 1:\n                            newS += S[i-1]\n                    chain = False\n                    count = 1\n                else:\n                    chain = True\n                    count += 1\n            if not chain:\n                newS += S[-1]\n            else:\n                if count % 2 == 1:\n                    newS += S[-1]\n            if newS == S:\n                return S\n            S = newS\n            #print(S)\n        return S\n", "class Solution:\n    def removeDuplicates(self, S: str) -> str:\n        stack = []\n        for i in S:\n            if stack:\n                if stack[-1] == i:\n                    stack.pop()\n                else:\n                    stack.append(i)\n            else:\n                stack.append(i)\n        return ''.join(stack)", "class Char(object):\n    def __init__(self, val):\n        self.val = val\n        self.count = 1\n        \nclass Solution:\n    def removeDuplicates(self, S: str) -> str:\n        '''\n        similar to 1D candy crush\n        '''\n        if len(S) == 0:\n            return S\n        \n        stack = [Char(S[0])]\n        k = 2 #duplicate\n        \n        n = len(S)\n        \n        for i in range(1, n):\n            if stack and stack[-1].val == S[i]:\n                stack[-1].count += 1\n                \n                if stack[-1].count == k:\n                    stack.pop()\n            else:\n                stack.append(Char(S[i]))\n        \n        output = ''\n        while stack:\n            char = stack.pop()\n            output = char.val*char.count + output\n        \n        return output\n        \n\n", "class Solution:\n    def removeDuplicates(self, S: str) -> str:\n        \n        def remove_once(S):\n            i = 0\n            res = ''\n            while i<len(S)-1:\n                if S[i]!=S[i+1]:\n                    res += S[i]\n                    i += 1\n                else:\n                    i += 2\n            if i==len(S)-1:\n                res += S[i]\n            return res\n        \n        previous_string = S\n        removed_string = remove_once(S)\n        while removed_string!=previous_string:\n            previous_string = removed_string\n            removed_string = remove_once(previous_string)\n            \n        return removed_string", "class Solution:\n    def removeDuplicates(self, S: str) -> str:\n        letters = list(S) + ['#']\n        while True:\n            nLetters = []\n            i = 0\n            while i < len(letters) - 1:\n                if letters[i] != letters[i + 1]:\n                    nLetters.append(letters[i])\n                    i += 1\n                else:\n                    i += 2\n\n            if len(nLetters) + 1 == len(letters): \n                break\n            letters = nLetters + ['#']\n        return ''.join(letters[:-1])\n                \n        \n", "class Solution:\n    def removeDuplicates(self, S: str) -> str:\n        i = 0\n        repeat = True\n        while repeat:\n            repeat = False\n            new = ''\n            while i < len(S):\n                if i < len(S)-1 and S[i] == S[i+1]:\n                    i += 2\n                    repeat = True\n                else:\n                    new += S[i]\n                    i += 1\n            S = new\n            i = 0\n        return S", "class Solution:\n    def removeDuplicates(self, S: str) -> str:\n        def remove(s):\n            if len(s) <= 1:\n                return s\n            i = 0\n            s = s + '#'\n            res = ''\n            while i < len(s) - 1:\n                if s[i] != s[i + 1]:\n                    res += s[i]\n                else:\n                    j = i\n                    while j < len(s) - 1 and s[j] == s[j + 1]:\n                        j += 1\n                    if (j - i) % 2 == 0:\n                        res += s[j - 1]\n                    i = j\n                i += 1\n            return res\n        \n        prev = S\n        cur = remove(S)\n        while cur != prev:\n            prev = cur\n            cur = remove(prev)\n        \n        return cur", "class Solution:\n    def removeDuplicates(self, S: str) -> str:\n        cur = list(S)\n        while True:\n            next_l = []\n            i = 0\n            while i < len(cur):\n                if i < len(cur) - 1 and cur[i] == cur[i + 1]:\n                    i += 2\n                    continue\n                next_l.append(cur[i])\n                i += 1\n            if len(next_l) == len(cur):\n                return ''.join(next_l)\n            cur = next_l\n        \n        return ''\n", "class Solution:\n    def removeDuplicates(self, S: str) -> str:\n        stack = []\n        for i in S:\n            if stack and stack[-1] == i:\n                stack.pop()\n            else:\n                stack.append(i)\n        return ''.join(stack)", "class Solution:\n    def removeDuplicates(self, S: str) -> str:\n        if len(S) <= 1:\n            return S\n        \n        duplicateFound = True\n        output = []\n        \n        while duplicateFound:\n            duplicateFound = False\n            i = 0\n            while i < len(S):\n                if i < len(S) - 1 and S[i] == S[i + 1]:\n                    duplicateFound = True\n                    i += 2\n                    continue\n                \n                output.append(S[i])\n                i += 1            \n            \n            S = output\n            output = []\n        \n        return ''.join(S)", "class Char(object):\n    def __init__(self, val):\n        self.val = val\n        self.count = 1\n        \nclass Solution:\n    def removeDuplicates(self, S: str) -> str:\n        '''\n        similar to 1D candy crush\n        This is stack mehod but slightly slower than stack approach in solutions. With this method\n            we could solve for duplicates > 2 (adjust k - look 2 submission)\n        '''\n        if len(S) == 0:\n            return S\n        \n        stack = [Char(S[0])]\n        k = 2 #duplicate\n        \n        n = len(S)\n        \n        for i in range(1, n):\n            if stack and stack[-1].val == S[i]:\n                stack[-1].count += 1\n                \n                if stack[-1].count == k:\n                    stack.pop()\n            else:\n                stack.append(Char(S[i]))\n        \n        output = ''\n        while stack:\n            char = stack.pop()\n            output = char.val*char.count + output\n        \n        return output\n        \n\n", "class Solution:\n    def removeDuplicates(self, S: str) -> str:\n        if S.count(S[0]) == len(S):\n            if len(S)%2==0:\n                return ''\n            else:\n                return S[0]\n        while True:\n            Sbuffer = S[0]\n            new_string = S[0]\n            for i in S[1:]:\n                if i != Sbuffer:\n                    new_string += i\n                    Sbuffer = i\n                else:\n                    new_string = new_string[:-1]\n                    Sbuffer = ' '\n            numlist = [i for i in range(0, len(S)-1)]\n            list1 = list(filter(lambda x: S[x+1] == S[x], numlist))\n            if list1:\n                S = new_string\n            else:\n                break\n        return new_string", "def remove_dupes(s):\n    i = 0\n    out = []\n    while i < len(s):\n        if i + 1 < len(s) and s[i] == s[i + 1]:\n            i += 2\n        else:\n            out.append(s[i])\n            i += 1\n    return ''.join(out)\n        \n    \nclass Solution:\n    def removeDuplicates(self, s: str) -> str:\n        prev = None\n        while s != prev:\n            s, prev = remove_dupes(s), s\n        return s\n            \n", "class Solution:\n    def removeDuplicates(self, S: str) -> str:\n        \n        prev = S\n        \n        while True:\n            \n            i = 0\n            \n            s = ''\n            \n            while i < len(prev):\n                \n                if i != len(prev) - 1 and prev[i] == prev[i + 1]:\n                    \n                    i += 2\n                    \n                else:\n                    \n                    s += prev[i]\n                    i += 1\n                    \n          \n            if prev == s:\n                \n                break\n                \n            prev = s\n                \n        return s", "class Solution:\n    def removeDuplicates(self, S: str) -> str:\n        found = True\n        while(found):\n            found = False\n            for i in range(len(S)-1):\n                if i >= len(S) - 1:\n                    break\n                elif S[i] == S[i+1]:\n                    found = True\n                    S = S[:i] + S[i+2:]\n                    i -= 2\n        return S", "from itertools import groupby\n\nclass Solution:\n    def removeDuplicates(self, S: str) -> str:\n        \n        uncompleted = True\n        while uncompleted:\n            uncompleted = False\n            tmp = ['']\n            for key, grp in groupby(S):\n                letters = list(grp)\n                if len(letters) == 1:\n                    tmp.extend(letters)\n                else:\n                    tmp.append(key * (len(letters) - 2))\n                    uncompleted = True\n            S = ''.join(tmp)\n        return S", "class Solution:\n    def removeDuplicates(self, S: str) -> str:\n        i, n = 0, len(S)\n        for j in range(0, n):\n            #S[i] = S[j]\n            S = S[:i] + S[j] + S[i + 1:]\n            if i > 0 and S[i - 1] == S[i]:\n                i -= 2\n            i += 1\n        return S[:i]\n", "class Solution:\n    def removeDuplicates(self, S: str) -> str:\n        stack = ['']\n        for s in S:\n            if s==stack[-1]:\n                stack = stack[:-1]\n            else:\n                stack+=[s]\n        return ''.join(stack[1:])", "class Solution:\n    def removeDuplicates(self, S: str) -> str:\n        stack = []\n        for elem in S:\n            if stack == []:\n                stack.append(elem)\n            elif stack[-1] == elem:\n                stack = stack[:-1]\n            else:\n                stack.append(elem)\n        return ''.join(stack)"]