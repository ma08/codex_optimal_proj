["import sys\nfrom collections import deque\ninput = sys.stdin.readline\n\nt = int(input())\nfor _ in range(t):\n    n, m, a, b, c = list(map(int,input().split()))\n    p = list(map(int, input().split()))\n    p.sort()\n    \n    pref = [0]\n    curr = 0\n    for i in range(m):\n        curr += p[i]\n        pref.append(curr)\n\n    adj = [[] for i in range(n)]\n    for _ in range(m):\n        u, v = list(map(int,input().split()))\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n        \n    aD = [-1] * n\n    bD = [-1] * n\n    cD = [-1] * n\n\n    for i in range(3):\n        q = deque()\n        q.append(([a,b,c][i]-1,0))\n        l = [aD,bD,cD][i]\n        l[q[0][0]] = 0\n        while q:\n            v, d = q.popleft()\n            for nex in adj[v]:\n                if l[nex] == -1:\n                    l[nex] = d + 1\n                    q.append((nex,d+1))\n    poss = []\n    for i in range(n):\n        if aD[i] + bD[i] + cD[i] <= m:\n            poss.append(pref[aD[i] + bD[i] + cD[i]] + pref[bD[i]])\n    print(min(poss))\n            \n", "import sys\nfrom collections import deque\ndef input():\n\treturn sys.stdin.readline()[:-1]\n\nINF = 10**6\nt = int(input())\nfor _ in range(t):\n\tn, m, a, b, c = map(int, input().split())\n\ta, b, c = a-1, b-1, c-1\n\tp = list(map(int, input().split()))\n\tp.sort()\n\tcum = [0 for _ in range(m+1)]\n\tfor i, x in enumerate(p):\n\t\tcum[i+1] = cum[i] + x\n\tadj = [[] for _ in range(n)]\n\tfor _ in range(m):\n\t\tu, v = map(int, input().split())\n\t\tadj[u-1].append(v-1)\n\t\tadj[v-1].append(u-1)\n\n\ta_dist, b_dist, c_dist = [INF for _ in range(n)], [INF for _ in range(n)], [INF for _ in range(n)]\n\n\ta_dist[a] = 0\n\tq = deque([a])\n\twhile q:\n\t\tl = q.popleft()\n\t\tfor v in adj[l]:\n\t\t\tif a_dist[v] > a_dist[l]+1:\n\t\t\t\ta_dist[v] = a_dist[l]+1\n\t\t\t\tq.append(v)\n\n\tb_dist[b] = 0\n\tq = deque([b])\n\twhile q:\n\t\tl = q.popleft()\n\t\tfor v in adj[l]:\n\t\t\tif b_dist[v] > b_dist[l]+1:\n\t\t\t\tb_dist[v] = b_dist[l]+1\n\t\t\t\tq.append(v)\n\n\tc_dist[c] = 0\n\tq = deque([c])\n\twhile q:\n\t\tl = q.popleft()\n\t\tfor v in adj[l]:\n\t\t\tif c_dist[v] > c_dist[l]+1:\n\t\t\t\tc_dist[v] = c_dist[l]+1\n\t\t\t\tq.append(v)\n\t\n\t#print(a_dist)\n\t#print(b_dist)\n\t#print(c_dist)\n\tans = 10**20\n\tfor i in range(n):\n\t\taa, bb, cc = a_dist[i], b_dist[i], c_dist[i]\n\t\t#print(aa, bb, cc)\n\t\tif aa+bb+cc > m:\n\t\t\tcontinue\n\t\tans = min(ans, cum[aa+bb+cc] + cum[bb])\n\tprint(ans)", "import sys\ninput = sys.stdin.readline\nfrom itertools import accumulate\nfrom collections import deque\n\ndef bfs(x):\n    DIS=[-1]*(n+1)\n    Q=deque([x])\n    DIS[x]=0\n    \n    while Q:\n        x=Q.pop()\n        for to in E[x]:\n            if DIS[to]==-1:\n                DIS[to]=DIS[x]+1\n                Q.appendleft(to)\n    return DIS\n                \n\nt=int(input())\nfor tests in range(t):\n    n,m,a,b,c=list(map(int,input().split()))\n    P=sorted(map(int,input().split()))\n    S=[0]+list(accumulate(P))\n\n    E=[[] for i in range(n+1)]\n    for i in range(m):\n        x,y=list(map(int,input().split()))\n        E[x].append(y)\n        E[y].append(x)\n\n    DIS_A=bfs(a)\n    DIS_B=bfs(b)\n    DIS_C=bfs(c)\n\n    ANS=1<<63\n\n    #print(S)\n\n    if DIS_A[b]+DIS_B[c]<=m and ANS>S[DIS_A[b]+DIS_B[c]]:\n        ANS=S[DIS_A[b]+DIS_B[c]]\n\n    for i in range(1,n+1):\n        d2=DIS_B[i]\n        d1=DIS_A[i]+DIS_C[i]\n\n        #print(i,d1,d2)\n\n        if d1+d2>m:\n            continue\n\n        if ANS>S[d2]*2+S[d1+d2]-S[d2]:\n            ANS=S[d2]*2+S[d1+d2]-S[d2]\n\n        #print(ANS)\n        \n\n    print(ANS)\n\n    \n\n    \n        \n            \n\n", "from collections import deque\nimport sys\ninput = sys.stdin.readline\ninf = int(1e9)\nfor i in range(int(input())):\n    n, m, a, b, c = list(map(int, input().split()))\n    a -= 1\n    b -= 1\n    c -= 1\n    cost = list(map(int, input().split()))\n    g = [[] for _ in range(n)]\n    for i in range(m):\n        a2, b2 = list(map(int, input().split()))\n        g[a2 - 1].append(b2 - 1)\n        g[b2 - 1].append(a2 - 1)\n    def bfs(st):\n        Q = deque(maxlen=n)\n        lv = [-1] * n\n        Q.append(st)\n        lv[st] = 0\n        while Q:\n            cur = Q.popleft()\n            for to in g[cur]:\n                if lv[to] == -1:\n                    lv[to] = lv[cur] + 1\n                    Q.append(to)\n        return lv\n    lvA = bfs(a)\n    lvB = bfs(b)\n    lvC = bfs(c)\n    # print(lvA, lvB, lvC)\n    ans = int(1e18)\n    cost.sort()\n    cost.insert(0, 0)\n    for i in range(1, len(cost)):\n        cost[i] += cost[i - 1]\n    # print(cost)\n    for i in range(n):\n        d1 = lvB[i]\n        d2 = lvA[i] + lvC[i]\n        if d1 + d2 >= len(cost):\n            continue\n        # print(f'i={i}, d1={d1}, d2={d2}')\n        ans = min(ans, cost[d1] * 2 + cost[d1 + d2] - cost[d1])\n    print(ans)\n\n    \n"]