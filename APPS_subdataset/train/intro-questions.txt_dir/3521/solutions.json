["def on_line(points):\n    points = list(set(points))\n    cross_product = lambda a, b, c: a[0]*(b[1]-c[1]) + b[0]*(c[1]-a[1]) + c[0]*(a[1]-b[1])\n    return all(cross_product(p, *points[:2]) == 0 for p in points[2:])", "from functools import partial\n\ndef collinear(p1, p2, p3):\n    return (p3[1] - p2[1])*(p2[0] - p1[0]) == (p2[1] - p1[1])*(p3[0] - p2[0])\n\ndef on_line(points):\n    points = list(set(points))\n    return all(map(partial(collinear, *points[:2]), points[2:]))", "def on_line(li):\n    try:\n        li = list(set(li))\n        x1,y1 = li.pop()\n        return li[0] and len(set([(y2-y1)/(x2-x1) for x2,y2 in li]))==1\n    except : return len(li)<2 or len({i[0] for i in li})==1", "from fractions import Fraction\n\ndef on_line(ps):\n    ps = list(set(ps))\n    if ps and all(isinstance(x, int) for x in ps):\n        return True\n    return len({\n        (x1 if x1 == x2 else Fraction(y2-y1, x2-x1))\n        for (x1,y1), (x2,y2) in zip(ps, ps[1:])\n    }) <= 1", "import numpy as np\n\ndef determinant(a):\n    return round(np.linalg.det(np.matrix(a)))\n\nf = lambda x: x + [1]\n\ndef on_line(points =None):\n    if points == None: return True\n    if len(points) <= 2: return True\n    points = map(list,list(points))\n    for i in range(len(points)-2):\n        matrix = [points[i], points[i+1], points[i+2]]\n        matrix = map(f,matrix)\n        if determinant(matrix) != 0:return False\n    return True", "def on_line(p):\n    p = list(set(p))\n    if len(p) <= 2: return True\n    (x0, y0), (x1, y1) = p[:2]\n    return all((x - x0) * (y1 - y0) == (x1 - x0) * (y - y0) for x, y in p[2:])\n", "from fractions import Fraction\ndef on_line(points):\n    return len(set(Fraction(a[1]-b[1],a[0]-b[0]) if a[0]!=b[0] else \"Invalid\" for a,b in zip(points,points[1:]) if a!=b))<2", "def on_line(points):\n    \n    def slope_intercept(p1, p2):\n        slope = (p2[1] - p1[1]) / (p2[0] - p1[0])\n        intercept = p1[1] - slope * p1[0]\n        return slope, intercept\n    \n    if len(points) == 0 or isinstance(points[0], int):\n        return True\n    \n    for p1, p2 in zip(points, points[1:]):\n        if p1[0] == p2[0] or p1[1] == p2[1]:\n            continue\n        else:\n            s, i = slope_intercept(p1, p2)\n            try:\n                if abs(s - slope) > 0.00000001 or abs(i - intercept) > 0.000001:\n                    return False\n            except:\n                pass\n            slope, intercept = s, i\n    return True", "def on_line(points):\n    try:\n        x1, y1 = points[0]\n        x2, y2 = points[-1]\n    except:\n        return True\n    for i in points[1:-1]:\n        x3, y3 = i\n        if (x1 - x3)*(y2 - y3) != (x2 - x3)*(y1 - y3):\n            return False\n    return True", "def on_line(points):\n    y = 1\n    x = 0\n    if len(points) <= 2:\n        return True\n    all_x = points[0][x]\n    all_y = points[0][y]\n    test = True\n    for point in points[1:]:\n        if point[x] != all_x:\n            test = False\n            break\n    if test:\n        return True\n    for point in points[1:]:\n        if point[y] != all_y:\n            test = False\n            break\n    if test:\n        return True\n    if (points[1][x] - points[0][x]) != 0:\n        a = (points[1][y] - points[0][y]) / (points[1][x] - points[0][x])\n    else:\n        a = 0\n    b = points[0][y] - a * points[0][x]\n    for point in points[2:]:\n        if point[y] != a * point[x] + b:\n            return False\n    return True\n    \n"]