["import re\n\ndef ant_bridge(ants, terrain):\n    nGap = sum( 2 + len(gap) - (free == '-') for free,gap in re.findall(r'(-+)(\\.+)', '-'+terrain) ) % len(ants)\n    return ants[-nGap:] + ants[:-nGap]", "def ant_bridge(ants, terrain):\n    n_ants = len(ants)\n    \n    terrain = terrain.replace('-.', '..')\n    terrain = terrain.replace('.-', '..')\n    \n    count = terrain.count('.') % n_ants\n    \n    return ants[-count:] + ants[:-count]", "def ant_bridge(ants, s):\n    remain, i = list(ants), 0\n\n    while True:\n        next_stop = next((k for k, l in enumerate(s[i:-1], i) if s[k + 1] == '.'), None)\n    \n        if next_stop is None:\n            return ''.join(remain)\n    \n        if next_stop != i or not i : remain.insert(0,remain.pop())\n        i = next_stop + 1\n    \n        while s[i] == '.':\n            remain.insert(0,remain.pop())\n            i += 1\n        remain.insert(0,remain.pop())    ", "def find_next_bridge_end(position, terrain):\n    next_bridge_end_position = ''.join(terrain[position:]).find('---')\n    if next_bridge_end_position == -1:\n        return len(terrain)+1\n    \n    return next_bridge_end_position + position\n    \ndef check_if_bridge_position(i, terrain):\n    if i == 0:\n        previous_terrain = '-'\n        next_terrain = terrain[i+1]\n    elif i >= len(terrain)-1:\n        previous_terrain = terrain[i-1]\n        next_terrain = '-'\n    else:\n        previous_terrain = terrain[i-1]\n        next_terrain = terrain[i+1]\n\n    if previous_terrain == '-' and terrain[i] == '-' and next_terrain == '-':\n        return False\n    return True\n\ndef create_terrain_with_ants(ant_positions, terrain):\n    terrain_with_ants = terrain[:]\n    for ant, position in list(ant_positions.items()):\n        terrain_with_ants[position] = ant\n    return ''.join(terrain_with_ants)\n\ndef ant_bridge(ants, terrain):\n    platform = ''.join(['-' for _ in range(len(ants))])\n    terrain = platform + terrain + platform\n    terrain = list(terrain)\n    terrain_length = len(terrain)\n    \n    ant_positions = list(range(len(ants)))\n\n    print(ants)\n    print((''.join(terrain)))\n\n    initial_states = []\n    \n    if len(ants) >= len(terrain):\n        return ants\n    \n    for i in range(len(ants)):\n        if i <= 0:\n            previous_terrain = '-'\n            current_terrain = terrain[i]\n            next_terrain = terrain[i+1]\n        elif i >= len(terrain)-1:\n            previous_terrain = terrain[i-1]\n            current_terrain = terrain[i]\n            next_terrain = '-'\n        else:\n            previous_terrain = terrain[i-1]\n            current_terrain = terrain[i]\n            next_terrain = terrain[i+1]\n            \n        if not previous_terrain == '.' and current_terrain == '-' and not next_terrain == '.':\n            initial_states.append('')\n        else:\n            initial_states.append('b')\n    \n    ant_states = dict(list(zip(ants, initial_states)))\n    ant_positions = dict(list(zip(ants[::-1], list(range(len(ants)-1, -1, -1)))))\n    \n    for k in range(len(ants), terrain_length):\n        #print(\"Iteration \" + str(k))\n        max_ant_position = max(ant_positions.values())\n        min_ant_position = min(ant_positions.values())\n    \n        #print(create_terrain_with_ants(ant_positions, terrain))\n    \n        for ant in ants:\n            i = ant_positions[ant]\n            s = ant_states[ant]\n        \n            is_end_of_terrain_reached = i >= len(terrain)-2\n        \n            if is_end_of_terrain_reached:\n                terrain = terrain + ['-', '-']\n\n            # ant is not part of a bridge and next position cannot be part of a bridge => increment by 1    \n            if terrain[i] == '-' and terrain[i+1] == '-' and terrain[i+2] == '-' and s == '':\n                ant_positions[ant] = i+1\n                ant_states[ant] = ''\n            # ant is not part of a bridge and it is at the front of the queue and next position is start of a bridge => increment by 1 and start a bridge\n            if terrain[i] == '-' and terrain[i+1] == '-' and terrain[i+2] == '.' and s == '' and i == max_ant_position:\n                ant_positions[ant] = i+1\n                ant_states[ant] = 'b'     \n            # ant is not part of a bridge and it is not at the front of the queue and next position is start of a bridge => jump ahead to the front of the queue\n            if terrain[i] == '-' and terrain[i+1] == '-' and terrain[i+2] == '.' and s == '' and not i == max_ant_position:\n                # DUPLICATED CODE\n                next_bridge_end = find_next_bridge_end(i, terrain)\n                if next_bridge_end < max_ant_position:\n                    ant_positions[ant] = next_bridge_end + 1\n                else:           \n                    ant_positions[ant] = max_ant_position + 1\n                ant_states[ant] = ''\n                if check_if_bridge_position(ant_positions[ant], terrain):\n                    ant_states[ant] = 'b'      \n            # ant is part of a bridge and it is at the back of the queue => jump ahead to the next bridge end or to the front of the queue\n            if s == 'b' and i == min_ant_position:\n                next_bridge_end = find_next_bridge_end(i, terrain)\n                if next_bridge_end < max_ant_position:\n                    ant_positions[ant] = next_bridge_end + 1\n                else:           \n                    ant_positions[ant] = max_ant_position + 1\n                \n                ant_states[ant] = ''\n                if check_if_bridge_position(ant_positions[ant], terrain):\n                    ant_states[ant] = 'b'\n            \n            if is_end_of_terrain_reached:\n                terrain = terrain[:len(terrain)-2]\n            \n            #print(create_terrain_with_ants(ant_positions, terrain))      \n    \n    return ''.join(sorted(ant_positions, key=ant_positions.get))\n", "from queue import deque\n\n\ndef ant_bridge(ants, terrain):\n    terrains = '-' + terrain + '-'\n    marching_ants = deque([ant, -len(ants)+count+1] for count, ant in enumerate(ants))\n    print(marching_ants)\n    bridge_ants = deque()\n    # \u5728\u5730\u5f62\u4e0a\u524d\u8fdb\n    for pos in range(1, len(terrains)-1):\n        if '.' in terrains[pos-1:pos+2]:\n            # \u5f53\u524d\u4f4d\u7f6e\u662f\u5751\uff0c\u62ff\u6700\u524d\u9762\u7684\u884c\u8fdb\u8681\u586b\u5751\uff0c\u5176\u4ed6\u7684\u524d\u79fb\u4e00\u6b65,\u5e76\u68c0\u67e5\u662f\u5426\u8981\u62c6\u6389\u6700\u5c3e\u7aef\u7684\u6865\u8681\n            leading_ant = marching_ants.pop()\n            leading_ant[1] = pos\n            bridge_ants.append(leading_ant)\n            march_forward(marching_ants, bridge_ants)\n        else:\n            # \u5f53\u524d\u4f4d\u7f6e\u4e0d\u662f\u5751\uff0c\u6240\u6709\u884c\u8fdb\u8681\u524d\u79fb\u4e00\u6b65\uff0c\u5e76\u68c0\u67e5\u662f\u5426\u8981\u62c6\u6389\u6700\u5c3e\u7aef\u7684\u6865\u8681\n            march_forward(marching_ants, bridge_ants)\n    # \u5230\u8fbe\u6700\u53f3\u7aef\u540e\uff0c\u7ee7\u7eed\u884c\u8fdb\u6240\u6709\u7684\u8682\u8681\uff0c\u76f4\u5230\u6ca1\u6709\u6865\u8681\u4e3a\u6b62\n    while len(bridge_ants) > 0:\n        march_forward(marching_ants, bridge_ants)\n    return ''.join(ant[0] for ant in marching_ants)\n\n\ndef march_forward(marching_ants, bridge_ants):\n    \"\"\"\n    \u5c06\u6574\u4e2a\u884c\u8fdb\u8681\u524d\u79fb\u4e00\u683c\uff0c\u5e76\u62c6\u6389\u6700\u5c3e\u7aef\u7a7a\u95f2\u7684\u6865\u8681\n    :param marching_ants: \u884c\u8fdb\u8681\u961f\u5217\n    :param bridge_ants: \u6865\u8681\u961f\u5217\n    \"\"\"\n    print(marching_ants, bridge_ants)\n    for ant in marching_ants:\n        ant[1] += 1\n    if len(marching_ants) == 0 or (len(bridge_ants) > 0 and bridge_ants[0][1] < marching_ants[0][1]):\n        marching_ants.appendleft(bridge_ants.popleft())", "def ant_bridge(ants, terrain):\n    q = [ c for c in ants ]\n    terrain = [ c for c in terrain ] + ['-']\n    for i in range(len(terrain)-1):\n        if terrain[i] == '-' and terrain[i+1] == '.':\n                terrain[i] = q.pop()\n                q.insert(0, terrain[i])\n        elif terrain[i] == '.':\n            terrain[i] = q.pop()\n            q.insert(0, terrain[i])\n            if terrain[i+1] == '-':\n                terrain[i+1] = q.pop()\n                q.insert(0, terrain[i+1])\n\n    rest = \"\".join(q)\n    return rest\n", "def ant_bridge(ants, terrain):\n    b = 0\n    for i, c in enumerate(terrain):\n        if c == '.':\n            b += 1\n        elif b:        \n            b = b + (1 if terrain[i-2-b] == '.' else 2)\n            ants, b = ants[-b:] + ants[:-b], 0\n\n    return ants", "ant_bridge=lambda w,s:(lambda n:w[n:]+w[:n])(-len(''.join(__import__('re').findall('(?:-\\.+)+-',s)))%len(w))", "def ant_bridge(ants, terrain):\n    n = terrain.replace('-.', '..').replace('.-', '..').count('.') % len(ants)\n    return ants[-n:] + ants[:-n]", "def ant_bridge(a, t):\n    t=t.replace('-.','..').replace('.-','..').strip('-')\n    A,B=list(a),[]\n    while t:\n        t=t.lstrip('-')[1:]\n        B+=[A.pop()if A else B.pop(0)]\n    return ''.join(B[::-1]+A)"]