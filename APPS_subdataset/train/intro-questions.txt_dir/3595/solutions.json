["def work_on_strings(a, b):\n    new_a = [letter if b.lower().count(letter.lower()) % 2 == 0 else letter.swapcase() for letter in a]\n    new_b = [letter if a.lower().count(letter.lower()) % 2 == 0 else letter.swapcase() for letter in b]\n    return ''.join(new_a) + ''.join(new_b)", "from collections import Counter\n\ndef swap_them(a, b):\n    cnt = Counter(b.lower())\n    return \"\".join(c.swapcase() if cnt[c.lower()] % 2 else c for c in a)\n\ndef work_on_strings(a, b):\n    return swap_them(a, b) + swap_them(b, a)", "def work_on_strings(a,b):\n    A = list(a); B =list(b)\n    #Forward Sort\n    for i in range(len(A)):\n        for j in range(len(B)):\n            if A[i].upper() == B[j] or A[i].lower() == B[j]:\n                B[j] = B[j].swapcase()\n    #Backwards Sort\n    for i in range(len(B)):\n        for j in range(len(A)):\n            if B[i].upper() == A[j] or B[i].lower() == A[j]:\n                A[j] = A[j].swapcase()\n    return \"\".join(str(i) for i in A+B)", "from collections import Counter\nimport re\n\ndef swaper(m):       return m[0].swapcase()\ndef buildPattern(s): return f\"[{ ''.join(c for c,n in Counter(s.lower()).items() if n&1) or ' ' }]\"\ndef player(a,b):     return re.sub(buildPattern(b), swaper, a, flags=re.I)\n\ndef work_on_strings(a,b): return player(a,b)+player(b,a)", "from collections import Counter\n\ndef work_on_strings(a, b):\n    sa, sb = (\"\".join(x + x.upper() for x, y in Counter(s.lower()).items() if y % 2) for s in (a, b))\n    return a.translate(str.maketrans(sb, sb.swapcase())) + b.translate(str.maketrans(sa, sa.swapcase()))", "work_on_strings=lambda a,b:''.join([elema if ((b.lower()).count(elema.lower()))%2==0 else elema.swapcase() for elema in a])+''.join([elemb if ((a.lower()).count(elemb.lower()))%2==0 else elemb.swapcase() for elemb in b])", "def work_on_strings(a,b):\n\n    # New A and B\n    corA = ''\n    corB = ''\n\n    # Hash table\n    lettersA = {}\n    lettersB = {}\n    for ia in a.lower():\n        lettersA[ia] = a.lower().count(ia)\n\n    for ib in b.lower():\n        lettersB[ib] = b.lower().count(ib)\n\n    # For A\n    for let in a:\n        if let in lettersB.keys() and lettersB[let] % 2 != 0:\n            corA += let.swapcase()\n        elif let.isupper() == True and let.lower() in lettersB.keys():\n            if lettersB[let.lower()] % 2 != 0:\n                corA += let.lower()\n            elif lettersB[let.lower()] % 2 == 0:\n                corA += let.upper()\n        else:\n            corA += let\n    # For B\n    for let in b:\n        if let in lettersA.keys() and lettersA[let] % 2 != 0:\n            corB += let.swapcase()\n        elif let.isupper() == True and let.lower() in lettersA.keys():\n            if lettersA[let.lower()] % 2 != 0:\n                corB += let.lower()\n            elif lettersA[let.lower()] % 2 == 0:\n                corB += let.upper()\n        else:\n            corB += let\n\n    return corA + corB", "def work_on_strings(a,b):\n    z = []\n    for i in a:\n         x = i\n         for j in b:\n              if i.upper()==j or i.lower()==j:\n                     x = x.swapcase()\n         z.append(x)\n    k = []\n    for i in b:\n         x = i\n         for j in a:\n              if i.upper()==j or i.lower()==j:\n                     x = x.swapcase()\n         k.append(x)\n\n    return ''.join(z)+''.join(k)", "def swapping(fir, sec):\n    sf = set(fir)\n    for ch in sf:\n        occurs = fir.count(ch)\n        if occurs%2 != 0 and ch in sec.lower():\n          f =f\"{ch}{ch.upper()}\"\n          s =f\"{ch.upper()}{ch}\" \n          t = sec.maketrans(f, s)\n          sec = sec.translate(t)\n    return sec\n\ndef work_on_strings(a,b):\n    return swapping(b.lower(),a)+ swapping(a.lower(),b)", "from collections import Counter\n\ndef swap(s1, s2):\n    temp = [(\"\", \"\")] + [(f\"{k}{k.upper()}\", f\"{k.upper()}{k}\") for k,v in Counter(s1.lower()).items() if v&1]\n    return s2.translate(str.maketrans(*map(''.join, zip(*temp))))\n\ndef work_on_strings(a,b):\n    return swap(b, a) + swap(a, b)"]