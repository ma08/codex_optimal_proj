["def ip_to_int32(ip):\n    \"\"\"\n    Take the following IPv4 address: 128.32.10.1 This address has 4 octets\n    where each octet is a single byte (or 8 bits).\n\n    1st octet 128 has the binary representation: 10000000\n    2nd octet 32 has the binary representation: 00100000\n    3rd octet 10 has the binary representation: 00001010\n    4th octet 1 has the binary representation: 00000001\n    So 128.32.10.1 == 10000000.00100000.00001010.00000001\n\n    Because the above IP address has 32 bits, we can represent it as\n    the 32 bit number: 2149583361.\n\n    Write a function ip_to_int32(ip) ( JS: ipToInt32(ip) ) that takes\n    an IPv4 address and returns a 32 bit number.\n\n    ip_to_int32(\"128.32.10.1\") => 2149583361\n\n    \"\"\"\n    addr = ip.split(\".\")\n    res = int(addr[0]) << 24\n    res += int(addr[1]) << 16\n    res += int(addr[2]) << 8\n    res += int(addr[3])\n    return res\n", "def ip_to_int32(ip):\n    return reduce(lambda acc, x: acc << 8 | x, (int(x) for x in ip.split('.')))", "def ip_to_int32(ip):\n    r =\"\"\n    for i in ip.split('.'):\n        r += \"{0:08b}\".format(int(i))\n    return int(r, 2)", "def ip_to_int32(ip):\n  return int(''.join([(bin(int(x))[2:]).zfill(8) for x in ip.split('.')]),2)", "def ip_to_int32(ip):\n    return reduce(lambda p, n: (p << 8) + int(n), ip.split('.'), 0)", "def ip_to_int32(ip):\n    return sum(int(o) << (8*i) for i, o in enumerate(ip.split(\".\")[::-1]))", "def ip_to_int32(ip):\n  retInt = 0\n  octets = ip.split('.')\n  for ndx, offset in enumerate((24, 16, 8, 0)):\n      retInt = retInt | int(octets[ndx]) << offset\n  return retInt", "import struct\nfrom socket import inet_aton\n\ndef ip_to_int32(ip):\n    return struct.unpack('>I', inet_aton(ip))[0]", "def ip_to_int32(ip):\n    result = 0\n    for s in ip.split('.'):\n        result *= 256\n        result += int(s)\n    return result", "def ip_to_int32(ip):\n    return int(''.join([(format(int(i),\"08b\")) for i in ip.split('.')]),2)\n     \n"]