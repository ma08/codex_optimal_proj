["import math\ndef goldbach_partitions(n):\n    def is_prime(x):\n        for i in range(2, int(math.sqrt(x))+1):\n            if x % i == 0:\n                return False\n        return True\n\n    if n % 2: return []\n\n    ret = []\n    for first in range(2, n//2 + 1):\n        if is_prime(first):\n            second = n - first\n            if is_prime(second):\n                ret.append('%d+%d' %(first, second))\n    return ret", "f=lambda n:n>1and all(n%d for d in range(2,int(n**.5)+1))\ngoldbach_partitions=lambda n:[]if n%2else['%d+%d'%(p,n-p)for p in range(n//2+1)if f(p)*f(n-p)]", "from itertools import chain\n\nimport numpy as np\n\nN = 32001\nxs = np.ones(N)\nxs[:2] = 0\nxs[4::2] = 0\nfor i in range(3, int(N ** 0.5) + 1, 2):\n    if xs[i]:\n        xs[i*i::i] = 0\nprimes = {i for i, x in enumerate(xs) if x}\n\n\ndef goldbach_partitions(n):\n    if n % 2:\n        return []\n    return [\n        f\"{i}+{n-i}\"\n        for i in chain([2], range(3, n // 2 + 1, 2))\n        if i in primes and n - i in primes\n    ]", "odd_primes = {n for n in range(3, 32000, 2) if all(n % k for k in range(3, int(n**0.5)+1, 2))}\n\ndef goldbach_partitions(n):\n    if n % 2 == 1:\n        return []\n    if n == 4:\n        return [\"2+2\"]\n    return [f\"{p}+{q}\" for p, q in sorted((p, n-p) for p in odd_primes if p <= (n-p) and (n-p) in odd_primes)]\n", "def goldbach_partitions(n):\n  is_prime = lambda n: all(n%j for j in range(2, int(n**0.5)+1)) and n>1\n  return [] if n%2 else [f'{i}+{n-i}' for i in range(2, int(n/2)+1) if is_prime(i) and is_prime(n-i)]", "def goldbach_partitions(n):\n    def prime(a):\n        if a == 2: return True\n        if a < 2 or a % 2 == 0: return False\n        return not any(a % x == 0 for x in range(3, int(a ** 0.5) + 1, 2))\n\n    if n<4 or n%2!=0:\n        return []\n    if n==4:\n        return ['2+2']\n    res = []\n    x = 3\n    while True:\n        y = n-x\n        if x>y:\n            return res\n        if prime(y):\n            res.append(str(x) + '+' + str(y))            \n        x += 2\n        while not prime(x):\n            x += 2", "def prime(givenNumber): \n  primes = []\n  for possiblePrime in range(2, givenNumber + 1):\n  \n    isPrime = True\n    for num in range(2, int(possiblePrime ** 0.5) + 1):\n      if possiblePrime % num == 0:\n        isPrime = False\n        break\n\n    if isPrime:\n      primes.append(possiblePrime)\n  \n  return(primes)\n\ndef goldbach_partitions(n):\n  if n % 2 != 0:\n    return []\n  else:\n    p = prime(n)\n    res = []\n  \n    for i in p:\n      if (n-i) in p:\n        res.append('{}+{}'.format(i, n-i)) \n        p.remove(n-i)\n    return res", "import math\ndef goldbach_partitions(n):\n    primes = []\n    partitions = []\n    \n    if n%2 != 0: return []\n    for i in range(0, n+1):\n        if i > 1:\n            for j in range(2, int(math.sqrt(i))+1):\n                if (i % j) == 0:\n                    break\n            else:\n                primes.append(i)\n\n    for i in primes:\n        if i <= n/2:\n            if n - i in primes:\n                partitions.append(str(i) + '+' + str(n - i))\n\n    return(partitions)", "sieve = [False] * 2 + [True] * 32000\nfor i in range(2, 200):\n    if sieve[i]:\n        for j in range(2, 32000):\n            if i * j >= len(sieve): break\n            sieve[i*j] = False\n\ndef goldbach_partitions(n):\n    if n % 2: return []\n    if n == 4: return ['2+2']\n    return ['{}+{}'.format(i, n-i) for i in range(2, n//2+1) if sieve[i] and sieve[n-i]]"]