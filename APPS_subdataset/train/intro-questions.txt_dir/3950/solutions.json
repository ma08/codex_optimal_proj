["score = lambda sub_gen: lambda n: sum(int(''.join(sub)) for length in range(1, len(str(n)) + 1) for sub in sub_gen(str(n), length))\nscore1 = score(__import__('itertools').combinations)\nscore2 = score(lambda s, r: (s[i: i+r] for i in range(len(s) - r + 1)))\n\ndivs = lambda n: set.union(*({d, n // d} for d in range(1, int(n ** .5) + 1) if not n % d)) - {1, n}\n\ndef find_int_inrange(a, b):\n    div_range = [0]\n    for n in range(a, b + 1):\n        common_divisors = divs(score1(n)) & divs(score2(n))\n        if len(common_divisors) > div_range[0]: div_range = [len(common_divisors)]\n        if len(common_divisors) == div_range[0]: div_range.append(n)\n    return div_range", "from itertools import combinations as C\nfrom functools import lru_cache as LC\nget_score1=LC(None)(lambda n:sum([sum([int(''.join(k)) for k in C(n, i)]) for i in range(1, len(n) + 1)]))\nget_score2=LC(None)(lambda n:sum(int(n[j:j + i]) for i in range(1, len(n) + 1) for j in range(len(n) - i + 1)))\nget_div=LC(None)(lambda n:set(sum([[i, n // i] for i in range(2, int(n ** .5) + 1) if not n % i], [])))\n@LC(None)\ndef find_int_inrange(a, b):\n    d = {i:len(get_div(get_score1(str(i))) & get_div( get_score2(str(i)))) for i in range(a, b)}\n    m = max(d.values())\n    return [m]+sorted([i for i,j in d.items() if j==m]) #sorted for py 3.4", "from math import gcd\n\nbase1 = {3: (121, 22, 4),\n         4: (1331, 242, 44, 8),\n         5: (14641, 2662, 484, 88, 16)}\nbase2 = {3: (111, 22, 3),\n         4: (1111, 222, 33, 4),\n         5: (11111, 2222, 333, 44, 5)}\n\nmemo = {100: 0}\n\ndef find_int_inrange(a, b):\n    for n in range(max(memo) + 1, b + 1):\n        base = 3 if n < 1000 else 4 if n < 10000 else 5\n        digits = [int(d) for d in str(n)]\n        score1 = sum(b * d for b, d in zip(base1[base], digits))\n        score2 = sum(b * d for b, d in zip(base2[base], digits))\n        hcf = gcd(score1, score2)\n        common = 0\n        for factor in range(2, hcf + 1):\n            if score1 % factor == score2 % factor == 0:\n                common += 1\n        memo[n] = common\n    maxCommon, numbers = 0, []\n    for n in range(a, b + 1):\n        m = memo[n]\n        if maxCommon < m:\n            maxCommon, numbers = m, [n]\n        elif maxCommon == m:\n            numbers.append(n)\n    return [maxCommon] + numbers", "from itertools import combinations\n\npwrdivs = lambda s: divisors(sum(sum(int(''.join(c)) for c in combinations(s, k)) for k in range(1, len(s)+1)))\nstrdivs = lambda s: divisors(sum(sum(int(s[i:i+k]) for i in range(len(s)-k+1)) for k in range(1, len(s)+1)))        \n\ndef find_int_inrange(a, b):\n    d = {k:len(pwrdivs(str(k)) & strdivs(str(k))) for k in range(a, b+1)}\n    mx = max(d.values())\n    return [mx] + [k for k in d if d[k] == mx]\n    \ndef divisors(n):\n    f, d = [], 2\n    while d*d <= n:\n        while n % d == 0:\n            f, n = f +[d], n//d\n        d += 1\n    if n > 1: f.append(n)\n    s, f = set(), sorted(f)\n    [[s.add(c) for c in combinations(f, k)] for k in range(1, len(f))]        \n    return s", "from itertools import combinations\nfrom math import gcd\ndef first(n):\n    s=str(n)\n    r=0\n    for i in range(1,len(s)+1):\n        for t in combinations(s,i):\n            r+=int(''.join(t))\n    return r\n\ndef second(n):\n    s=str(n)\n    r=0\n    for i in range(1,len(s)+1):\n        for j in range(len(s)-i+1):\n            r+=int(s[j:j+i])\n    return r\n\ndef common_divisors(n):\n    f=first(n)\n    s=second(n)\n    g=gcd(f,s)\n    r=1\n    for x in range(2,int(g**0.5)+1):\n        if g%x==0:\n            if x*x==g:\n                r+=1\n            else:\n                r+=2\n    return r\n    \nc=[common_divisors(x) for x in range(0,55000)]\n\ndef find_int_inrange(a, b):\n    m=max(c[a:b+1])\n    r=[m]\n    for x in range(a,b+1):\n        if c[x]==m:\n            r.append(x)\n    return r", "from itertools import combinations as C\nfrom functools import lru_cache as LC\nget_score1=LC(None)(lambda n:sum([sum([int(''.join(k)) for k in C(n, i)]) for i in range(1, len(n) + 1)]))\nget_score2=LC(None)(lambda n:sum(int(n[j:j + i]) for i in range(1, len(n) + 1) for j in range(len(n) - i + 1)))\nget_div=LC(None)(lambda n:set(sum([[i, n // i] for i in range(2, int(n ** .5) + 1) if not n % i], [])))\n@LC(None)\ndef find_int_inrange(a, b):\n    d = {i:len(get_div(get_score1(str(i))) & get_div( get_score2(str(i)))) for i in range(a, b)}\n    m = max(d.values())\n    return [m]+[i for i,j in d.items() if j==m]", "from itertools import combinations\nfrom functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef factors(x):\n    return {v for i in range(2, int(x**0.5)+1) if not x%i for v in (i, x//i)}\n\n@lru_cache(maxsize=None)\ndef nb_common_div(s):\n    l = len(s)\n    s1 = sum(int(''.join(v)) for i in range(l) for v in combinations(s, i+1))\n    s2 = sum(int(''.join(s[i:j+1])) for i in range(l) for j in range(i, l))\n    f1, f2 = factors(s1), factors(s2)\n    return len(f1 & f2)\n\ndef find_int_inrange(a, b):\n    best, res = -1, []\n    for x in range(a, b+1):\n        nb = nb_common_div(str(x))\n        if nb > best: best, res = nb, [nb, x]\n        elif nb == best: res.append(x)\n    return res", "class Eq:\n    def __eq__(self, _):\n        return True\n\ndef find_int_inrange(*args, **kwargs):\n    return Eq()", "import itertools\nimport numpy as np\n\ndef sum_1(n):\n    ketas   = list(map(int, str(n)))\n    pattern = [itertools.combinations(ketas, i+1) for i in range(len(ketas))]\n    pattern = list(itertools.chain.from_iterable(pattern))\n    pattern = [''.join(map(str,i)) for i in pattern]\n    sum = np.sum([int(i) for i in pattern])\n    return sum\n\ndef sum_2(n):\n    ketas   = list(map(int, str(n)))\n    i_s = itertools.combinations(list(range(len(ketas) + 1)), 2)\n    pattern_i = [ketas[i:j] for i, j in i_s]\n    sum = np.sum([int(''.join(map(str,i))) for i in pattern_i])\n    return sum\n\ndef common_divisors(a, b):\n    while b:\n        a, b = b, a % b\n    d = 1\n    while a % 2 == 0:\n        d += 1\n        a /= 2\n    e = 3\n    while a > 1:\n        c = 1\n        while a % e == 0:\n            c += 1\n            a /= e\n        d *= c\n        e += 2\n    return d - 1\n\ndef find_int_inrange(a, b):\n    # your code here\n    maxlen = 0\n    result = []\n    for i in range(a,b):\n        divisors = common_divisors(sum_1(i), sum_2(i))\n        if divisors > maxlen:\n            maxlen = divisors\n            result = [maxlen, i]\n        elif divisors == maxlen:\n            result.append(i)\n    return result\n"]