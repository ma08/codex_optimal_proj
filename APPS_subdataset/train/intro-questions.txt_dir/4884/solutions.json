["def connect_the_dots(paper):\n    Y    = paper.find(\"\\n\")+1\n    lst  = list(paper)\n    pts  = {c: i for i,c in enumerate(paper) if c.isalpha() }\n    chrs = sorted(pts)\n    \n    for i in range(len(pts)-1):\n        a,b = sorted((pts[chrs[i]], pts[chrs[i+1]]))\n        (x,y),(u,v) = divmod(a,Y), divmod(b,Y)\n        dx, dy = Y * ( (u>x)-(u<x) ), (v>y)-(v<y)\n    \n        for j in range(a,b+1,dx+dy): lst[j]='*'\n    \n    return ''.join(lst)\n", "def connect_the_dots(s):\n    s = list(map(list, s.splitlines()))\n    arr = sorted((v,i,j) for i,row in enumerate(s) for j,v in enumerate(row) if v.isalpha())\n    for (_,y1,x1),(_,y2,x2) in zip(arr,arr[1:]):\n        py,px = y1,x1\n        s[py][px] = '*'\n        while (py,px) != (y2,x2):\n            py += (1 if y2>py else -1 if y2<py else 0)\n            px += (1 if x2>px else -1 if x2<px else 0)\n            s[py][px] = '*'        \n    return '\\n'.join(map(''.join,s))+'\\n'", "def connect_the_dots(paper):\n    dots = {c: (i, j) for i, row in enumerate(paper.split(\"\\n\")) for j, c in enumerate(row) if c != \" \"}\n    points = sorted(dots.keys())\n    coords = sum((link(dots[a], dots[b]) for a, b in zip(points, points[1:])), list(dots.values()))\n    return \"\\n\".join(\"\".join(\"*\" if (i, j) in coords else \" \" for j, _ in enumerate(row)) for i, row in enumerate(paper.split(\"\\n\")))\n    \ndef link(a, b):\n    dx, dy = (-1 if a[i] > b[i] else 1 if a[i] < b[i] else 0 for i in (0, 1))\n    return [(a[0] + dx*i, a[1] + dy*i) for i in range(1, abs(a[0] - b[0]) or abs(a[1] - b[1]))]\n    \n# Not very proud of that, so ugly and antipythonic.\n", "def connect_the_dots(paper):\n    board = list(map(list, paper.splitlines(keepends=True)))\n    alphabets = {\n        x: (i, j)\n        for i, row in enumerate(board)\n        for j, x in enumerate(row)\n        if not x.isspace()\n    }\n    coords = [coord for _, coord in sorted(alphabets.items())]\n    for (r1, c1), (r2, c2) in zip(coords, coords[1:]):\n        dr = 0 if r1 == r2 else (r2 - r1) // abs(r2 - r1)\n        dc = 0 if c1 == c2 else (c2 - c1) // abs(c2 - c1)\n        while True:\n            board[r1][c1] = '*'\n            if r1 == r2 and c1 == c2:\n                break\n            r1 += dr\n            c1 += dc\n    return ''.join(map(''.join, board))", "def connect_the_dots(paper):\n    paper_list = list(paper)\n    lines = paper.split('\\n')\n    len_line = len(lines[0]) + 1\n    coords = []\n    for letter in 'abcdefghijklmnopqrstuvwxyz':\n        found = False\n\n        for row_index in range(len(lines)):\n            try:\n                column_index = lines[row_index].index(letter)\n                found = True\n                coords.append((row_index, column_index))\n            except:\n                pass\n\n        if not found:\n            break\n\n    for i in range(1, len(coords)):\n        from_x = coords[i-1][0]\n        to_x = coords[i][0]\n        from_y = coords[i-1][1]\n        to_y = coords[i][1]\n\n        step_x = 1\n        step_y = 1\n\n        if from_x == to_x:\n            step_x = 0\n        if from_x > to_x:\n            step_x = -1\n        if from_y == to_y:\n            step_y = 0\n        if from_y > to_y:\n            step_y = -1\n\n        for _ in range(1 + max(from_x-to_x, to_x-from_x,from_y-to_y,to_y-from_y)):\n            paper_list[from_y + (from_x * len_line)] = '*'\n            from_x += step_x\n            from_y += step_y\n\n\n    return \"\".join(paper_list)", "from string import ascii_lowercase as lu\ndef connect_the_dots(li):\n    li = [[j for j in i] for i in li.splitlines()]\n    \n    find_char = lambda c: next(([i,k] for i,j in enumerate(li) for k,l in enumerate(j) if l==c), 0) # find next char from string/array\n    \n    lower = iter(lu)\n    \n    char, chars = find_char(next(lower)), []\n    \n    while char:\n        chars.append(char)\n        char = find_char(next(lower))\n    \n    A = lambda s, se, see, e, ee, eee: list(zip(list(range(s, se + 1, see)), list(range(e, ee + 1, eee)))) # for diagonals\n    \n    for h, g in zip(chars, chars[1:]):\n        i, j = h ; k, l = g\n        m, m1, n, n1 = min(i, k), min(j, l), max(i, k), max(j, l)\n        if i == k:                      # horizontal\n            while m1 <= n1 : \n                li[i][m1] = '*' ; m1 += 1\n        elif j == l:                    # verical\n            while m <= n : \n                li[m][j] = '*' ; m += 1\n        else:                           # diagonals\n            B,C = i > k, j > l\n            for o, p in A(i, k - (2 if B else 0), (1 if not B else -1), j, l - (2 if C else 0),(1 if not C else -1)) : \n                 li[o][p] = '*'\n        i, j = k, l\n    return \"\\n\".join([\"\".join(i) for i in li])+\"\\n\"", "def connect_the_dots(paper):\n    \n    laliste = paper[:-1].split(\"\\n\")\n    tablo = [[' ' for i in range(len(laliste[0]))] for j in range(len(laliste)) ]\n    lesPositions = []\n    \n    for i, ligne in enumerate(laliste):\n        listeCar = list(ligne)\n        #listeCar.pop()\n        for j, car in enumerate(listeCar):\n            if 97<=ord(car)<=122:\n                lesPositions.append((car, i, j))\n    lesPositions.sort(key = lambda x:x[0])\n    pointA = lesPositions.pop()\n    while lesPositions:\n        pointB = lesPositions.pop()\n        if pointA[1] == pointB[1]: #ligne verticale\n            ext = [pointB[2], pointA[2]]\n            for y in range(min(ext), max(ext)+1):\n                tablo[pointA[1]][y] = '*'\n                \n        elif pointA[2] == pointB[2]: #ligne horizontale\n            ext = [pointB[1], pointA[1]]\n            for x in range(min(ext), max(ext)+1):\n                tablo[x][pointA[2]] = '*'\n        else :\n            dx = 1 if pointA[1]<pointB[1] else -1\n            dy = 1 if pointA[2]<pointB[2] else -1\n            y = pointA[2]\n            for x in range(pointA[1], pointB[1]+dx, dx):\n                tablo[x][y]='*'\n                y += dy\n        pointA = pointB\n                \n    tablo2 = [''.join(ligne)+'\\n' for ligne in tablo]\n    return ''.join(tablo2)", "def connect_the_dots(paper: str) -> str:\n    res = list(map(list, paper.splitlines()))\n    d = [v for _, v in sorted({c: (i, j) for i, row in enumerate(res) for j, c in enumerate(row) if c != ' '}.items())]\n\n    for (prev_i, prev_j), (i, j) in zip(d, d[1:]):\n        if prev_i == i:  # same row\n            for x in range(min(j, prev_j), max(j, prev_j) + 1):\n                res[i][x] = '*'\n\n        elif prev_j == j:  # same column\n            for x in range(min(i, prev_i), max(i, prev_i) + 1):\n                res[x][j] = '*'\n\n        else:  # diagonal\n            di, dj = [1, -1][prev_i > i], [1, -1][prev_j > j]\n            for x in range(abs(prev_j - j) + 1):\n                res[prev_i + x * di][prev_j + x * dj] = '*'\n\n    return '\\n'.join(map(''.join, res)) + \"\\n\"\n", "def connect_the_dots(paper):\n    letters_input = [l for l in \"abcdefghijklmnopqrstuvwxyz\" if l in paper]\n    table = [list(row) for row in paper.split(\"\\n\")[:-1:]]\n    coordinates = [(row.index(letter), indx) for letter in letters_input for indx, row in enumerate(table) if letter in row]\n    print(coordinates)\n    for indx, coord in enumerate(coordinates[:-1:]):\n        if coord[1] == coordinates[indx+1][1]:\n            for x in range(min(coord[0], coordinates[indx+1][0]), max(coord[0], coordinates[indx+1][0]) + 1):\n                table[coord[1]][x] = \"*\"\n        elif coord[0] == coordinates[indx + 1][0]:\n            for y in range(min(coord[1], coordinates[indx + 1][1]), max(coord[1], coordinates[indx + 1][1]) + 1):\n                table[y][coord[0]] = \"*\"\n        else:\n            step_x = (coordinates[indx+1][0] - coord[0]) / abs(coord[0] - coordinates[indx+1][0])\n            lst_x = [int(coord[0] + step_x * k) for k in range(abs(coord[0] - coordinates[indx+1][0]) + 1)]\n            step_y = (coordinates[indx + 1][1] - coord[1]) / abs(coord[1] - coordinates[indx + 1][1])\n            lst_y = [int(coord[1] + step_y * k) for k in range(abs(coord[1] - coordinates[indx + 1][1]) + 1)]\n            for x, y in zip(lst_x, lst_y):\n                table[y][x] = \"*\"\n    res = \"\\n\".join([\"\".join(row) for row in table]) + \"\\n\"\n    return res", "def abs(x):\n    if x<0:\n        return -x\n    else:\n        return x\n\ndef norm(x):\n    if x == 0:\n        return 0\n    else:\n        return abs(x)//x\n\ndef string_to_grid(string):\n    return [list(x) for x in string.split('\\n')][0:-1]\n\ndef grid_to_string(grid):\n    result = ''\n    for y in range(0,len(grid)):\n        result += ''.join(grid[y]) + '\\n'\n    return result\ndef connect_two_points(p1,p2,grid):\n    ydiff = p2[0] - p1[0]\n    xdiff = p2[1] - p1[1]\n    ystep = norm(ydiff)\n    xstep = norm(xdiff)\n    \n    step = (ystep,xstep)\n    \n    for i in range(0,max(abs(ydiff),abs(xdiff))+1):\n        y_coord = p1[0] + ystep*i\n        x_coord = p1[1] + xstep*i\n        \n        grid[y_coord][x_coord] = '*'\n\ndef generate_point_dictionary(grid):\n    D = {}\n    for y in range(0,len(grid)):\n        for x in range(0, len(grid[y])):\n            if grid[y][x] != ' ':\n                D[grid[y][x]] = [y,x]\n    return D\n    \ndef connect_the_dots(inp):\n    grid = string_to_grid(inp)\n    D = generate_point_dictionary(grid)\n    alph = 'abcdefghijklmnopqrstuvwxyz'\n    for x in range(0,len(alph)):\n        try:\n            connect_two_points(D[alph[x]],D[alph[x+1]],grid)\n        except:\n            return grid_to_string(grid)\n            \n"]