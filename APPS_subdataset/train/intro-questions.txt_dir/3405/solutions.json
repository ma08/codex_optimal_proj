["def is_pandigital(n):\n    s = str(n)\n    return not '0' in s and len(set(s)) == len(s)\n\ndef pow_root_pandigit(val, n, k):\n    res = []\n    current = int(round(val ** (1.0 / n), 5)) + 1\n    while len(res) < k and current <= 987654321 ** (1.0 / n):\n        if is_pandigital(current):\n            p = current ** n\n            if is_pandigital(p):\n                res += [[current, p]]\n        current += 1\n    return res if len(res) != 1 else res[0]", "def is_pandigital(n):\n    s = set(c for c in str(n) if c != \"0\" )\n    if len(s) != len(str(n)): return False\n    else: return True\n\ndef pow_root_pandigit(val, n, k):\n\n    i, l = int(val**(1.0/n))-1, []\n    while len(l) < k:\n        if i**n > val and is_pandigital(i) and is_pandigital(i**n):\n            l.append([i, i**n])\n        i += 1\n        \n        # largest possible\n        if i**n > 987654321: \n            break\n        \n    if len(l) == 1: return l[0]\n    else: return l", "def pow_root_pandigit(v,n,k):\n    r,i=[],int(v**(1.0/n))\n    while len(r)<k and i<25942:\n        i+=1\n        s=str(i)\n        if '0' not in s and len(s)==len(set(s)):\n            j=i**n\n            if j<=v:continue\n            t=str(j)\n            if '0' not in t and len(t)==len(set(t)):\n                r+=[[i,j]]\n    return [] if not r else r if len(r)>1 else r[0]", "from itertools import permutations as p\n\nn_str = '123456789'\nformt = lambda n: sorted(list(map(''.join, list(filter(set, p(n_str, n))))))\ndb = formt(1) + formt(2) + formt(3) + formt(4) + formt(5)\nhs = {1:0, 2:9, 3:81, 4:585, 5:3609}\n\ndef next_pandigital(lp):\n    if lp in db:\n        return db[db.index(lp):]\n    while 1:\n        lp = str(int(lp) + 1)\n        if lp in db[hs[len(lp)]:]:\n            break\n    return db[db.index(lp):]\n\ndef is_pandigital(lp):\n    return len(set(lp)) == len(lp) and '0' not in lp\n\ndef pow_root_pandigit(val, n, k):\n    l = []\n    low = int(val ** (1 / n) + 0.0001) + 1\n    for p in next_pandigital(str(low)):\n        v = int(p) ** n\n        if is_pandigital(str(v)):\n            l.append([int(p), v])\n        if len(l) == k:\n            return l\n    return l[0] if len(l) == 1 else l", "import math\n\ndef is_pandigit(val):\n    val = str(val)\n    return ('0' not in val) and len(val)==len(set(val))\n\ndef pow_root_pandigit(val, n, k):\n    result = []\n    rt = math.ceil((val+1) ** (1/n))\n    for r in range(rt, math.ceil(10**(9/n))):\n        if is_pandigit(r):\n            x = r**n\n            if is_pandigit(x):\n                result.append([r, x])\n                if len(result)==k:\n                    break   \n    return result if len(result)!=1 else result[0]", "from math import *\n\ndef pow_root_pandigit(val, n, k):\n    '''\n    Create a function to give k smaller couples of the root - pandigital numbers with the power n\n    and bigger than val.\n    '''\n    # Create the empty list to return\n    l = []\n    # Put the value to zero\n    if val < 0:\n        val = 0\n    # Case where val is bigger than the bigger pandigital number\n    if val > 987654321:\n        return l\n    r = 1./n\n    # Look for all the powers bigger than val and stop when it reach the len of the list or the\n    # end of the possibility\n    for i in range(int(ceil(((val+1) ** r))), int(987654322 ** r)):\n        string = str(i ** n)\n        if len(set(string)) == len(string) and '0' not in string and '0' not in str(i) and len(set(str(i))) == len(str(i)): \n            l.append([i, int(string)])\n        if len(l) == k : break\n    # Check if only one element\n    if len(l) == 1:\n        l = l[0]\n    return l\n    \n"]