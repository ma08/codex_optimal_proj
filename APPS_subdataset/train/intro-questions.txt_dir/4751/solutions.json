["def deficiently_abundant_amicable_numbers(a,b):\n    c,d = list(map(sumOfDivs,(a,b)))\n    return f'{ kind(a,c)} { kind(b,d) } { \"not \"*(a!=d or b!=c or a==b) }amicable'\n\ndef kind(n,sD):   return 'abundant' if sD>n else 'perfect' if sD==n else 'deficient'\ndef sumOfDivs(n): return sum(d for d in range(1,int(n/2+1)) if not n%d)\n", "def deficiently_abundant_amicable_numbers(n1, n2):\n    d1, d2 = (sum(d for d in range(1, n//2 + 1) if n % d == 0) for n in (n1, n2))\n    is_amicable = \"not \" if n1 == n2 or (n1, n2) != (d2, d1) else \"\"\n    return f\"{perfection(n1, d1)} {perfection(n2, d2)} {is_amicable}amicable\"\n\n\ndef perfection(n, d):\n    return \"deficient\" if d < n else \"abundant\" if n < d else \"perfect\"", "def pdsum(n):\n    \"\"\"proper divisors sum\"\"\"\n    xs = {1}\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            xs.add(i)\n            xs.add(n // i)\n    return sum(xs)\n\ndef describe(s, n):\n    if s < n:\n        return 'deficient'\n    elif s > n:\n        return 'abundant'\n    else:\n        return 'perfect'\n\ndef deficiently_abundant_amicable_numbers(n1,n2):\n    s1, s2 = (pdsum(n) for n in [n1, n2])\n    return '{} {} {}'.format(\n        describe(s1, n1),\n        describe(s2, n2),\n        'amicable' if s1 == n2 and s2 == n1 and n1 != n2 else 'not amicable',\n    )", "def deficiently_abundant_amicable_numbers(n1, n2):\n    d1, d2 = (sum(d for d in range(1, n//2 + 1) if n % d == 0) for n in (n1, n2))\n    perf = \" \".join(\"deficient\" if d < n else \"abundant\" if n < d else \"perfect\" for (n, d) in ((n1, d1), (n2, d2)))\n    is_amic = \"\" if n1 != n2 and (n1, n2) == (d2, d1) else \"not \"\n    return f\"{perf} {is_amic}amicable\"", "def sum_of_divisors(number):\n    divisors = [1]\n    i = 2\n    while i < number//i:\n        if not number%i:\n            divisors.append(i)\n            divisors.append(number//i)\n        i += 1\n    if i**2==number: divisors.append(i)\n    return sum(divisors)\n\ndef is_perfect(number):\n    return number == sum_of_divisors(number)\n\ndef is_amicable(number_1, number_2):\n    return number_2 == sum_of_divisors(number_1)\n    \ndef deficiently_abundant_amicable_numbers(n1,n2):\n    perfect_1 = \"perfect\" if is_perfect(n1) else False\n    if not perfect_1: perfect_1 = \"abundant\" if n1 < sum_of_divisors(n1) else \"deficient\"\n    perfect_2 = \"perfect\" if is_perfect(n2) else False\n    if not perfect_2: perfect_2 = \"abundant\" if n2 < sum_of_divisors(n2) else \"deficient\"\n    amicable = \"amicable\" if is_amicable(n1,n2) and not (is_perfect(n1) and is_perfect(n2)) else \"not amicable\"\n    return perfect_1 + \" \" + perfect_2 + \" \" + amicable", "def deficiently_abundant_amicable_numbers(n1,n2):\n    def check(n):\n        temp = set([1])\n        for j in range(2, int(n**0.5)+1):\n            if n%j == 0:\n                temp.add(j)\n                temp.add(n//j)\n        x = sum(temp)\n        return x\n    lst = [\"abundant\", \"perfect\", \"deficient\"]\n    a1, a2 = check(n1), check(n2)\n    ans1 = lst[0] if a1 > n1 else (lst[1] if a1==n1 else lst[2])\n    ans2 = lst[0] if a2 > n2 else (lst[1] if a2==n2 else lst[2])\n    return \"{} {} {}\".format(ans1, ans2, \"amicable\" if a1==n2 and a2==n1 and n1 != n2 else \"not amicable\")", "def divs(n):\n    s = 1\n    for i in range(2,int(n**.5)+1):\n        if not n%i:\n            s += i\n            s += n//i\n    return s\n\ndef deficiently_abundant_amicable_numbers(n1,n2):\n    d1,d2 = map(divs,(n1,n2))\n    f = lambda x,y: 'perfect' if x==y else 'abundant' if x>y else 'deficient'\n    return f\"{f(d1,n1)} {f(d2,n2)} {'amicable' if d1==n2 and d2==n1 and n1!=n2 else 'not amicable'}\"", "def deficiently_abundant_amicable_numbers(n1, n2):\n    d1, d2 = (sum(d for d in range(1, n//2 + 1) if n % d == 0) for n in (n1, n2))\n    perf = \" \".join(\"abundant\" if n < d else \"deficient\" if d < n else \"perfect\" for (n, d) in ((n1, d1), (n2, d2)))\n    is_amic = \"\" if n1 != n2 and (n1, n2) == (d2, d1) else \"not \"\n    return f\"{perf} {is_amic}amicable\"\n", "def sum_of_divisors(number):\n    divisors = [1]\n    i = 2\n    while i < number//i:\n        if not number%i:\n            divisors.append(i)\n            divisors.append(number//i)\n        i += 1\n    if i**2==number: divisors.append(i)\n    return sum(divisors)\n\ndef is_perfect(number):\n    return number == sum_of_divisors(number)\n\ndef is_amicable(number_1, number_2):\n    return number_2 == sum_of_divisors(number_1)\n    \ndef deficiently_abundant_amicable_numbers(n1,n2):\n    perfect_1 = \"perfect\" if is_perfect(n1) else False\n    if not perfect_1: perfect_1 = \"abundant\" if n1 < sum_of_divisors(n1) else \"deficient\"\n    perfect_2 = \"perfect\" if is_perfect(n2) else False\n    if not perfect_2: perfect_2 = \"abundant\" if n2 < sum_of_divisors(n2) else \"deficient\"\n    amicable = \"amicable\" if is_amicable(n1,n2) and not (is_perfect(n1) and is_perfect(n2)) else \"not amicable\"\n    return perfect_1 + \" \" + perfect_2 + \" \" + amicable\n\nprint(deficiently_abundant_amicable_numbers(4,6))", "def deficiently_abundant_amicable_numbers(a,b):\n    c,d = list(map(sumOfDivs,(a,b)))\n    return f'{ kind(a,c)} { kind(b,d) } { notAmicable(a,b,c,d) }amicable'\n\ndef sumOfDivs(n): return sum(d for d in range(1,int(n/2+1)) if not n%d)\ndef kind(n,sD):   return 'abundant' if sD>n else 'perfect' if sD==n else 'deficient'\ndef notAmicable(a,b,c,d): return 'not '*(a!=d or b!=c or a==b);\n"]