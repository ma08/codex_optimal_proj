["def de_nico(key, msg):\n    ll, order, s = len(key), [sorted(key).index(c) for c in key], ''\n    while msg:\n        s, msg = s + ''.join(msg[i] for i in order if i < len(msg)), msg[ll:]\n    return s.strip()", "def de_nico(key,msg):\n    \n    decoder = []\n    \n    # assign key letters numbers according to alphabetized/sorted indices\n    for letter in key:\n        decoder.append(sorted(key).index(letter))\n\n    # break msg into segments based on key length\n    msg_segs = [msg[i:(i+len(key))] for i in range(0, len(msg), len(key))]\n    \n    # enumerate segments along their ranges\n    enum_segs = []\n    for seg in msg_segs:\n        enum_segs.append(dict(zip(range(len(seg)),seg)))\n\n    # read segs back into decoded_msg by codon in decoder, excepting KeyErrors out to account for final\n    # seg length < len(decoder)\n    decoded_msg = []\n    for seg in enum_segs:\n        for codon in decoder:\n            try:\n                decoded_msg.append(seg[codon])\n            except KeyError:\n                continue\n    \n    return ((''.join(decoded_msg)).rstrip())", "from operator import itemgetter\ndef de_nico(key,msg):\n    #keyDict = dict(zip(sorted(key), range(1, len(key)+1)))\n    #encryptkey = \"\".join([str(keyDict[x]) for x in key])\n    decryptkey, _ = zip( *sorted(zip(range(1, len(key)+1), key), key = itemgetter(1) ))\n    decryptkey = \"\".join(str(x) for x in decryptkey)\n    chunksize = len(decryptkey)\n    chunks = [msg[y-chunksize:y] for y in range(chunksize, len(msg)+chunksize, chunksize)]\n    #chunks[-1] += \" \"*(len(key) - len(chunks[-1])) ## add whitespaces accordingly if the last chunk happens to be too short    \n    for i, chunk in enumerate(chunks):\n        chunkSorted, _ = zip( *sorted( zip(chunk, decryptkey), key = itemgetter(1) ))\n        chunks[i] = \"\".join(chunkSorted)\n    return \"\".join(chunks).rstrip()", "import itertools\ndef de_nico(key,msg):\n    pack =[list(range(len(key)))]+list(list(msg[i:i+len(key)]) for i in range(0,len(msg),len(key)))\n    sor = [sorted(key).index(i) for i in key]\n    sorting = sorted(itertools.zip_longest(*pack,fillvalue=\"\"), key=lambda col: sor.index(col[0]))\n    return \"\".join([\"\".join(j) for i,j in enumerate(itertools.zip_longest(*sorting,fillvalue=\" \")) if i>0]).strip(\" \")", "def de_nico(key,msg):\n    result = ''\n    counter = -1\n    while len(result) < len(msg):\n        counter += 1\n        for i in [sorted(key).index(c) for c in key]:\n            try:\n                result += msg[i+counter*len(key)]\n            except:\n                continue\n    return result.strip()\n", "def de_nico(key,msg):\n    sorted_key = sorted(key)\n    num_key = []\n    for chr in key:\n        num_key.append(sorted_key.index(chr))\n\n    result = ''\n    start = 0\n    end = len(key)\n    while start < len(msg):\n        chunk = msg[start : end]\n        for index in num_key:\n            if index < len(chunk):\n                result += chunk[index]\n        start = end\n        end += len(key)\n\n    return result.strip()", "de_nico=lambda k,m: (lambda k: \"\".join((lambda g: \"\".join(g[p] for p in k if p<len(g)))(m[i*len(k):(i+1)*len(k)]) for i in range(len(m)//len(k)+1)).strip())((lambda s: [s.index(l) for l in k])(sorted(k)))", "def de_nico(key,msg):\n    num_key = ''.join([str(id) for i in key for id, item in enumerate(sorted(key), 1) if item == i])\n    cut_msg = [msg[i:i+len(num_key)] for i in range(0, len(msg), len(num_key))]\n    d_msg = [''.join([item for i in num_key for id, item in enumerate(list(x), 1) if id == int(i)]) for x in cut_msg]\n    return ''.join(d_msg).rstrip()", "from itertools import chain, zip_longest\n\ndef de_nico(key, msg):\n    columns = [msg[n::len(key)] for n in range(len(key))]\n    key = (n for n, c in sorted(enumerate(key), key=lambda k: k[1]))\n    return ''.join(chain(*zip_longest(*sorted(columns, key=lambda k: next(key)), fillvalue=''))).strip()", "from itertools import cycle\n\n\ndef de_nico(key, msg):\n    code = tuple(sorted(key).index(k) + 1 for k in key)\n    code_cycle = cycle(code)\n    key_cycle = cycle(range(1, len(key) + 1))\n    msg_encrypted = [(k, next(key_cycle)) for k in msg]\n    result = []\n    while msg_encrypted:\n        try:\n            index = next(code_cycle)\n            found = next(p for p in msg_encrypted if p[1] == index)\n            msg_encrypted.remove(found)\n            result.append(found[0])\n        except StopIteration:\n            pass\n    return ''.join(result).strip()"]