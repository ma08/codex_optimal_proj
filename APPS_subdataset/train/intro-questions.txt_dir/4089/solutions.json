["MEMO = []\n\ndef sum_dif_rev(n):\n    i = MEMO[-1] if MEMO else 0\n    \n    while len(MEMO) < n:\n        i += 1\n        r = int(str(i)[::-1])\n        if i % 10 and r != i and (i + r) % abs(r - i) == 0:\n            MEMO.append(i)\n\n    return MEMO[n-1]", "from itertools import count\n\n# It's not worth it to memoize they numbers we reversed because a number is not always followed by its reversed in the result\n# So we would have to save they numbers and return the minimum saved each time we find a new one\n# All the numbers in this list are divisible by 9 so we can skip 88.9% of the possibilities\ndef gen():\n    for x in count(0, 9):\n        y = int(str(x)[::-1])\n        if x != y and x % 10 and (x + y) % abs(x - y) == 0:\n            yield x\nnumbers, result = gen(), []\n\ndef sum_dif_rev(n):\n    while len(result) < n: result.append(next(numbers))\n    return result[n-1]", "def sum_dif_rev(num):\n    n = 36\n    while num:\n        n += 9\n        if n % 10 == 0:\n            continue\n        r = int(str(n)[::-1])\n        if n != r and (n + r) % abs(n - r) == 0:\n                num -= 1\n    return n\n", "def memoize_sum_dif(f):\n    memory = {}\n    \n    def inner(n):\n        if n not in memory:\n            memory[n] = f(n)\n        return memory[n]\n    return inner\n    \n    \n@memoize_sum_dif\ndef sum_dif_rev(n):\n    \n    if n == 1: return 45\n    \n    num = sum_dif_rev(n-1)\n    \n    while True:\n        num = num+1\n        if str(num)[::-1][0] == \"0\" or abs(num - int(str(num)[::-1])) == 0 :\n            continue\n        if (num + int(str(num)[::-1]))%abs(num - int(str(num)[::-1])) == 0:\n            break              \n    return num", "seq = [] \ndef sum_dif_rev(n):\n    i = seq[-1] if seq else 0 \n    while len(seq) < n:\n        i += 9\n        r = int(str(i)[::-1])\n        if i % 10 and r != i and (r+i) % abs(r-i) == 0:\n            seq.append(i)\n    return seq[n-1]", "def sum_dif():\n    yield  45\n    yield  54\n    yield  495\n    yield  594\n    n1 = 595\n    while True:\n        n_rev = str(n1)[::-1]\n        if n_rev[0] == '0':\n            n1 += 1\n            continue\n        n_rev_int = int(n_rev)\n        if n1 - n_rev_int != 0 and (n1 + n_rev_int) % abs(n1 - n_rev_int) == 0:\n            yield n1\n        n1 += 1\n\ndef sum_dif_rev(n):\n    p = sum_dif()\n    return [next(p) for x in range(1, n+1)][-1]", "def sum_dif_rev(n):\n    k = 0\n    i = 1\n    while(i <= n) :\n      k += 1\n      if str(k)[-1] != '0' :\n          p = int((str(k))[::-1])\n          if abs(p - k) != 0 :\n              if (p + k) % abs(p - k) == 0 :\n                 i += 1\n    return k", "buf = [45,54,495,594]\n\ndef sum_dif_rev(n):\n    i = buf[-1]\n    while len(buf)<n:\n        i += 1; j = int(str(i)[::-1]); d = abs(i-j)\n        if i%10 and d and not (i+j)%d: buf.append(i)\n    return buf[n-1]\n"]