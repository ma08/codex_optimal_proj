["import re\ndef mid_endian(n):\n    h= hex(n)[2:].upper()\n    r= re.findall('..','0'*(len(h)%2)+h)\n    return \"\".join(r[1::2][::-1]+r[0::2])", "def mid_endian(n):\n    bs = n.to_bytes((n.bit_length() + 7) // 8 or 1, byteorder='little')\n    return (bs[len(bs)%2::2] + bs[::-2]).hex().upper()", "from collections import deque\n\ndef mid_endian(n):\n    h, m = hex(n)[2:].upper(), deque()\n    if len(h) & 1: h = '0' + h\n    for i in range(len(h) >> 1):\n        if i & 1: m.appendleft(h[i << 1: i + 1 << 1])\n        else: m.append(h[i << 1: i + 1 << 1])\n    return ''.join(m)", "def mid_endian(n):\n    x = format(n, 'X')\n    xs = [a+b for a, b in zip(*[iter('0' * (len(x) % 2) + x)]*2)]\n    return ''.join(xs[1::2][::-1] + xs[::2])", "import re\ndef mid_endian(n):\n    t = f'{n:X}'\n    t = '0' + t if len(t) % 2 else t\n\n    odds, evens = [], []\n    for i, f in enumerate(re.findall(r'..', t), start=1):\n        if i % 2:\n            odds.append(f)\n        else:\n            evens.append(f)\n    return ''.join(list(reversed(evens)) + odds)", "from re import findall; from functools import reduce; mid_endian=lambda n: reduce(lambda a,b: b[1]+a if b[0]%2 else a+b[1], enumerate(findall(r\".{2}\", (lambda h: (\"0\" if len(h)%2 else \"\")+h)(hex(n)[2:].upper()))), \"\")", "def mid_endian(n):\n    x = hex(n)[2:]\n    x = '0' + x if len(x)%2 != 0 else x\n    lst = [x.upper()[i:i+2] for i in range(0, len(x), 2)]\n    ans = []\n    for i, e in enumerate(lst):\n        if i%2 == 0:\n            ans.append(e)\n        else:\n            ans.insert(0, e)\n    return ''.join(ans)", "def mid_endian(n):\n    hex_str = hex(n)[2:].zfill(len(hex(n)[2:]) + len(hex(n)[2:]) % 2).upper()\n    cut = [hex_str[i:i + 2] for i in range(0, len(hex_str) - 1, 2)]\n    cut += [] if len(cut) % 2 else ['']\n    return ''.join(cut[1::2][::-1] + cut[0:1] + cut[2::2])", "def mid_endian(n):\n    s = format(n,'x')\n    s = '0' + s if len(s)%2 else s\n    r,c = '',0\n    while s:\n        if not c%2:\n            r += s[:2]\n        else:\n            r = s[:2] + r\n        c += 1\n        s = s[2:]\n    return r.upper()\n", "\ndef mid_endian(n):\n    s = '{:0X}'.format(n)\n    s = '0' * (len(s) % 2) + s\n    ret = ''\n    for n, i in enumerate([s[i * 2: (i + 1) * 2] for i in range(len(s) // 2)]):\n        ret = i + ret if n%2 == 1 else ret + i\n    return ret"]