["class Solution:\n    def largestPerimeter(self, A: List[int]) -> int:\n        \n        A.sort(reverse=True)\n        la=len(A)\n        for i in range(la-2):\n            if A[i]<A[i+1]+A[i+2]:\n                return A[i]+A[i+1]+A[i+2]\n        return 0", "class Solution:\n    def largestPerimeter(self, A: List[int]) -> int:\n        sortedA = sorted(A)\n        \n        for i in range(len(sortedA)-3, -1 ,-1):\n            if sortedA[i+2]<(sortedA[i]+sortedA[i+1]):\n                return sum(sortedA[i:i+3])\n        return 0\n", "class Solution:\n    def largestPerimeter(self, A: List[int]) -> int:\n        A.sort()\n        return ([0] + [a + b + c for a, b, c in zip(A, A[1:], A[2:]) if c < a + b])[-1]\n        \n", "class Solution:\n    def largestPerimeter(self, A: List[int]) -> int:\n        A.sort()\n        return ([0] + [a + b + c for a, b, c in zip(A, A[1:], A[2:]) if c < a + b])[-1]", "class Solution:\n    def largestPerimeter(self, A: List[int]) -> int:\n        \n        A.sort()\n        \n        for i in range(len(A)-1, 1, -1):\n            len1 = A[i]\n            len2 = A[i-1]\n            len3 = A[i-2]\n            if self.check_triangle(len1, len2, len3):\n                return len1 + len2 + len3\n            \n        return 0\n        #print(A)\n        \n    def check_triangle(self, len1, len2, len3):\n        if len1 + len2 <= len3 or len2 + len3 <= len1 or len1 + len3 <= len2:\n            return False\n        return True\n    \n", "class Solution:\n    def largestPerimeter(self, A):\n        A.sort(reverse=True)\n\n        for i in range(len(A)-2):\n            if A[i] < A[i+1]+A[i+2]:\n                return A[i]+A[i+1]+A[i+2]\n\n        return 0", "class Solution:\n    def largestPerimeter(self, A: List[int]) -> int:\n        A.sort()\n        return ([0] + [a + b + c for a, b, c in zip(A, A[1:], A[2:]) if c < a + b])[-1]\n", "class Solution:\n    def largestPerimeter(self, A: List[int]) -> int:\n        A.sort(reverse=True)\n        i=0\n        while i< len(A)-2:\n            if A[i]<A[i+1]+A[i+2]:\n                return(A[i]+A[i+1]+A[i+2])\n            else:\n                i=i+1\n        return (0)\n", "class Solution:\n    def largestPerimeter(self, A: List[int]) -> int:\n        p=0\n        A.sort()\n        for i in range(len(A)-2):\n            if A[i]+A[i+1]>A[i+2]:\n                p=A[i]+A[i+1]+A[i+2]\n        return p", "class Solution:\n    def largestPerimeter(self, A: List[int]) -> int:\n        A=sorted(A)\n        perimeter=0\n        for i in range(len(A)-2):\n            s1,s2,s3=A[i],A[i+1],A[i+2]\n            p=s1+s2+s3\n            if s1+s2>s3 and s2+s3>s1 and s1+s3>s2:\n                perimeter=max(perimeter,p)\n        return perimeter", "class Solution:\n    def largestPerimeter(self, A: List[int]) -> int:\n        # hold result.\n        result = 0\n        # sort the given lengths.\n        A = sorted(A)\n        # go through lengths, check for valid triangle.\n        for i in range(len(A) - 2):\n            # store triangle sides.\n            a, b, c = A[i], A[i + 1], A[i + 2]\n            # check if valid.\n            if (a + b) > c and (a + c) > b and (b + c) > a:\n                result = max(result, a + b + c)\n        # return result.\n        return result", "class Solution:\n    def largestPerimeter(self, A: List[int]) -> int:\n        A.sort()\n        \n        for i in range(len(A) - 1, 1, -1):\n            a = A[i]\n            b = A[i - 1]\n            c = A[i - 2]\n            if a < b + c:\n                return a + b + c\n            \n        return 0", "class Solution:\n    def largestPerimeter(self, A: List[int]) -> int:\n        A.sort(reverse=True)\n        n = len(A)\n        for i in range(n-2):\n            if A[i] < A[i+1] + A[i+2]:\n                return  A[i] + A[i+1] + A[i+2]\n        return 0\n", "import numpy as np\nclass Solution:\n\n#     def valid_area(self, A):\n#         s = np.sum([a for a in A])/2\n#         area = np.sqrt(s*(s-A[0])*(s-A[1])*(s-A[2]))\n        \n#         return False if np.isnan(area) or area == 0 else True\n        \n        \n    def largestPerimeter(self, A: List[int]) -> int:\n        \n        valid_area = lambda x,y,z: True if x < y + z else False \n        A = sorted(A, reverse=True)\n        for a in range(2,len(A)):\n            if valid_area(A[a-2], A[a-1], A[a]): \n                return np.sum([A[a-2], A[a-1], A[a]])\n        return 0\n        \n#         # greedy approach\n#         comb = set([i for i in combinations(A,3)])\n#         comb_sorted = sorted(comb, key=lambda x: np.sum(x), reverse=True)\n#         for c in comb_sorted:\n#             if self.valid_area(c):\n#                 return np.sum(c)\n            \n#         return 0\n", "class Solution:\n    def largestPerimeter(self, A: List[int]) -> int:\n        A.sort()\n        ans = 0\n        for i in range(1, len(A)-1):\n            if A[i-1] + A[i] <= A[i+1]:\n                continue\n            else:\n                p = sum(A[i-1:i+2])\n                ans = max(ans, p)\n        return ans\n        \n", "class Solution:\n    def largestPerimeter(self, A: List[int]) -> int:\n        if len(A) < 3:\n            return 0\n        A.sort()\n        counter = 3\n        perimeter = 0\n        while counter <= len(A):\n            \n            a = A[counter -3]\n            b = A[counter - 2]\n            c = A[counter - 1]\n            \n            if a +b <= c:\n                counter += 1\n                continue\n            elif b +c <= a:\n                counter += 1\n                continue\n            elif c + a <= b:\n                counter += 1\n                continue\n            perimeter = a+b+c\n            if a+b+c > perimeter:\n                perimeter= a+b+c\n                \n            counter += 1\n        return perimeter", "class Solution:\n    def largestPerimeter(self, A: List[int]) -> int:\n        A.sort()\n        Flag = 0\n        \n        for i in range(len(A)-1,1,-1):\n            if A[i] < A[i-1] + A[i-2]:\n                Flag = 1\n                return A[i-1] + A[i-2] + A[i]\n        \n        if Flag == 0:\n            return Flag\n            \n            \n            \n", "class Solution:\n    def largestPerimeter(self, A: List[int]) -> int:\n        A.sort()\n        first=0\n        second=1\n        mx=0\n        for third in range(2,len(A)):\n            if (A[first]+A[second])>A[third]:\n                mx=max(mx,A[first]+A[second]+A[third])\n            first+=1\n            second+=1\n        \n        return(mx)\n", "class Solution:\n    def largestPerimeter(self, A: List[int]) -> int:\n        A.sort()\n        a = len(A)-1\n        while a >= 2 :\n          if A[a] < A[a-1] + A[a-2] :\n            return (A[a] + A[a-1] + A[a-2])\n          else:\n            a-= 1\n        return 0", "class Solution:\n    def largestPerimeter(self, A: List[int]) -> int:\n        A.sort(reverse=True)\n        n = len(A)\n        for i in range(n-2):\n            for j in range(i+1,n-1):\n                if A[j] <= A[i]//2: break\n                for k in range(j+1,n):\n                    if A[i]<A[j]+A[k]: return A[i]+A[j]+A[k]\n        return 0", "class Solution:\n    def largestPerimeter(self, A: List[int]) -> int:\n        A.sort()\n        for i in range(len(A) - 3, -1, -1):\n            if A[i] + A[i+1] > A[i+2]:\n                return A[i] + A[i+1] + A[i+2]\n        return 0            ", "class Solution:\n    def largestPerimeter(self, A: List[int]) -> int:\n        A = sorted(A)\n        i = len(A)-1\n        while i>=2:\n            if A[i-2]+A[i-1]>A[i]: return A[i-2]+A[i-1]+A[i]\n            i -= 1\n        return 0", "class Solution:\n    def largestPerimeter(self, A: List[int]) -> int:\n        A.sort(reverse=True)\n        for a, b, c in zip(A, A[1:], A[2:]):\n            if a< b+c:\n                return(a+b+c)\n            else:\n                continue\n        return (0)\n", "class Solution:\n    def largestPerimeter(self, A: List[int]) -> int:\n        A.sort(reverse = True) # sort list from largest to smallest\n        for i in range(len(A) - 2):\n            if A[i] < A[i+1] + A[i+2]:\n                return A[i] + A[i+1] + A[i+2]\n        return 0\n            \n", "class Solution:\n    def largestPerimeter(self, A: List[int]) -> int:\n        A.sort(reverse=True)\n        m=0\n        for i in range(len(A)-2):\n            if (A[i]+A[i+1]>A[i+2]) and (A[i+2]+A[i+1]>A[i]) and (A[i+2]+A[i]>A[i+1]):\n                x=A[i:i+3]\n                if sum(x)>m:\n                    m=sum(x)\n        return m\n", "class Solution:\n    def largestPerimeter(self, A: List[int]) -> int:\n        def check(x,y,z):\n            if(x+y>z and y+z>x and x+z>y):\n                return True\n            else:\n                False\n        A=sorted(A)\n        A=A[::-1]\n        x=A\n        print(x)\n        lar=0\n        for i in range(len(x)-2):\n            if(check(x[i],x[i+1],x[i+2])):\n                lar=max(lar,(x[i]+x[i+1]+x[i+2]))\n        return lar        \n                \n        \n", "class Solution:\n    def _isTriangle(self, queue):\n        return queue[0] < queue[1] + queue[2]\n    \n    def largestPerimeter(self, A: List[int]) -> int:\n        A.sort(key = lambda x: -x)\n        \n        nums = []\n        \n        for num in A:\n            nums.append(num)\n            \n            if len(nums) == 3:\n                if self._isTriangle(nums):\n                    return sum(nums)\n                nums.pop(0)\n                \n        return 0", "class Solution:\n    def largestPerimeter(self, A: List[int]) -> int:\n        A.sort()\n        for i in range(len(A) - 3, -1, -1):\n            if A[i] + A[i + 1] > A[i + 2]:\n                return A[i] + A[i + 1] + A[i + 2]\n        return 0", "#\nclass Solution:\n    def largestPerimeter(self, A: List[int]) -> int:\n        A.sort()\n        for i in range(len(A) - 3, -1, -1):\n            if A[i] + A[i+1] > A[i+2]:\n                return A[i] + A[i+1] + A[i+2]\n        return 0", "class Solution:\n    def largestPerimeter(self, A: List[int]) -> int:\n        A.sort(reverse=True)\n        for i in range(len(A)-2):\n            if A[i] < A[i+1] + A[i+2]:\n                return A[i]+A[i+1]+A[i+2]\n        return 0\n", "class Solution:\n    def largestPerimeter(self, A: List[int]) -> int:\n        #\u8981\u6ee1\u8db3\u4e24\u4e2a\u6761\u4ef6\uff0c\u4e00\u662f\u4e09\u4e2a\u76f8\u52a0\u6700\u5927\uff0c\u4e8c\u662f\u4e24\u8fb9\u548c\u5927\u4e8e\u7b2c\u4e09\u8fb9\uff0c\u5148\u8003\u8651\u6ee1\u8db3\u6761\u4ef6\u4e00\uff0c\u770b\u5728\u6761\u4ef6\u4e00\u4e0b\u6761\u4ef6\u4e8c\u662f\u5426\u6ee1\u8db3\n        A = sorted(A,reverse=True)\n        #A.sort(reverse = True)\n        for i in range(len(A)-2):\n            if A[i] < A[i+1] + A[i+2]:\n                return A[i] + A[i+1] + A[i+2]\n        return 0\n                \n", "class Solution:\n    def largestPerimeter(self, A: List[int]) -> int:\n        A.sort(reverse=True)\n        p = 0\n        for i in range(len(A) - 2):\n            if A[i] < A[i + 1] + A[i + 2]:\n                p = A[i] + A[i + 1] + A[i + 2]\n                break\n        return p\n", "class Solution:\n    def largestPerimeter(self, A: List[int]) -> int:\n        A.sort()\n        maxPe = 0\n        for i in range(len(A)-2):\n            if A[i]+A[i+1] > A[i+2]:\n                maxPe = A[i]+A[i+1]+A[i+2]\n        return maxPe", "class Solution:\n    def largestPerimeter(self, A: List[int]) -> int:\n        A.sort(reverse=True)\n        n = len(A)\n        for i in range(n-2):\n            if A[i] < A[i+1] + A[i+2]:\n                return  A[i] + A[i+1] + A[i+2]\n        return 0\n", "class Solution:\n    #3 max, check if they form a triangle\n    # 9 5 4 3 2 1\n    def largestPerimeter(self, A: List[int]) -> int:\n        n = len(A)\n        \n        A.sort(reverse = True)\n        a = 0\n        while (a < n):\n            b = a+1\n            c = a+2\n            while (b < n and c < n):\n                if (A[b]+A[c]>A[a]):\n                    return A[a]+A[b]+A[c]\n                else:\n                    b += 1\n                    c += 1\n            a+=1\n        return 0\n", "class Solution:\n    def largestPerimeter(self, A: List[int]) -> int:\n        if (len(A) < 3):\n            return 0;\n        \n        maxer = 0;\n        pointer1 = len(A) - 3;\n        pointer2 = len(A) - 2;\n        pointer3 = len(A) - 1;\n        A.sort();\n        \n        if len(A) == 3:\n            if (A[0] + A[1] > A[2]):\n                return sum(A);\n            else:\n                return 0;\n        \n        \n        \n        while (pointer3 >= 2):\n            if A[pointer1] + A[pointer2] > A[pointer3]:\n                return A[pointer1] + A[pointer3] + A[pointer2];\n            elif pointer1 == 0:\n                pointer3 -= 1;\n                pointer2 = pointer3 - 1;\n                pointer1 = pointer2 - 1;\n            else:\n                pointer1 -= 1;\n                pointer2 -= 1;\n            \n                \n        return maxer;\n        \n                    \n            \n        \n        \n        \n        \n        \n            \n        \n        \n", "class Solution:\n    def largestPerimeter(self, A: List[int]) -> int:\n        A.sort(reverse=True)\n        p = 0\n        for i in range(len(A) - 2):\n            if A[i] < sum(A[i+1:i+3]):\n                p = sum(A[i:i+3])\n                break\n        return p\n", "class Solution:\n    def largestPerimeter(self, A: List[int]) -> int:\n        A.sort(reverse = True)\n        for i in range(len(A)-2):\n            if A[i+1] + A[i+2] > A[i]:\n                return A[i+1] + A[i+2] + A[i]\n        return 0", "class Solution:\n    def largestPerimeter(self, A: List[int]) -> int:\n        A = sorted(A)\n        while(True):\n            if (A[-1] + A[-2] > A[-3]) and (A[-1] + A[-3] > A[-2]) and (A[-3] + A[-2] > A[-1]):\n                return (A[-1] + A[-2] + A[-3])\n            A.remove(A[-1])\n            if len(A) == 2:\n                return 0", "class Solution:\n    def largestPerimeter(self, A: List[int]) -> int:\n        A.sort(reverse=True)\n\n        for i in range(len(A) - 2):\n            a, b, c = A[i], A[i + 1], A[i + 2]\n            if a < b + c:\n                return a + b + c\n\n        return 0", "class Solution:\n    def largestPerimeter(self, A: List[int]) -> int:\n        \n        def area(a,b,c):\n            s=(a+b+c)/2\n            \n            val=(s*(s-a)*(s-b)*(s-c))**(1/2)\n            #print(type(val))\n            if isinstance(val,complex):\n                return 0\n            return val\n        \n        A.sort()\n        maxi=0\n        \n        for i in range(len(A)-2):\n            val=area(A[i],A[i+1],A[i+2])\n            \n            if val!=0:\n                p=(A[i]+A[i+1]+A[i+2])\n                #print(p,val)\n                if p>maxi:\n                    maxi=p\n            \n        return maxi\n            \n            \n            \n            \n        \n        \n", "class Solution:\n    def largestPerimeter(self, A: List[int]) -> int:\n        \n        def formT(a,b,c):\n            if not a+b>c:\n                return False\n            if not b+c>a:\n                return False\n            if not a+c>b:\n                return False\n            return True\n        \n        sides=sorted(A)\n        \n        for i in range(len(sides)-3,-1,-1):\n            if formT(sides[i],sides[i+1],sides[i+2]):\n                return sides[i]+sides[i+1]+sides[i+2]\n            \n        return 0", "class Solution:\n    def largestPerimeter(self, A: List[int]) -> int:\n        if len(A)<3:\n            return 0\n        \n        A.sort(reverse=True)\n        \n        while len(A)>2:\n            max_num = A.pop(0)\n            if max_num >= A[0] + A[1]:\n                continue\n            else:\n                return max_num+A[0]+A[1]\n        return 0\n", "class Solution:\n    def largestPerimeter(self, A: List[int]) -> int:\n      res = 0\n      A.sort()\n      for i in range(len(A)):\n        for j in range(i+1, len(A)):\n          source = A[i]\n          target = A[j]\n          lower = abs(target - source)\n          upper = source + target\n          if (upper*2 < res):\n            continue\n          for t in range(j+1, len(A)):\n            if lower < A[t] < upper:\n              res = max(source + target + A[t], res)\n              break\n          if res != 0:\n            break\n      return res\n", "class Solution:\n    def largestPerimeter(self, A: List[int]) -> int:\n        A.sort()\n        res = 0\n        for i in range(len(A)-2):\n            test = A[i:i+3]\n            if test[0] + test[1] > test[2] and test[2] - test[1] < test[0] and sum(test) > res:\n                res =sum(test)\n        return res\n            \n", "class Solution:\n    def largestPerimeter(self, A: List[int]) -> int:\n        A.sort(reverse=True)\n        for i in range(len(A)-2):\n            if A[i:i+3][1] + A[i:i+3][2] > A[i:i+3][0]:\n                return sum(A[i:i+3])\n        return 0", "class Solution:\n    def largestPerimeter(self, A: List[int]) -> int:\n        A.sort(reverse=True)\n        while len(A) >= 3:\n            if A[1] + A[2] > A[0]:\n                return A[1] + A[2] + A[0]\n            A.pop(0)\n        return 0", "class Solution:\n    def largestPerimeter(self, A: List[int]) -> int:\n        A.sort(reverse=True)\n        for i in range(len(A)-2):\n            a,b,c = A[i],A[i+1],A[i+2]\n            c1 = a+b>c\n            c2 = b+c>a\n            c3 = c+a>b\n            if c1 and c2 and c3:\n                return a+b+c\n            \n        return 0", "class Solution:\n    def largestPerimeter(self, A: List[int]) -> int:\n        A.sort(reverse = True)\n        for i in range(len(A) - 2):\n            if A[i] < A[i+1] + A[i+2]:\n                return A[i] + A[i+1] + A[i+2]\n        return 0\n            \n", "class Solution:\n    def largestPerimeter(self, A: List[int]) -> int:\n        A.sort(reverse=True)\n        n = len(A)\n        for i in range(n-2):\n            if A[i] < A[i+1] + A[i+2]:\n                return  A[i] + A[i+1] + A[i+2]\n        return 0", "class Solution:\n    def largestPerimeter(self, A: List[int]) -> int:\n        # A.sort()\n        # for i in range(len(A) - 3, -1, -1):\n        #     if A[i] + A[i + 1] > A[i + 2]:\n        #         return A[i] + A[i + 1] + A[i + 2]\n        # return 0\n        \n        A.sort(reverse  = True)\n        for i in range(len(A) - 2):\n            if A[i] < A[i + 1] + A[i + 2]:\n                return A[i] + A[i + 1] + A[i + 2]\n        return 0"]