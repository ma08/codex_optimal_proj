["from math import hypot\n\ndef dropzone(fire, dropzones):\n    return min(dropzones, key=lambda p: hypot(p[0]-fire[0], p[1]-fire[1]))", "def dropzone(p, dropzones):\n  return min(dropzones, key=lambda q: (q[0]-p[0])**2 + (q[1]-p[1])**2)", "from scipy.spatial.distance import euclidean\ndef dropzone(p, dropzones):\n    return min(dropzones, key = lambda a: euclidean(a, p))", "def dropzone(p, dropzones):\n    return min(dropzones, key=lambda d: (p[0]-d[0])**2 + (p[1]-d[1])**2)", "from math import sqrt\ndef dropzone(p, dropzones):\n    distances = {sqrt((p[0]-dz[0])**2+(p[1]-dz[1])**2):dz for dz in dropzones}\n    return distances[min(list(distances.keys()))]", "def dropzone(p, dropzones):\n    return min(dropzones,key=lambda d:(((d[0]-p[0])**2+(d[1]-p[1])**2)**0.5,(d[0]**2+d[1]**2)**0.5))", "def dropzone(p, dropzones):\n    distances = []\n    for dropzone in dropzones:\n        distances.append(((dropzone[0]-p[0])**2+(dropzone[1]-p[1])**2)**0.5)\n    return dropzones[distances.index(min(distances))]", "def dropzone(p, d):\n    res,ds=[],1000\n    for i in range(0,3):\n        d0=((p[0]-d[i][0])**2+(p[1]-d[i][1])**2)\n        if d0<ds:\n            ds=d0\n            res=d[i]\n    return res\n", "def dropzone(p, dropzones):\n    res = []\n    x1, y1 = p[0], p[1]\n    for dropzone in dropzones:\n        x2, y2 = dropzone[0], dropzone[1]\n        dist = ((x2-x1)**2 + (y2-y1)**2)**.5\n        res.append(dist)\n    shortest = res.index(min(res))\n    return dropzones[shortest]", "from math import hypot\n\ndef dropzone(fire, dropzones): ###\n    return min(dropzones, key=lambda x: hypot(x[0]-fire[0], x[1]-fire[1]))"]