["class Solution:\n    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:\n        \n        obstacles = set([tuple(x) for x in obstacles])\n        \n        face = 0 # NESW = 0123\n        x,y = 0,0\n        max_dist = 0\n        for command in commands:\n            if command==-2:\n                face = (face-1)%4\n            elif command==-1:\n                face = (face+1)%4\n            else:\n                if face==0:\n                    for i in range(1, command+1):\n                        if (x,y+i) in obstacles:\n                            i -= 1\n                            break\n                    y += i\n                    \n                elif face==1:\n                    for i in range(1, command+1):\n                        if (x+i,y) in obstacles:\n                            i -= 1\n                            break\n                    x += i\n                    \n                elif face==2:\n                    for i in range(1, command+1):\n                        if (x,y-i) in obstacles:\n                            i -= 1\n                            break\n                    y -= i\n                    \n                else:\n                    for i in range(1, command+1):\n                        if (x-i,y) in obstacles:\n                            i -= 1\n                            break\n                    x -= i\n                    \n                max_dist = max(max_dist, x**2+y**2)\n                \n        return max_dist", "class Solution:\n    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:\n        pos = [0,0]\n        #deg = [[0,1],[1,0],[0,-1],[-1,0]]\n        deg_x = 0\n        deg_y = 1\n        obstacles = set(map(tuple, obstacles))\n        ans = 0\n        \n        for walk in commands:\n            if walk == -2:\n                deg_x, deg_y = -deg_y, deg_x\n            elif walk == -1:\n                deg_x, deg_y = deg_y, -deg_x\n            else:\n                while walk > 0 :\n                    pos[0] += deg_x\n                    pos[1] += deg_y\n                    \n                    walk -= 1\n                    \n                    if (pos[0],pos[1]) in obstacles:\n                        pos[0] -= deg_x\n                        pos[1] -= deg_y\n                        break\n                ans = max(ans, pos[0]**2 + pos[1]**2)\n        return ans\n            \n", "class Solution(object):\n    def robotSim(self, commands, obstacles):\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        x = y = di = 0\n        obstacleSet = set(map(tuple, obstacles))\n        ans = 0\n\n        for cmd in commands:\n            if cmd == -2:  #left\n                di = (di - 1) % 4\n            elif cmd == -1:  #right\n                di = (di + 1) % 4\n            else:\n                for k in range(cmd):\n                    if (x+dx[di], y+dy[di]) not in obstacleSet:\n                        x += dx[di]\n                        y += dy[di]\n                        ans = max(ans, x*x + y*y)\n        return ans", "class Solution:\n    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        x = y = di = 0\n        o_set = set(map(tuple, obstacles))\n        max_dis = 0\n        for cmd in commands:\n            if cmd == -2:\n                di = (di - 1) % 4\n            elif cmd == -1:\n                di = (di + 1) % 4\n            else:\n                for _ in range(cmd):\n                    if (x + dx[di], y + dy[di]) not in o_set:\n                        x += dx[di]\n                        y += dy[di]\n                        max_dis = max(max_dis, x*x + y*y)\n        return max_dis\n", "class Solution:\n    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:\n        \n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        d = 0\n        x, y = 0, 0\n        \n        oset = set()\n        for o in obstacles: \n            oset.add(tuple(o))\n        \n        result = 0\n        for c in commands: \n            if c == -1:\n                d = (d + 1)% 4\n            elif c == -2: \n                d = (d + 4 - 1)%4\n            else: \n                for k in range(c): \n                    if (x + dx[d], y + dy[d]) not in oset: \n                        x+= dx[d]\n                        y += dy[d]\n                        result = max(result, x*x + y*y)\n        return result\n", "class Solution:\n    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:\n        # 10:20am\n        \n        # DFS\n        \n        cur = [0, 0]\n        directions = [[0,1],[1,0],[0,-1],[-1,0]]\n        cur_direction = 0 # facing north\n        max_distance = -1\n        obstacles = {tuple(i) for i in obstacles}  # have to use this to avoid TLE\n        for c in commands:\n            if c > 0:\n                while c > 0:\n                    # move forward\n                    cx, cy = cur\n                    next_pos = [cx + directions[cur_direction][0], cy + directions[cur_direction][1]]\n                    if (cx + directions[cur_direction][0], cy + directions[cur_direction][1]) in obstacles:\n                        break # stop moving, go to next command\n                    cur = next_pos\n                    c -= 1\n            elif c == -1:\n                cur_direction += 1\n                if cur_direction > 3:\n                    cur_direction = 0\n            elif c == -2:\n                cur_direction -= 1\n                if cur_direction < 0:\n                    cur_direction = 3\n            max_distance=max(max_distance, cur[0]*cur[0] + cur[1]*cur[1])\n        return max_distance\n                \n#         x, y = 0, 0   #current position of robot\n#         dx, dy = 0, 1   #direction of robot\n#         obs = {tuple(i) for i in obstacles}   #create set of obstacles for faster access\n#         maxdist = 0   #store max distance after each command\n        \n#         for step in commands:\n#             if 0 < step < 10:\n#                 for i in range(step):\n#                     x, y = x+dx, y+dy   #take each step individually\n#                     if (x,y) in obs:   #take one step back if on an obstacle\n#                         x, y = x-dx, y-dy\n#                         break\n#             elif step == -2:   #change direction | move left\n#                 dx, dy = -dy, dx\n#             elif step == -1:   #change direction | move right\n#                 dx, dy = dy, -dx\n            \n#             maxdist = max(maxdist, x**2 + y**2)\n        \n#         return maxdist\n", "class Solution:\n    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        x = y = di = 0\n        o_set = set(map(tuple, obstacles))\n        res = 0\n        for cmd in commands:\n            if cmd == -2:\n                di = (di - 1) % 4\n            elif cmd == -1:\n                di = (di + 1) % 4\n            else:\n                for _ in range(cmd):\n                    if (x + dx[di], y + dy[di]) not in o_set:\n                        x += dx[di]\n                        y += dy[di]\n                        res = max(res, x*x + y*y)\n        return res\n", "class Solution:\n    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:\n        \n        maxD2=0\n        pos=[0,0]\n        ori=[[0,1],[1,0],[0,-1],[-1,0]]\n        pOri=0\n        \n        obsSet=set()\n        for i in obstacles:\n            obsSet.add(tuple(i))\n        \n        for i in commands:\n            if i==-1:\n                pOri+=1\n                pOri%=4\n            elif i==-2:\n                pOri-=1\n                pOri%=4\n            else:\n                n=1\n                while n<=i:\n                    tempx=pos[0]+ori[pOri][0]\n                    tempy=pos[1]+ori[pOri][1]\n                    if (tempx,tempy) not in obsSet:\n                        pos[0]=tempx\n                        pos[1]=tempy\n                        n+=1\n                    else:\n                        break\n                maxD2=max(maxD2,pos[0]**2+pos[1]**2)\n                        \n        return(maxD2)", "class Solution:\n    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:\n        dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        d = 0\n        x = 0\n        y = 0\n        obs = set([tuple(x) for x in obstacles])\n        res = 0\n        for c in commands:\n            if c == -1:\n                d = (d + 1) % 4\n            elif c == -2:\n                d = (d - 1 + 4) % 4\n            else:\n                dx, dy = dirs[d]\n                for i in range(c):\n                    if (x + dx, y + dy) not in obs:\n                        x += dx\n                        y += dy\n                        res = max(res, x * x + y * y)\n        return res", "class Solution:\n    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:\n                i = j = mx = d = 0\n                move, obstacles = [(0, 1), (-1, 0), (0, -1), (1, 0), ], set(map(tuple, obstacles))\n                for command in commands:\n                    if command == -2: d = (d + 1) % 4\n                    elif command == -1: d = (d - 1) % 4\n                    else:\n                        x, y = move[d]\n                        while command and (i + x, j + y) not in obstacles:\n                            i += x\n                            j += y\n                            command -= 1\n                            mx = max(mx, i ** 2 + j ** 2)\n                return mx\n", "class Solution:\n    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:\n        x,y,di=0,0,0\n        dx=[0,1,0,-1]\n        dy=[1,0,-1,0]\n        obstacles=set(map(tuple,obstacles))\n        ans=0\n        \n        for cmd in commands:\n            if cmd==-2:\n                di=(di-1)%4\n            elif cmd==-1:\n                di=(di+1)%4\n            else:\n                for k in range(cmd):\n                    if (dx[di]+x,dy[di]+y) not in obstacles:\n                        x+=dx[di]\n                        y+=dy[di]\n                        ans=max(ans,x**2+y**2)\n        return ans\n                \n", "class Solution:\n    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        x = y = di = 0\n        obstacleSet = set(map(tuple, obstacles))\n        ans = 0\n\n        for cmd in commands:\n            if cmd == -2:  #left\n                di = (di - 1) % 4\n            elif cmd == -1:  #right\n                di = (di + 1) % 4\n            else:\n                for k in range(cmd):\n                    if (x+dx[di], y+dy[di]) not in obstacleSet:\n                        x += dx[di]\n                        y += dy[di]\n                    else:\n                        break\n                ans = max(ans, x*x + y*y)\n\n        return ans", "class Solution:\n    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:\n        x, y = 0, 0\n        d = 1\n        result = 0\n        dxy = [[1, 0], [0, 1], [-1, 0], [0, -1]]\n        obstacles = set(map(tuple, obstacles))\n        for c in commands:\n            if c == -2:\n                d = (d + 1) % 4\n            elif c == -1:\n                d = (d - 1) % 4\n            else:\n                for i in range(c):\n                    if (x + dxy[d][0], y + dxy[d][1]) in obstacles:\n                        break\n                    x += dxy[d][0]\n                    y += dxy[d][1]\n                    result = max(result, x ** 2 + y ** 2)\n        return result\n", "class Solution:\n\n        \n    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:\n        gldis=0\n        pos=[0,0]\n        dr=0\n        obs={tuple(i) for i in obstacles}\n        def nex (dr):\n            if dr==0:\n                return [pos[0],pos[1]+1]\n            if dr==1:\n                return [pos[0]+1,pos[1]]\n            if dr==2:\n                return [pos[0],pos[1]-1]\n            if dr==3:\n                return [pos[0]-1,pos[1]]\n        for i in commands:\n            if i==-1:\n                ne=dr+1\n                dr=ne%4\n            if i==-2:\n                ne=dr-1\n                dr=ne%4\n            else: \n                j=0\n                while j<i and (tuple(nex(dr)) not in obs):\n                        pos=nex(dr)\n                        j+=1\n                gldis=max(gldis,pos[0]*pos[0]+pos[1]*pos[1])\n        return gldis\n            \n                \n", "class Solution:\n    def __init__(self):\n        self.x = 0\n        self.y = 0\n        self.direction = (0, 1)\n        \n        self.obstacleSet = set()\n        \n    def _turnLeft(self):\n        newXDirection = -self.direction[1]\n        newYDirection = self.direction[0]\n        self.direction = (newXDirection, newYDirection)\n    \n    def _turnRight(self):\n        newXDirection = self.direction[1]\n        newYDirection = -self.direction[0]\n        self.direction = (newXDirection, newYDirection)\n    \n    def _tryMoveForward(self, numUnits):\n        canMoveNumUnits = 0\n        \n        xMove = self.direction[0]\n        yMove = self.direction[1]\n        \n        for i in range(1, numUnits + 1):\n            newX = self.x + (xMove * i)\n            newY = self.y + (yMove * i)\n            \n            if (newX, newY) not in self.obstacleSet:\n                canMoveNumUnits = i\n            else:\n                break\n        return canMoveNumUnits\n    \n    def _move(self, numUnits):\n        self.x += self.direction[0] * numUnits\n        self.y += self.direction[1] * numUnits\n    \n    \n    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:\n        maxDistance = 0        \n        \n        for obstacle in obstacles:\n            self.obstacleSet.add(tuple(obstacle))\n        \n        for command in commands:\n            if command == -2:\n                self._turnLeft()\n            elif command == -1:\n                self._turnRight()\n            else:\n                canMoveNumUnits = self._tryMoveForward(command)\n                self._move(canMoveNumUnits)\n                \n                maxDistance = max(maxDistance, self.x ** 2 + self.y ** 2)\n                \n        return maxDistance\n", "class Solution:\n    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:\n        if not commands:\n            return 0\n        \n        # \u8bbe\u7f6e\u521d\u59cb\u503c\n        x, y, res = 0, 0, 0\n        \n        # \u8bbe\u7f6e\u65b9\u5411\u6620\u5c04\n        directions = {0:1, 1:1, 2:-1, 3:-1}\n        cur_dir = 1\n        \n        # \u8bbe\u7f6e\u969c\u788d\u6620\u5c04\n        obs = set(map(tuple, obstacles))\n        \n        # \u57fa\u4e8e\u8f93\u5165\u503c\uff0c\u6539\u53d8\u65b9\u5411\uff1b\u57fa\u4e8e\u65b9\u5411\uff0c\u6539\u53d8\u5750\u6807\n        for cmd in commands:\n            # \u6539\u53d8\u65b9\u5411\n            if cmd == -2:\n                cur_dir = (cur_dir + 1) % 4\n            elif cmd == -1:\n                cur_dir = (cur_dir + 3 ) % 4 \n            else:\n                # \u57fa\u4e8e\u65b9\u5411\u6539\u53d8\u5750\u6807\n                t = directions[cur_dir]\n                x_move, y_move = (t,0) if cur_dir in (0,2) else (0,t)\n                for _ in range(cmd):\n                    if (x + x_move, y + y_move) not in obs:\n                        x += x_move\n                        y += y_move\n                        res = max(res, (x**2 + y**2))\n                    else:\n                        break\n        return res", "class Solution:\n    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:\n        obs = set(tuple(t) for t in obstacles)\n        \n        turns = {}\n        turns[('N', -1)] = 'E'\n        turns[('E', -1)] = 'S'\n        turns[('S', -1)] = 'W'\n        turns[('W', -1)] = 'N'\n        \n        turns[('N', -2)] = 'W'\n        turns[('W', -2)] = 'S'\n        turns[('S', -2)] = 'E'\n        turns[('E', -2)] = 'N'\n        \n        shifts = {}\n        shifts['N'] = (0, 1)\n        shifts['S'] = (0, -1)\n        shifts['E'] = (1, 0)\n        shifts['W'] = (-1,0)\n        \n        cur = [0,0]\n        curD = 'N'\n        \n        res = 0\n        for command in commands:\n            if command < 0:\n                curD = turns[(curD, command)]\n            else:\n                shift = shifts[curD]\n                for i in range(command):\n                    \n                    tmp = [cur[0]+shift[0], cur[1]+shift[1]]\n                    if tuple(tmp) in obs:\n                        break\n                    cur = tmp\n                    res = max(res, cur[0]*cur[0] + cur[1]*cur[1])\n\n        \n            print(cur)\n        return res\n                    \n                    \n                    \n        \n", "class Solution(object):\n    def robotSim(self, commands, obstacles):\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        x = y = di = 0\n        obstacleSet = set(map(tuple, obstacles))\n        ans = 0\n\n        for cmd in commands:\n            if cmd == -2:  #left\n                di = (di - 1) % 4\n            elif cmd == -1:  #right\n                di = (di + 1) % 4\n            else:\n                for k in range(0,cmd):\n                    if (x+dx[di], y+dy[di]) not in obstacleSet:\n                        x += dx[di]\n                        y += dy[di]\n                        ans = max(ans, x*x + y*y)\n\n        return ans", "class Solution:\n    def robotSim(self, c: List[int], b: List[List[int]]) -> int:\n        x, y, d, b, M = 0, 0, 0, set([tuple(i) for i in b]), 0\n        for i in c:\n            if i < 0: d = (d + 2*i + 3)%4\n            else:\n                if d in [1,3]:\n                    for x in range(x, x+(i+1)*(2-d), 2-d):\n                        if (x+(2-d), y) in b: break\n                else:\n                    for y in range(y, y+(i+1)*(1-d), 1-d):\n                        if (x, y+(1-d)) in b: break\n            M = max(M, x**2 + y**2)\n        return M", "class Solution:\n    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:\n        arrow = [(-1,0), (0,1), (1,0), (0,-1)]\n        arrowNow = 1\n        curPoint = [0,0]\n        obstacles = [tuple(e) for e in obstacles]\n        setObs = set(obstacles)\n        ans = 0\n        for e in commands:\n            if e==-1:\n                arrowNow= (arrowNow+1)%4\n            elif e==-2:\n                arrowNow= (arrowNow-1)%4\n            else:\n                for i in range(e):\n                    rowNow = curPoint[0] + arrow[arrowNow][0]\n                    colomNow = curPoint[1] + arrow[arrowNow][1]\n                    if (rowNow, colomNow) not in setObs:\n                        ans = max(ans, rowNow**2 + colomNow**2)\n                        curPoint[0], curPoint[1] = rowNow, colomNow\n        return ans\n        \n                        \n", "class Solution:\n    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:\n        i = j = mx = d = 0\n        move, obstacles = [(0, 1), (-1, 0), (0, -1), (1, 0), ], set(map(tuple, obstacles))\n        for command in commands:\n            if command == -2: d = (d + 1) % 4\n            elif command == -1: d = (d - 1) % 4\n            else:\n                x, y = move[d]\n                while command and (i + x, j + y) not in obstacles:\n                    i += x\n                    j += y\n                    command -= 1\n            mx = max(mx, i ** 2 + j ** 2)\n        return mx\n", "class Solution:\n    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:\n        move_pos = [[1, 0], [0, 1], [-1, 0], [0, -1]]\n        \n        now_pos = move_pos[0]\n        idx_now_pos = 0\n        obstacles = set(map(tuple, obstacles))\n\n        row_now = 0\n        col_now = 0\n        answer = 0\n        \n        for command in commands:\n            if command > 0:\n                for _ in range(command):\n                    row_tmp = row_now + now_pos[0]\n                    col_tmp = col_now + now_pos[1]\n                    if (col_tmp, row_tmp) not in obstacles:\n                        row_now += now_pos[0]\n                        col_now += now_pos[1]\n                        answer = max(answer, row_now**2 + col_now**2)\n            else:\n                if command == -1:\n                    idx_now_pos += 1\n                    if idx_now_pos > 3:\n                        idx_now_pos = 0 \n                elif command == -2:\n                    idx_now_pos -= 1\n                    if idx_now_pos < 0:\n                        idx_now_pos = 3 \n                now_pos = move_pos[idx_now_pos] \n        \n        return answer", "class Solution:\n    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:\n        \n        i = j = mx = d = 0\n        move, obstacles = [(0, 1), (-1, 0), (0, -1), (1, 0), ], set(map(tuple, obstacles))\n        for command in commands:\n            if command == -2: d = (d + 1) % 4\n            elif command == -1: d = (d - 1) % 4\n            else:\n                x, y = move[d]\n                while command and (i + x, j + y) not in obstacles:\n                    i += x\n                    j += y\n                    command -= 1\n            mx = max(mx, i ** 2 + j ** 2)\n        return mx\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n", "class Solution:\n    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        \n        obs = set(map(tuple, obstacles))\n        \n        x, y, direction, result = 0, 0, 0, 0\n        for cmd in commands:\n            if cmd == -1:\n                direction = (direction + 1) % 4\n            elif cmd == -2:\n                direction = (direction - 1) % 4\n            else:\n                for _ in range(cmd):\n                    nx, ny = x + dx[direction], y + dy[direction]\n                    if (nx, ny) in obs:\n                        break\n                    x, y = nx, ny\n            result = max(result, x**2 + y**2)\n        \n        return result\n", "class Solution:\n    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:\n        direction=(0,1)\n        start=[0,0]\n        obstacleSet = set(map(tuple,obstacles))\n        ans = 0\n        for cmd in commands:\n            if cmd == -2:\n                direction = (-direction[1], direction[0])\n            elif cmd == -1:\n                direction = (direction[1], -direction[0])\n            else:\n                for g in range(cmd):\n                    if (start[0]+direction[0],start[1]+direction[1]) not in obstacleSet:\n                        start[1] += direction[1]\n                        start[0] += direction[0]\n                        ans = max(ans, start[0]**2 + start[1]**2)\n        return ans", "class Solution:\n    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:\n        obSet= set(map(tuple,  obstacles))\n        print(obSet)\n        \n        result=0\n        X=0\n        Y=0\n        directions=[[0,1],[-1,0],[0,-1],[1,0]]\n        dirs=0\n        \n        for i in commands:\n            if i==-2:\n                dirs=(dirs+1)%4\n            elif i==-1:\n                dirs=(dirs+3)%4\n                \n            else:\n                for j in range(i):\n                    new_X= X+directions[dirs][0]\n                    new_Y= Y+directions[dirs][1]\n                    \n                    if (new_X, new_Y) in obSet:\n                        break\n                    \n                    X=new_X\n                    Y=new_Y\n                result=max(result, X*X + Y*Y)\n        return result", "class Solution:\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    dir_idx = 0 \n    curr_coords = (0, 0)\n        \n    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:\n        max_distance = 0 \n        obstacles = set(tuple(obstacle) for obstacle in obstacles)\n        \n        for command in commands: \n            if command == -2:\n                self.dir_idx = (self.dir_idx - 1) % 4 \n\n            if command == -1:\n                self.dir_idx = (self.dir_idx + 1) % 4 \n\n            else:\n                for i in range(command): \n                    x_move, y_move = self.directions[self.dir_idx]\n                    new_coords_x = self.curr_coords[0] + x_move\n                    new_coords_y = self.curr_coords[1] + y_move \n                    \n                    if (new_coords_x, new_coords_y) in obstacles: \n                        break\n                    \n                    self.curr_coords = (new_coords_x, new_coords_y)\n                    max_distance = max(max_distance, sum(coord ** 2 for coord in self.curr_coords))\n                    \n        return max_distance\n                \n                \n        \n", "class Solution:\n    def robotSim(self, c: List[int], b: List[List[int]]) -> int:\n             \n        x, y, d, b, M = 0, 0, 0, set([tuple(i) for i in b]), 0\n        for i in c:\n            if i < 0: d = (d + 2*i + 3)%4\n            else:\n                if d in [1,3]:\n                    for x in range(x, x+(i+1)*(2-d), 2-d):\n                        if (x+(2-d), y) in b: break\n                else:\n                    for y in range(y, y+(i+1)*(1-d), 1-d):\n                        if (x, y+(1-d)) in b: break\n            M = max(M, x**2 + y**2)\n        return M\n        \n", "class Solution:\n    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:\n        \n        # LC solution copy\n        '''\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        \n        x = y = di = 0\n        \n        obstacleSet = set(map(tuple,obstacles))\n        ans = 0\n        \n        for cmd in commands:\n            if cmd == -2: # left\n                di = (di - 1) % 4\n            elif cmd == -1: # right\n                di = (di + 1) % 4\n            else:\n                for k in range(cmd):\n                    if (x + dx[di], y + dy[di]) not in obstacleSet:\n                        x += dx[di]\n                        y += dy[di]\n                        ans = max(ans, x*x + y*y)\n                        \n        return ans\n        '''\n        \n        \n        \n        \n        \n        \n        # My attempt failed with incorrect answer for some large input, so above is LC copy, Fixed the mistake in code below,\n        # Basically we are asked for maximum distance the robot went, not the distance to final destination.\n        \n        # -2: turn left 90 degrees\n        # -1: turn right 90 deg\n        # 1 <= x <= 9 forward x units\n        \n        #obstacle[i][0], obstacles[i][1] is an obstacle\n        \n        # Calculate euclidean distance from origin.\n        \n        #check obstacle at every move and apply the distance and turns he can perform.\n        \n        # cmd[i]\n        # position[i] = position[i-1] + min(cmd[i], blocked())\n        \n        obstacleSet = set()\n        \n        for p in obstacles:\n            obstacleSet.add(tuple(p))\n        \n        dirs = [1, 1, -1, -1] # must be 1 for west and north, -1 for east and south \n        \n        axis = [0, 1] # must be 0 for east and west, 1 for north and south.\n        \n        position = [0,0]\n        \n        ax = 1 # Along Y axis \n        up = 0 # Facing north\n        result = 0\n        for cmd in commands:\n            \n            if cmd > 0:\n                # scan for obstacle and limit move up to the obstacle\n                nextstop = list(position)\n                for c in range(cmd):\n                    \n                    nextstop[ax] = nextstop[ax] + (dirs[up])\n                    \n                    if tuple(nextstop) in obstacleSet:\n                        break\n                    position = list(nextstop)\n                    result = max(result,position[0]**2 + position[1]**2)\n    \n            elif cmd == -2:\n                ax = (ax + 1)%2\n                up = (up + 3)%4 # Left\n            elif cmd == -1:\n                ax = (ax + 1)%2\n                up = (up + 1)%4 # Right\n            \n            #print(prev, \\\"->\\\", position, ax, up)\n        \n        return result", "class Solution:\n    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int: \n        x = y = d = ans = 0\n        obs = set(map(tuple, obstacles))\n        move = [[0,1],[1,0],[0,-1],[-1,0]]\n        for i in commands:\n            if i == -2:\n                d = (d-1)%4\n            elif i == -1:\n                d = (d+1)%4\n            else:\n                for j in range(i):\n                    if (x + move[d][0], y +move[d][1]) not in obs:\n                        x += move[d][0]\n                        y += move[d][1]\n                        ans = max(ans, x**2 + y**2)\n        return ans\n                \n        \n                \n", "class Solution:\n    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:\n        d = [(0,1),(1,0),(0,-1),(-1,0)]\n        di = 0\n        cur = [0,0]\n        obs = set([tuple(x) for x in obstacles])\n        maxx = 0\n        for i in commands:\n            if i == -2:\n                di = di-1 if di>0 else 3\n            elif i == -1:\n                di = (di+1)%4\n            else:\n                for x in range(i):\n                    xi,yi = cur[0]+d[di][0],cur[1]+d[di][1]\n                    if (xi, yi) in obs:\n                        break\n                    cur = (xi,yi)\n                    maxx = max(maxx,cur[0]**2 + cur[1]**2)\n        return maxx\n", "class Solution:\n    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:\n        \n        x,y = (0,0)\n        \n        ob = set([tuple(i) for i in obstacles])\n        \n        dd = {0:[[-1, 0]], 1:[[0,1]], 2:[[1,0]], 3:[[0,-1]]}\n        \n        d = 1\n        \n        ans = 0\n        \n        for i in commands:\n            if i < 0:\n                d += 1 if i == -1 else -1\n                d %= 4\n            else:\n                for m,n in dd[d]:\n                    while i and (x+m,y+n) not in ob:\n                        x += m \n                        y += n\n                        i-=1\n                    ans = max(ans, x**2+y**2)\n        \n        return ans\n        \n        \n", "class Solution:\n    def robotSim(self, commands, obstacles):\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        x = y = di = 0\n        obstacleSet = set(map(tuple, obstacles))\n        ans = 0\n\n        for cmd in commands:\n            if cmd == -2:  #left\n                di = (di - 1) % 4\n            elif cmd == -1:  #right\n                di = (di + 1) % 4\n            else:\n                for k in range(cmd):\n                    if (x+dx[di], y+dy[di]) not in obstacleSet:\n                        x += dx[di]\n                        y += dy[di]\n                        ans = max(ans, x*x + y*y)\n\n        return ans", "class Solution:\n    \n    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:\n        \n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        x = y = di = 0\n        obstacleSet = set(map(tuple, obstacles))\n        ans = 0\n        \n        for command in commands:\n            if command == -2:\n                di = (di - 1) % 4  # left\n            elif command == -1:\n                di = (di + 1) % 4  # right\n            else:\n                for _ in range(command):\n                    if (x + dx[di], y + dy[di]) not in obstacleSet:\n                        x += dx[di]\n                        y += dy[di]\n                    ans = max(ans, pow(x, 2) + pow(y, 2))\n        \n        return ans\n", "class Solution:\n    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:\n        \n        x = y = 0\n        max_dist = 0\n        directions = ((0,1), (1,0), (0,-1), (-1,0))\n        obstacles = set(tuple(x) for x in obstacles)\n        direction = 0\n        \n        for command in commands:\n            \n            if command == -1:\n                \n                direction += 1\n                \n                if direction == 4:\n                    direction = 0\n            \n            elif command == -2:\n                \n                direction -= 1\n                \n                if direction == -1:\n                    direction = 3\n            \n            else:\n                \n                new_x, new_y = directions[direction]\n                \n                while command > 0 and (x+new_x, y+new_y) not in obstacles:\n                    \n                    x += new_x\n                    y += new_y\n                    command -= 1\n                \n                max_dist = max(max_dist, x**2 + y**2)\n        \n        return max_dist\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n", "class Solution:\n    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:\n        x, y = 0, 0   #current position of robot\n        dx, dy = 0, 1   #direction of robot\n        obs = {tuple(i) for i in obstacles}   #create set of obstacles for faster access\n        maxdist = 0   #store max distance after each command\n        \n        for step in commands:\n            if 0 < step < 10:\n                for i in range(step):\n                    x, y = x+dx, y+dy   #take each step individually\n                    if (x,y) in obs:   #take one step back if on an obstacle\n                        x, y = x-dx, y-dy\n                        break\n            elif step == -2:   #change direction | move left\n                dx, dy = -dy, dx\n            elif step == -1:   #change direction | move right\n                dx, dy = dy, -dx\n            \n            maxdist = max(maxdist, x**2 + y**2)\n        \n        return maxdist", "class Solution:\n    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:\n        direct = [[0, 1], [1, 0], [0, -1], [-1, 0]]\n        i = 0\n        pos = [0, 0]\n        obstacles = set(tuple(x) for x in obstacles)\n        max_dis = 0\n        for num in commands:\n            if num >= 0:\n                for j in range(num):\n                    pos[0] += direct[i][0]\n                    pos[1] += direct[i][1]\n                    if tuple(pos) in obstacles:\n                        pos[0] -= direct[i][0]\n                        pos[1] -= direct[i][1]\n                        break\n            else:\n                if num == -1:\n                    i = (i+1) % 4\n                elif num == -2:\n                    i = i-1 \n                    if i < 0: i = 3\n            \n            max_dis = max(max_dis, pos[0]**2+pos[1]**2)\n        return max_dis", "class Solution:\n    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:\n        i = j = mx = d = 0\n        move, obstacles = [(0, 1), (-1, 0), (0, -1), (1, 0), ], set(map(tuple, obstacles))\n        for command in commands:\n            if command == -2: d = (d + 1) % 4\n            elif command == -1: d = (d - 1) % 4\n            else:\n                x, y = move[d]\n                while command and (i + x, j + y) not in obstacles:\n                    i += x\n                    j += y\n                    command -= 1\n            mx = max(mx, i ** 2 + j ** 2)\n        return mx", "class Solution:\n    coordinates = [[0,1],[1,0],[0,-1],[-1,0]]\n    \n    def robotSim(self, cmd: List[int], ob: List[List[int]]) -> int:\n        obstruction = set(tuple(x) for x in ob)\n        curr = 0\n        x = 0\n        y = 0\n        res = 0\n        for c in cmd:\n            if c == -2:\n                curr -= 1\n                if curr < 0:\n                    curr = 3\n            elif c == -1:\n                curr = (curr+1)%4\n            else:\n                while c > 0:\n                    x,y = x + self.coordinates[curr][0], y + self.coordinates[curr][1]\n                    if (x,y) in obstruction:\n                        x = x - self.coordinates[curr][0]\n                        y = y - self.coordinates[curr][1]\n                        break\n                    c -= 1\n            res = max(res, x*x+y*y)\n        return res\n                    \n                \n", "class Solution:\n    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:\n        directions = [(0,1), (1, 0), (0, -1), (-1, 0)]\n        d_id = 0\n        \n        obs = set()\n        for o in obstacles:\n            obs.add(tuple(o))\n        \n        x = 0\n        y = 0\n        best = 0\n        for i in range(len(commands)):\n            if commands[i] == -1:\n                d_id = (d_id + 1) % 4\n            elif commands[i] == -2:\n                d_id = (d_id - 1) % 4\n            else:\n                while commands[i] > 0:\n                    if (x + directions[d_id][0], y + directions[d_id][1]) not in obs:\n                        x +=  directions[d_id][0]\n                        y += directions[d_id][1]\n                        best = max(best, x**2 + y**2)\n                    else:\n                        break\n                    commands[i] -= 1\n                        \n        return best", "class Solution:\n    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:\n        obs = set(map(tuple, obstacles))\n        cur_pos = (0, 0)\n        d = 0\n        m = 0\n        \n        cur_steps = 0\n        for cmd_idx, cmd in enumerate(commands):\n            if cmd < 0:\n                cur_pos = self.new_pos(obs, d, cur_steps, cur_pos)\n                m = max(m, cur_pos[0] ** 2 + cur_pos[1] **2)\n                cur_steps = 0\n                \n                if cmd == -2:\n                    d = (d - 1) % 4\n                elif cmd == -1:\n                    d = (d + 1) % 4\n            else:\n                cur_steps += cmd\n                \n        cur_pos = self.new_pos(obs, d, cur_steps, cur_pos)\n        m = max(m, cur_pos[0] ** 2 + cur_pos[1] **2)\n        return m\n    \n    def new_pos(self, obs, d, cur_steps, cur_pos):\n        if cur_steps == 0:\n            return cur_pos \n        \n        if d == 0:\n            idx = 1\n            incr = 1\n        elif d == 1:\n            idx = 0\n            incr = 1\n        elif d == 2:\n            idx = 1\n            incr = -1\n        elif d == 3:\n            idx = 0\n            incr = -1\n\n        while cur_steps > 0:\n            if idx == 0:\n                next_pos = (cur_pos[0] + incr, cur_pos[1])\n            else:\n                next_pos = (cur_pos[0], cur_pos[1] + incr)\n            if next_pos in obs:\n                break\n            cur_pos = next_pos\n            cur_steps -= 1\n        return cur_pos\n", "class Solution:\n    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:\n        pos = [0, 0]\n        deg = 90\n        ans = 0\n        obstaclesSet = set(map(tuple, obstacles))\n\n        for command in commands:\n            if command == -1:\n                deg = (deg + 270) % 360\n            elif command == -2:\n                deg = (deg + 90) % 360\n            else:\n                if deg == 0:\n                    i = 0\n                    while i < command and not (pos[0] + 1, pos[1]) in obstaclesSet:\n                        pos[0] += 1\n                        i += 1\n                if deg == 90:\n                    i = 0\n                    while i < command and not (pos[0], pos[1] + 1) in obstaclesSet:\n                        pos[1] += 1\n                        i += 1\n                if deg == 180:\n                    i = 0\n                    while i < command and not (pos[0] - 1, pos[1]) in obstaclesSet:\n                        pos[0] -= 1\n                        i += 1\n                if deg == 270:\n                    i = 0\n                    while i < command and not (pos[0], pos[1] - 1) in obstaclesSet:\n                        pos[1] -= 1\n                        i += 1\n                ans = max(ans, pos[0] ** 2 + pos[1] ** 2)\n        return ans\n", "class Solution:\n    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:\n        obs = {tuple(i) for i in obstacles}\n        x, y = 0, 0\n        dx, dy = 0, 1\n        maxdist = 0\n        for i in commands:\n            if 1 <= i <= 9:\n                for j in range(i):\n                    x, y = x+dx, y+dy\n                    if (x,y) in obs:\n                        x, y = x - dx, y-dy\n                        break\n            elif i == -2:\n                dx, dy = -dy, dx\n            elif i == -1:\n                dx, dy = dy, -dx\n                \n            maxdist = max(maxdist, x**2+y**2)\n        return maxdist\n    \n", "class Solution:\n    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:\n        directions=[[0,1], [1,0], [0,-1], [-1,0]]\n        curr=[0,0]\n        ori=0\n        obstacles={tuple(obs) for obs in obstacles}\n        maxx=0\n        for cmd in commands:\n            if cmd==-2:\n                ori=(ori-1)%4\n            elif cmd==-1:\n                ori=(ori+1)%4\n            else:\n                for _ in range(cmd):\n                    nexxt=[curr[0]+directions[ori][0], curr[1]+directions[ori][1]]\n                    if tuple(nexxt) not in obstacles:\n                        curr=nexxt\n                        maxx=max(maxx, curr[0]**2+curr[1]**2)\n        return maxx", "class Solution:\n    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:\n        \n        \n        i = j = mx = d = 0\n        move, obstacles = [(0, 1), (-1, 0), (0, -1), (1, 0), ], set(map(tuple, obstacles))\n        for command in commands:\n            if command == -2: d = (d + 1) % 4\n            elif command == -1: d = (d - 1) % 4\n            else:\n                x, y = move[d]\n                while command and (i + x, j + y) not in obstacles:\n                    i += x\n                    j += y\n                    command -= 1\n            mx = max(mx, i ** 2 + j ** 2)\n        return mx", "class Solution:\n    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:\n        x = y = 0\n        dx = 0\n        dy = 1\n        ans = 0\n        o_dict = {}\n        for obstacle in obstacles:\n            o_dict[tuple(obstacle)] = True\n        for command in commands:\n            if command == -2:\n                dx, dy = -dy, dx\n            elif command == -1:\n                dy, dx = -dx, dy\n            else:\n                for k in range(command):\n                    if (x+dx, y+dy) not in o_dict.keys():\n                        x += (dx)\n                        y += (dy)\n                        ans = max(ans, x**2 + y**2)\n                    else:\n                        break\n                        \n        return ans", "class Solution:\n    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        x = y = di = 0\n        obstacleSet = set(map(tuple, obstacles))\n        ans = 0\n\n        for cmd in commands:\n            if cmd == -2:  #left\n                di = (di - 1) % 4\n            elif cmd == -1:  #right\n                di = (di + 1) % 4\n            else:\n                for k in range(cmd):\n                    if (x+dx[di], y+dy[di]) not in obstacleSet:\n                        x += dx[di]\n                        y += dy[di]\n                        ans = max(ans, x*x + y*y)\n\n        return ans\n"]