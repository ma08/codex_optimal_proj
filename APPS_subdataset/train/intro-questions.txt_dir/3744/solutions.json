["def oddest(numbers):\n    most_odd   = 0      # The current most odd number in the list\n    max_oddity = -1     # The current greatest oddity rate, starts at -1 so that even an even number can be the unique most odd\n    is_unique  = True   # If the current most odd number is really the most, so if there is no unique oddest number, it will return None\n    for num in numbers:  # Loop through all the numbers\n        oddity  = 0      # The oddity rate starts at 0\n        print(num)\n        insider = num    # The coefficient of the number 2, so in 2n + 1, the insider is n\n        while insider % 2 == 1:  # While that coefficient is odd\n            if insider == -1:\n                oddity = 1 + max([abs(n) for n in numbers]) # Since the oddity rate of a number is NEVER greater than the absolute value of the number, this garantees that the current number is the most odd one\n                break\n            else:\n                oddity  += 1               # Add the oddity rate of the total number\n                insider = (insider-1)/2    # So if in 2n + 1, n is odd, represent it as 2(2m + 1) + 1, and set the value to m\n        if oddity > max_oddity:  # If the current number's oddity rate is greater than the current max oddity,\n            is_unique = True     # Set it to unique\n            max_oddity = oddity  # Set the max oddity to the current oddity\n            most_odd   = num     # Set the most odd number to the current number\n        elif oddity == max_oddity:# Otherwise, if it's the same rate\n            is_unique = False    # It's not unique\n    if is_unique and max_oddity >= 0:  # If the current most odd number is REALLY the most odd number and the list isn't empty\n        return most_odd # Return it\n    return None # Otherwise, return None", "def oddest(xs):\n    os = list(map(oddness, xs))\n    max_o = max(os, default=None)\n    return xs[os.index(max_o)] if os.count(max_o) == 1 else None\n\ndef oddness(x):\n    return float('inf') if x == -1 else ~x & -~x", "from collections import defaultdict\n\ndef oddity(n):\n    if n == -1:\n        return float('inf')\n    odd = 0\n    while n % 2:\n        odd += 1\n        n //= 2\n    return odd\n\ndef oddest(a):\n    result = defaultdict(list)\n    for n in a:\n        result[oddity(n)].append(n)\n    try:\n        x, = result[max(result)]\n        return x\n    except ValueError:\n        pass", "from heapq import nlargest\nfrom functools import cmp_to_key\n\ndef oddity(n1, n2):\n    while True:\n        n1, m1 = divmod(n1, 2)\n        n2, m2 = divmod(n2, 2)\n        if m1 != m2 or m1 == 0 == m2 or n1 == n2:\n            break\n    return -1 if m1 < m2 else m1 > m2\n    \ndef oddest(arr):\n    res = nlargest(2, arr, key = cmp_to_key(oddity))\n    if res and (len(res) == 1 or oddity(res[0], res[1])):\n        return res[0]", "def oddest(a):\n    d, o = {}, a.count(-1)\n    for i, j in enumerate(a):\n        n = j\n        while n != 0 and n & 1 and n != -1:\n            n = (abs(n) // 2 + int(n < 0)) * [1, -1][n < 0]\n            d[i] = d.get(i, -1) + 1\n    m = max(d, key=lambda x: d[x],default=0)  \n    return a[0] if len(a)==1 else -1 if o==1 else a[m] if d and list(d.values()).count(d[m])==1 and o<2 else None", "from collections import defaultdict\n\ndef odd(x):\n    if x == -1: return 10 # Infinite recursive, that's the oddest you can get\n    if not x&1: return 0\n    return 1 + odd((x-1)>>1)\n\ndef oddest(a):\n    if not a: return\n    D = defaultdict(list)\n    for x in a: D[odd(x)].append(x)\n    L = D[max(D)]\n    if len(L) == 1: return L[0]", "def oddest(a):\n    f = lambda x: 1e6 if x == -1 else x % 2 and 1 + f(x // 2) or 0\n    a = [(x, f(x)) for x in a]\n    n = max((y for x, y in a), default=-1)\n    a = [x for x, y in a if y == n]\n    if len(a) == 1: return a[0]", "def oddest(a):\n    if all(n % 2 == 0 for n in a):\n        return a[0] if len(a) == 1 else None\n    if -1 in a:\n        return -1 if a.count(-1) == 1 else None\n    a = [(x, x) for x in a if x % 2 != 0]\n    while True:\n        if len(a) == 0:\n            return None\n        if len(a) == 1:\n            return a[0][0]\n        a = list(filter(lambda n: n[1] % 2 != 0, ((n[0], (n[1] - 1) // 2 if n[1] != -1 else 1) for n in a)))", "d={}\ndef odd(n):\n    if n==-1:return 10**1000\n    r=0\n    while n%2:\n        r+=1\n        n=(n-1)//2\n    return r\n    \ndef oddest(a):\n    if not a:return\n    o=[*map(odd,a)]\n    if o.count(max(o))>1:return\n    return max(a,key=odd)", "from collections import Counter\nfrom math import inf\n\ndef oddest(arr):\n    c = Counter(map(oddness, arr))\n    return max(arr, key=oddness) if c and c[max(c)] == 1 else None\n    \ndef oddness(n):\n    if n == -1:\n        return inf\n    m, is_odd = divmod(n, 2)\n    cnt = 0\n    while is_odd:\n        m, is_odd = divmod(m, 2)\n        cnt += 1\n    return cnt"]