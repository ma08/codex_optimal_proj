["def sort_array(xs):\n    es = sorted(x for x in xs if x % 2 == 0)\n    os = sorted((x for x in xs if x % 2 != 0), reverse=True)\n    return [(es if x % 2 == 0 else os).pop() for x in xs]", "def sort_array(a):\n    odds = []; evens = []; newArray = []\n    for i in a:\n        if i % 2 == 0:\n            evens.append(i)\n        else:\n            odds.append(i)\n    evens.sort(); evens.reverse()\n    odds.sort()\n    for i in range(len(a)):\n        if a[i] % 2 == 0:\n            newArray.append(evens[0])\n            evens.pop(0)\n        else:\n            newArray.append(odds[0])\n            odds.pop(0)\n    return newArray", "def sort_array(a):\n    odds = iter(sorted(n for n in a if n % 2))\n    evens = iter(sorted((n for n in a if not n % 2), reverse=True))\n    return [next(odds) if n % 2 else next(evens) for n in a]\n", "def sort_array(a):\n    sorted_odd, sorted_even = sorted(value for value in a if value & 1), sorted([value for value in a if not value & 1], reverse=True)\n    return [sorted_odd.pop(0) if value & 1 else sorted_even.pop(0) for value in a]", "def sort_array(a):\n    e, o = sorted(x for x in a if x % 2 ^ 1), sorted((x for x in a if x % 2), reverse=True)\n    return [(o if x % 2 else e).pop() for x in a]", "def sort_array(a):\n    # Create two sorted arrays one containing even and on odd numbers. Each array \n    # is sorted opposite of the desired results as we will pop items off the array.\n    sorted_odd = sorted([x for x in a if x % 2 == 1], reverse=True)\n    sorted_even = sorted([x for x in a if x % 2 == 0])\n    \n    # Build the final output. Place the sorted even numbers where even numbers were\n    # in the original list and sorted odd numbers where odd numbers were in the \n    # original list.\n    out = []\n    for x in a:\n        if x % 2 == 0:\n            out.append(sorted_even.pop())\n        else:\n            out.append(sorted_odd.pop())\n            \n    return out\n", "def sort_array(lst):\n    s = sorted(lst)\n    even = (n for n in s[::-1] if n & 1 == 0)\n    odd = (n for n in s if n & 1)\n    return [next(odd if n & 1 else even) for n in lst]", "def sort_array(lst):\n    even, odd = [], []\n    for n in sorted(lst):\n        (odd if n & 1 else even).append(n)\n    even, odd = iter(even[::-1]), iter(odd)\n    return [next(odd if n & 1 else even) for n in lst]", "def sort_array(a):\n    lenList = len(a)\n\n    if lenList ==0:\n        return []\n\n    evenNums, oddNums = [], []\n    evenNumLoc, oddNumLoc = [],[]\n\n    #Walk through the given list of numbers, and store even numbers (and \n    #their index loc); same for odds \n    for i in range(0, lenList, 1):\n        if a[i]%2==0:\n            evenNums.append(a[i])   #save even number\n            evenNumLoc.append(i)    #save even number index location\n        else:\n            oddNums.append(a[i])    #save odd number\n            oddNumLoc.append(i)     #save odd number location\n\n    evenNums.sort(reverse = True)   #decending order for evens\n    oddNums.sort()                  #ascending order for odds\n\n    #pre allocate the list so we can store via direct access\n    sortedList = [0 for _ in range(lenList)]\n    totalNumEvens = len(evenNums)\n    totalNumOdds  = len(oddNums)\n\n    #Store the sorted even numbers at the indicies where they were located in the original list\n    for i in range(0, totalNumEvens, 1):\n        sortedList[evenNumLoc[i]] = evenNums[i]\n\n    #Store the sorted odd numbers at the indicies where they were located in the original list\n    for i in range(0, totalNumOdds, 1):\n        sortedList[oddNumLoc[i]] = oddNums[i]\n\n    return sortedList\n\n#end function\n", "from collections import deque\n\ndef sort_array(a):\n    asc = deque(sorted(x for x in a if x%2))\n    desc = sorted(x for x in a if not x%2)\n    return [asc.popleft() if x%2 else desc.pop() for x in a]"]