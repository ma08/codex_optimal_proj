["def sierpinski():\n    x = s = 0\n    while 1:\n        for a in 4, 9, 56, 61:\n            s += x + a\n            yield s\n        x += 65\n\ns = sierpinski()\nS = [next(s)]\n\nfrom bisect import bisect_left\ndef find_closest_value(m):\n    while S[-1] < m: S.append(next(s))\n    i = bisect_left(S, m)\n    return min(S[i:i-2:-1], key=lambda n: abs(m - n))", "import math\ndef find_closest_value(Q) :\n    B = math.ceil((math.ceil(Q / 65) / 2) ** .5)\n    S,B = 130 * B * B,65 * B\n    return S - min((0,B - 4,B + B - 13,3 * B - 69,4 * B - 130),key = lambda V : abs(Q - S + V)) or 4", "def find_closest_value(m):\n    x = int((m/130)**0.5)\n    y, z = 130 * x**2, 65*x\n    res = [y + v + i*z for i,v in enumerate((0, 4, 13, 69, 130))]\n    return min(res, key=lambda k: (abs(m-k), m-k)) or 4", "class SierpinskiSumFunc():\n    def __init__(self):\n        sierpinski_number = 4\n        sierpinski_numbers_add = (5, 47, 5, 8)  # (47, 5, 8, 5)\n        sierpinski_sum = [4, ]\n        n = 0\n        while sierpinski_sum[-1] < 520000000000000:\n            sierpinski_number += sierpinski_numbers_add[n]\n            sierpinski_sum.append(sierpinski_sum[-1] + sierpinski_number)\n            n = 0 if n == 3 else n + 1\n        self.sierpinski_sum = tuple(sierpinski_sum)\n\n\nsierpinski_sum_obj = SierpinskiSumFunc()\n\ndef find_closest_value(m):\n    if m <= 4:\n        return 4\n    if m <= 100000:\n        sierpinski_sum = sierpinski_sum_obj.sierpinski_sum\n        nn = 0\n        while True:\n            if m == sierpinski_sum[nn]:\n                return m\n            elif m < sierpinski_sum[nn + 1] and m > sierpinski_sum[nn]:\n                return sierpinski_sum[nn + 1] if m - sierpinski_sum[nn + 1] >= sierpinski_sum[nn] - m else sierpinski_sum[nn]\n            nn += 1\n    elif m > 100000:\n        sierpinski_sum = sierpinski_sum_obj.sierpinski_sum\n        nn = -1\n        while True:\n            if m == sierpinski_sum[nn]:\n                return m\n            elif m > sierpinski_sum[nn - 1] and m < sierpinski_sum[nn]:\n                return sierpinski_sum[nn - 1] if m - sierpinski_sum[nn - 1] < sierpinski_sum[nn] - m else sierpinski_sum[nn]\n            if m < sierpinski_sum[nn - 20]:\n                nn -= 20\n            else:\n                nn -= 1", "# Helpful math trivias: \n# ---------------------\n# 1. if \"x\" is in the sequence of the 'a's, then \n#    5*13*y+x is also in the sequence of 'a's\n# 2. the base solutions are 4, 9, 56, 61\n# 3. if the sequence is terminated at the right point,\n#    then it is the mix of 4 independent arithmetic\n#    sequences (x=130*n**2 is the total sum of the four)\n\nimport math\n\ndef find_closest_value(x):\n   if x < 4:\n      return 4\n\n   n = math.sqrt(x/130)\n   n_low = math.floor(n)\n   seed = 130*n_low**2\n   n_inc = n_low*65\n   candidates = [seed,\n                 seed+4  +1*n_inc,\n                 seed+13 +2*n_inc,\n                 seed+69 +3*n_inc,\n                 seed+130+4*n_inc]\n   candidates=sorted(candidates,reverse=True)\n   candidates=sorted(candidates,key=lambda a:abs(a-x))\n   return candidates[0]", "# https://oeis.org/A203464\ns = [0]\nfor m in range(0,10**9):\n    for p in (4,9,56,61):\n        s.append(s[-1]+m*65+p)\n    if s[-1]>52*10**13: break\n\nfrom bisect import bisect\n\ndef find_closest_value(m):\n    if m<4: return 4\n    i = bisect(s,m)\n    return s[min([i,i-1], key=lambda i:abs(s[i]-m))]", "def find_closest_value(m):\n    if m < 4:\n        return 4\n    l = [130 * k ** 2 + k * i * 65 + a for i, a in enumerate([4, 13, 69, 130], 1) for k in [int((m // 130) ** 0.5) - 1, int((m // 130) ** 0.5)]]\n    return min(l, key = lambda x: (abs(m - x), -x))", "def find_closest_value(m):\n    a = lambda i: ((i - 1) // 4) * 65 + [4, 9, 56, 61][(i - 1) % 4]\n    s = lambda n: a(-~((n * n - 1) // 2)) + (4 if n % 2 == 0 else 0)\n    n = int((m // 65 * 8) ** 0.5)\n    while s(n) <= m:\n        n += 1\n    if n == 1: return 4\n    d1 = s(n) - m\n    d2 = m - s(n - 1)\n    return s(n) if d1 <= d2 else s(n - 1)"]