["from itertools import combinations\n\n\ndef closest_sum(ints, num):\n    return sum(min(combinations(ints, 3), key=lambda a: abs(num - sum(a))))", "from itertools import combinations\n\ndef closest_sum(ints, num):\n    ss = map(sum, combinations(ints, 3))\n    return min(ss, key=lambda x: abs(x-num))", "from itertools import combinations\n\ndef closest_sum(arr, target):\n    return min(map(sum, combinations(arr, 3)), key=lambda s: abs(target-s))", "from itertools import combinations\n\ndef closest_sum(ints, num):\n    return sum(min(combinations(ints, 3), key=lambda i: abs(num-sum(i))))", "from itertools import combinations\n\ndef closest_sum(ints, num):\n    return min(map(sum, combinations(ints, 3)), key=lambda x: abs(x - num))", "def closest_sum(i, ii):\n    # your solution goes here\n    print (i)\n    print (ii)\n    iii = len(i)\n    iiiiiii = 264064296425738246861428640756429.1754206\n    for iiii in range(iii):\n        for iiiii in range(iii):\n            for iiiiii in range(iii):\n                if iiii != iiiii and iiiii != iiiiii and iiiiii != iiii:\n                    if abs(i[iiii] + i[iiiii] + i[iiiiii] - ii) < abs(iiiiiii - ii):\n                        iiiiiii = i[iiii] + i[iiiii] + i[iiiiii]\n    return iiiiiii", "closest_sum=lambda a,n:min(map(sum,__import__('itertools').combinations(a,3)),key=lambda c:abs(c-n))", "from itertools import permutations;closest_sum=lambda s,n:min([sum(i) for i in permutations(s, 3)], key=lambda x: abs(x - n))", "def A(arr,a,b,c,L,T):\n    if c<L:\n        T.append(arr[a]+arr[b]+arr[c])\n    if a==L-2:\n        return 0\n    elif b==L-2:\n        return A(arr,a+1,a+2,a+3,L,T)\n    elif c==L-1:\n        return A(arr,a,b+1,b+2,L,T)\n    \n    return A(arr,a,b,c+1,L,T)\n    \ndef closest_sum(ints, num):\n    print((num,ints))\n    T=[]\n    A(ints,0,1,2,len(ints),T)\n    print(T)\n    if num in T:\n        return num\n    else:\n        l,h=num,num\n        while True:\n            l-=1\n            h+=1\n            if l in T and h in T:\n                return l if T.index(l)<T.index(h) else h\n            if l in T:\n                return l\n            if h in T:\n                return h\n", "import itertools\n\ndef closest_sum(ints, num):\n    res = ints[:3]\n    comb = list(itertools.combinations(ints, 3))\n    for i in comb:\n        if abs(num-sum(i)) < abs(num-sum(res)):\n            res = [_ for _ in i]\n    return sum(res)"]