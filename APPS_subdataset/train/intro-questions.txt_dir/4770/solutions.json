["def peak_height(mountain):\n    M = {(r, c) for r, l in enumerate(mountain) for c in range(len(l)) if l[c] == '^'}\n    h = 0\n    while M:\n        M -= {(r, c) for r, c in M if {(r, c+1), (r, c-1), (r+1, c), (r-1, c)} - M}\n        h += 1\n    return h", "from scipy.ndimage.morphology import binary_erosion as erode, numpy as np\n\ndef peak_height(mountain):\n    M, n = np.array([*map(list,mountain)]) == \"^\", 0\n    while M.any(): M, n = erode(M), n+1\n    return n", "def peak_height(mountain):\n    lX, lY  = len(mountain), len(mountain[0])\n    top,lst = 0, [[0]*lY for _ in range(lX)]\n    \n    for x,row in enumerate(mountain):\n        for y,v in enumerate(row):\n            lst[x][y] = (v=='^') + (0<x<lX-1 and 0<y<lY-1 and v=='^' and min(lst[x-1][y], lst[x][y-1]))\n            top      |= lst[x][y]>0\n    \n    for x in reversed(range(1,lX-1)):\n        for y in reversed(range(1,lY-1)):\n            lst[x][y] = min(lst[x][y], lst[x+1][y]+1, lst[x][y+1]+1)\n            top      += top < lst[x][y]\n    \n    return top", "def peak_height(mountain):\n    points = { (row,col) for row,lst in enumerate(mountain) for col in range(len(lst)) if lst[col] == '^' }\n    height = 0\n    while points:\n        points -= { (row,col) for row,col in points if { (row-1,col), (row+1,col), (row,col-1), (row,col+1) } - points }\n        height += 1\n    return height", "from collections import defaultdict\n\ndef peak_height(mountain):\n    heights = defaultdict(int)\n    h, w = len(mountain), len(mountain[0])\n    heights.update({(x,y) : 0 if mountain[y][x] == \" \" else -1 for x in range(w) for y in range(h)})\n    \n    res = 0    \n    while True: \n        todo = []\n        \n        for y in range(len(mountain)):\n            for x in range(len(mountain[y])):\n                if heights[(x,y)] == -1:\n                    neighbors = [heights[(x+a,y+b)] for a,b in [(1,0), (-1,0), (0,1), (0,-1)] if heights[(x+a,y+b)] > -1]\n                    \n                    if neighbors:                        \n                        todo.append((x,y, 1 + min(neighbors)))\n        \n        for x,y,v in todo:\n            heights[(x,y)] = v\n            res = max(res, v)    \n        \n        if not todo:\n            return res", "def peak_height(mountain):\n    new_mnt = [[\"x\" for i in range(len(mountain[0]))] for _ in range(len(mountain))]\n\n    for i in range(len(mountain)):\n        for j in range(len(mountain[0])):\n            if mountain[i][j] == \"^\":\n                if i>0 and j>0 and i <len(mountain)-1 and j<len(mountain[0])-1:\n                    if (mountain[i+1][j] == \" \") or (mountain[i-1][j] == \" \") or (mountain[i][j+1] == \" \") or (mountain[i][j-1] == \" \"):\n                        new_mnt[i][j] = 1\n                else:\n                    new_mnt[i][j] = 1\n            else:\n                new_mnt[i][j] = 0\n    done = False\n    round = 1\n    while not done:\n        done = True\n        for i in range(0, len(new_mnt)-1):\n            for j in range(0, len(new_mnt[0])-1):\n                if new_mnt[i][j] == \"x\":\n                    if (new_mnt[i+1][j] == round) or (new_mnt[i-1][j] == round) or (new_mnt[i][j+1] == round) or (new_mnt[i][j-1] == round):\n                      new_mnt[i][j] = round+1\n                    else:\n                        done = False\n        round +=1\n    maxVal = 0 \n    for l in new_mnt:\n        maxVal = max(maxVal, max(l))\n    return maxVal    ", "from math import floor\n\ndef peak_height(mountain):\n    a = []\n    for i in mountain:\n        b = []\n        for j in i:\n            if j == ' ':\n                b.append(0)\n            else:\n                b.append(1)\n        a.append(b)\n\n    for m in range(floor(min(len(a), len(a[0]))/2)):\n        for i in range(1+m, len(a) - 1-m):\n            for j in range(1+m, len(a[0])-1-m):\n                if a[i][j] > 0:\n                    a[i][j] = min(a[i-1][j], a[i+1][j], a[i][j-1], a[i][j+1]) + 1\n\n    return max([max(i) for i in a])\n", "from collections import Counter\n\ndef neigthboors(peaks):\n    for x,y in peaks:\n        yield x,y-1\n        yield x-1,y\n        yield x,y\n        yield x+1,y\n        yield x,y+1       \n        \ndef peak_height(mountain):\n    mountain = [(x,y) for y,row in enumerate(mountain) for x,p in enumerate(row)  if p ==\"^\"]\n    i = 0\n    while mountain:\n        mountain = [x_y for x_y, cnt in list(Counter(neigthboors(mountain)).items()) if cnt == 5]\n        i+=1\n    return i\n        \n        \n", "def peak_height(mountain):\n    neighbours = lambda z: {z + 1j ** d for d in range(4)}\n    mountain = {x + 1j * y for x, r in enumerate(mountain)\n                           for y, c in enumerate(r) if c == '^'}\n    height, base = 0, set().union(*map(neighbours, mountain)) - mountain\n    while mountain:\n        height += 1\n        base = set.union(*map(neighbours, base)) & mountain\n        mountain -= base\n    return height", "def peak_height(mountain):\n    def condition1(a, b,mountian):\n        return a == 0 or a == len(mountain)-1 or b == 0 or b == len(mountain[0])-1\n\n\n    def condition2(a, b, k):\n        if k == -1:\n            return any([mountain_list[a + 1][b] == ' ',\n                        mountain_list[a - 1][b] == ' ',\n                        mountain_list[a][b + 1] == ' ',\n                        mountain_list[a][b - 1] == ' '])\n        else:\n            return any([mountain_list[a + 1][b] == k+1,\n                        mountain_list[a - 1][b] == k+1,\n                        mountain_list[a][b + 1] == k+1,\n                        mountain_list[a][b - 1] == k+1])\n\n\n    def loop_firt(list):\n        for a, i in enumerate(list):\n            for b, j in enumerate(i):\n                if j == '^' and condition1(a, b, mountain):\n                    list[a][b] = 1\n                elif j == '^' and condition2(a, b, -1):\n                    list[a][b] = 1\n\n\n    def loop_again(list, y):\n        for a, i in enumerate(list):\n            for b, j in enumerate(i):\n                if j == \"^\" and condition1(a, b, mountain):\n                    pass\n                elif j == \"^\" and condition2(a, b, y-1):\n                    list[a][b] = y+1\n\n    def the_biggest(list):\n            for i in mountain_list:\n                for j in i:\n                    if type(j) == int:\n                        yield j\n                    elif j == ' ':\n                        pass\n\n\n\n    if mountain == []:\n        return []\n\n    x = ['^', 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\n    y = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]\n    mountain_list = []\n    list2 = []\n    for i in mountain:\n        list1 = []\n        for j in i:\n            list1.append(j)\n        mountain_list.append(list1)\n\n\n    for i in range(len(x)):\n        if i == 0:\n            loop_firt(mountain_list)\n        else:\n            loop_again(mountain_list, i)\n\n    for i in mountain_list:\n        list1 = []\n        for j in i:\n            list1.append(str(j))\n        list2.append(''.join(list1))\n####return list2\n########### TO SHOW A NEW MAP PRINT LIST2 ################\n    if (list(the_biggest(mountain_list))) == []:\n        return 0\n    else:\n        return max(list(the_biggest(mountain_list)))"]