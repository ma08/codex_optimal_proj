["def shortest_time(speed):\n    a,b,c,d = sorted(speed)\n    return a+b+d + min(2*b, a+c)", "from itertools import combinations\n\ndef shortest_time(xs, ys=[]):\n    if len(xs) == 2:\n        return max(xs)\n    result = 999999999\n    for i, j in combinations(range(len(xs)), 2):\n        m = max(xs[i], xs[j])\n        xs2 = xs[:i] + xs[i+1:j] + xs[j+1:]\n        ys2 = ys + [xs[i], xs[j]]\n        for k, y in enumerate(ys2):\n            result = min(m + y + shortest_time(xs2+[y], ys2[:k] + ys2[k+1:]), result)\n    return result", "shortest_time=lambda a:a.sort()or a[0]+a[1]+min(2*a[1],a[0]+a[2])+a[3]", "def shortest_time(speed):\n    import itertools\n    from collections import Counter\n    times=[]\n    for elem in itertools.combinations(speed,2):   \n        end1 = [x for x in elem] \n        base1 = list((Counter(speed)-Counter(end1)).elements())             \n        for i in itertools.combinations(end1,1):            \n            base2 = [x for x in base1+[i[0]]]   \n            if sum(end1)!= 2*end1[0]:\n                end2 = [x for x in end1 if x != i[0]]\n            else:\n                 end2 = [end1[0]]   \n            for j in itertools.combinations(base2,2):                                            \n                end3 = [x for x in end2 +[j[0],j[1]]]\n                base3 = list((Counter(base2)-Counter(j)).elements())\n                for k in itertools.combinations(end3,1):             \n                    base4 = [x for x in base3+[k[0]]]                             \n                    times += [max(elem)+ i[0]+max(j)+k[0]+max(base4)]                                                                                               \n    return min(times)", "from math import inf\nfrom itertools import chain, combinations, combinations_with_replacement\n\n# thanks to \"The capacity-C torch problem\" by Roland Backhouse, Hai Truong\n# https://www.sciencedirect.com/science/article/pii/S0167642315000118\n\ndef shortest_time(speed: [int]):\n    forward_trips_num = 3       # for len(speed) == 4\n    best_time = inf\n#     path = []\n    for forward_trips in combinations_with_replacement(list(combinations(speed, 2)), forward_trips_num):\n        # not all people made at least one forward trip\n        if any(list(chain(*forward_trips)).count(s) < speed.count(s) for s in set(speed)):\n            continue\n        sum_forward = sum([max(trip[0], trip[1]) for trip in forward_trips])     # time of all forward trips\n        sum_return = 0                                                           # time of all return trips\n        # number of return trips for each speed\n        # (if there are several people with equal speed, the sum of all their return trips);\n        returns = {s: 0 for s in set(speed)}\n        for s in set(speed):\n            # for every person the number of forward trips is one more than the number of return trips\n            returns[s] += sum([trip.count(s) for trip in forward_trips]) - speed.count(s)\n            sum_return += returns[s]*s\n\n        if best_time > sum_forward+sum_return:\n            best_time = sum_forward + sum_return\n#             path = list(forward_trips) + list(chain(*[[(s,)]*returns[s] for s in set(speed)]))\n#     print(path)\n    return best_time", "def shortest_time(speed):\n    speed.sort()\n    [a,b,c,d]=speed\n    return min(a+3*b+d,2*a+b+c+d)", "def shortest_time(speed):\n    speed.sort()\n    return speed[0]+speed[1]+speed[3] + min(2*speed[1],speed[0]+speed[2])", "def shortest_time(speed):\n    speed.sort()\n    o = 3*speed[1]+speed[0]+speed[3]\n    t = sum(speed[1:])+(len(speed)-2)*speed[0]\n    return o if o<=t else t", "def shortest_time(speed):\n    \n    copy = speed\n    copy.sort()\n    y = copy[0] + copy[1] * 3 + copy[3]\n    minimum = copy.pop(0)\n    answers = list()\n    x = sum(copy) + minimum * (len(copy)-1)\n    answers.append(x)\n    answers.append(y)\n    \n    return min(answers)", "def shortest_time(speed):\n    speed = sorted(speed)\n    return min(speed[1]*3+speed[0]+speed[3],speed[0]+sum(speed))"]