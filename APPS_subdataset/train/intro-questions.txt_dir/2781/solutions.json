["AVAILABLE_METHODS = {\n    'even' : lambda x: x / 2,\n    'odd': lambda x: 3 * x + 1\n}\n\ndef generator(x):\n    temp = x\n    temp_num = 0\n    while temp > 1:\n        if temp % 2 == 0:\n            temp = AVAILABLE_METHODS['even'](temp)\n        else:\n            temp = AVAILABLE_METHODS['odd'](temp)\n        temp_num += 1\n        yield temp_num\n\ndef longest_collatz(input_array):\n    answer_list = [sum([item for item in generator(dig)]) for dig in input_array]\n    print(max(answer_list), answer_list)\n    return input_array[(answer_list.index(max(answer_list)))]", "def collatz(n, t=1):\n    return t if n == 1 else collatz(n / 2 if n % 2 == 0 else 3 * n + 1, t + 1)\n\n\ndef longest_collatz(input_array):\n    return sorted(list(zip(list(map(collatz, input_array)), input_array)))[-1][1]", "def longest_collatz(arr):\n    return max([(gen_s(e),e) for  e in arr])[1]\n    \ndef gen_s(n, c=1):\n    return c + gen_s((n//2, n*3+1)[n%2], c+1) if n != 1 else 1", "from functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef collatz(n):\n    return n != 1 and 1 + collatz(3*n+1 if n&1 else n>>1)\n\ndef longest_collatz(input_array):\n    return max(input_array, key=collatz)", "def longest_collatz(a):\n    def f(n):\n        r = 1\n        while n > 1:\n            n = n * 3 + 1 if n % 2 else n // 2\n            r += 1\n        return r\n    return max(a, key=f)", "def longest_collatz(lst):\n    return max(lst, key=seq_len)\n\ndef seq_len(n):\n    count = 0\n    while n > 1:\n        n = (3 * n + 1) if n % 2 else (n // 2)\n        count += 1\n    return count\n    \n# two-liner\n#seq_len = lambda n: 0 if n == 1 else 1 + seq_len(3 * n + 1 if n % 2 else n // 2)\n#longest_collatz = lambda lst: max(lst, key=seq_len)\n\n\n", "def collatz_len(n):\n    result = 1\n    while n != 1:\n        if n % 2:\n            n = 3 * n + 1\n        else:\n            n //= 2\n        result += 1\n    return result\n\ndef longest_collatz(input_array):\n    return max(input_array, key=collatz_len)", "def longest_collatz(input_array):\n    results = {1: 1}\n    \n    for n in range(2, max(input_array) + 1):\n        count = 0\n        x = n\n        while x not in results:\n            x = x * 3 + 1 if x % 2 else x // 2\n            count += 1\n        \n        count += results[x]\n        results[n] = count\n    \n    return max(input_array, key=results.get)", "def collatz(n):\n    d = {1:1}\n    count = 0\n    while n != 1:    \n        if n in d:\n            count += d[n]\n            n = 1\n        else:\n            if n % 2 == 0:\n                n /= 2\n                count += 1\n            else:\n                n = (3*n + 1)/2\n                count += 2      \n    return count \n\ndef longest_collatz(input_array):\n    return max(input_array, key=collatz)", "def longest_collatz(input_array):\n    def collatz_len(n):\n        ctr = 0\n        while n > 1:\n            ctr, n = ctr + 1, (n // 2 if n % 2 == 0 else 3*n + 1)\n        return ctr\n    return max((n for n in input_array), key=collatz_len)"]