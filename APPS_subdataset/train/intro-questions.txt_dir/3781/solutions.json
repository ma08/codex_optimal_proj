["def prod_int_partII(n, s, min_=2):\n    total, fac = 0, []\n    for d in range(min_, int(n ** .5) + 1):\n        if not n % d:\n            count, l, sub = prod_int_partII(n // d, s-1, d)\n            if l == 1: sub = [sub]\n            total += count + 1\n            fac.extend([d] + x for x in sub)\n    if s == 1: fac = [[n]]\n    return [total, len(fac), fac[0] if len(fac) == 1 else fac]", "from functools import reduce    \n\ndef updateParts(d,s,n,p):\n    d.append(p)\n    for t in list(s):\n        s.add(tuple(sorted(t+(p,))))\n        for i in range(len(t)):\n            s.add( tuple(sorted(t[:i]+(p*t[i],)+(t[i+1:]))) )\n    s.add((p,))\n    return n//p\n\ndef prod_int_partII(n,m):\n    x,d,s,p = n,[],set(),2\n    while p*p<=n:\n        while not n%p: n = updateParts(d,s,n,p)\n        p += 1+(p!=2)\n    if n-1 and n!=x: updateParts(d,s,-1,n)\n    \n    s = [t for t in s if reduce(int.__mul__,t)==x and len(t)>1]\n    d = sorted(list(t) for t in s if len(t)==m)\n    \n    return [len(s),len(d),d[0] if len(d)==1 else d]", "def prod_int_partII(n, s):\n    part = list(mul_part_gen(n))[:-1]\n    sub = [p for p in part if len(p) == s]\n    return [len(part), len(sub), sub[0] if len(sub) == 1 else sub]\n\ndef mul_part_gen(n, k=2): \n    if n == 1: \n        yield [] \n    for i in range(k, n+1): \n        if n % i == 0: \n            for part in mul_part_gen(n//i, i): \n                yield [i] + part\n", "div=lambda n:[[i,n//i] for i in range(2,int(n**.5)+1) if not n%i]\ndef prod_int_partII(n, s):\n        li,parts = div(n), set()\n        def recur(li, s=[]):\n            parts.add(tuple(sorted(s)))\n            for i in li:\n                recur(div(i[1]),s+i if not s else s[:-1]+i)\n        recur(li)\n        req = sorted(filter(lambda x:len(x)==s, parts))\n        return [len(parts)-1, len(req), list([map(list,req),req[0]][len(req)==1]) if req else []]", "from math import sqrt\n\ndef partitions(n, floor = 2):\n    parts = [[n]]\n    for i in range(floor, int(sqrt(n)) + 1):\n        if n % i == 0:\n            for part in partitions(n // i, i):\n                parts.append([i] + part) \n    return parts\n\ndef prod_int_partII(n, s):\n    lists = []\n    parts = partitions(n, 2)\n    for part in parts:\n        if len(part) == s:\n            lists.append(part)\n    if len(lists) == 1:\n        list = lists[0]\n    else:\n        list = lists\n    return [len(parts) - 1, len(lists), list]", "def prod_int_partII(n, s):\n    comb = set()\n    \n    for p in partition(n):\n        if len(p) > 1: comb.add(tuple(sorted(p)))\n    \n    res = sorted([p for p in comb if len(p) == s])\n    \n    return [len(comb), len(res), list(res[0]) if len(res) == 1 else [list(t) for t in res]]\n    \ndef partition(n, start = 2):\n    if n == 1:\n        yield []\n    for i in range(start, n + 1):\n        if n % i == 0:\n            for p in partition(n // i, i):\n                yield p + [i]", "def p(n,z=2):\n    r=[]\n    s=0\n    for i in range(z,int(n**.5)+1):\n        if n%i==0:\n            x,y=p(n//i,i)\n            s+=x+1\n            r+=[[i]+v for v in y]+[[i,n//i]]\n    return s,r\ndef prod_int_partII(n, l): # n, integer to have the multiplicative partitions\n    s,r=p(n)\n    x=[v for v in r if len(v)==l]\n    L=len(x)\n    if L==1:x=x[0]\n    return[s,L,x]\n", "def prod_int_partII(n, s):\n    res = []\n    stack = [[n, 2, []]]\n    while stack:\n        m, d, store = stack.pop(0)\n        for i in range(d, int(m**0.5) + 1):\n            if m % i == 0:\n                res.append(store + [i] + [m // i])\n                stack.append([m // i, i, store + [i]])\n    filtred_res = list(filter(lambda x: len(x) == s, res))\n    if filtred_res:\n        return [len(res), len(filtred_res), filtred_res] if len(filtred_res) > 1 else [len(res), len(filtred_res), filtred_res[0]]\n    else:\n        return [len(res), 0, []]", "#!/usr/bin/env python\nfrom collections import defaultdict\nfrom itertools import islice\n\ndef primes():\n    yield 2\n    D = defaultdict(list)\n    i = 3\n    while True:\n        if i not in D:\n            D[i * i].append(i)\n            yield i\n        else:\n            for k in D[i]:\n                j = i + k\n                while j % 2 == 0: j += k\n                D[j].append(k)\n            del D[i]\n        i += 2\n\n\nPRIMES = list(islice(primes(), 1000))\n\ndef decompose(n):\n    r = defaultdict(int)\n    for p in PRIMES:\n        while n % p == 0: r[p] += 1; n //= p\n        if n == 1: break\n    return r\n\n\ndef prod_int_partII(n, s):\n    r = []\n    d = decompose(n)\n    ds = [i for i in range(2, n) if n % i == 0]\n    total = sum(i for _, i in list(d.items()))\n    q = defaultdict(list)\n    def aux(m, ci, c, i=0, p=[]):\n        if c == 0:\n            if m == 1: q[ci].append(p)\n            return\n        else:\n            for j in range(i, len(ds)):\n                if m % ds[j] == 0: aux(m // ds[j], ci, c - 1, j, p + [ds[j]])\n    for i in range(2, total + 1): aux(n, i, i)\n    return [sum(len(i) for i in list(q.values())), len(q[s]), q[s][0] if len(q[s]) == 1 else q[s]]\n"]