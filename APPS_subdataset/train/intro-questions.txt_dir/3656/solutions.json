["from math import ceil\nfrom fractions import Fraction as F\ndef decompose(n):\n    f = F(n)\n    ff = int(f)\n    result = [str(ff)] if ff else []\n    f -= ff\n    while f>0:\n        x = F(1,int(ceil(f**-1)))\n        f -= x\n        result.append(str(x))\n    return result", "from fractions import Fraction\nfrom math import ceil\n \ndef decompose(n):\n    try:\n        n = Fraction(n)\n    except ValueError:\n        return []\n    try:\n        e = int(n)\n    except ValueError:\n        return []\n    if n == 0: return []\n    \n    if n == e: return [str(n)]\n    n -= e\n    if e != 0: l = [str(e)] \n    else: l = []\n    while(n.numerator > 1):\n        e = Fraction(1, int(ceil(1 / n)))\n        l.append(str(e.numerator) + \"/\" + str(e.denominator))\n        n -= e\n    l.append(str(n.numerator) + \"/\" + str(n.denominator))\n    return l", "from fractions import Fraction\nfrom math import ceil\n\ndef decompose(n):\n    f = Fraction(n)\n    result = []\n    \n    if f > 1:\n        int_part = int(f)\n        result = [str(int_part)]\n        f -= int_part\n    \n    while f:\n        x = Fraction(1, ceil(1/f))\n        result.append(str(x))\n        f -= x\n\n    return result", "from fractions import Fraction as fr\nfrom math import ceil\ndef decompose(s):\n    s = str(fr(s)).split('/')\n    if len(s)==1 : return [s,[]][s[0]=='0'] \n    li = [[1, ceil(eval('int(s[1]) / int(s[0])'))]]\n    while 1:\n        n, d = li[-1]\n        s = str(fr(int(s[0]), int(s[1])) - fr(n, d)).split('/')\n        if len(s) == 1 : break\n        li.append([1, ceil(eval('int(s[1]) / int(s[0])'))])\n    return [str(fr(f'{i}/{j}')) for i,j in li] ", "def decompose(n):\n    if '/' in n:\n        strs = n.split('/')\n        a = int(strs[0]); b = int(strs[1]);\n    elif '.' in n:\n        strs = n.split('.')\n        b = 10**len(strs[1]);a = int(strs[1]) + b*int(strs[0]); \n    else: a=int(n); b=1\n    output = []\n    while a >= b:\n        i = a//b; a = a - b*i;\n        output.append(str(i))\n    while a > 0:\n        i = b//a+1 if b%a else b//a;\n        a = a*i-b; b = b*i\n        output.append('1/'+str(i))\n    return output", "from fractions import Fraction\ndef decompose(n):\n    answer=[]\n    current_number=Fraction(n)\n    if current_number>1:\n        answer.append(str(current_number//1))\n        current_number=Fraction(current_number-(current_number//1))\n    if current_number==0:\n        return answer\n    x=2\n    while True:\n        if Fraction(1,x)<current_number:\n            answer.append(str(Fraction(1,x)))\n            current_number=Fraction(current_number-Fraction(1,x))\n        if current_number.numerator==1:\n            answer.append(str(current_number))\n            break\n        else:\n            x=(current_number.denominator//current_number.numerator)+1           \n    return answer", "from fractions import Fraction\nimport math\ndef decompose(n):\n\n    if n == '0':\n        return []\n\n    refFrac = Fraction(n)\n    if refFrac.numerator == refFrac.denominator:\n        return ['1']\n    elif refFrac.denominator == 1:\n        return [str(refFrac.numerator)]\n\n    final_tab = []\n    while(refFrac.numerator != 0):\n        denom = math.ceil(refFrac.denominator / refFrac.numerator)\n        next = Fraction(1, denom)\n        final_tab.append(next)\n        refFrac -= next\n\n    return [str(frac) for frac in final_tab]\n", "def decompose(n):\n    # your code\n    from fractions import Fraction\n    f = Fraction(n)\n    ret = []\n    \n    if 0 == f:\n        return ret\n    \n\n    while not (f.numerator == 1 or f.denominator == 1):\n        x = int(1/f) + 1\n        ff = Fraction(1,x)\n        ret.append(str(ff))\n        f -= ff\n    else:\n        ret.append(str(f))\n    \n    return ret", "from fractions import Fraction\nimport sys\nfrom math import floor, ceil\n\nclass EgyptianFraction(Fraction):\n      def decompose(self, rst=None):\n          if rst is None:\n              rst = []\n          \n          # stop condition\n          if self == 0:\n              return rst\n          elif self.numerator == 1 or self.denominator == 1:\n              rst.append(Fraction(self))\n              return rst \n          \n          # greedy search\n          if self > 1:\n              frac = Fraction(floor(self))\n          else:\n              frac = Fraction(1, ceil(1/self))\n          rst.append(frac)\n          return EgyptianFraction(self-frac).decompose(rst)\n\ndef decompose(n):\n    rst = EgyptianFraction(n).decompose()\n    return [str(i) for i in rst]", "from fractions import Fraction\nfrom math import ceil\n\ndef decompose(n):\n    n = Fraction(n)\n    lst, n = [int(n)], n - int(n)\n    while n > 0:\n        next_denom = int(ceil(1/n))\n        lst.append(next_denom)\n        n -= Fraction(1, next_denom)\n    return ([] if lst[0] == 0 else [str(lst[0])]) + [\"1/{}\".format(d) for d in lst[1:]]"]