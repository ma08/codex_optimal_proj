["import numpy as np\nfrom itertools import zip_longest\nfrom string import ascii_lowercase as lower, ascii_uppercase as upper\n\nD = {c:i%26 for i,c in enumerate(lower+upper)}\n\ndef encrypt(text, key):\n    result = []\n    text = ''.join(filter(str.isalpha, text))\n    key = np.array(([D[key[0]], D[key[1]]], [D[key[2]], D[key[3]]]))\n    for c1,c2 in zip_longest(text[::2], text[1::2], fillvalue='Z'):\n        x,y = key @ ([D[c1]], [D[c2]])\n        result.append(upper[x[0]%26] + upper[y[0]%26])\n    return ''.join(result)", "import numpy as np\n\ndef encrypt(text,key):\n    # Declare string variable to store the answer\n    ans=''\n    # Covert all the alphabets to upper case and clean everything else\n    clean_text=''.join([i.upper() for i in text if i.isalpha()])\n    # Add Z to the cleaned text if the length of it is odd\n    clean_text+='Z'*(len(clean_text)%2)\n    # Return empty string if the cleaned text is empty\n    if len(clean_text)==0:\n        return ''\n    # Find the key matrix\n    km=np.matrix([[ord(key[0])-97,ord(key[1])-97],[ord(key[2])-97,ord(key[3])-97]])\n    # Create a text matrix\n    tm=np.matrix([[ord(clean_text[i])-65,ord(clean_text[i+1])-65] for i in range(0,len(clean_text),2)]).T\n    # Multiply the key matrix by the text matrix and apply modulo 26\n    am=(km*tm)%26\n    # Convert the numbers back to letters and append them to the ans variable\n    for i in np.array(am.T): \n        ans+=chr(i[0]+65)\n        ans+=chr(i[1]+65)\n    # Return the answer variable    \n    return ans", "from string import ascii_letters\nimport numpy as np\n\ndef encrypt(text, key):\n    # Character and interger conversions\n    code = lambda s: ord(s.lower()) - ord('a')\n    letter = lambda n: chr(n + ord('A'))\n\n    # Build key\n    size = int(len(key) ** 0.5)\n    if size ** 2 != len(key):\n        raise ValueError('Key must be of length n^2')    \n    key_matrix = np.array([code(c) for c in key]).reshape(size, size)\n    \n    # Filter out non letters and pad if necessary\n    text = ''.join(c for c in text if c in ascii_letters)\n    if len(text) % size != 0:\n        text += 'z' * (size - (len(text) % size))\n    text_matrix = np.array([code(c) for c in text]).reshape(len(text) // size, size).transpose()\n    \n    # Perform encoding\n    encoded = (key_matrix @ text_matrix) % 26\n    return ''.join(letter(n) for n in encoded.transpose().flatten())\n", "def encrypt(text,key):\n    final_list=[]\n    if text==\"\":\n        return \"\"\n    alpha_dict={}\n    num_lst_1=[]\n    alphabet=\"abcdefghijklmnopqrstuvwxyz\"\n    for i in range(0,26):\n        alpha_dict[alphabet[i]]=i\n    for letter in text.lower():\n        if letter in alphabet:\n            num_lst_1.append(alpha_dict[letter])\n    if len(num_lst_1)%2==1:\n        num_lst_1.append(25)\n    num_lst_2=[]\n    for char in key.lower():\n        num_lst_2.append(alpha_dict[char])\n    sum_row_1=0\n    sum_row_2=0\n    for x in range(0,len(num_lst_1),2):\n        sum_row_1=num_lst_2[0]*num_lst_1[x]+num_lst_2[1]*num_lst_1[x+1]\n        sum_row_2=num_lst_2[2]*num_lst_1[x]+num_lst_2[3]*num_lst_1[x+1]\n        final_list.append(sum_row_1%26)\n        final_list.append(sum_row_2%26)\n    enpt=\"\"\n    for num in final_list:\n        enpt+=alphabet[num]\n    return enpt.upper()\n", "import re\n\ndef encrypt(text, key):\n    a, b, c, d = (ord(t) - 65 for t in key.upper())\n    r = ''\n    for x, y in zip(*[iter(re.findall('[A-Z]', text.upper()) + ['Z'])] * 2):\n        x, y = (ord(t) - 65 for t in (x, y))\n        x, y = (a * x + b * y) % 26, (c * x + d * y) % 26\n        r += chr(x + 65) + chr(y + 65)\n    return r\n", "def encrypt(text,key):\n    r =''\n    a = 'abcdefghijklmnopqrstuvwxyz'\n    km = [[a.index(key[0]),a.index(key[1])],[a.index(key[2]),a.index(key[3])]]\n    text = ''.join(x for x in text.lower() if x in a)\n    if len(text)%2: text += 'z'\n    for i in range(0,len(text),2):\n        tm = [a.index(text.lower()[i]),a.index(text.lower()[i+1])]\n        r += a.upper()[(km[0][0]*tm[0]+km[0][1]*tm[1])%26]+a.upper()[(km[1][0]*tm[0]+km[1][1]*tm[1])%26]\n    return r", "def encrypt(text,key):\n    k = [ord(i) - 97 for i in key]\n    text = ''.join(c for c in text if c.isalpha())\n    text = text.upper() + \"Z\"*(len(text) % 2)\n    nums = [ord(c) - 65 for c in text]\n    Out = ''\n    for i, j in zip(nums[::2],nums[1::2]):\n        Out += chr((k[0]*i + k[1]*j)%26 + 65) + chr((k[2]*i + k[3]*j)%26 + 65)\n    return Out", "from string import ascii_uppercase as letters\n\ndef encrypt(text, key):\n    key = [[letters.index(c) for c in key.upper()[i:i+2]] for i in (0,2)]\n    text = [letters.index(c) for c in text.upper() if c.isalpha()]\n    if len(text) % 2 != 0: text.append(letters.index('Z'))\n    out = []\n    for i in range(0, len(text), 2):\n        for j in range(2):\n            out.append((key[j][0]*text[i] + key[j][1]*text[i+1]) % 26)\n    return ''.join(letters[n] for n in out)", "\"\"\"by Zakhar M.\"\"\"\nimport re\nimport numpy as np\nfrom math import gcd\n\n\nALPHABET = {chr(letters): letters - 65 for letters in range(65, 91)}\nREVERSE_ALPHABET = {number_symbol: symbol for symbol, number_symbol in list(ALPHABET.items())}\n\n\ndef checking_key_for_validity(matrix_key, length_alphabet):\n    determinant = np.linalg.det(matrix_key)\n    nod_determinant_and_length_alphabet = gcd(int(round(determinant)), length_alphabet)\n\n    if nod_determinant_and_length_alphabet == 1 and nod_determinant_and_length_alphabet != 0:\n        return True\n    return False\n\n\ndef get_matrix_key(key, length_block=2):\n    tmp_list = list()\n    matrix_key = list()\n    length_key = len(key)\n\n    if length_key % 2 != 0:\n        return ''\n\n    for symbol in key:\n        number_symbol_in_alphabet = ALPHABET[symbol]\n        tmp_list.append(number_symbol_in_alphabet)\n        length_tmp_list = len(tmp_list)\n\n        if length_tmp_list != length_block:\n            continue\n\n        matrix_key.append(tmp_list)\n        tmp_list = list()\n\n    return matrix_key\n\n\ndef get_matrix_open_text(open_text, length_blocks=2):\n    tmp_list = list()\n    matrix_open_text = list()\n    pattern_only_letters = re.compile(r'[^a-zA-Z]*')\n    prepared_open_text = pattern_only_letters.sub('', open_text).upper()\n    length_prepared_open_text = len(prepared_open_text)\n\n    if length_prepared_open_text % 2 != 0:\n        prepared_open_text += 'Z'\n\n    for symbol in prepared_open_text:\n        number_symbol_in_alphabet = ALPHABET[symbol]\n        tmp_list.append(number_symbol_in_alphabet)\n        length_tmp_list = len(tmp_list)\n\n        if length_tmp_list != length_blocks:\n            continue\n\n        matrix_open_text.append(tmp_list)\n        tmp_list = list()\n        \n    return matrix_open_text\n\n\ndef smart_mul_matrix(matrix_1, matrix_2):\n    result_matrix = list()\n    \n    for i in range(len(matrix_1)):\n        tmp_sum = 0\n        \n        for j in range(len(matrix_2)):\n            tmp_sum += (matrix_1[i][j] * matrix_2[j])\n        result_matrix.append(tmp_sum % 26)\n        \n    return result_matrix\n\ndef encrypt(open_text, key):\n    cipher_text = ''\n    length_alphabet = len(ALPHABET)\n    matrix_cipher_text = list()\n    \n    pattern_only_letters = re.compile(r'[^a-zA-Z]*')\n    prepared_key_text = pattern_only_letters.sub('', key).upper()\n    matrix_key = get_matrix_key(prepared_key_text)\n    \n    matrix_open_text = get_matrix_open_text(open_text)\n    \n    for current_list_open_text in matrix_open_text:\n        matrix_multiplication = smart_mul_matrix(matrix_key, current_list_open_text)\n        matrix_cipher_text.append(matrix_multiplication)\n        \n    for list_cipher_text in matrix_cipher_text:\n        for number_cipher_text in list_cipher_text:\n            cipher_text += REVERSE_ALPHABET[number_cipher_text]\n    return cipher_text\n\n", "def encrypt(text,key):\n    import numpy as np\n    import string\n\n    mapowanie_dig_str=dict(zip([x for x in range(0,26)],list(string.ascii_uppercase)))\n    mapowanie_str_dig=dict(zip(list(string.ascii_uppercase),[x for x in range(0,26)]))\n    \n    l_key=[]\n    for s in key.upper():\n        l_key=l_key+[mapowanie_str_dig[s]]\n\n\n    key_array_dig=np.array([l_key[0:2],l_key[2:]])\n    correct_text=''\n    for s in text.upper():\n        if s in string.ascii_uppercase:\n            correct_text=correct_text+s\n            \n    if len(correct_text)%2!=0:\n       correct_text=correct_text+'Z' \n    \n    output=''\n    l_core=list(correct_text)   \n    while l_core!=[]:\n        pice_text_array=np.array([[mapowanie_str_dig[l_core[0]]],[mapowanie_str_dig[l_core[1]]]])\n        l_core.pop(0)\n        l_core.pop(0)\n        P=(key_array_dig.dot(pice_text_array))%26\n        output=output+mapowanie_dig_str[P[0][0]]+mapowanie_dig_str[P[1][0]]       \n        \n    return output"]