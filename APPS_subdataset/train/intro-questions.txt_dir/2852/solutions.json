["def find_longest(st):\n    res,pos=0,[0]\n    for i,b in enumerate(st,1):\n        if b==\"(\": pos.append(i)\n        else:   \n            try:pos.pop();res=max(res,i-pos[-1])\n            except:pos.append(i)\n    return res", "def find_longest(s):\n    stack, m = [-1], 0\n    for i,j in enumerate(s):\n        if j == '(' : stack.append(i)\n        else:\n            stack.pop()\n            if stack : m = max(m,i-stack[-1])\n            else : stack.append(i)\n    return m", "def find_longest(st):\n    longest_run, stack = 0, [-1]\n    for i, c in enumerate(st):\n        if c == \")\":\n            stack.pop()\n            if stack:\n                longest_run = max(longest_run, i-stack[-1])\n                continue\n        stack.append(i)\n    return longest_run", "def find_longest(st):\n    stack=[-1]\n    longest=0\n    for index in range(0,len(st)):\n        if(st[index]==\"(\"):\n            stack.append(index)\n        else:\n            stack.pop()\n            if stack:\n                longest=max(longest,index-stack[-1])\n            else:\n                stack.append(index)\n    print(longest)\n    return longest", "def find_longest(st):\n    n = len(st)\n    lis = []  \n    lis.append(-1) \n    result = 0\n    for i in range(n):\n        if st[i] == '(':\n            lis.append(i)\n        else:    # If closing bracket, i.e., str[i] = ')'\n            lis.pop() \n            if len(lis) != 0: \n                result = max(result, i - lis[len(lis)-1]) \n            else: \n                lis.append(i)\n    return result ", "def find_longest(st):\n    stack, max_so_far = [-1], 0\n    for ind in range(len(st)):\n        if st[ind] == '(':\n            stack.append(ind)\n        else:\n            stack.pop()\n            if len(stack) > 0:\n                max_so_far = max(max_so_far, ind - stack[-1])\n            else:\n                stack.append(ind)\n    return max_so_far", "\ndef find_longest(string): \n    n = len(string) \n  \n    # Create a stack and push -1 as initial index to it. \n    stk = [] \n    stk.append(-1) \n  \n    # Initialize result \n    result = 0\n  \n    # Traverse all characters of given string \n    for i in range(n): \n      \n        # If opening bracket, push index of it \n        if string[i] == '(': \n            stk.append(i) \n  \n        else:    # If closing bracket, i.e., str[i] = ')' \n      \n            # Pop the previous opening bracket's index \n            stk.pop() \n      \n            # Check if this length formed with base of \n            # current valid substring is more than max  \n            # so far \n            if len(stk) != 0: \n                result = max(result, i - stk[len(stk)-1]) \n  \n            # If stack is empty. push current index as  \n            # base for next valid substring (if any) \n            else: \n                stk.append(i) \n  \n    return result ", "from itertools import groupby\n\ndef find_longest(st):\n    positions = []\n    stack = []\n    for i, ch in enumerate(st):\n        if ch == '(':\n            stack.append(i)\n        elif stack:\n            positions.append(stack.pop())\n            positions.append(i)\n    positions.sort()\n\n    res = [a+1 == b for a, b in zip(positions, positions[1:])]\n    ans = [len(list(g))+1 for k, g in groupby(res)]\n    return max(ans, default=0)", "def find_longest(st):\n    positions = []\n    stack = []\n    for i, ch in enumerate(st):\n        if ch == '(':\n            stack.append(i)\n        elif stack:\n            positions.append(stack.pop())\n            positions.append(i)\n\n    prev = float('-inf')\n    cons = 0\n    ans = 0\n    for i, p in enumerate(sorted(positions)):\n        if p == prev + 1:\n            cons += 1\n        else:\n            ans = max(ans, cons)\n            cons = 1\n        prev = p\n    return max(ans, cons)", "import re\n\ndef find_longest(s):\n    regex = r\"\\(a*\\)\"\n    while re.search(regex, s): s = re.sub(regex, lambda x: \"a\" * len(x.group()), s)\n    r = map(len, re.findall(r\"a+\", s))\n    return max(r, default = 0)"]