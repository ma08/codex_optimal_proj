["def palindrome(num):\n    if type(num) is not int or num < 0:\n        return \"Not valid\"\n    else:\n        c =0\n        for i in range(num,num**2):\n            if is_pal(i):\n                return i\n            elif is_pal(i-c):\n                return i-c\n            else:\n                c +=2\n    \ndef is_pal(n):\n    return n > 10 and n == int(str(n)[::-1])", "def palindrome(num):\n    is_palindrome = lambda chunk: int(chunk) > 9 and chunk == chunk[::-1]\n    if not isinstance(num, int) or num < 0: return 'Not valid'\n    i = 0\n    while(True):\n        if is_palindrome(str(num + i)): return num + i\n        if is_palindrome(str(num - i)): return num - i\n        i += 1\n", "def palindrome(num):\n        \n    if not isinstance(num, int) or num < 0:\n        return \"Not valid\"\n    \n    if num > 9 and str(num) == str(num)[::-1]:\n        return num\n\n    num_down = num\n    num_up = num\n    \n    d = {}\n    while not d:\n        num_down -= 1\n        num_up += 1\n\n        if str(num_down) == str(num_down)[::-1] and num_down > 9:\n            d['?'] = num_down\n    \n        if str(num_up) == str(num_up)[::-1] and num_up > 9:\n            d['?'] = num_up\n\n    return d.get('?', num)", "def palindrome(num):\n    if not isinstance(num, int) or num < 0: return 'Not valid'\n    n = 1\n    num = max(num, 11)\n    minus, plus = num, num\n    f = lambda x: str(x) == str(x)[::-1]\n    pal = 0 if not f(num) else num\n    while not pal:\n        plus += n\n        if f(plus):\n            return plus\n        minus -= n\n        if f(minus):\n            return minus\n    return pal", "is_palindrome = lambda x: x > 10 and str(x) == str(x)[::-1]\n\n\ndef palindrome(num):\n    if not isinstance(num, int) or num < 0:\n        return \"Not valid\"\n    \n    smaller, larger = num, num\n    \n    while True:\n        checks = is_palindrome(smaller), is_palindrome(larger)\n        \n        if checks == (True, False): return smaller\n        if checks == (False, True): return larger\n        if checks == (True,  True): return larger\n        \n        smaller -= 1\n        larger  += 1", "def is_palindrome(n):\n    s = str(n)\n    return s == s[::-1]\n\ndef palindrome(num):\n    if not isinstance(num, int) or num < 0:\n        return \"Not valid\"\n    if num < 17:\n        return 11\n    inf = next(n for n in range(num, 0, -1) if is_palindrome(n))\n    sup = next(n for n in range(num, 2*num) if is_palindrome(n))\n    mean = (inf + sup) / 2\n    return sup if num >= mean else inf", "from itertools import count\ndef palindrome(num):\n    return next(c for b in count(0) for c in (num + b, num - b) if c > 9 and c == int(str(c)[::-1])) if isinstance(num, int) and num >= 0 else 'Not valid'", "def findR(num):\n    while True:\n        if str(num)==str(num)[::-1]:\n            return num\n        num+=1\ndef findL(num):\n    while True:\n        if str(num)==str(num)[::-1]:\n            return num\n        num-=1\ndef palindrome(num):\n    if type(num)!=int or num<0:\n        return 'Not valid'\n    if num<=10:\n        return 11\n    else:\n        if findR(num)-num<=num-findL(num):\n            return findR(num)\n        else:\n            return findL(num)\n", "def is_pali(num):\n    return str(num) == str(num)[::-1] and num > 9\n\ndef palindrome(num):\n    if type(num) != int or str(num) != str(int(num)) or int(num) < 0:\n        return 'Not valid'\n    n = 0\n    if num <= 11:\n        return 11\n    while n < num:\n        test1 = num - n\n        test2 = num + n\n        if is_pali(test2):\n            return num + n\n        elif is_pali(test1):\n            return num - n\n        n += 1", "\"\"\" Solution without loops ! \"\"\"\n\n\"\"\" Define the first segment of what wwould be a \"not far away palindrome\" based on \"num\" :\n            num = 1258  -> midPart = 12  ( -> would give \"1221\" )\n            num = 459   -> midPart = 45  ( -> would give \"454\"  )\n    \n    Check for lower and upper values (in case num is near of change of decade, upperbond or lowerbond)\n    and define 3 possible parts of palindromes:\n            num = 1258  -> 12  ->  lowPart  = 11\n                                   midPart  = 12\n                                   highPart = 13\n            num = 459   -> 45  ->  lowPart  = 44\n                                   midPart  = 45\n                                   highPart = 46\n                                   \n    Construct palindromes according to each part an the parity of the length of the original number:\n            num = 1258  -> lPal = 1111 ; mPal = 1221 ; hPal = 1331\n            num = 459   -> lPal = 444  ; mPal = 454  ; hPal = 464\n    \n    Sort the result with tuples defined as:     (abs(num-newPal), -newPal)\n    This way, the nearest new palindrome value are first, and if two values of \"abs(num-newPal)\"\n    are equal, the second element of the tuple ensure to find the highest one as first element of \n    the sorted list of tuples.\n    return the opposite of the second element of the first tuple, which is so \"newPal\".\n    \n    Edge cases:  num = 1999 -> lPal = 1881 ; mPal = 1991 ; hPal = 2002  =>  return 2002\n                 num = 801  -> lPal = 797  ; mPal = 808  ; hPal = 818   =>  return 797\n                 num = 1002 -> lPal = 99(!); mPal = 1001 ; hPal = 1111  =>  return 1001\n\"\"\"\n\ndef nextPal(sPart, ls): return int( sPart + sPart[:len(sPart)-ls%2][::-1] )\n\ndef palindrome(num):\n    if type(num) != int or num <= 0: return \"Not valid\"\n    \n    s = str(num)\n    midPart  = s[:(len(s)+1)//2]\n    lowPart  = str(int(midPart)-1)\n    highPart = str(int(midPart)+1)\n    lPal, mPal, hPal = nextPal(lowPart, len(s)), nextPal(midPart, len(s)), nextPal(highPart, len(s))\n    \n    return 11 if num <= 16 else -sorted( (abs(num-pal), -pal)  for pal in [lPal, mPal, hPal] )[0][1]"]