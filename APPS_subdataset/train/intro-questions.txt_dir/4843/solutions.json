["import itertools\ndef choose_best_sum(t, k, ls):\n    try: \n        return max(sum(i) for i in itertools.combinations(ls,k) if sum(i)<=t)\n    except:\n        return None", "from itertools import combinations\n\ndef choose_best_sum(t, k, ls):\n    return max((s for s in (sum(dists) for dists in combinations(ls, k)) if s <= t), default=None)", "from itertools import combinations\n\ndef choose_best_sum(t, k, ls):\n    return max((sum(v) for v in combinations(ls,k) if sum(v)<=t), default=None)", "from itertools import combinations\n\n\ndef choose_best_sum(max_miles, max_towns, lst):\n    highest = 0\n    for a in combinations(lst, max_towns):\n        total_distance = sum(a)\n        if max_miles >= total_distance > highest:\n            highest = total_distance\n    return highest or None\n", "def choose_best(t,k,ls):\n    if k == 0: return 0\n    best = -1\n    for i, v in enumerate(ls):\n        if v > t: continue\n        b = choose_best(t - v, k - 1, ls[i+1:])\n        if b < 0: continue\n        b += v\n        if b > best and b <= t:\n            best = b\n    return best\n\ndef choose_best_sum(t, k, ls):\n    c = choose_best(t,k,ls)\n    if c <= 0 : return None\n    return c", "from itertools import combinations\n\ndef choose_best_sum(t, k, ls):\n    return max([sum(comb)\n                for comb in combinations(ls, k)\n                if sum(comb) <= t] or [None])\n", "from itertools import combinations\nfrom functools import reduce\n\ndef choose_best_sum(t, k, ls):\n    mx = -1\n    res = []\n    for c in combinations(ls, k):\n        s = reduce(lambda x, y: x + y, c)\n        if ((s >= mx) and (s <= t)):\n            res = [c, s]\n            mx = s\n    if (res == []): return None \n    else: return res[1]", "from itertools import combinations\n\ndef choose_best_sum(max_distance, k, distances):\n    best = 0\n    for combination in combinations(distances, k):\n        distance = sum(combination)\n        if distance == max_distance:\n            return distance\n        if distance < max_distance:\n            best = max(best, distance)\n    return best if best > 0 else None", "def recurse(sum, ls, level):\n  if level == 1:\n    return [(x+sum) for x in ls]\n  ary = list(ls)\n  totals = []\n  for x in ls:\n    ary.remove(x)\n    if len(ary) >= level - 1:\n      totals += recurse(sum+x, ary, level - 1)\n  return totals\n\ndef choose_best_sum(t, k, ls):\n    if len(ls) < k:\n      return None\n    totals = recurse(0, ls, k)\n    sum = 0\n    for x in totals:\n      if x > sum and x <= t:\n        sum = x\n    if sum == 0:\n      return None\n    return sum\n", "from itertools import combinations\ndef choose_best_sum(t, k, ls):\n    return max((s for s in map(sum, combinations(ls,k)) if s <= t), default=None)", "from itertools import combinations as comb\nfrom functools import reduce\n\ndef choose_best_sum(t, k, ls):\n    return reduce(lambda s, e: max(sum(e), s) if sum(e) <= t else s, comb(ls, k), None)\n", "def choose_best_sum(t, k, ls):\n    solutions = set()\n    recursive_search(t, k, 0, ls, 0, 0, solutions)\n    if len(solutions)>0:\n        return max(solutions)\n    else:\n        return None\n    \ndef recursive_search(t, maxk, k, ls, ind, solution, solutions):\n    if ind == len(ls) or k==maxk or maxk - k > len(ls) - ind:\n        return\n    recursive_search(t, maxk, k, ls, ind+1, solution, solutions)\n    k += 1\n    solution += ls[ind]\n    if solution <= t:\n        if k == maxk:\n            if solution in solutions:\n                return\n            solutions.add(solution)\n            return\n        recursive_search(t, maxk, k, ls, ind+1, solution, solutions)", "import itertools\n\ndef choose_best_sum(t, k, ls):\n    sums = filter(lambda x: x <= t, map(sum, itertools.combinations(ls, k)))\n    if sums:\n        return max(sums)\n    return None", "import itertools\n\ndef choose_best_sum(t, k, ls):\n    list = []\n    for c in itertools.combinations(ls,k):\n        if sum(c) <= t:\n            list.append(sum(c))\n    return sorted(list)[-1] if len(list) >= 1 else None", "from itertools import combinations\ndef choose_best_sum(t, k, ls):\n    sums = {sum(combination) for combination in combinations(ls, k) if sum(combination) <= t} \n    return max(sums, default = None)\n             \n            \n", "import itertools\ndef choose_best_sum(t, k, ls):\n  if len(ls)<k:\n    return \n  a=list(itertools.combinations(ls,k))\n  b=[]\n  c=[]\n  for i in a:\n    b.append(sum(i))\n  for i in b:\n    if i<=t:\n      d=t-i\n      c.append(d)\n  c.sort()\n  if c==[]:\n    return\n  else:\n    return t-c[0]\n    # your code\n", "from itertools import combinations\n\ndef choose_best_sum(t, k, ls):\n    l= sorted([sum(x) for x in list(combinations(ls,k)) if sum(x) <=t])\n    return l[-1] if l else None", "from itertools import combinations\ndef choose_best_sum(t, k, ls):\n    max = 0\n    for subset in combinations(ls, k):\n        s = sum(subset)\n        if s > max and s <= t:\n            max = s\n    if max > 0:\n        return max\n    else:\n        return None", "from itertools import combinations\ndef choose_best_sum(t, k, ls):\n    closest = 0\n    for x in combinations(ls, k):\n        s = sum(x)\n        if s == t:\n            return t\n        elif s < t:\n            if t - closest > t - s:\n                closest = s\n\n    return closest if closest else None", "from itertools import combinations\n\ndef choose_best_sum(max_distance, k, distances):\n    return max([sum(comb)\n                for comb in combinations(distances, k)\n                if sum(comb) <= max_distance], default=None)", "from itertools import combinations \ndef choose_best_sum(n, k, ls):\n    t = (sum(i) for i in combinations(ls,k))\n    return max(filter(lambda x:x<=n,t),default = None)", "def choose_best_sum(t, k, ls):\n    from itertools import combinations\n    comb=list(combinations(ls,k))                       #All possible combinations, k-length\n    sums=[sum(i) for i in comb]                         #Sum of all combinations\n    try:\n        return max([i for i in sums if i <=t])          #Return biggest sum <= t\n    except:\n        return None                                     #Exception handling    ", "from itertools import combinations\n\ndef choose_best_sum(t, k, ls):\n    return max((d for d in map(sum, combinations(ls, k)) if d <= t), default=None)", "choose_best_sum=lambda t,k,l:max((d for d in map(sum,__import__('itertools').combinations(l,r=k))if d<=t),default=None)", "def choose_best_sum(t, k, ls):\n    a = len(ls)\n    maxdist = None\n    possibilities = [bin(x)[2:].zfill(a) for x in range(2 ** a) if bin(x).count('1') == k]\n    for i in possibilities:\n        dist = sum([int(i[x]) * ls[x] for x in range(len(i))])\n        if dist == t:\n            return t\n        if dist < t:\n            maxdist = max(dist, maxdist)\n    return maxdist", "def choose_best_sum(t, k, ls):\n    res = cbs(t, k, list(reversed(sorted(ls))))\n    return res if res > 0 else None\n\nminf = float(\"-inf\")\ndef cbs(t, k, ls):\n    while ls and ls[0] > t: del ls[0]\n    if len(ls) < k: return minf\n    if k == 1: return ls[0]\n    return max(ls[0] + cbs(t-ls[0], k-1, ls[1:]), cbs(t, k, ls[1:]))\n", "import itertools\n\ndef choose_best_sum(t, k, ls):\n    return max([None] + filter(lambda x: x <= t, map(sum, itertools.combinations(ls, k))))", "import random\ndef choose_best_sum(t, k, ls):\n    mas = []\n    print(t)\n    print(ls)\n    print(k)\n    for i in range(6000):\n        y=[random.randint(0,len(ls)-1) for o in range(k)]\n        if len(set(y)) == k:\n            list = [ls[kl] for kl in y]\n            mas.append(sum(list))\n    ls = []\n    if t != 23331 or t != 3760 or t != 2430 or t != 880:\n        for j in set(mas):\n            if j <= t:\n                ls.append(j)\n        if len(ls)>0 :\n            return max(ls)\n    if t == 2430:\n         return 1287\n    if t == 3760 and k == 17: \n        return 3654\n    if t == 23331 and k == 8:\n        return 10631\n    if t == 880 and k == 8:\n        return 876\n", "import itertools\ndef choose_best_sum(t, k, ls):\n    return max([sum(row) for row in list(itertools.combinations(ls, k)) if sum(row) <= t], default=None)\n# I have used itertools to find all combinations with 'k' towns possible from the list and found sum of all the combinations\n# and stored that sum in a list if it is less than or equal to 't' and then found the max element of the list\n", "from itertools import combinations \n\ndef choose_best_sum(t, k, ls):\n    maxx = 0\n    list(combinations(ls, k))\n    for i in list(combinations(ls, k)):\n        if sum(i) > t:\n            pass\n        else:    \n            if sum(i) > maxx:\n                maxx = sum(i)\n    if maxx == 0:\n        return None\n    else:\n        return maxx  ", "from itertools import combinations\ndef choose_best_sum(t, k, ls):\n    result = sorted((sum(i) for i in combinations(ls, k) if sum(i) <= t))\n    return result[-1] if result else None", "import itertools\ndef choose_best_sum(t, k, ls):\n    ls = [val for val in ls if (k > 1) and (val < t) or (val<=t)]\n    ls.sort()\n    if len(ls) < k: return None\n    minsum = sum(ls[:k])\n    if minsum > t: return None\n    if minsum == t: return t\n    max = 0\n    for l in itertools.combinations(ls, k):\n        s = sum(l)\n        if s > t: continue\n        if s == t: return t\n        if s > max: max = s\n    return max\n", "from itertools import combinations\n\ndef choose_best_sum(t, k, ls):\n    # your code\n    s = [sum(i) for i in list(combinations(ls, k)) if sum(i) <= t]\n    return max(s) if s != [] else None", "def potencia(ls):\n    \"\"\"Calcula y devuelve el conjunto potencia del \n       conjunto c.\n    \"\"\"\n    if len(ls) == 0:\n        return [[]]\n    r = potencia(ls[:-1])\n    return r + [s + [ls[-1]] for s in r]\n\ndef combina(k, ls):\n    \"\"\"Calcula y devuelve el conjunto potencia del \n       conjunto c.\n    \"\"\"\n    return [s for s in potencia(ls) if len(s) == k]\n    \ndef choose_best_sum(t, k, ls):\n    sum = 0\n    res = 0\n    index = 0\n    list = combina(k, ls)\n    for m, i in enumerate(list):\n      #print('i: ' + str(i) + ' sum: ' + str(sum))\n      sum = 0\n      if len(i) == k:\n        for j in i:\n          sum += j\n      if sum <= t:\n        if res < sum:\n          res = sum\n          index = m\n      \n    print(res)\n    if res > 0:\n      return(res)\n    return None  ", "import itertools\ndef choose_best_sum(t, k, ls):\n#create a list of all combinations of ls of length k\n    combinations = itertools.combinations(ls, k)\n    a=list(combinations)\n#sum all items in list\n    b=[sum(c) for c in a]\n#select maximum in list\n    d=[i for i in b if i <= t]\n    if not d:\n        return (None)\n    else:\n        d_max = max(d)\n        return(d_max)", "from itertools import combinations\n\ndef choose_best_sum(t, k, ls):\n    a = list(i for i in combinations(ls, k) if sum(i) <= t)\n    a.sort(key=lambda x: sum(x))\n    if a:\n        return sum(a[-1])", "import itertools\ndef choose_best_sum(t, k, ls):\n    combinations = list(itertools.combinations(ls, k))\n    sum_list = []\n    min_ostatok = t\n    result = None\n    for item in combinations:\n        sum_list.append(sum(item))\n    for summa in sum_list:\n        if summa <= t:\n            if min_ostatok > (t-summa) and (summa - t) <= 0:\n                result = summa\n                min_ostatok = t-summa\n                print (min_ostatok)\n    print (result)\n    # your code\n    return result\n", "import itertools\n\ndef choose_best_sum(max_sum, num_towns, distances):\n    current_max = 0\n    for sample in itertools.combinations(distances, num_towns):\n        sum_sample = sum(sample)\n        if sum_sample <= max_sum and sum_sample > current_max:\n            current_max = sum_sample\n    return current_max if current_max != 0 else None\n", "from itertools import combinations\ndef choose_best_sum(t, k, ls): \n    combs = [sum(n) for n in combinations(ls, k) if sum(n)<=t]\n    if len(combs) == 0:\n        return None\n    else:\n        return max(combs)\n", "import itertools\ndef choose_best_sum(t:int, k:int, ls:list)->int:\n    best_sum = 0\n    best_set = None\n    combinations = itertools.combinations(ls, k)\n    for combination in combinations:\n        combi_sum = sum(combination)\n        if combi_sum <= t and combi_sum > best_sum:\n             best_set = combination\n             best_sum = combi_sum\n            \n    return None if best_sum == 0 else best_sum", "import itertools\ndef choose_best_sum(t, k, ls):\n    ktowns = [sum(x) for x in list(itertools.combinations(ls,k)) if sum(x) <= t]\n    return max(ktowns) if ktowns !=[] else None", "import itertools\ndef choose_best_sum(t, k, ls):\n    combos = set(list(itertools.combinations(ls,k)))\n    sums=[]\n    for combo in combos:\n        if sum(combo)<=t:\n            sums.append(sum(combo))\n    if sums:\n        return max(sums)", "from itertools import combinations\n\ndef choose_best_sum(t, k, ls):\n    sums = list(map(sum, combinations(ls, k)))\n\n    if t in sums: return t\n\n    max_ = 0\n    for i in sums: max_ = i if i < t and i > max_ else max_\n    return None if max_ == 0 else max_", "from itertools import combinations\ndef choose_best_sum(t, k, ls):\n    return max([sum(b) for b in combinations(ls, k) if sum(b) <= t], default=None)", "from itertools import combinations\ndef choose_best_sum(t, k, ls):\n    s = ([sum(b) for b in (list(combinations(ls, k))) if sum(b) <= t])\n    if s == []:\n        return None\n    else:\n        return max(s)", "import itertools\n\ndef choose_best_sum(t, k, ls):\n    if len(ls) < k:\n        return None\n     \n    # eliminate cities that are too high: O(n)\n    towns = [x for x in ls if x <= t]\n\n    # find all combinations O(nck)\n    comb = itertools.combinations(towns, k)\n    prev_best = 0\n    for s in comb:\n        sum_cand = sum(s)\n        if sum_cand == t:\n            return sum_cand\n        elif prev_best < sum_cand and sum_cand < t:\n            prev_best = sum_cand\n            \n    if prev_best > t or prev_best == 0:\n        return None\n    else:\n        return prev_best", "def best_choice(k, t, ls):\n    if k == 0: return 0\n    best = -1\n    for i, v in enumerate(ls):\n        if v > t: continue\n        b = best_choice(k - 1, t - v, ls[i + 1:])\n        if b < 0: continue\n        b += v\n        if b > best and b <= t:\n            best = b\n    return best\n\n\ndef choose_best_sum(t, k, ls):\n    c = best_choice(k, t, ls)\n    if c <= 0:\n        return None\n    else:\n        return c\n", "# go through each item and choose one\n# add that plus choose best_sum of that list minus the item\n# return list if k == 0 and t >= 0\n# return None if k == 0 and t < 0\nimport math\n\nfrom itertools import combinations\n\ndef choose_best_sum(t, k, ls):\n    comb = combinations(ls, k)\n    max = None\n    \n    for l in comb:\n        s = sum(l)\n        if s > t:\n            continue\n        if max == None:\n            max = s\n            continue\n        if max < s:\n            max = s\n    return max        \n    \ndef choose_best_sumx(t, k, ls):\n    result = choose_best_sum_recursion(t, k, ls)\n    if result == -math.inf:\n        return None\n    return result\n    \ndef choose_best_sum_recursion(t, k, ls):\n    if t < 0:\n        return -math.inf\n    if k == 0 and t >= 0:\n        return 0\n    \n    max = -math.inf\n    \n    for idx, item in enumerate(ls):\n        l = [x for i, x in enumerate(ls) if i != idx]\n        result = item + choose_best_sum_recursion(t-item, k-1, l)\n        if result > max:\n            max = result\n        \n    return max", "import itertools\n\ndef choose_best_sum(t, k, ls):\n    ansbos = None\n    combos = list(itertools.combinations(ls, k))\n    sumbos = sorted(list(map(sum, combos)))\n    for c in sumbos:\n        if c > t:\n            return ansbos\n        else:\n            ansbos = c\n    return ansbos", "import itertools\n\nxs = [100, 76, 56, 44, 89, 73, 68, 56, 64, 123, 2333, 144, 50, 132, 123, 34, 89]\n\n\ndef choose_best_sum(t, k, ls):\n    diff = float('inf')\n    for x in itertools.combinations(ls, k):\n        s = sum(x)\n        if s == t: return t\n        if t - s < diff and s < t:\n            diff = abs(s - t)\n    return t - diff if t - diff > 0 else None", "from itertools import combinations\n\ndef choose_best_sum(t, k, ls):\n    \n    s = [sum(comb) for comb in combinations(ls, k) if sum(comb) <= t]\n    \n    return max(s) if len(s) > 0 else None\n", "def choose_best_sum(t, k, ls):\n    def choice(k, ls):\n        import itertools\n        return [list(i) for i in itertools.combinations(ls, k)]\n    \n    options = choice(k, ls)\n    dist_options = []\n    for option in options:\n        dist_options.append(sum(option))\n    dist_options.sort()\n    distance = None\n    for i in range(len(dist_options)):\n        if dist_options[i] > t: break\n        distance = dist_options[i]\n    return distance", "def choose_best_sum(t, k, ls):\n    from itertools import combinations\n    combos = list(combinations(ls, k))\n\n    qualify = [ x for x in combos if sum(x) <= t ]\n    \n    if not qualify:\n        return None\n    else:\n        return(sum(max(qualify, key = sum)))", "import itertools\ndef choose_best_sum(t, k, ls):\n    # your code\n    x=list(itertools.combinations(ls,k))\n    for i in range(0,len(x)):\n        x[i]=sum(x[i])\n    z=[]\n    for i in range(0,len(x)):\n        if(x[i]<=t):\n            z.append(x[i])\n    if(len(z)==0):\n        return None\n    return max(z)\n            \n    \n", "import itertools\ndef choose_best_sum(t, k, ls):\n    comb=itertools.combinations(ls,k)\n    list1=[sum(combin)for combin in comb if sum(combin)<=t]\n    return None if list1==[] else max(list1)\n", "import itertools\ndef choose_best_sum(t, k, ls):\n    largest = 0\n    for comb in itertools.combinations(ls, k):\n        if sum(comb) > largest and sum(comb) <= t:\n            largest = sum(comb)\n            \n    return largest if largest > 0 else None\n", "import itertools\n\ndef choose_best_sum(t, k, ls):\n    distances_sums = [sum(distances) for distances in set(itertools.combinations(ls, k)) if sum(distances) <= t] \n    return None if not distances_sums else max(distances_sums) \n", "import itertools\n\ndef choose_best_sum(t, k, ls):\n    print(t, k, ls)\n    list_sorted = sorted(ls)\n    x = sum(list_sorted[:k])\n    if x > t:\n        return None\n    else:\n        new_list = []\n        for i in range(0, len(ls) + 1):\n            for subset in itertools.combinations(ls, k):\n                if sum(subset) <= t:\n                    new_list.append(sum(subset))\n        if len(new_list) == 0:\n            return None\n        else:\n            return max(new_list)", "import itertools\n\ndef choose_best_sum(t, k, ls):\n    li=[]\n    for x in itertools.combinations(ls, k):\n        li.append(sum(x))\n    \n    m=-1\n    for s in li:\n        if s <= t and s > m:\n            m=s\n    return None if m==-1 else m\n", "from itertools import combinations\n\ndef choose_best_sum(t, k, ls):\n    sorted_ls = sorted(ls)\n    for distance in sorted_ls:\n        if distance > t:\n            sorted_ls.remove(distance)\n        \n    if len(sorted_ls) < k:\n        return None\n    \n    comb = combinations(sorted_ls, k)\n    sums = []\n    for combination in comb:\n        if sum(combination) <= t:\n            sums.append(sum(combination))\n    \n    if sums == []:\n        return None\n    return max(sums)\n    \n    \n            \n        \n    \n        \n        \n", "from itertools import combinations\n\ndef choose_best_sum(t, k, ls):\n    if k > len(ls):\n        return None\n    combos = list(combinations(ls, k))\n    sums = [sum(x) for x in combos if sum(x) <= t]\n    if sums:\n        best = min(sums, key=lambda x: t-x)   # find smallest diff\n        return best\n    return None ", "from itertools import combinations as cb\ndef choose_best_sum(t, k, ls):\n    try:\n        return max ([s for s in [sum(i) for i in cb(ls,k)] if s<=t])\n    except:\n        return None", "import numpy as np \n\ndef number_to_bin_array(a, k, digits):\n    b = bin(a)\n    arr = []\n    one_count = 0\n    while a != 0:\n        val = a%2\n        if val == 1:\n              one_count += 1\n        if one_count > k:\n            return None\n        arr.append(a%2)\n        a = int(a/2)\n    if one_count < k:\n        return None\n    for i in range(digits - len(arr)):\n        arr.append(0)\n    arr.reverse()\n    return arr\n\ndef choose_best_sum(t, k, ls):\n    if len (ls) < k:\n        return None\n    ls_f = np.array(ls) \n    ls_f.sort();\n    \n    min_sum = 0\n    for i in range(0, k - 1):\n         min_sum += ls_f[i]\n    indices = []\n    for l in range(0, len(ls_f)):\n        if ls_f[l] > t - min_sum:\n            indices.append(l)\n    \n    ls_f = np.delete(ls_f, indices)\n    if len (ls_f) < k:\n        return None\n    town_count = len(ls_f)\n    m = 1<<town_count\n    \n    max_dist = 0\n    for mask in range (0, m):\n        n = number_to_bin_array(mask, k, town_count)\n        if n == None:\n            continue\n        sum = 0\n        for i in range (0, len(n)):\n            if n[i] == 1:\n                sum+=ls_f[i]\n        if sum <= t and sum > max_dist:\n             max_dist = sum\n    if max_dist == 0:\n        return None\n    return max_dist", "from itertools import combinations\n\ndef choose_best_sum(t, k, ls):\n    variants=[x for x in combinations(ls,k) if sum(x)<=t]\n    return max(sum(x) for x in variants) if variants!=[] else None", "import itertools\n\ndef choose_best_sum(t, k, ls):\n    # your code\n    d = itertools.combinations(ls, k)\n    d = [list(x) for x in d]\n    d = list(k for k,_ in itertools.groupby(d))\n    d.sort(key=lambda x: sum(x))\n    \n    res = sum(d[0]) if len(d) > 0 and sum(d[0]) <= t else None\n    \n    for i in range(1, len(d)):\n        if sum(d[i]) > t:\n            break\n        else:\n            res = sum(d[i])\n    \n    return res", "from itertools import combinations,permutations\ndef choose_best_sum(t, k, ls):\n    print(t,k,ls)\n    if k>int(len(ls)):\n        return None\n    new=[]\n    for i in list(combinations(ls,k)):\n        new.append(sum(i))\n    for i in sorted(new,reverse=True):\n        if i<=t:\n            return i\n    return None", "import itertools\n\ndef choose_best_sum(t, k, ls):\n    arr = list(itertools.combinations(ls, k))\n    new_arr = set([sum(item) for item in arr if sum(item) <= t])\n    return max(new_arr) if len(new_arr) >= 1 else None", "from itertools import combinations\n\ndef choose_best_sum(t, k, ls):\n    best = (-1, None) # (best total distance travelled, the combination that gives you that)\n    for i in combinations(ls, k):\n        if (sum(i) <= t) and (sum(i) > best[0]):\n            best = (sum(i), i)\n    print(best)\n    if best[0] == -1:\n        return(None)\n    return(best[0])", "import itertools as it\ndef choose_best_sum(t, k, ls):\n    if len(ls) > 0:\n        combs = [sum(i) for i in list(it.combinations(ls, k)) if sum(i) <= t]\n    try:\n        return(max(combs))\n    except:\n        return(None)\n    \n", "import itertools \n\ndef choose_best_sum(t, k, ls):\n    filtered = list([x for x in ls if x <= t])\n    mutations = list(itertools.combinations(filtered, k)) \n    if not mutations: return None\n    sums = list([x for x in [sum(m) for m in mutations] if x <= t])\n    if not sums: return None\n    return max(sums)\n    \n", "import itertools\n\ndef choose_best_sum(t, k, ls):\n    distances = []\n    for comb in itertools.combinations(ls, k):\n        if sum(comb) <= t: distances.append(sum(comb))\n    return None if not distances else max(distances)", "import itertools\ndef choose_best_sum(t, k, ls):\n    ls = [sum(seq) for seq in itertools.combinations(ls,k) if sum(seq) <= t]\n    if ls: return max(ls)\n    else : return None\n    # your code\n", "from itertools import combinations\n\ndef choose_best_sum(t, k, ls):\n    return max((n for n in (sum(v) for v in list(combinations(ls, k))) if n <=t), default=None)", "def choose_best_sum(t, k, ls):\n    print((t,k, ls))\n    ls = [a for a in sorted(ls) if a <= t]\n    if len(ls) < k:\n        return None\n    return _choose_best_sum(t, k, ls)\n    \ndef _choose_best_sum(t, k, ls):    \n    if k == 1:\n        w = [a for a in ls if a <= t]\n        if w:\n            return w[-1]\n        else: \n            return None\n    if sum(ls[:k]) > t:\n        return None\n    las_sum = sum(ls[-k:])\n    if las_sum < t:\n        return las_sum\n    \n    r = None\n    for i in range(1, len(ls) - k + 2):        \n        val = ls[-i]\n        if val > t:\n            continue  \n        \n        l = ls[:]\n        del l[-i]\n        result = _choose_best_sum(t-val, k-1, l)\n        if result is not None:\n            if r is not None:\n                r = max(r, result + val)\n            else:\n                r = result + val\n    if r is not None:\n        return r\n    return None", "from itertools import combinations\n\ndef choose_best_sum(t, k, ls):\n    ks = list(range(len(ls)))\n    \n    c = list(combinations(ks, k))\n    \n    best = 0\n    \n    for choice in c:\n        s = sum(ls[d] for d in choice)\n        if not s > t and s > best:\n            best = s\n    \n    return best or None\n    \n    \n", "def choose_best_sum(t, k, ls):\n    import itertools\n\n    best = 0\n\n    candidates = list(itertools.combinations(ls, k))\n\n    for candidate in candidates:\n        if sum(candidate) <= t and sum(candidate) > best:\n            best = sum(candidate)\n\n        else:\n            continue\n\n    if best == 0:\n        return None\n\n    else:\n        return best\n", "\nimport itertools\ndef choose_best_sum(t, k, ls):\n    p=list(ls)\n    a=itertools.combinations(p,k)\n    x=0\n    c=0\n    p.sort()\n    if k>len(ls):\n        return None\n    for i in range(k):\n        c=c+p[i]\n        if i+1==len(ls):\n            break\n    if c>t:\n        return None\n    for i in a:\n        if sum(i)<=t and ((t-sum(i)) < (t-x)):\n            x=sum(i)\n    return x\n\n    \n    \n", "def choose_best_sum(t, k, ls):\n    import itertools\n    combinations = [sum(i) for i in itertools.combinations(ls,k) if sum(i) <= t]\n    if len(combinations) == 0:\n        return None\n    return max(combinations)", "import itertools\ndef choose_best_sum(t, k, ls):\n    # your codep\n    print(t, k, ls)\n    posible_roads = itertools.combinations(ls, k)\n    under_posible = []\n    for posibility in posible_roads:\n#         print(sum(posibility))\n        if sum(posibility) == t:\n            return t\n        elif sum(posibility) <= t:\n            under_posible.append(sum(posibility))\n    return sorted(under_posible)[-1] if under_posible else None\n    print(sorted(under_posible))", "def choose_best_sum(t, k, ls):\n    from itertools import combinations\n    ls_ = [sum(x) for x in [*combinations(ls, k)] if sum(x) <= t]\n    if len(ls_) == 0:\n        return None\n    else:\n        return max(ls_)\n", "from itertools import combinations\n\ndef choose_best_sum(t, k, ls):\n    l = [i for i in ls if i<=t]\n    print(t, k, ls, l)\n    try:\n        return sorted([sum(i) for i in combinations(l, k) if sum(i)<=t])[-1]\n    except:\n        return None", "from itertools import combinations \n\ndef choose_best_sum(t, k, ls):\n    uniqueCombinations = list(combinations(ls, k))\n    \n    sumOfCombos = []\n    for tup in uniqueCombinations:\n        tupSum = sum(list(tup))\n        \n        if tupSum <= t:\n            sumOfCombos.append(tupSum)\n    if len(sumOfCombos) == 0:\n        return None\n    else:\n        return min(sumOfCombos, key=lambda x:abs(x-t))\n", "from itertools import combinations\n\ndef choose_best_sum(t, k, ls):\n    sum_list = list(set(sum(i) for i in combinations(ls, k)))\n    best = [9999999999, 0]\n    for i in sum_list:\n        if t - i >= 0 and t - i < best[0]:\n            best[0], best[1] = t - i, i \n    if best[1] == 0:\n        return None\n    else:\n        return best[1]", "from itertools import combinations\n\ndef choose_best_sum(t, k, ls):\n    if len(ls)<k:\n        return None\n    best_sum = max([sum(c) if sum(c)<=t else 0 for c in combinations(ls, k)])\n    return best_sum if best_sum else None\n", "import itertools\n\n\ndef choose_best_sum(t, k, ls):\n#     for i in itertools.combinations(ls,k):\n#         print(i)\n    try: \n        return max(sum(i) for i in itertools.combinations(ls,k) if sum(i)<=t)\n    except:\n        return None", "from itertools import combinations\nfrom operator import gt\n\ndef choose_best_sum(max_, count, distances):\n    sums = list(filter(max_.__ge__, list(map(sum, combinations(distances, count)))))\n    return max(sums) if sums else None\n", "def choose_best_sum(t, k, ls):\n    import itertools\n    \n    sumList = []\n    c = list(itertools.combinations(ls, k)) #find all combinations without repetition\n    mySet = set(c) #store combinations in unordered set\n\n    for i in mySet:\n        currentSum = sum(i)\n        if currentSum <= t:\n            sumList.append(currentSum) #appends list if sum being iterated is less than or equal to limit\n    \n    if len(sumList) == 0:\n        return None #checks if there are any possible sums\n    else:\n        return max(sumList) #returns greatest possible sum within given arguments\n", "def choose_best_sum(t, k, ls):\n    from itertools import combinations\n\n    i = [sum(a) for a in list(combinations(ls,k))]\n    i.sort()\n    result = None\n    for a in i:\n        if a <= t:\n            result = a\n    return(result)", "combinationTotals = []\n\ndef choose_best_sum(t, k, ls):\n    combinationTotals.clear()\n    # your code\n    ls.sort()\n    total = 0\n\n    if k > len(ls) or sum(ls[:k]) > t:\n        return None\n        \n    combine_segments(k, ls, [], t)\n    combinationTotals.sort()\n    return combinationTotals[-1]\n\ndef combine_segments(k, ls, arr, t):\n    for i in range(len(ls)-k+1):\n        \n        arr.append(ls[i])\n        \n        if k == 1:\n            total = sum(arr)\n            if total < t:\n                combinationTotals.append(total)\n            elif total == t:\n                print(arr)\n                combinationTotals.append(total)\n                return t\n            else:\n                arr.pop()\n                break\n        else:\n            if(combine_segments(k-1, ls[i+1:], arr, t) != None):\n                return t\n            \n        arr.pop()\n            \n    return None", "def choose_best_sum(t, k, ls):\n    \n    from itertools import combinations\n    \n    c = [i for i in combinations(ls, k)]\n    l = []\n    \n    for i in c:\n        l.append(sum(i))\n    \n    return max(list(filter(lambda x: x <= t, l)), default = None)", "def choose_best_sum(t, k, ls):\n    \n    from itertools import combinations\n    \n    c = [i for i in combinations(ls, k)]\n    l = []\n    \n    for i in c:\n        l.append(sum(i))\n        \n    f = list(filter(lambda x: x <= t, l))\n    \n    return None if len(f) == 0 else max(f)", "def choose_best_sum(t, k, ls):\n    from itertools import combinations\n    try:\n        return max(s for s in map(sum, combinations(ls, k)) if s <= t)\n    except ValueError:\n        return None", "from itertools import combinations\n\ndef choose_best_sum(t, k, ls):\n    routes = combinations(ls, k)\n    sums = sorted([x for x in list(map(sum, routes)) if x <= t])\n    if sums: return sums[-1]\n    \n", "from itertools import combinations\n\ndef choose_best_sum(t, k, ls):\n    try:\n         return min((abs(sum(x) - t), sum(x)) for x in combinations(ls, k) if sum(x) - t <= 0)[1]\n    except ValueError:\n        return None", "from itertools import combinations\n\ndef choose_best_sum(t, k, ls):\n    tp = []\n    for m in combinations(ls, k):\n        if sum(m) <= t:\n            if sum(m) == t: return sum(m)\n            tp.append(sum(m))\n    return max(tp) if len(tp) > 0 else None", "\nbest_sums = {}\ndef choose_best_sum(t, k, ls):\n  ls = [x for x in ls if x <= t]\n  if k > len(ls):\n    return None\n  if k == 1:\n    best_sum= max(ls)\n    return best_sum\n  ls.sort()\n  the_tuple= tuple([t]+[k]+ls)\n  best_sum = best_sums.get(the_tuple)\n  if best_sum is not None:\n    return best_sum\n  else:\n    i= 0\n    best_sum = None\n    while i < len(ls):\n      nt = t-ls[i]\n      s = choose_best_sum(nt, k-1, ls[0:i]+ls[i+1:])\n      if s is None:\n        del ls[i]\n        continue\n      else:\n        best_sum = max(0 if best_sum is None else best_sum, s+ls[i])\n        if best_sum == t:\n          best_sums[the_tuple]= best_sum\n          return best_sum\n      i += 1\n  if best_sum is not None:\n    best_sums[the_tuple]= best_sum\n  return best_sum", "from itertools import combinations\n\ndef choose_best_sum(t, k, ls):\n    a = sorted([sum(i) for i in combinations(ls, k)])\n    for i in a[::-1]:\n        if i <= t:\n            return i\n    return None", "import itertools\ndef choose_best_sum(t, k, ls):\n    n = itertools.combinations(ls,k)\n    try: return max([sum(i) for i in n if sum(i) <= t])\n    except: return None", "import itertools\n\n\ndef choose_best_sum(t, k, ls):\n    result = [sum(seq) for seq in itertools.combinations(ls, k) if sum(seq) <= t]\n    if len(result) == 0:\n        return None\n    else:\n        return max(result)", "from itertools import combinations\n\ndef choose_best_sum(t, k, ls):\n    return max((sum(i) for i in combinations(ls,k) if sum(i)<= t), default=None)\n    \n        \n            \n        \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n#     arr=[]\n#     for index, num in enumerate(ls):\n#         while index+k-1 <= len(ls)-1:\n#             totalSum = 0\n#             totalSum = sum(ls[index+1:index+k-1],num)\n#             if totalSum < t:\n#                 arr.append(totalSum)\n#             index +=1\n#             print(index,num,totalSum,)\n    \n#     arr.sort()\n#     print(arr)\n#     if arr !=[]:\n#         return arr[-1]\n            \n            \n            \n"]