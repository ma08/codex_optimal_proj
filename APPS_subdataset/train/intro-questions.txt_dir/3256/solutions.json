["def sum_pow_dig_seq(num, exp, k):\n    seq = []\n    \n    for step in range(k):\n        seq.append(num)\n        num = sum( int(dig) ** exp for dig in str(num) )\n        \n        if num in seq:\n            cycle_start = seq.index(num)\n            cycle = seq[cycle_start:]\n            last_term = cycle[(k - cycle_start) % len(cycle)]\n            return [ cycle_start, cycle, len(cycle), last_term ]\n    \n    return [ 0, [], 0, num ]", "def sum_pow_dig_seq(start, n, k):\n    seq = [start]\n    num = start\n    for i in range(k):\n        num = sum([int(x)**n for x in str(num)])\n        if num in seq:\n            # We got the loop!\n            loop_starts_from = seq.index(num)\n            loop_array = seq[loop_starts_from:]\n            tail_size = loop_starts_from\n            loop_size = len(loop_array)\n            last_term = loop_array[(k - tail_size) % loop_size]\n            return [tail_size, loop_array, loop_size, last_term]\n        seq.append(num)\n    else:\n        # What if we didn`t get the loop?\n        return [len(seq), [], 0, seq[-1]]\n    \n", "def sum_pow_dig_seq(start, n, k):\n    seen = [start]\n    for i in range(k):\n        r1 = sum(map(lambda x: x**n, map(int,str(seen[-1]))))\n        if r1 in seen: #Cycle detected.\n            h = seen.index(r1)\n            cyc_patt_arr = seen[h:]\n            patt_len = len(seen) - h\n            last_term = cyc_patt_arr[(k-i-1)%patt_len]\n            break\n        seen.append(r1)\n        \n    return [h, cyc_patt_arr, patt_len, last_term]", "def sum_of_digits_pow(n, e):\n    return sum([i**e for i in map(int, str(n))])\n\ndef sum_pow_dig_seq(start, e, k):\n    h = 0\n    cyc_patt_arr, sums = [], []\n    for i in range(1, k+1):\n        start = sum_of_digits_pow(start, e)\n        if not cyc_patt_arr and start in sums:\n            cyc_patt_arr = [j for j in sums[sums.index(start):]]\n            h = sums.index(start) + 1\n            return [h, cyc_patt_arr, len(cyc_patt_arr), cyc_patt_arr[(k-i) % len(cyc_patt_arr)]]\n        sums.append(start)\n        \n", "def sum_pow_dig_seq(start, n, k):\n    def next_(v):\n        return sum(int(c) ** n for c in str(v))\n    \n    history = []\n    history_set = set()\n    x = start\n    while True:\n        if x in history_set:\n            i = history.index(x)\n            cyc = history[i:]\n            if k < len(history):\n                return [i, cyc, len(cyc), history[k]]\n            return [i, cyc, len(cyc), cyc[(k - i) % len(cyc)]]\n        history.append(x)\n        history_set.add(x)\n        x = next_(x)", "def sum_pow_dig_seq(start, n, k):\n    cycle, l, h, drop = set(), [], -1, False\n    for i in range(k):\n        start = sum(int(d)**n for d in str(start))\n        if h != -1 and start in cycle: break\n        if h == -1  and start in cycle:\n            cycle, h, l = set(), i, []\n        cycle.add(start)\n        l.append(start)\n    return [h-len(l)+1, l, len(l), l[(k-i-1)%len(l)]]", "def sum_pow_dig_seq(start, n, k):\n    x = start\n    series = []\n    seen_at = {}\n    i = 0\n    while x not in seen_at:\n        series.append(x)\n        seen_at[x] = i\n        x = sum(int(d) ** n for d in str(x))\n        i += 1\n    i_first = seen_at[x]\n    cycle_length = i - i_first\n    if k >= i:\n        k = i_first + (k - i_first) % cycle_length\n    return [i_first, series[i_first:], cycle_length, series[k]]", "def sum_pow_dig_seq(start, n, k):\n    r=[]\n    for i in range (0,k):\n       c=0\n       for d in str(start):\n          c+=int(d)**n\n       r.append(c); start=c\n    for i in range (0,k):\n       if r[i] in r[i+1:]:\n          posE=r.index(r[i],i+1)\n          if posE>=0:\n             if r[i:posE-1]==r[posE:posE+posE-1-i]: posS=i; break \n    return [posS+1, r[posS:posE], posE-posS, start]", "def sum_pow_dig_seq(start, n, k):\n    li = []\n    for _ in range(k):\n        r = sum([j ** n for j in map(int, str(start))])\n        if r in li:\n            reach = n = li.index(r) + 1 ; series = li[li.index(r):] ; s_l = len(series)\n            while n + s_l <= k : n += s_l\n            return [reach, series, s_l, series[k - n]]\n        li.append(r) ; start = r", "def sum_pow_dig_seq(n, e, k):\n    path = [n]\n    while True:\n        n = sum(int(d)**e for d in str(n))\n        if n in path: break\n        path.append(n)\n    h = path.index(n)\n    loop = path[h:]\n    return [h, loop, len(loop), loop[(k-h)%len(loop)]]\n"]