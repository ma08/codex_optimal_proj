["from fractions import gcd\n\ndef DPC_sequence(s):\n    n=1\n    for i,c in enumerate(s,1):\n        if c=='D':\n            n=(n*i)//gcd(n,i)\n        elif c=='P':\n            if gcd(n,i)!=1: return -1\n        elif c=='C':\n            if gcd(n,i) in (1,i): return -1\n    return n\n", "from fractions import gcd\n\ndef DPC_sequence(s):\n    n = 1\n    for i, c in enumerate(s, 1):\n        if c == 'D': n = n * i // gcd(n, i)\n    for i, c in enumerate(s, 1):\n        g = gcd(n, i)\n        if c == 'P' and 1 < g: return -1\n        if c == 'C' and not 1 < g < i: return -1\n    return n", "from fractions   import gcd\nfrom collections import defaultdict\nfrom functools   import reduce\n\ndef lcm(a,b):        return int(a*b/gcd(a,b))\ndef full_lcm(*args): return reduce(lcm, args)\n\ndef DPC_sequence(s):\n    DPC_dct = defaultdict(set)\n    for i,c in enumerate(s,1): DPC_dct[c].add(i)\n    n = full_lcm(*DPC_dct['D'])\n    return  -1 if any( gcd(n, x) in [1, x] for x in DPC_dct['C']) or any( gcd(n, x) != 1 for x in DPC_dct['P']) else n\n", "from math import gcd\nfrom functools import reduce\n\ndef DPC_sequence(s):\n    def lcm(a, b):\n        return a*b // gcd(a, b)\n    \n    d, p, c = [], [], []\n    for i in range(len(s)):\n        if s[i] == \"D\": \n            d.append(i+1)\n        elif s[i] == \"P\":\n            p.append(i+1)\n        else:\n            c.append(i+1)\n    \n    if not d:\n        return -1\n    lcm_d = reduce(lambda i, j: lcm(i, j), d)\n    for i in p:\n        if gcd(lcm_d, i) != 1:\n            return -1\n    for i in c:\n        if lcm_d % i == 0 or gcd(lcm_d, i) == 1:\n            return -1\n    return lcm_d\n", "from math import gcd\n\ntry:\n    from math import prod\nexcept ImportError:\n    def prod(l, p=1):\n        for n in l: p *= n\n        return p\n\nmax_n = 1000000000\n\ndef DPC_sequence(s):\n    if s[0] == 'C':\n        return -1\n    primes = list(find_primes(len(s)))\n    pf = []\n    for p in primes:\n        if s[p-1] == 'C':\n            return -1\n        if s[p-1] == 'D':\n            pf.append(p)\n    #print(pf)\n    for p in pf:\n        for i in range(2*p-1, len(s), p):\n            if s[i] == 'P':\n                return -1\n    base = prod(pf)\n    nmax = min(prod(primes), max_n)\n    #print(base, nmax)\n    for n in range(base, nmax, base):\n        if test(s, n):\n            return n\n    return -1\n\ndef test(s, n):\n    for k in range(2, len(s)+1):\n        c = s[k-1]\n        if c == 'D':\n            if n % k != 0: return False\n        else:\n            if (gcd(n, k) == 1) != (c == 'P'): return False\n    return True\n\ndef find_primes(n):\n    if n < 2: return\n    yield 2\n    s = list(range(1, n+1, 2))\n    mroot = int(n ** 0.5)\n    half = (n+1) // 2\n    i = 1\n    m = 3\n    while m <= mroot:\n        if s[i]:\n            yield s[i]\n            j = m*m // 2\n            while j < half:\n                s[j] = 0\n                j += m\n        i += 1\n        m += 2\n    for x in s[i:]:\n        if x:\n            yield x\n", "from math import gcd\ndef DPC_sequence(s):\n    r=1\n    pset=set()\n    for i,c in enumerate(s):\n        x=i+1\n        if c=='D':\n            if r%x==0:\n                continue\n            y=x//gcd(r,x)\n            if y in pset:\n                return-1\n            r*=y\n        elif c=='P':\n            if r%x==0 or gcd(r,x)>1:\n                return -1\n            pset.add(x)\n        else:\n            if r%x==0 or gcd(r,x)==1:\n                return -1\n    return r", "from fractions import gcd\n\ndef DPC_sequence(s):\n    res = 1\n    \n    for i, c in enumerate(s, 1):\n        if c == 'D':\n            res *= i // gcd(i, res)\n            \n    def check_DPC_at(i, c):\n        if c == 'D':\n            return gcd(i, res) == i\n        elif c == 'C':\n            return gcd(i, res) in range(2, i)\n        elif c == 'P':\n            return gcd(i, res) == 1\n            \n    return res if all(check_DPC_at(*e) for e in enumerate(s, 1)) else -1\n", "from math import gcd\nfrom copy import copy\n\n\ndef DPC_sequence(s):\n    d = [x for x, y in enumerate(s, 1) if y == 'D']\n    p = [x for x, y in enumerate(s, 1) if y == 'P']\n    c = [x for x, y in enumerate(s, 1) if y == 'C']\n    D = lcm(d) if len(d) > 1 else d[0]\n    return D if all(gcd(D, i) == 1 for i in p if i != 1) and all(1 < gcd(D, i) < i for i in c) else -1\n\n\ndef lcm(n):\n    x = n.copy()\n    while x:\n        i, n = x[-2:]\n        del x[-2:]\n        if not x: return n\n        x.append(i * n // gcd(i, n))", "from math import gcd\nlcm = lambda x,y: x*y//gcd(x,y)\n\ndef DPC_sequence(s):\n    res = 1\n    for i,x in enumerate(s):\n        if x == 'D':\n            res = lcm(res, i+1)\n    for i,x in enumerate(s):\n        if (x == 'C' and (not res%(i+1) or gcd(res, i+1) == 1)) or (x == 'P' and gcd(res, i+1) > 1):\n            return -1\n    return res", "from fractions import gcd\nfrom functools import reduce\n\ndef DPC_sequence(s):\n    ds, ps, cs, prod = [], [], [], 1\n    \n    for i, v in enumerate(s, 1):\n        if v == 'D': \n            ds.append(i)\n            prod = (prod * i) // gcd(prod, i)\n        elif v == 'P': ps.append(i)\n        elif v == 'C': cs.append(i)\n    \n    for p in ps: \n        if gcd(prod, p) != 1: return -1\n    for c in cs: \n        if prod % c == 0 or gcd(prod, c) == 1: return -1\n    \n    return prod"]