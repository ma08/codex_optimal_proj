["def word_problem(rules: List[Tuple[str, str]], from_str: str, to_str: str, applications: int) -> bool:\n    rec = lambda s,n: s == to_str or n and any(s[i:].startswith(x) and rec(s[:i] + y + s[i+len(x):], n-1) for i in range(len(s)) for x,y in rules)\n    return rec(from_str, applications)", "def word_problem(rules, start, to, N):\n    q   = [(0,0,start)]\n    for i,n,s in q:\n        if s==to: return True\n        if n<N and i<len(s):\n            q.extend( (i, n+1, s[:i]+y+s[i+len(x):]) for x,y in rules if s[i:].startswith(x) )\n            q.append( (i+1,n,s) )\n    return False", "from copy import deepcopy\n\ndef word_problem(rules: List[Tuple[str, str]], from_str: str, to_str: str, applications: int) -> bool:\n    if applications == 0 or from_str == to_str:\n        return from_str == to_str\n    currentStrings = [from_str]\n    for i in range(applications):\n        # create all possible next strings from current string(s), using all rules\n        nextStrings = []\n        # iterate over all current strings\n        for s in currentStrings:\n            # determine all possible next strings\n            for rule in rules:\n                pos = 0\n                while pos < len(s) and rule[0] in s[pos:]:\n                    if s[pos:].startswith(rule[0]):\n                        newString = s[:pos] + rule[1] + s[pos+len(rule[0]):]\n                        if newString == to_str:\n                            return True\n                        if not newString in nextStrings:\n                            nextStrings.append(newString)\n                    pos += 1\n        currentStrings = nextStrings\n    return False\n", "def word_problem(rules,f,t,a):\n    if f==t:return True\n    if a==0:\n        return f==t\n    return any(word_problem(rules,x,t,a-1)for r in rules for x in apply(r,f))\n\ndef apply(r,f):\n    x,y=r\n    l=len(x)\n    for i in range(len(f)-l+1):\n        if f[i:i+l]==x:\n            yield f[:i]+y+f[i+l:]", "def word_problem(\n    rules: List[Tuple[str, str]], \n    from_str: str, \n    to_str: str, \n    applications: int\n) -> bool:\n\n    def recurse(from_str, applications) -> bool:\n        if from_str == to_str:\n            yield True\n        elif applications == 0:\n            yield False\n        else:\n            for f, t in rules:\n                i = from_str.find(f)\n                while i > -1:\n                    yield from recurse(\n                        from_str[:i] + t + from_str[i + len(f):],\n                        applications - 1\n                    )\n                    i = from_str.find(f, i + 1)\n    \n    return any(recurse(from_str, applications))\n", "import re\n\ndef replacenth(string, elem, values, i):\n    where = [m.start() for m in re.finditer(elem, string)][i-1]\n    before = string[:where]\n    after = string[where:]\n    after = after.replace(elem, values, 1)\n    newString = before + after\n    return newString\n\ndef string_convertor(strings_options, tuples_options):\n    new_list = []\n    new_list.clear()\n    \n    for strings in strings_options:\n        for elem, values in tuples_options:\n            if elem in strings:\n                count_strings = strings.count(elem)\n                if count_strings == 1:\n                    strings_options = strings.replace(elem, values, 1)\n                    new_list.append(strings_options)\n                else:\n                    i = 0\n                    while i != count_strings:\n                        strings_options = replacenth(strings, elem, values, i)\n                        new_list.append(strings_options)\n                        i += 1    \n        \n    list_string_converted = new_list\n    return list_string_converted\n\n\ndef word_problem(rules: List[Tuple[str, str]], from_str: str, to_str: str, applications: int) -> bool:\n\n    if applications == 0:\n        if from_str == to_str:\n            return True\n        else:\n            return False\n\n    elif applications >= 1:\n        \n        list_string_converted = from_str.split()\n        nb_try = 0\n\n        while nb_try <= applications:\n            try:\n                list_string_converted = list(set(string_convertor(list_string_converted, rules)))\n                nb_try += 1\n                \n                if not list_string_converted:\n                    return False\n                \n                for elem in list_string_converted:    \n                    if elem == to_str :\n                        return True\n                    \n                    elif elem != to_str and nb_try == applications+1:\n                        return False\n                    else:\n                        pass\n            except:\n                pass\n", "import re\n\n# def replacenth(strings, elem, values, i):\n#     find = strings.find(elem)\n#     # If find is not -1 we have found at least one match for the substring\n#     j = find != -1\n#     # loop util we find the nth or we find no match\n#     while find != -1 and j != i:\n#         # find + 1 means we start searching from after the last match\n#         find = strings.find(elem, find + 1)\n#         j += 1\n#     # If i is equal to n we found nth match so replace\n#     if j == i:\n#         return strings[:find] + values + strings[find+len(elem):]\n#     return strings\n\ndef replacenth(string, elem, values, i):\n    where = [m.start() for m in re.finditer(elem, string)][i-1]\n    before = string[:where]\n    after = string[where:]\n    after = after.replace(elem, values, 1)\n    newString = before + after\n    return newString\n\ndef string_convertor(strings_options, tuples_options):\n    new_list = []\n    new_list.clear()\n    \n    for strings in strings_options:\n        # Try to find the second string in tuple and replace in strings_options\n        for elem, values in tuples_options:\n            if elem in strings:\n                count_strings = strings.count(elem)\n                if count_strings == 1:\n                    strings_options = strings.replace(elem, values, 1)\n                    new_list.append(strings_options)\n                else:\n                    i = 0\n                    while i != count_strings:\n                        strings_options = replacenth(strings, elem, values, i)\n                        new_list.append(strings_options)\n                        i += 1\n                    \n        \n    list_string_converted = new_list\n    return list_string_converted\n\n\ndef word_problem(rules: List[Tuple[str, str]], from_str: str, to_str: str, applications: int) -> bool:\n\n    print((\"From\", from_str, \"to\", to_str, \"with\", applications, \"applications\"))\n    print((\"Rules :\", rules))\n\n    if applications == 0:\n        if from_str == to_str:\n            return True\n        else:\n            return False\n\n    elif applications >= 1:\n        # Call string_convertor function the same number of times we've applications\n        # except if before reaching this number we run out of options\n        \n        list_string_converted = from_str.split()\n        print((list_string_converted, \" -----------\"))\n        nb_try = 0\n\n        while nb_try <= applications:\n            try:\n                print((\"-while nb :\", nb_try, \"list cvd :\", list_string_converted))\n                # call the function and use list(set()) to remove doubles in list:\n                list_string_converted = list(set(string_convertor(list_string_converted, rules)))\n                nb_try += 1\n                \n                if not list_string_converted:\n                    return False\n                \n                for elem in list_string_converted:    \n                    if elem == to_str :\n                        print((\"Find it!\", elem))\n                        return True\n                    \n                    elif elem != to_str and nb_try == applications+1:\n                        return False\n                    else:\n                        pass\n            except:\n                print(\"error\")\n\n", "from collections import deque\n\ndef replace(s, rule):\n    res = set()\n    i = s.find(rule[0], 0, len(s))\n    while i != -1:\n        res.add(s[:i] + rule[1] + s[i+len(rule[0]):])\n        i = s.find(rule[0], i + 1, len(s))\n    return res\n    \ndef word_problem(rules, frm, to, limit):\n    if limit == 0 or frm == to: return False or frm == to\n    steps = deque([[frm, limit]])\n    while len(steps):\n        st, lim = steps.popleft()\n        for rule in rules:\n            rep = replace(st, rule)\n            for s in rep:\n                if s == to: return True\n                if lim > 1: steps.append([s, lim - 1])\n    return False", "from collections import defaultdict\n\ndef word_problem(rules, from_str, to_str, applications):\n    d = defaultdict(list)\n    for x, y in rules:\n        d[y].append(x)\n    b, visited = False, set()\n    def dfs(s, p=0):\n        nonlocal b\n        if s == from_str:\n            b = p <= applications\n            return\n        if p >= len(to_str) or s in visited:\n            return\n        for i in range(0, len(s)):\n            for j in range(i+1, len(s)+1):\n                k = s[i:j]\n                if k in d:\n                    for v in d[k]:\n                        dfs(s[:i] + v + s[j:], p + 1)\n        visited.add(s)\n    dfs(to_str)\n    return b", "def word_problem(r,s1,s2,c):\n    if s1 == s2: return True\n    ix = {s1}\n    for _ in range(c):\n        xi = set()\n        for s in ix:\n            for x,y in r:\n                if x in s:\n                    i = s.find(x)\n                    while i != -1:\n                        ns = s[:i] + y + s[i+len(x):]\n                        if ns == s2: return True\n                        xi.add(ns)\n                        i = s.find(x,i+1)\n        ix = xi\n    return False"]