["def solve(n):\n    moves = []\n    for a, b in [\"25\", \"75\", \"50\", \"00\"]:\n        s = str(n)[::-1]\n        x = s.find(a)\n        y = s.find(b, x+1 if a == \"0\" else 0)\n        if x == -1 or y == -1:\n            continue\n        moves.append(x + y - (x > y) - (a == b))\n        s = s.replace(a, \"\", 1).replace(b, \"\", 1)\n        l = len(s.rstrip(\"0\"))\n        if l:\n            moves[-1] = moves[-1] + (len(s) - l)\n        elif s:\n            moves.pop()\n    return min(moves, default=-1)", "def moves(st, ending):\n    s = list(st)\n    \n    steps = 0\n    for i in range(-1, -len(ending) - 1, -1):\n        char = ending[i]\n        while s[i] != char:\n            # Find latest example of the missing char in the string prior to our position\n            actual = [j for j, c in enumerate(s[:i]) if c == char][-1]\n            # Transpose it with the character to its right\n            s[actual], s[actual + 1] = s[actual + 1], s[actual]\n            steps += 1\n\n    while s[0] == '0':\n        # Transpose first non-zero character with character to its left  \n        actual = [j for j, c in enumerate(s) if c != '0'][0]\n        s[actual - 1], s[actual] = s[actual], s[actual - 1]\n        steps += 1\n        \n    return steps\n\n\n\ndef solve(n):\n    print(f'n: {n}')\n    s = str(n)\n    _0, _2, _5, _7 = s.count('0'), s.count('2'), s.count('5'), s.count('7')\n    \n    best = not_possible = len(s) * 2 + 1\n    if _0 > 1:\n        # Enough 0s to end in ..00\n        best = min(best, moves(s, '00'))\n    if _2 and _5:\n        # 2 & 5 present so we can end in ..25\n        best = min(best, moves(s, '25'))\n    if _5 and _0:        \n        # 5 & 0 present so we can end in ..50\n        best = min(best, moves(s, '50'))\n    if _7 and _5:        \n        # 7 & 5 present so we can end in ..75\n        best = min(best, moves(s, '75'))\n\n    if best == not_possible:\n        best = -1\n    return best\n", "def solve(n):\n    def inversion(s, a, b):\n        x, y = s.rfind(a), s.rfind(b)\n        if a == b: x = s.rfind(a, 0, y)\n        # Suffix not found\n        if not x > -1 < y: return float('inf')\n        inv = len(s) - 2 - x + len(s) - 1 - y + (x > y)\n        # Leading zeros\n        if not x > 0 < y:\n            t = s[1 + ({x, y} == {0, 1}):]\n            if t: inv += len(s) - len(str(int(t))) - 1 - ({x, y} == {0, 1})\n        return inv\n\n    inv = min(inversion(str(n), a, b) for a, b in '00 25 50 75'.split())\n    return -1 if inv == float('inf') else inv\n", "from functools import partial\n\ndef check(s, tail):\n    i = s.find(tail[1])\n    if i == -1: return float('inf')\n    s = s[:i] + s[i+1:]\n    \n    j = s.find(tail[0])\n    if j == -1: return float('inf')\n    s = s[:j] + s[j+1:]\n    \n    if not s: return i+j\n    if s == '0'*len(s): return float('inf')\n    return i + j + next(i for i,c in enumerate(reversed(s)) if c != '0')\n\ndef solve(n):\n    result = min(map(partial(check, str(n)[::-1]), ('00', '25', '50', '75')))\n    return -1 if result == float('inf') else result", "from collections import Counter as C\ndef solve(n):\n    c, l, li = C(str(n)), len(str(n))-1, []\n    for i in '75 50 00 25'.split():\n        if not C(i) - c:\n            a, b, cn, t = i[0], i[1], 0, list(str(n))\n            bi = l - t[::-1].index(b)\n            t.insert(l, t.pop(bi))\n            ai = l - t[:-1][::-1].index(a) - 1\n            t.insert(l-1, t.pop(ai))\n            li.append((l-bi)+(l-ai-1)+[0,next(k for k,l in enumerate(t) if l!='0')][t[0]=='0'])\n    return min(li,default=-1)   #headache", "def solve(n):\n    sn = str(n)\n    ret = 0\n    if n % 25 == 0:\n        return ret\n    \n    if not (sn.count('0') >= 2 or ('5' in sn and ('0' in sn or '2' in sn or '7' in sn))):\n        return -1\n\n    zeroes = []\n    two = -1\n    five = -1\n    seven = -1\n    for c in range(len(sn)):\n        if sn[c] == '0':\n            zeroes.append(c)\n        elif sn[c] == '2':\n            two = c\n        elif sn[c] == '5':\n            five = c\n        elif sn[c] == '7':\n            seven = c\n            \n    minlen = 2 * len(sn)\n    if len(zeroes) > 1:\n        # '00' possible\n        # move last 0 to last place\n        steps = len(sn) - zeroes[-1] - 1\n        # move second to last 0 to last place but 1\n        steps += len(sn) - zeroes[-2] - 2\n        minlen = min(minlen, steps)\n    \n    if five != -1:\n        # 25\n        if two != -1:\n            steps = 2*len(sn) - five - two - 3\n            if five < two:\n                steps += 1\n            # check for leading zeroes\n            min25 = min(two,five)\n            max25 = max(two,five)\n            popsn = sn[:min25] + sn[min25+1:max25] + sn[max25+1:]\n            update = False\n            while len(popsn) > 0 and popsn[0] == '0':\n                steps += 1\n                update = True\n                popsn = popsn[1:]\n            minlen = min(minlen, steps)\n        # 50\n        if zeroes != []:\n            steps = 2*len(sn) - five - zeroes[-1] - 3\n            if zeroes[-1] < five:\n                steps += 1\n            # check for leading zeroes\n            min50 = min(zeroes[-1],five)\n            max50 = max(zeroes[-1],five)\n            popsn = sn[:min50] + sn[min50+1:max50] + sn[max50+1:]\n            update = False\n            while len(popsn) > 0 and popsn[0] == '0':\n                steps += 1\n                update = True\n                popsn = popsn[1:]\n            minlen = min(minlen, steps)\n        # 75\n        if seven != -1:\n            steps = 2*len(sn) - five - seven - 3\n            if five < seven:\n                steps += 1\n            # check for leading zeroes\n            min75 = min(five,seven)\n            max75 = max(five,seven)\n            popsn = sn[:min75] + sn[min75+1:max75] + sn[max75+1:]\n            update = False\n            while len(popsn) > 0 and popsn[0] == '0':\n                steps += 1\n                update = True\n                popsn = popsn[1:]\n            minlen = min(minlen, steps)\n    return minlen\n", "def spoc(sn, cyfry):\n    if sn.endswith(cyfry): return 0\n    cp, co = cyfry\n    res = 0\n    ico = sn.rfind(co)\n    res += len(sn) - ico - 1\n    sn = sn[:ico] + sn[ico+1:]\n    icp = sn.rfind(cp)\n    res += len(sn) - icp - 1\n    sn = sn[:icp] + sn[icp+1:]\n    lpz,i  = 0, 0\n    if len(sn) > 0 and len(sn) == sn.count('0'): return None\n    while sn and sn[i] == '0':\n        i += 1\n        lpz += 1\n    return res + lpz\n    \ndef solve(n):\n    print(n)\n    sn, t = str(n), []\n    if sn.count('0') > 1:\n        t.append(spoc(sn, '00'))\n    for p, d in ('25', '50', '75'):\n        if p in sn and d in sn:\n            x = spoc(sn, p + d)\n            if x is not None: t.append(x)\n    return min(t) if t else -1\n", "import re\ndef difference(n,s) :\n    n = str(n)[::-1]\n    try :\n        right_index = n.index(s[1])\n        left_index = n.index(s[0],[0,1 + right_index][s[0] == s[1]])\n    except : return float('inf')\n    upper_index = 1 + max(left_index,right_index) == len(n) and '0' == n[-2] and len(re.search('0*.$',n)[0])\n    return right_index + left_index - 1 + (left_index < right_index) + (upper_index and upper_index - 1 - (len(n) <= min(left_index,right_index) + upper_index))\ndef solve(n) :\n    removes = min([difference(n,'00'),difference(n,'25'),difference(n,'50'),difference(n,'75')])\n    return [-1,removes][int == type(removes)]\n", "def solve(n):\n    min_cost = -1\n    # Change the number to a string and reverse it.\n    # This makes it possible to use .index to find the lowest place a digit appears.\n    s = str(n)[::-1]\n    # Calculate cost of each possible ending digit pair and keep the lowest cost at each point.\n    for pair in ('00', '25', '50', '75'):\n        cost = calculate_ending_pair_cost(s, pair)\n        if min_cost == -1 or (cost != -1 and cost < min_cost):\n            min_cost = cost\n\n    return min_cost\n\ndef calculate_ending_pair_cost(s, pair):\n    # First find the lowest place indices of each desired digit.\n    indices = find_lowest_places(s, pair)\n    # If we can't find one of the digits, then this ending pair is not possible.\n    if indices is None:\n        return -1\n    # Start with an indicator of whether the desired digits are in the wrong order.\n    cost = 1 if indices[1] > indices[0] else 0\n    # Then swap the digits so the rest of our calculations are easier.\n    # It's important to have these index numbers in descending order.\n    if cost == 1:\n        indices = (indices[1], indices[0])\n    # Our number now looks something like this: aaa2bbbb5ccccc\n    # The cost should be the number of digits (b's) we have to displace to move the 2 next to the 5,\n    # and then twice the number of digits to displace to move the 2 and 5 to the \"front\".\n    # This is because each c must move past both the 5 and the 2.\n    cost += indices[0] - indices[1] - 1\n    cost += 2 * indices[1]\n    # We have one last special case to consider: What about leaving leading 0's in the high places?\n    # We only bother with this if the number is more than 2 digits.\n    if len(s) > 2:\n        non_zero_index = first_non_zero_digit_after_indices(s, indices)\n        if non_zero_index is None:\n            return -1\n        cost += len(s) - 1 - non_zero_index\n        # Make sure not to double-count any digits we already moved as part of the desired digits.\n        cost -= 1 if indices[0] > non_zero_index else 0\n        cost -= 1 if indices[1] > non_zero_index else 0\n    \n    return cost\n\ndef find_lowest_places(s, pair):\n    # Split the two-char string into the 1s place digit and 10s place digit.\n    d10, d1 = pair\n    try:\n        i1 = s.index(d1)\n    except:\n        # Index raises an exception if it can't find the digit,\n        # so just use that as an indicator of when to return a failure state.\n        return None\n    \n    # If the pair we're looking for is a repeated digit ('00'), then we need to start\n    # searching the string at the index just beyond that point.\n    start = 0\n    if d1 == d10:\n        start = i1 + 1\n    try:\n        i10 = s.index(d10, start)\n    except:\n        return None\n    \n    return (i10, i1)\n\ndef first_non_zero_digit_after_indices(s, indices):\n    # We need to reverse the string and indices because we're actually searching\n    # from the highest place in the number now.\n    s = s[::-1]\n    indices = [len(s) - 1 - indices[i] for i in range(len(indices))]\n    # Now search through linearly for the first non-zero digit which is not an index.\n    non_zero_index = None\n    for i in range(len(s)):\n        if i not in indices and s[i] != '0':\n            non_zero_index = i\n            break\n    # If we didn't find a non-zero index, that means we're dealing with something like\n    # trying to use '25' as the final digits of 250. In other words, impossible.\n    if non_zero_index is None:\n        return None\n    # Otherwise, translate the index back into place number.\n    return len(s) - 1 - non_zero_index", "import re\ndef solve(n):\n    print(n)\n    min_moves=[]\n    n=str(n)\n    l=len(n)-1\n    extra=0\n    \n    if '2' in n and '5' in n:\n        print('25')\n        temp=list(n)\n        if n.rindex('2') > n.rindex('5'):\n            extra=1\n        temp[n.rindex('2')]=''\n        temp[n.rindex('5')]=''\n        #temp=re.sub(' ','',temp)\n        temp=''.join(temp)\n        if temp and temp[0]=='0':\n                x = re.search(\"[1-9]\", temp)\n                if x:\n                    extra+=x.start()\n        min_moves.append(l-1-n.rindex('2')+l-n.rindex('5')+extra)\n        extra=0\n         \n    if '7' in n and '5' in n:\n        print('75')\n        temp=list(n)\n        if n.rindex('7') > n.rindex('5'):\n            extra=1\n        temp[n.rindex('7')]=''\n        temp[n.rindex('5')]=''\n        #temp=re.sub(' ','',temp)\n        temp=''.join(temp)\n        print('temp',temp)\n        if temp and temp[0]=='0':\n                x = re.search(\"[1-9]\", temp)\n                if x:\n                    extra+=x.start()\n                    print('extra',extra)\n        min_moves.append(l-1-n.rindex('7')+l-n.rindex('5')+extra)\n        extra=0\n    if '5' in n and '0' in n:\n        print('50')\n        if n.rindex('5') > n.rindex('0'):\n            extra=1\n        \n        min_moves.append(l-1-n.rindex('5')+l-n.rindex('0')+extra)\n        extra=0\n    if n.count('0')>1:\n        print('00')\n        min_moves.append(l-1-n.rindex('0')+l-n.rindex('0',0,n.rindex('0')))\n    print(min_moves)\n    if not min_moves:\n        return -1\n    return min(min_moves)"]