["BLACK = 0\nWHITE = 1\n# N, E, S, W\nCARDINALS = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n\ndef ant(grid, column, row, n, direction=0):\n    r, c, d = row, column, direction\n    for _ in range(n):\n        # Handle direction change and current cell colour flip\n        if grid[r][c] == BLACK:\n            grid[r][c] = WHITE\n            d = (d + 3) % 4\n        else:\n            grid[r][c] = BLACK\n            d = (d + 1) % 4\n        # Apply movement to next grid position\n        r, c = r + CARDINALS[d][0], c + CARDINALS[d][1]\n        # Resize grid as required\n        if r < 0:\n            grid.insert(0, [0] * len(grid[0]))\n            r += 1\n        elif r == len(grid):\n            grid.append([0] * len(grid[0]))\n        elif c < 0:\n            grid = [[0] + row for row in grid]\n            c += 1\n        elif c == len(grid[0]):\n            grid = [row + [0] for row in grid]\n    return grid", "def ant(grid, c, r, n, direction = 0):\n    \n    MOVES = [(-1,0), (0,1), (1,0), (0,-1)]             # directions the ant can move\n    \n    dims = {(min, 0): 0, (max, 0): len(grid)-1,        # min and max values of row index\n            (min, 1): 0, (max, 1): len(grid[0])-1}     # min and max values of column index\n            \n    gridWhite = { (x,y) for x in range(len(grid)) for y in range(len(grid[0])) if grid[x][y] }    # set of white squares only\n    \n    for _ in range(n):                                                  # Ant is at work...\n        direction = (direction + (-1)**((r,c) not in gridWhite)) % 4    # shift the ant\n        gridWhite ^= {(r,c)}                                            # shift the square\n        r += MOVES[direction][0]                                        # update position\n        c += MOVES[direction][1]\n        for func,dim in dims:\n            dims[(func,dim)] = func(dims[(func,dim)], (r,c)[dim])       # update min and max values of the indexes\n    \n    MinX, MinY = dims[(min,0)], dims[(min,1)]                  # minimum for rows (x) and columns(y)\n    lenX, lenY = dims[(max,0)]-MinX+1, dims[(max,1)]-MinY+1    # determine the final dimensions of the grid\n    \n    return [ [(1 if (x+MinX, y+MinY) in gridWhite else 0) for y in range(lenY)] for x in range(lenX) ]", "def ant(grid, col, row, n, dir = 0):\n    for _ in range(n):\n        # turn\n        color = grid[row][col]\n        if   color == 1: dir = (dir + 1) % 4\n        elif color == 0: dir = (dir - 1) % 4\n        \n        # flip color\n        grid[row][col] ^= 1\n        \n        # move forward\n        if   dir == 0: row -= 1\n        elif dir == 1: col += 1\n        elif dir == 2: row += 1\n        elif dir == 3: col -= 1\n        \n        # expand grid\n        if row < 0:\n            grid.insert(0, [0] * len(grid[0]))\n            row = 0\n        if row == len(grid):\n            grid.append([0] * len(grid[0]))\n        if col < 0:\n            for i in range(len(grid)):\n                grid[i].insert(0, 0)\n            col = 0\n        if col == len(grid[0]):\n            for i in range(len(grid)):\n                grid[i].append(0)\n    \n    return grid", "def ant(grid, column, row, n, dir = 0):\n    w, d = len(grid[0]), len(grid)\n    m = [[0 for i in range(w+2*n)] for j in range(d+2*n)]\n    for i in range(d):\n        m[i+n][n:n+w] = grid[i][:]\n    x, y = column + n, row + n\n    t = 0\n    xmax, xmin = x, x\n    ymax, ymin = y, y\n    for _ in range(n):\n        dir += (m[y][x]==1)*(1) +(m[y][x]==0)*(-1)\n        dir %= 4\n        m[y][x] = 1-m[y][x]\n        y += (dir==0)*(-1) + (dir==2)*1\n        x += (dir==3)*(-1) + (dir==1)*1\n        xmax,xmin = max(xmax,x), min(xmin,x)\n        ymax,ymin = max(ymax,y), min(ymin,y)\n    return [m[i][min(xmin,n):max(xmax,n+w-1)+1] for i in range(min(ymin,n), max(ymax, n+d-1)+1)]", "def ant(gr, cl, ro, n, di = 0):\n    class ant_class():\n        def __init__(self, col, row, direction):\n            self.c = col\n            self.r = row\n            self.direction = ['N', 'E', 'S', 'W']\n        def __repr__(self):\n            return ('col: {}, row: {}, direction: {}'.format(self.c, self.r, self.direction[0]))\n        def turn_right(self):\n            self.direction.append(self.direction.pop(0))\n        def turn_left(self):\n            self.direction.insert(0, self.direction.pop(-1))\n        def move(self, grid):\n            if self.direction[0] == 'N':\n                 if ant.r == 0:\n                    grid.expand_north()\n                 else:\n                    ant.r -= 1\n            elif self.direction[0] == 'S':\n                if ant.r == len(grid.grid) - 1:\n                    grid.expand_south()\n                ant.r += 1\n            elif self.direction[0] == 'W':\n                if ant.c == 0:\n                    grid.expand_west()\n                else:\n                    ant.c -= 1\n            elif self.direction[0] == 'E':\n                if ant.c == len(grid.grid[0]) - 1:\n                    grid.expand_east()\n                ant.c += 1\n    \n    class grid():\n        def __init__(self, arr):\n            self.grid = arr\n        def expand_south(self):\n            self.grid.append([0 for i in range(len(self.grid[0]))])\n        def expand_north(self):\n            self.grid.insert(0, [0 for i in range(len(self.grid[0]))])\n        def expand_east(self):\n            self.grid = [i + [0] for i in self.grid]\n        def expand_west(self):\n            self.grid = [[0] + i for i in self.grid]\n        def invert(self, ant):\n            self.grid[ant.r][ant.c] = int(not(self.grid[ant.r][ant.c]))\n        \n    ant = ant_class(cl, ro, di)\n    field = grid(gr)\n    for i in range(di):\n        ant.turn_right()\n    \n    for i in range(n):\n        if field.grid[ant.r][ant.c] == 1:\n            ant.turn_right()\n            field.invert(ant)\n            ant.move(field)\n        elif field.grid[ant.r][ant.c] == 0:\n            ant.turn_left()\n            field.invert(ant)\n            ant.move(field)\n    \n    return field.grid\n", "def ant(grid, x, y, n, d=0):\n    g, p = {(j, i):v for j, row in enumerate(grid) for i, v in enumerate(row)}, (x, y)\n    for m in range(n):\n        g[p] = (g[p] + 1) % 2\n        d += -1 if g[p] else 1        \n        p = p[0] + [0, 1, 0, -1][d % 4], p[1] + [-1, 0, 1, 0][d % 4]\n        g[p] = g.get(p, 0) \n        \n    return [[g.get((x, y), 0) for x in range(min(x for x, _ in g), max(x for x, _ in g)+1)] for y in range(min(y for _, y in g), max(y for _, y in g)+1)]", "def ant(grid, column, row, n, direction = 0):\n\n    def checc(m,k,grid):\n    \n        if m>len(grid)-1:\n            grid1 = [[0 for j in range(len(grid[0]))] for i in range(len(grid)+1)]\n            for i in range(len(grid)):\n                for j in range(len(grid[i])):\n                    grid1[i][j]=grid[i][j]\n            grid=grid1\n            \n        elif m<0:\n            grid1 = [[0 for j in range(len(grid[0]))] for i in range(len(grid)+1)]\n            for i in range(len(grid)):\n                for j in range(len(grid[i])):\n                    grid1[i+1][j]=grid[i][j]\n            m+=1 \n            grid=grid1\n        \n        elif k<0:\n            grid1 = [[0 for j in range(len(grid[0])+1)] for i in range(len(grid))]\n            for i in range(len(grid)):\n                for j in range(len(grid[i])):\n                    grid1[i][j+1]=grid[i][j]\n            k+=1\n            grid=grid1\n            \n        elif k>len(grid[0])-1:\n            grid1 = [[0 for j in range(len(grid[0])+1)] for i in range(len(grid))]\n            for i in range(len(grid)):\n                for j in range(len(grid[0])):\n                    grid1[i][j]=grid[i][j] \n            grid=grid1\n            \n        return [m,k,grid]\n\n    m,k=row,column\n    dire=direction\n    directions = {(1,0):[0,1], (1,1):[0,2], (1,2):[0,3], (1,3):[0,0],\n                  (0,0):[1,3], (0,1):[1,0], (0,2):[1,1], (0,3):[1,2]}\n    grids ={0:[-1,0],1:[0,1],2:[1,0],3:[0,-1]}\n    \n    for l in range(n):\n             \n        m,k,grid=checc(m,k,grid)\n        \n        col = grid[m][k] \n        grid[m][k], dire = directions[(col,dire)]\n        \n        m += (grids[dire])[0]\n        k += (grids[dire])[1]\n        \n        \n        m,k,grid=checc(m,k,grid)\n    \n    return grid\n", "def ant(g, c, r, n, d = 0):\n    grid = {(i, j):g[i][j] for j in range(len(g[0])) for i in range(len(g))}\n    D = {1: (0, 1), 2: (1, 0), 3: (0, -1), 0: (-1, 0)}\n    for i in range(n):\n        d = (d + (1 if grid[(r,c)] == 1 else -1))%4\n        grid[(r,c)] = 1 - grid[(r,c)]\n        R,C = D[d]\n        r,c = r + R, c + C\n        grid[(r, c)] = 0 if (r,c) not in grid else grid[(r,c)]\n    S = grid.keys()\n    m_y, m_x = [min(S,key=lambda x:x[i])[i] for i in [0,1]]\n    M_y, M_x = [max(S,key=lambda x:x[i])[i] for i in [0,1]]\n    return [[grid.get((m_y+j, m_x+i),0) for i in range(M_x-m_x+1)] for j in range(M_y-m_y+1)]", "def ant(grid, column, row, n, direction = 0):\n    for _ in range(n):\n        direction = (direction - 1 + 2*grid[row][column]) % 4\n        dx, dy = d[direction]\n        grid[row][column] = 1 - grid[row][column]\n        row += dy\n        column += dx\n        if column < 0:\n            for i, r in enumerate(grid):\n                grid[i] = [0] + r\n            column += 1\n        elif column >= len(grid[0]):\n            for r in grid: r.append(0)\n        if row < 0:\n            grid = [[0] * len(grid[0])] + grid\n            row += 1\n        elif row >= len(grid):\n            grid.append([0] * len(grid[0]))\n    return grid\n\nd = (0, -1), (1, 0), (0, 1), (-1, 0)", "def ant(grid, col, row, n, direction=0):\n    for count in range(n):\n        if grid[row][col] == 1:\n            direction = (direction + 1)%4\n        else:\n            direction = (direction - 1)%4\n        \n        grid[row][col] = int(not grid[row][col])\n        if direction == 0:\n            row -= 1 \n            if row < 0:\n                row = 0\n                grid.insert(0, [0 for i in range(len(grid[0]))])\n        elif direction == 1:\n            col += 1\n            if col >= len(grid[0]):\n                grid = [row + [0] for row in grid]\n        elif direction == 2:\n            row += 1\n            if row >= len(grid):\n                grid.append([0 for i in range(len(grid[0]))])\n        else:\n            col -= 1\n            if col < 0:\n                col = 0\n                grid = [[0] + row for row in grid]\n    return grid\n    \n"]