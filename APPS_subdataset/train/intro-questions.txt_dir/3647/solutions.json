["def solve(arr):\n    arr = sorted(arr, reverse=True)\n    res = []\n    while len(arr):\n        res.append(arr.pop(0))\n        if len(arr):\n            res.append(arr.pop())\n    return res", "def solve(arr):\n    lmax, lmin = iter(sorted(arr)) , iter(sorted(arr)[::-1])\n    return [next(lmax) if i%2==1 else next(lmin) for i in range(0,len(arr))]", "def solve(arr):\n    return [sorted(arr)[::-1][(-1)**i*i//2] for i in range(len(arr))]", "def solve(arr):\n    rarr = sorted(arr, reverse=True)\n    farr = rarr[::-1]\n    return [item for sublist in zip(rarr, farr) for item in sublist][:len(rarr)]", "def solve(arr):\n    arr.sort(reverse=True)\n    return [arr.pop(-(i % 2)) for i in range(len(arr))]", "def solve(arr):\n    l = sorted(arr)\n    result = []\n    while l:\n        result.append(l.pop())\n        l.reverse()\n    return result", "# I haven't tested them, but I think candle_index is the best of these\n\ndef zip_slices(arr):\n    arr = sorted(arr)[::-1]\n    res = []\n    n = len(arr)\n    m = n // 2\n    mins = arr[m:][::-1]\n    maxes = arr[:m]\n    for a, b in zip(maxes, mins):\n        res.extend([a, b])\n    if n % 2:\n        res.append(mins[-1])\n    return res\n\ndef candle_pop(arr):\n    candle = sorted(arr)\n    res = []\n    i = -1\n    while candle:\n        res.append(candle.pop(i))\n        i = 0 if i else -1\n    return res\n\ndef candle_index(arr):\n    candle = sorted(arr)\n    n = len(arr)\n    a = 0\n    z = n - 1\n    res = []\n    for i in range(n):\n        if i % 2:\n            res.append(candle[a])\n            a += 1\n        else:\n            res.append(candle[z])\n            z -= 1\n    return res\n\ndef set_pop(arr):\n    nums = set(arr)\n    res = []\n    i = 0\n    while nums:\n        if i % 2:\n            n = min(nums)\n        else:\n            n = max(nums)\n        res.append(n)\n        nums.remove(n)\n        i += 1\n    return res\n\nfrom random import randint\n\nsolve = lambda arr: (zip_slices, candle_pop, candle_index, set_pop)[randint(0,3)](arr)", "def solve(arr):\n    arr=sorted(arr)\n    arr.append(0)\n    arr=sorted(arr)\n    list1 = []\n    for i in range(1,len(arr)//2+2):\n        list1.append(arr[-i])\n        list1.append(arr[i])\n    list1=list(dict.fromkeys(list1))\n    return list1\n", "def solve(arr):\n    \n    # sort and reverse the list, make a new list to store answer\n    arr = sorted(arr, reverse=True)\n    new_list = []\n    \n    boolean = True\n    # while there are still items in arr[]\n    while (len(arr) >= 1):\n        \n        # append the 0th item to new_list[]\n        new_list.append(arr[0])\n        \n        # flip our boolean value from true to false to reverse the list later\n        if (boolean == True) :  \n            boolean = False      \n        else:\n            boolean = True\n        \n        # remove the 0th element from arr[]\n        arr.pop(0)\n        \n        # sort the list either forwards or in reverse based on boolean\n        arr = sorted(arr, reverse=boolean)\n        \n    return new_list", "def solve(arr):\n    print(arr)\n    max_l=sorted(arr,reverse=True)\n    min_l=sorted(arr)\n    l=[]\n    for i,a in enumerate(zip(max_l,min_l)):\n        if a[0]!=a[1]:\n            l.append(a[0])\n            l.append(a[1])\n        else:\n            l.append(a[0])\n            break\n    return list(dict.fromkeys(l))"]