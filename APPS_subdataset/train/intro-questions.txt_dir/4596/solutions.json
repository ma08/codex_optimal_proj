["from operator import mul\nfrom math import factorial\nfrom functools import reduce\nfrom collections import Counter\n\ndef perms(inp):\n    return factorial(len(str(inp))) // reduce(mul, map(factorial, Counter(str(inp)).values()), 1)", "from math import factorial\ndef perms(e):\n    e = str(e)\n    n = factorial(len(e))\n    for i in (e.count(i) for i in set(e) if e.count(i)>1):\n        if i:\n            n = n / factorial(i)\n    return n", "from collections import Counter\nimport math\n\ndef perms(element):\n    stringElement = str(element)\n    tally = Counter(stringElement)\n    topPart = math.factorial(len(stringElement))\n    product = 1\n    for t in tally:\n        product = product * math.factorial(tally[t])\n    return topPart / product", "from collections import Counter\nfrom math import factorial as fact\nfrom functools import reduce\nfrom operator import mul\n\ndef perms(element):\n    s = str(element)\n    c = Counter(s)\n    return fact(len(s)) / reduce(mul, [fact(n) for n in c.values()], 1)", "import math\nimport functools\nimport operator\n\ndef perms(element):\n    element = str(element)\n    permutation_count = math.factorial(len(element))\n    eq_bottom = [math.factorial(element.count(char)) for char in set(element)]       \n    combination_count = functools.reduce(operator.mul, eq_bottom, 1)\n    return permutation_count / combination_count", "from itertools import permutations\nfrom collections import Counter\nfrom math import factorial\nfrom functools import reduce\n\ndef perms(e):\n    if isinstance(e, int):\n        return perms(str(e))\n        \n    c = Counter(e)\n        \n    return factorial(len(e)) / reduce(lambda x,y:x*y, [factorial(x) for x in list(c.values())])\n"]