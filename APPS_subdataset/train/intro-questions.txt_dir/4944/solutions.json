["import math\n\n\nclass VectorInputCoordsValidationError(Exception):\n    \"\"\"Custom exception class for invalid input args given to the Vector instantiation\"\"\"\n\n\nclass Vector:\n    # https://www.mathsisfun.com/algebra/vectors.html\n\n    def __init__(self, *args):\n        try:\n            self.x, self.y, self.z = args if len(args) == 3 else args[0]\n        except ValueError:\n            raise VectorInputCoordsValidationError('Either give single iterable of 3 coords or pass them as *args')\n\n    def __add__(self, other) -> \"Vector\":\n        return Vector(\n            self.x + other.x,\n            self.y + other.y,\n            self.z + other.z\n        )\n\n    def __sub__(self, other) -> \"Vector\":\n\n        return Vector(\n            self.x - other.x,\n            self.y - other.y,\n            self.z - other.z\n        )\n\n    def __eq__(self, other) -> bool:\n        # https://www.grc.nasa.gov/www/k-12/airplane/vectcomp.html\n        # https://onlinemschool.com/math/library/vector/equality/\n        return all((\n            self.x == other.x,\n            self.y == other.y,\n            self.z == other.z\n        ))\n\n    def cross(self, other) -> \"Vector\":\n        # https://www.mathsisfun.com/algebra/vectors-cross-product.html\n        return Vector(\n            self.y*other.z - self.z*other.y,\n            self.z*other.x - self.x*other.z,\n            self.x*other.y - self.y*other.x\n        )\n\n    def dot(self, other) -> int:\n        # https://www.mathsisfun.com/algebra/vectors-dot-product.html\n        return self.x*other.x + self.y*other.y + self.z*other.z\n\n    def to_tuple(self) -> tuple:\n        return self.x, self.y, self.z\n\n    def __str__(self) -> str:\n        return \"<{x}, {y}, {z}>\".format(**self.__dict__)\n\n    @property\n    def magnitude(self) -> float:\n        return math.sqrt(\n            sum (\n                    (\n                        self.x ** 2,\n                        self.y ** 2,\n                        self.z ** 2\n                    )\n            )\n        )\n", "from operator import itemgetter, add, sub, mul\nfrom itertools import starmap\n\n\nclass Vector(list):\n    \n    def __init__(self, *args):\n        if len(args)==1: args = args[0]\n        super().__init__(args)\n    \n    __add__, __sub__, __mul__ = (\n        ( lambda self,o,f=fun: Vector(starmap(f, zip(self,o))) ) for fun in (add, sub, mul)\n    )\n    \n    x,y,z = (property(itemgetter(i)) for i in range(3))\n    \n    @property\n    def magnitude(self): return self.dot(self)**.5\n    \n    def __str__(self):   return f'<{ \", \".join(map(str,self)) }>'\n    def to_tuple(self):  return tuple(self)\n    def dot(self,o):     return sum(self*o)\n    def cross(self,o):   return Vector( self.y*o.z - self.z*o.y,\n                                        self.z*o.x - self.x*o.z,\n                                        self.x*o.y - self.y*o.x)", "import numpy as np\nclass Vector:\n    def __init__(self, *args):\n        args = args[0] if len(args) == 1 else args\n        self.x, self.y, self.z = args[0], args[1], args[2]\n        self.li = [self.x,self.y,self.z]\n        self.magnitude = np.linalg.norm(self.li)\n    def __add__(self, other)   :   return Vector([i+j for i,j in zip(self.li,other.li)])\n    def __sub__(self, other)   :   return Vector([i-j for i,j in zip(self.li,other.li)])\n    def __eq__(self, other)    :   return all([i==j for i,j in zip(self.li,other.li)])\n    def __str__(self)          :   return f'<{self.x}, {self.y}, {self.z}>'\n    def cross(self, other)     :   return Vector(np.cross(self.li, other.li))\n    def dot(self, other)       :   return np.dot(self.li,other.li)\n    def to_tuple(self)         :   return tuple(self.li)", "class Vector:\n    def __init__(self, a, b = None, c = None):\n        if c is None:\n            a, b, c = a\n        self.x = a\n        self.y = b\n        self.z = c\n        self.magnitude = ((self.x) ** 2 + (self.y) ** 2 + (self.z) ** 2) ** .5\n    def to_tuple(self):\n        return (self.x, self.y, self.z)\n    def __eq__(self, other):\n        return self.to_tuple() == other.to_tuple()\n    def cross(self, other):\n        a = self.y * other.z - self.z * other.y\n        b = self.z * other.x - self.x * other.z\n        c = self.x * other.y - self.y * other.x\n        return Vector(a, b, c)\n    def dot(self, other):\n        return self.x * other.x + self.y * other.y + self.z * other.z\n    def __str__(self):\n        return \"<{}, {}, {}>\".format(*self.to_tuple())\n    def __add__(self, other):\n        return Vector(self.x + other.x, self.y + other.y, self.z + other.z)\n    def __sub__(self, other):\n        return Vector(self.x - other.x, self.y - other.y, self.z - other.z)", "from  math import sqrt\n\n\n\n#Code recycled from my Kata solution\nclass Vector(object):\n\n    __3DVECSIZE__= 3\n\n    def __init__(self, *args, **kwargs):\n        numArgs = len(args)\n        \n        if numArgs == 1:                            #Scenario: vecList is provided\n            vecList = args[0]\n        else:                                       #Scenario: a, b, c provided\n            vecList = [args[0], args[1], args[2]]\n\n        self.myVecSize = len(vecList)\n        self.__checkForSizeException__(vecList)\n        self.myComponents = vecList\n        self.x = self.myComponents[0]\n        self.y = self.myComponents[1]\n        self.z = self.myComponents[2]\n        self.magnitude = self.norm()\n    #-----end constructor\n\n    \n    def __add__(self, v):\n        return self.add(v)\n\n    \n    def __sub__(self, v):\n        return self.subtract(v)\n\n    \n    def __eq__(self, v):\n        return self.equals(v)\n\n    \n    def __str__(self):\n        return self.toString('<','>')\n\n    \n    def __checkForSizeException__(self, v):\n        lenPassedVec = len(v)\n        if self.myVecSize != self.__3DVECSIZE__:\n            raise ValueError('Missmatch of vector size: Size ', str(lenPassedVec), 'applied to vector of size ', str(self.myVecSize))  \n        else:\n            return lenPassedVec\n    #-----end function\n\n\n    def add(self, v):\n        self.__checkForSizeException__(v.myComponents)\n        return Vector([sum(x) for x in  zip(self.myComponents, v.myComponents)])\n    #-----end function\n\n\n    def subtract(self, v):\n        negV = Vector([-comp for comp in v.myComponents])\n        return self.add(negV)\n    #-----end function\n\n    \n    #order of cross product is self cross v\n    def cross(self, v):\n        self.__checkForSizeException__(v.myComponents)\n        xCrossComp = self.y*v.z - self.z*v.y\n        yCrossComp = self.z*v.x - self.x*v.z\n        zCrossComp = self.x*v.y - self.y*v.x\n        return Vector([xCrossComp, yCrossComp, zCrossComp])\n    #---end function\n\n    \n    def dot(self, v):\n        self.__checkForSizeException__(v.myComponents)\n        return (sum([ a*b for a,b in zip(self.myComponents, v.myComponents)]))\n    #-----end function\n\n\n    def norm(self):\n        return sqrt( self.dot(self) )\n    #-----end function\n\n\n    def toString(self, groupSymbolLeft, groupSymbolRight):\n        strVec = groupSymbolLeft\n        for  i  in range(self.myVecSize-1):\n            strVec += str(self.myComponents[i]) + ', '\n        \n        strVec += str(self.myComponents[-1]) + groupSymbolRight\n\n        return strVec\n    #-----end function\n\n    \n    def to_tuple(self):\n        return tuple(self.myComponents)\n\n    \n    def equals(self, v):\n        try:\n            lenV = self.__checkForSizeException__(v.myComponents)\n        except:\n            return False \n        else:\n            for i in range(lenV):\n                if self.myComponents[i] != v.myComponents[i]:\n                    return False\n            return True\n    #-----end function\n\n#---end vector class\n", "from math import sqrt\n\nclass Vector:\n    def __init__(self, *vector):\n        self.vector = vector\n        if len(vector) == 1:\n           self.vector = tuple(vector[0])\n        self.x, self.y, self.z = self.vector\n        self.magnitude = sqrt(sum(v*v for v in self.vector))\n\n    def to_tuple(self):\n        return tuple(self.vector)\n\n    def __str__(self):\n        return f'<{self.x}, {self.y}, {self.z}>'\n\n    def __add__(self, other):\n        x, y, z = (a + other.vector[i] for i,a in enumerate(self.vector))\n        return Vector(x, y, z)\n\n    def __sub__(self, other):\n        x, y, z = (a - other.vector[i] for i,a in enumerate(self.vector))\n        return Vector(x, y, z)\n    \n    def __eq__(self, other):\n        return all(v == other.vector[i] for i, v in enumerate(self.vector))\n\n    def dot(self, other):\n        return sum(v * other.vector[i] for i, v in enumerate(self.vector))\n\n    def cross(self, other):\n        x = self.y * other.z - self.z * other.y\n        y = -(self.x * other.z - self.z * other.x)\n        z = self.x * other.y - self.y * other.x\n        return Vector(x, y, z)", "import math\nimport operator\n\n\nclass Vector:\n    def __init__(self, *args):\n        self.x, self.y, self.z = self.args = tuple(args[0] if len(args) == 1 else args)\n        self.magnitude = math.sqrt(sum(i ** 2 for i in self.args))\n\n    def __str__(self):\n        return '<{}>'.format(', '.join(map(str, self.args)))\n\n    def __eq__(self, other):\n        return self.args == other.args\n\n    def __add__(self, other):\n        return Vector(*map(operator.add, self.args, other.args))\n\n    def __sub__(self, other):\n        return Vector(*map(operator.sub, self.args, other.args))\n\n    def dot(self, other):\n        return sum(map(operator.mul, self.args, other.args))\n\n    def to_tuple(self):\n        return self.args\n\n    def cross(self, other):\n        return Vector(\n            self.y * other.z - self.z * other.y,\n            self.z * other.x - self.x * other.z,\n            self.x * other.y - self.y * other.x,\n        )", "import numpy as np\n\nclass Vector:\n    def __init__(self, *args):\n        self.vec = np.array(args if type(args[0]) == int else args[0])\n        self.x, self.y, self.z, self.magnitude = *self.vec, np.linalg.norm(self.vec)\n    def __str__(self):\n        return f'<{self.x}, {self.y}, {self.z}>'\n    def __eq__(self, other):\n        if type(other) != Vector: return False\n        return np.array_equal(self.vec, other.vec)\n    def __add__(self, other):\n        return Vector(self.vec + other.vec)\n    def __sub__(self, other):\n        return Vector(self.vec - other.vec)\n    def cross(self, other):\n        return Vector(np.cross(self.vec, other.vec))\n    def dot(self, other):\n        return np.dot(self.vec, other.vec)\n    def to_tuple(self):\n        return tuple(self.vec)", "class Vector:\n    def __init__(s,*A):\n        s.x,s.y,s.z=len(A)!=1 and A or A[0]\n        s.magnitude=(s.x**2+s.y**2+s.z**2)**.5\n    __str__=lambda s:\"<%d, %d, %d>\"%(s.x,s.y,s.z)\n    __eq__=lambda s,o:(s.x,s.y,s.z)==(o.x,o.y,o.z)\n    __add__=lambda s,o:Vector([s.x+o.x,s.y+o.y,s.z+o.z])\n    __sub__=lambda s,o:Vector([s.x-o.x,s.y-o.y,s.z-o.z])\n    to_tuple=lambda s:(s.x,s.y,s.z)\n    dot=lambda s,o:s.x*o.x+s.y*o.y+s.z*o.z\n    cross=lambda s,o:Vector(s.y*o.z-s.z*o.y,s.z*o.x-s.x*o.z,s.x*o.y-s.y*o.x)", "from math import sqrt\n\n\nclass Vector:\n    \n    def __init__(self, *args):\n        if isinstance(args[0], (list, tuple)):\n            self.x, self.y, self.z = args[0]\n        else:\n            self.x, self.y, self.z = args\n        \n    def __add__(self, other):\n        return Vector(\n            self.x + other.x,\n            self.y + other.y,\n            self.z + other.z\n        )\n        \n    def __sub__(self, other):\n        return Vector(\n            self.x - other.x,\n            self.y - other.y,\n            self.z - other.z\n        )\n        \n    def __eq__(self, other):\n        if isinstance(other, (list, tuple)):\n            other = Vector(other)\n        return (\n            self.magnitude == other.magnitude and \n            self.x / other.x == self.y / other.y == self.z / other.z\n        )\n    \n    def __str__(self):\n        return \"<%d, %d, %d>\" % (self.x, self.y, self.z)\n    \n    def to_tuple(self):\n        return (self.x, self.y, self.z)\n\n    def cross(self, other):\n        return Vector(\n            self.y * other.z - other.y * self.z,\n            -(self.x * other.z - other.x * self.z),\n            self.x * other.y - other.x * self.y\n        )\n\n    def dot(self, other):\n        return self.x * other.x + self.y * other.y + self.z * other.z\n\n    @property\n    def magnitude(self):\n        return sqrt(self.x ** 2 + self.y ** 2 + self.z ** 2)\n"]