["import re\ndef reversi_row(moves):\n    row = '........'\n    stones = '*O'\n    for i, m in enumerate(moves):\n        L, M, R = row[:m], stones[i%2], row[m+1:]\n        if R!='' and R[0] == stones[(i+1)%2] and R.find(stones[i%2])>0 and '.' not in R[:R.find(stones[i%2])]:\n            R = R.replace(stones[(i+1)%2], stones[i%2], R.find(stones[i%2]))\n        if L!='' and  L[-1] == stones[(i+1)%2] and L[::-1].find(stones[i%2])>0 and '.' not in L[-1-L[::-1].find(stones[i%2]):]:\n            L = L[::-1].replace(stones[(i+1)%2], stones[i%2], L[::-1].find(stones[i%2]))[::-1]\n\n        row = L + M + R\n    return row", "from re import sub\n\ndef reversi_row(moves):\n    current = '.'*8\n    for i,x in enumerate(moves):\n        c1, c2 = \"Ox\" if i&1 else \"xO\"\n        left = sub(r\"(?<={}){}+$\".format(c1, c2), lambda r: c1*len(r.group()), current[:x])\n        right = sub(r\"^{}+(?={})\".format(c2, c1), lambda r: c1*len(r.group()), current[x+1:])\n        current = left + c1 + right\n    return current.replace('x', '*')", "def reversi_row(moves):\n    row = ['.'] * 8\n    for turn, move in enumerate(moves):\n        tile = '*O'[turn % 2]\n        row[move] = tile\n        for direction in (-1, 1):\n            other = move + direction\n            while 0 <= other < 8 and row[other] != '.':\n                if row[other] == tile:\n                    break\n                other += direction\n            else:\n                other = move\n            row[move: other: direction] = [tile] * abs(move - other)\n    return ''.join(row)", "def reversi_row(moves):\n  stones = [set(), set()]\n  \n  for i, p in enumerate(moves):\n    curr, oppn = stones[i%2], stones[(i+1)%2]\n    curr.add(p)\n    \n    l, r = p-1, p+1\n    while l in oppn: l-=1\n    while r in oppn: r+=1\n    flip = set(range(l+1 if l in curr else p+1, r if r in curr else p))\n    \n    oppn -= flip\n    curr |= flip\n  \n  return ''.join('*' if i in stones[0] else 'O' if i in stones[1] else '.' for i in range(8))", "from itertools import cycle\n\n\ndef reversi_row(moves):\n    row = ['.'] * 8\n    player = cycle('*O')\n    for move in moves:\n        current_player = next(player)\n        invalid = {'.', current_player}\n        row[move] = current_player\n        row_str = ''.join(row)\n        # look left\n        first_left = row_str.rfind(current_player, 0, move)\n        if first_left != -1:\n            # flip to the left\n            left_chunk = row_str[first_left + 1:move]\n            if not invalid.intersection(left_chunk):\n                row[first_left + 1:move] = [current_player] * len(left_chunk)\n        # look right\n        first_right = row_str.find(current_player, move + 1)\n        if first_right != -1:\n            # flip to the right\n            right_chunk = row_str[move + 1:first_right]\n            if not invalid.intersection(right_chunk):\n                row[move + 1:first_right] = [current_player] * len(right_chunk)\n    return ''.join(row)", "from functools import reduce\n\ndef reversi_row(moves):\n  return ''.join(reduce(lambda board, x: play(board, x[1], 'O' if x[0]%2 else '*'), enumerate(moves), ['.'] * 8))\n\ndef play(board, position, pawn):\n  board[position] = pawn\n  opp = 'O' if pawn == '*' else '*'\n  after = next((x for x in [opp*i+pawn for i in range(6)] if ''.join(board[position+1:]).startswith(x)), None)\n  if after:\n    board[position+1:position+len(after)] = [pawn]*(len(after)-1)\n  before = next((x for x in [pawn+opp*i for i in range(6)] if ''.join(board[:position]).endswith(x)), None)\n  if before:\n    board[position-len(before):position] = [pawn]*len(before)\n  return board", "from re import sub\n\ndef reversi_row(moves):\n    base=\"........\"\n    point=\"*\"\n    for move in moves:\n        base=list(base)\n        base[move]=\"#\"\n        base=\"\".join(base)\n        base=sub(\"#O+\\*\",  lambda m: \"*\"*len(m.group(0)), sub(\"\\*O+#\", lambda m: \"*\"*(len(m.group(0))-1)+\"#\",base)) if point==\"*\" else sub(\"#\\*+O\", lambda m: \"O\"*len(m.group(0)),sub(\"O\\*+#\", lambda m: \"O\"*(len(m.group(0))-1)+\"#\",base))\n        base=base.replace(\"#\",point)\n        point='O' if point==\"*\" else '*'\n    return base", "def reversi_row(a):\n    r = [\".\"] * 8\n    for p, i in enumerate(a):\n        cur, opp = \"*O\"[p%2], \"*O\"[1-p%2]\n        r[i] = cur\n        for range_ in (range(i - 1, -1, -1), range(i + 1, 8)):\n            for j in range_:\n                if r[j] == \".\":\n                    break\n                if r[j] == cur:\n                    if abs(i - j) > 1:\n                        r[min(i, j):max(i, j)] = cur * abs(i - j)\n                    break\n    return \"\".join(r)", "import re\ndef reversi_row(moves):\n    res=\".\"*8\n    star=False\n    for move in moves:\n        star=not star\n        assert res[move]==\".\"\n        res=res[:move]+\"@\"+res[move+1:]\n        if star:\n            res=re.sub(r\"(@)(O+)(\\*)\", lambda g:g[1]+\"*\"*len(g[2])+g[3],res)\n            res=re.sub(r\"(\\*)(O+)(@)\", lambda g:g[1]+\"*\"*len(g[2])+g[3],res)\n            res=res.replace(\"@\",\"*\")\n        else:            \n            res=re.sub(r\"(@)(\\*+)(O)\", lambda g:g[1]+\"O\"*len(g[2])+g[3],res)\n            res=re.sub(r\"(O)(\\*+)(@)\", lambda g:g[1]+\"O\"*len(g[2])+g[3],res)\n            res=res.replace(\"@\",\"O\")\n    return res"]