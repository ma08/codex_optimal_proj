["from itertools import groupby\nfrom operator import itemgetter\nfrom os.path import commonprefix\n\nfirst = itemgetter(0)\n\ndef radix_tree(*words):\n    words = [w for w in words if w]\n    result = {}\n    for key, grp in groupby(sorted(words), key=first):\n        lst = list(grp)\n        prefix = commonprefix(lst)\n        result[prefix] = radix_tree(*(w[len(prefix):] for w in lst))\n    return result", "def radix_tree(*words):\n    byFirstChar={}\n    for w in words:\n        if w != \"\":\n            l=byFirstChar.get(w[0],[])\n            l.append(w[1:])\n            byFirstChar[w[0]]=l\n    result={}\n    for c,l in byFirstChar.items():\n        rt=radix_tree(*l)\n        if len(rt) == 1 and not '' in l:\n            for key,value in rt.items():\n                c=c+key\n                rt=value\n        result[c]=rt\n    return result", "from itertools import groupby\ndef radix_tree(*d, need=1):\n    if not {i for i in d if i} : return {} \n    store = {}\n    for i, j in groupby(sorted(d) if need else d, lambda x: x[0]):\n        words = list(j)\n        if len(words) == 1 : store[words[0]] = {}\n        else:\n            common = next((j for j, i in enumerate(zip(*words)) if len(set(i)) != 1), len(min(words, key=len)))\n            store[words[0][:common]] = radix_tree(*[i[common:] for i in words if i[common:]],need = 0)\n    return store", "from os.path import commonprefix\n\ndef radix_tree(*words):\n    groups = {}\n    for word in words:\n        if word:\n            groups[word[0]] = groups.get(word[0], []) + [word]\n    root = {}\n    for group in groups.values():\n        prefix = commonprefix(group)\n        root[prefix] = radix_tree(*(w[len(prefix):] for w in group))\n    return root", "def radix_tree(*W):\n    D={}\n    for w in W:\n        if w:D[w[0]]=D.get(w[0],[])+[w[1:]]\n    Z={}\n    for k in D:\n        T=radix_tree(*D[k])\n        if len(T)==1and''not in D[k]:\n            for j in T:k,T=k+j,T[j]\n        Z[k]=T\n    return Z", "def radix_tree(*a):\n    r = {}\n    for s in a:\n        d = r\n        for x in s + \"*\":\n            if x not in d: d[x] = {}\n            d = d[x]\n    def g(d):\n        dd = {}\n        for x in d:\n            d[x] = g(d[x])\n            if len(d[x]) == 1:\n                k, v = [*d[x].items()][0]\n                dd[x+k] = v\n            else:\n                dd[x] = d[x]\n        return dd\n    def h(d):\n        dd = {}\n        for x in d:\n            d[x] = h(d[x])\n            if x != \"*\":\n                dd[x if x[-1] != \"*\" else x[:-1]] = d[x]\n        return dd\n    return h(g(r))", "def radix_tree(*Q) :\n    U,R = set(Q),{}\n    for Q in Q :\n        T = R\n        for Q in Q :\n            if not Q in T : T[Q] = {}\n            T = T[Q]\n    def H(Q,S) :\n        T = list(Q)\n        for V in T :\n            if 1 == len(Q[V]) and (S + V) not in U :\n                B = next(iter(Q[V]))\n                Q[V + B] = Q[V][B]\n                del Q[V]\n                T.append(V + B)\n            else : H(Q[V],S + V)\n    H(R,'')\n    return R", "from itertools import groupby\n\ndef radix_tree(*words):\n    d = {}\n    if not any(words): return d\n    words = sorted(words)\n    for g in (list(g) for _,g in groupby(words, key=lambda w:w[0] if w else '')):\n        i = next((i for i in range(len(g[0])) if not all(len(w) > i and w[i] == g[0][i] for w in g)), len(g[0]))\n        d[g[0][:i]] = radix_tree(*(w[i:] for w in g if len(w) > i))\n    return d\n        \n        \n", "from itertools import groupby\ndef radix_tree(*d):\n    if not {i for i in d if i} : return {} \n    store = {}\n    for i, j in groupby(sorted(d), lambda x: x[0]):\n        words = list(j)\n        if len(words) == 1 : store[words[0]] = {}\n        else:\n            common = next((j for j, i in enumerate(zip(*words)) if len(set(i)) != 1), len(min(words, key=len)))\n            store[words[0][:common]] = radix_tree(*[i[common:] for i in words if i[common:]])\n    return store", "from functools import reduce\n\ndef splitAlong(xs, ys):\n    i = 0\n    try:\n        while xs[i] == ys[i]:\n            i += 1\n    except IndexError:\n        pass\n    return (xs[:i], xs[i:], ys[i:])\n\ndef insert(tree, word):\n    for key, val in tree.items():\n        pref, wt, kt = splitAlong(word, key)\n        if pref:\n            if kt:\n                del tree[key]\n                tree[pref] = {wt: {}, kt: val} if wt else {kt: val}\n            else:\n                insert(tree[pref], wt)\n            return tree\n    if word:\n        tree[word] = {}\n    return tree\n\n\ndef radix_tree(*words):\n    return reduce(insert, words, {})"]