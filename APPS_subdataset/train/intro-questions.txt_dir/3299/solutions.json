["def calc(a):\n    res = [0] * (len(a) + 1)\n    for k in range(len(a)):\n        res = [2 * max(a[i] + res[i+1], a[i+k] + res[i]) for i in range(len(a) - k)]\n    return res[0]", "from functools import lru_cache\n\ncalc = lambda cards : get(tuple(cards))\nget = lru_cache(None) ( lambda seq, turn=1:max([2**turn*seq[0]+get(seq[1:], turn+1), 2**turn*seq[-1]+get(seq[:-1], turn+1)]) \n                                           if seq else 0 )", "from collections import deque, defaultdict\n\ndef calc(cards):\n    memo = defaultdict(int)\n    ans = 0\n    q = deque([(1, 0, tuple(cards))])\n    while q:\n        i, score, remains = q.popleft()\n        if len(remains) == 1:\n            score += remains[0] * 2 ** i\n            if score > ans:\n                ans = score\n        else:\n            score_l = score + (remains[0] * 2 ** i)\n            if score_l > memo[remains[1:]]:\n                memo[remains[1:]] = score_l\n                q.append((i + 1, score_l, remains[1:]))\n            score_r = score + (remains[-1] * 2 ** i)\n            if score_r > memo[remains[:-1]]:\n                memo[remains[:-1]] = score_r\n                q.append((i + 1, score_r, remains[:-1]))\n    return ans", "VISITED = dict()\n\n\ndef calc(cards, idx = 0):\n    if idx == 0:\n        VISITED.clear()\n    \n    if len(cards) == 0:\n        return 0\n    \n    tpl = tuple(cards)\n    m_value = VISITED.get(tpl, None)\n    if m_value:\n        return m_value\n    \n    res = max(cards[0]*(2<<idx) + calc(cards[1:], idx+1), cards[-1]*(2<<idx) + calc(cards[:-1], idx+1))\n    VISITED[tpl] = res\n    return res\n", "from sys import intern\n\n\ndef calc(cards, i=1, memo={}):\n    if len(cards) == 1:\n        memo[intern(str((i, cards)))] = cards[0] * 2**i\n        return cards[0] * 2**i\n    \n    if str((i, cards)) in memo:\n        return memo[intern(str((i, cards)))]\n    \n    result = max(cards[0] * 2**i + calc(cards[1:], i+1, memo),\n                 cards[-1] * 2**i + calc(cards[:-1], i+1, memo))\n    memo[intern(str((i, cards)))] = result\n    \n    return result", "def calc(cards):\n    f = 1<<len(cards)\n    dp = [f*v for v in cards]\n    for d in range(1,len(cards)):\n        f>>=1\n        dp = [ max( dp[i]+f*cards[i+d], dp[i+1]+f*cards[i] )\n               for i in range(len(dp)-1)]\n    return dp.pop()", "from functools import lru_cache as memo\n\ndef calc(cards):\n    \n    @memo(None)\n    def get_value(i, j, n):\n        if i == j:\n            return cards[i]*2**n\n        return max(cards[i]*2**n + get_value(i + 1, j, n + 1),\n                    cards[j]*2**n + get_value(i, j - 1, n + 1)) \n\n    return get_value(0, len(cards) - 1, 1)", "\ndef calc(cards):\n    \n    queue = [(0, (0,len(cards)-1))]\n    counter = 1\n    multiplier = 1\n    global_max = 0\n    while True:\n        \n        hold = {}\n        \n        for _ in range(counter):\n            \n            bonus, indices = queue.pop(0)\n            if indices[0] > indices[1]: \n                return global_max\n            \n            take_right = (indices[0], indices[1]-1)\n            bonus_right = bonus + cards[indices[1]]*(2**multiplier)\n            take_left = (indices[0]+1, indices[1])\n            bonus_left = bonus + cards[indices[0]]*(2**multiplier)\n            \n            if take_left in hold:\n                hold[take_left] = max(hold[take_left], bonus_left)\n            \n            else:\n                hold[take_left] = bonus_left\n            \n            if take_right in hold:\n                hold[take_right] = max(hold[take_right], bonus_right)\n            \n            else:\n                hold[take_right] = bonus_right\n        \n            global_max = max(global_max, bonus_left, bonus_right)\n            \n        queue.extend([(hold[cards], cards) for cards in hold])\n        \n        counter += 1\n        multiplier += 1        \n    \n    return global_max", "def calc(cards):\n    n = len(cards)\n\n    table = [[-1 for i in range(n)] for j in range(n)] # stores intermediate highest score\n    high = n - 1\n\n    def score(low, high, i):\n        # base case \n        if (i == n):\n            return 2**i * cards[low]\n        # looks up if we have already calculated highest score\n        elif (table[low][high] != -1): \n            return table[low][high]\n        # recursive case\n        else:\n            max_score =  max( score(low+1, high, i+1) + 2**i * cards[low] ,  # pick card on the left, LOW\n                            score(low, high-1, i+1) + 2**i * cards[high] )   # pick card on the right, HIGH\n            table[low][high] = max_score\n\n            return max_score\n\n    return score(0, high, 1)", "def calc(a):\n    # k = 0\n    res = [0] * (len(a) + 1)\n    \n    for k in range(1,len(a)+1):\n        new_res = []\n        new_res_size = len(res)-1\n        for i in range(new_res_size):\n            j = i+k\n            new_res.append(2 * max(a[i]+res[i+1], a[j-1]+res[i]))\n        res = new_res\n    return res[0]\n"]