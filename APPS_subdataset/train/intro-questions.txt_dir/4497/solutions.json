["def positive_to_negative(binary):\n    return [1 - d if 1 in binary[i:] else d for i, d in enumerate(binary, 1)]\n", "def positive_to_negative(b):\n    last = next((i for i in range(len(b) - 1, -1, -1) if b[i]), 0)\n    return [1 - d for d in b[:last]] + b[last:]", "def positive_to_negative(arr):\n    flip = [0 if n == 1 else 1 for n in arr]\n    \n    for i in range(len(flip)):\n        if flip[-(i+1)] == 1:\n            flip[-(i+1)] = 0\n        else:\n            flip[-(i+1)] = 1\n            break\n    return flip", "def positive_to_negative(binary):\n    binary = [not i for i in binary]    \n    for i in range(len(binary)-1,-1,-1):\n        if binary[i]:\n            binary[i] = 0\n        else:\n            binary[i] = 1\n            break \n    \n    return binary    ", "def positive_to_negative(binary):\n    flip = [int(not(e)) for e in binary]\n    for i in range(len(flip)-1,-1,-1):\n        if flip[i] == 0:\n            flip[i] = 1\n            break\n        flip[i] = 0\n    return flip", "def positive_to_negative(binary):\n    b = []\n    \n    print(\"\uc6d0\ub798 \uc774\uc9c4\uc218 :\", binary)\n    #range(1, 5) 1, 2, 3, 4\n    for bit in binary:\n        if bit == 1:\n            b.append(0)\n        else:\n            b.append(1)\n    print(\"1\uacfc 0 \ubc14\uafb8\uae30 :\", b)\n    \n    c = 1\n    for i in range(len (b)):\n        if b[-1-i] == 1 and c == 1:\n            b[-1-i] = 0\n        elif b[-1-i] == 0 and c == 1:\n            c = 0\n            b[-1-i] = 1\n        else:\n            pass    \n    \n    \"\"\"\n    b.reverse()\n    print(\"\ubc30\uc5f4 \uc21c\uc11c \ubc14\uafb8\uae30 :\",b)\n    \n    c = 1\n    for i in range(len (b)):\n        if b[i] == 1 and c == 1:\n            b[i] = 0\n        elif b[i] == 0 and c == 1:\n            c = 0\n            b[i] = 1\n        else:\n            pass\n        \n    print(b)\n    b.reverse()        \"\"\"\n    print(\"\ucd5c\uc885 :\",b)\n    \n    return b", "p = lambda b,c=1: [*p(b[:-1],1-b[-1]&c), 1-b[-1]^c] if len(b) else []\npositive_to_negative = p", "def positive_to_negative(b):\n    return [int(d) for d in f\"{int(''.join(str(1 - d) for d in b), 2) + 1:b}\"] if 1 in b else b\n", "def positive_to_negative(binary):\n    n = len(binary)\n    end = 0\n    for i in range(n - 1, -1, -1):\n        if(binary[i] == 1):\n            end = i\n            break\n    for i in range(end):\n        binary[i] ^= 1\n    return binary", "def positive_to_negative(binary):\n    if sum(binary) == 0:\n        return binary\n    steps = []\n    index = 0\n    zero_counter = 0\n    for bin_num in binary:\n        if binary[index] == 0:\n            zero_counter += 1\n            binary[index] = 1\n        elif binary[index] == 1:\n            binary[index] = 0\n        steps.append(0)\n\n        index += 1\n    fill = list(steps)\n    fill[-1] = 1\n\n    index = len(binary) - 1\n    while index >= 0:\n        if index != len(binary) -1:\n            binary[index] += fill[index] + steps[index+1]\n        else:\n            binary[index] += fill[index]\n\n        if binary[index] == 2:\n            binary[index] -= 2\n            steps[index] += 1\n\n        index -= 1\n\n    return binary"]