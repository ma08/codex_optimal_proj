["def solve(a, b):\n    if len(a) is 1:\n        return b.count(a)\n    index = [x for x in range(len(b)-1) if b[x] is a[0]]\n    return sum(solve(a[1:], b[x+1:]) for x in index)", "def solve(a, b, i=0, j=0):\n    return i == len(a) or sum(solve(a,b,i+1,x+1) for x in range(j, len(b)-(len(a)-i-1)) if a[i] == b[x])", "from functools import lru_cache\n\ndef solve(a, b):\n    l_a, l_b, rec = len(a), len(b), lru_cache(maxsize=None)(lambda x,y: (x == l_a) or sum(rec(x+1, i+1) for i in range(y, l_b) if b[i] == a[x]))\n    return rec(0, 0)", "def solve(a, b):\n    if not a:\n        return 1\n    if not b:\n        return 0\n    if b[0].lower() == a[0].lower():\n        return solve(a, b[1:]) + solve(a[1:], b[1:])\n    else:\n        return solve(a, b[1:])", "def solve(a, b):\n    if a[0] in b:\n        if len(a) > 1:\n            return solve(a[1:],b[b.index(a[0])+1:])+solve(a,b[b.index(a[0])+1:])\n        else:\n            print((b.count(a)))\n            return b.count(a)\n    else:\n        return 0\n\n    \n", "def solve(a, b, i=0, j=0):\n    return (1 if i == len(a) else\n            0 if j == len(b) else\n            solve(a,b,i,j+1) if a[i] != b[j] else\n            solve(a,b,i+1,j+1) + solve(a,b,i,j+1))", "def solve_dp (needle, haystack):\n    # let prefixes[h][n] = number of n-letters-long prefixes\n    #                      ending in h-th position of haystack\n    N, H = len(needle), len(haystack)\n    prefixes = [[1] + N*[0] for h in range(H)]\n    \n    def match (h, n): return haystack[h] == needle[n-1]\n    prefixes[0][1] = 1 if match(0, 1) else 0\n\n    for h in range(1, H):\n        max_prefix_len = min(h+1, N)\n        for n in range(1, max_prefix_len+1):\n            with_current = prefixes[h-1][n-1] if match(h, n) else 0\n            without_current = prefixes[h-1][n]\n            prefixes[h][n] = with_current + without_current\n    return prefixes[H-1][N]\n\ndef solve_recursive (needle, haystack):\n    if not needle or needle == haystack: return 1\n    if not haystack: return 0\n    \n    needle_head, *needle_tail = needle\n    haystack_head, *haystack_tail = haystack\n    match = needle_head == haystack_head\n    \n    head_matches = solve_recursive(needle_tail, haystack_tail) if match else 0\n    tail_matches = solve_recursive(needle, haystack_tail)\n    return head_matches + tail_matches\n\ndef solve (needle, haystack, method=solve_dp):\n    return method(needle, haystack)\n\n", "from itertools import combinations as c\n\ndef solve(a, b):\n    tot=0\n    a = tuple(a)\n    b = [i for i in b if i in a]\n    for k in range(len(b)):\n        if b[k]!=a[0]: continue\n        for kk in range(k+1, len(b)):\n            if b[kk]!=a[1]: continue\n            for i in c(b[kk+1:],len(a)-2):\n                if i==a[2:]:\n                    tot+=1\n    return tot", "def solve(a, b):\n    if len(a)==1:\n        return b.count(a)\n    r=0\n    for i in range(len(b)-len(a)+1):\n        if b[i]==a[0]:\n            r+=solve(a[1:],b[i+1:])\n    return r", "def solve(a,b):\n    if not a: return 1\n    x,c = a[0],0   \n    for i in range(len(b)):\n        if b[i] == x:\n            c += solve(a[1:],b[i+1:])   \n    return c"]