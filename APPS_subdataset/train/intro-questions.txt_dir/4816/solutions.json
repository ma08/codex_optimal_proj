["def diffs(bird1, bird2):\n    return sum(c1 != c2 for c1, c2 in zip(bird1, bird2))\n\ndef child(bird1, bird2):\n    return diffs(bird1, bird2) in [1, 2]\n\ndef grandchild(bird1, bird2):\n    return diffs(bird1, bird2) in [0, 1, 2, 3, 4] if len(bird1) > 1 else bird1 == bird2", "def child(bird1, bird2):\n    return 1 <= sum(i != j for i, j in zip(bird1, bird2)) <= 2 \n\ndef grandchild(bird1, bird2):\n    return bird1 == bird2 or sum(i != j for i, j in zip(bird1, bird2)) <= 4 and len(bird1) > 1\n", "from itertools import islice\nfrom operator import ne\n\ndef child(bird1, bird2):\n    return 0 < sum(islice(filter(None, map(ne, bird1, bird2)), 3)) < 3\n\ndef grandchild(bird1, bird2):\n    if len(bird1) == 1: return bird1 == bird2\n    return sum(islice(filter(None, map(ne, bird1, bird2)), 5)) < 5", "def diffs(a, b):\n    return sum(1 for aa, bb in zip(a, b) if aa != bb)\n\ndef child(bird1, bird2):\n    return diffs(bird1, bird2) in [1, 2] \n\ndef grandchild(bird1, bird2):\n    l = len(bird1)\n    d = diffs(bird1, bird2)\n    return (d < 5 and l > 1) or (d == 0 and l == 1)\n", "child=lambda b1,b2:0<sum([i!=j for i,j in zip(b1,b2)])<3\ngrandchild=lambda b1,b2:sum([i!=j for i,j in zip(b1,b2)])<5and b1+b2 not in['WB','BW']", "def hamming(a, b):\n    return sum(c1 != c2 for c1, c2 in zip(a, b))\n\ndef child(bird1, bird2):\n    return 1 <= hamming(bird1, bird2) <= 2\n\ndef grandchild(bird1, bird2):\n    if len(bird1) == 1:\n        return bird1 == bird2\n    return 0 <= hamming(bird1, bird2) <= 4", "def diff(bird1, bird2):\n    return sum(c1 != c2 for c1, c2 in zip(bird1, bird2))\n\ndef child(bird1, bird2):\n    return 1 <= diff(bird1, bird2) <= 2\n\ndef grandchild(bird1, bird2):\n    d = diff(bird1, bird2)\n    if len(bird1) == 1:\n        return d == 0\n    return 0 <= d <= 4", "from operator import ne\n\ndef child(bird1, bird2):\n    return 1 <= sum(map(ne, bird1, bird2)) <= 2\n\ndef grandchild(bird1, bird2):\n    return sum(map(ne, bird1, bird2)) <= 4 and bird1 + bird2 not in 'BWB'", "# Ever so slightly computationally inefficient method :)\n\ndef mutations(s):\n    def flip(c):\n        return {'B': 'W', 'W': 'B'}[c]\n        \n    def recurse(ss, n, acc):\n        if not ss:\n            if n > 0:\n                yield ''.join(acc)\n        else:\n            yield from recurse(ss[1:], n, acc + [ss[0]])\n            if n < 2:\n                yield from recurse(ss[1:], n + 1, acc + [flip(ss[0])])\n    \n    yield from recurse(s, 0, [])\n\ndef child(bird1, bird2):\n    possible = set(mutations(bird1))\n    return bird2 in possible \n\ndef grandchild(bird1, bird2):\n    possible = set(\n        grand_child \n        for child in mutations(bird1) \n        for grand_child in mutations(child)\n    )\n    return bird2 in possible \n", "from itertools import product\n\ndef child(bird1, bird2):\n    return sum([b[0] != b[1] for b in zip(bird1, bird2)]) in (1, 2)\n\n\ndef grandchild(bird1, bird2):\n    for mother in product(\"BW\", repeat=len(bird1)):\n        # check if both birds are related to the 'created' mother magpie\n        if child(bird1, mother) and child(bird2, mother): \n            return True\n    return False\n"]