["def is_palindrome(s):\n    s = s.lower()\n    return s == s[::-1]", "def is_palindrome(s):\n    \"\"\"return True if word \"s\" is a palindrome\"\"\"\n    return s.lower() == s[::-1].lower()\n", "def is_palindrome(s):\n    s = s.lower()\n    return s[::-1] == s\n", "def is_palindrome(string):\n    return string.lower() == string[::-1].lower()\n", "def is_palindrome(s):\n    s = s.casefold()\n    return s == s[::-1]\n", "def is_palindrome(s):\n    \n    p1=0 #Pointer 1 starts beginning of string\n    p2=len(s)-1 #Pointer 2 starts at end of string\n    \n    while p1<p2: #While the first pointer is less than the second\n        \n        #Compares the values of first and last characters in string\n        if s[p1].lower()==s[p2].lower():  \n            p1+=1 #Increases position of pointer 1 \n            p2-=1 #Decreases position of pointer 2\n            continue\n        \n        else: #Returns false if the values do not match\n            return False\n    \n    return True #If while loop is broken, returns true\n", "def is_palindrome(s):\n    s=s.lower() #making all characters lowercase \n    _list = list(s) #saving the text from the string s in a list\n    _list.reverse(); #reversing the list\n    str = \"\" #declaring some string variable\n    for i in _list:\n        str+=i #adding every item in our list in the string variable\n    return str==s #comaparing the origianl string ot the reverset string\n                  #this will automaticly return true or false\n", "def is_palindrome(s):\n    word = s.lower()   \n    l_for = []\n    i = 0\n    \n    for char in s:\n        l_for.append(word[i])\n        i += 1\n        \n    l_back = []\n    j = -1\n    \n    for char in s:\n        l_back.append(word[j])\n        j -= 1\n   \n    if l_for == l_back:\n        return True\n    else:\n        return False\n      \n      \nis_palindrome('aba')", "is_palindrome=lambda x:x.lower()==x[::-1].lower()", "def is_palindrome(s):\n    s = s.upper()\n    rev = \"\".join(x for x in s[::-1])\n    return rev == s", "def is_palindrome(s):\n    return s.lower()==s[::-1].lower()  #I solved this Kata on  8/17/2019  01:06 PM...#Hussam'sCodingDiary\n", "def is_palindrome(s):\n    for i in range(len(s)):\n        if s[i].upper() != s[len(s) - 1 -i].upper():\n            return False\n    return True\n", "def is_palindrome(s):\n    return s.lower()==s[::-1].lower()\n", "def is_palindrome(s):\n    return s.lower() == s.lower()[::-1]\n", "def is_palindrome(s):\n    s = s.lower()\n    return True if list(s) == list(s)[::-1] else False\n", "def is_palindrome(s):\n    # `s` contains only [a-z] and [A-Z]!\n\n    i = 0\n    j = len(s) - 1\n    \n    while i < j:\n        if ord(s[i]) ^ ord(s[j]) | 32 != 32:\n            return False\n        i += 1\n        j -= 1\n    \n    return True", "is_palindrome=lambda s:(lambda _:_==_[::-1])(s.lower())\n", "from math import floor, ceil\n\ndef is_palindrome(s: str) -> bool:\n    \"\"\" Check if a given string (case insensitive) is a palindrome. \"\"\"\n    s = s.lower()\n    if not len(s) % 2:\n        return s[:floor(len(s) / 2)] == s[floor(len(s) / 2):][::-1]\n    else:\n        return s[:floor(len(s) / 2)] == s[ceil(len(s) / 2):][::-1]", "def is_palindrome(s):\n    for i in range(len(s)//2):\n        if s[i].lower() != s[-i-1].lower():\n            return False\n        else:\n            pass\n    return True", "def is_palindrome(s):\n    return False if sum([1 for i in range(len(s)) if s[i].lower() != s[len(s) - 1 - i].lower() ]) else True\n", "def is_palindrome(s):\n    s_low = s.lower()\n    if len(s) == 1:\n        return True\n    elif len(s) % 2 == 0:\n        half = int(len(s) / 2)\n        word_part_1 = s_low[:half]\n        word_part_2 = s_low[half:][::-1]\n        if word_part_1 == word_part_2:\n            return True\n        else:\n            return False\n    elif len(s) % 2 == 1:\n        half2 = int(len(s) / 2)\n        word_part_3 = s_low[:half2]\n        word_part_4 = s_low[(half2 + 1):][::-1]\n        if word_part_3 == word_part_4:\n            return True\n        else:\n            return False\n", "def is_palindrome(s):\n    output=True\n    s=s.upper()\n    for i in range((len(s)//2)):\n        if s[i]!=s[len(s)-1-i]:\n            output=False\n    return output\n", "def is_palindrome(s):\n    x = s[::-1].lower()\n    if s.lower() == x:\n        return True\n    else:\n        return False\n", "def is_palindrome(s):\n    s = s.lower()\n    start = 0\n    end = -1\n    palindrome = True\n    for x in range(int(len(s))):\n        if s[start] == s[end]:\n            start += 1\n            end -= 1\n        else: palindrome = False\n    if palindrome is True: return True\n    else: return False\n        \n    \n", "def is_palindrome(s):\n    s=s.lower()\n    a=s[::-1]\n    if a == s :\n        return True\n    if a !=s :\n        return False", "def is_palindrome(string):\n    return all(s.lower() == e.lower() for s, e in zip(string, reversed(string)))\n", "def is_palindrome(s):\n    return True if s.lower() == \"\".join(reversed(s.lower())) else False\n", "def is_palindrome(s):\n    return True if s[::-1].casefold()==s.casefold()  else False\n", "def is_palindrome(s):\n    n = len(s)\n    l = 0;\n    r = n - 1;\n    res = True\n    s = s.lower()\n    if(n == 0 or n == 1):\n        return res\n    else:\n        while(l < r):\n            if(s[l] != s[r]):\n                res = False\n                break\n            l += 1\n            r -= 1\n        return res\n", "def is_palindrome(s):\n    for i in range(len(s)):\n        if len(s) <= 1:\n            print(s)\n            return True\n        elif s.lower()[0] != s.lower()[-1]:\n            print(s)\n            return False\n        s = s[1:-1]\n    return True    ", "def is_palindrome(s):\n    return all(s.lower()[i] == s.lower()[len(s) - 1 - i] for i in range(len(s) // 2))\n", "def is_palindrome(s):\n    s = s.upper()\n    for i in range(len(s)//2):\n        if s[i] != s[-i-1]:\n            return False\n    return True", "def is_palindrome(s):\n    \n    if(len(s)==0): return True\n    if len(s) == 1:\n        return True\n    if len(s)==2:\n        if str(s[0]).lower()==str(s[1]).lower():\n            return True\n    if s[0]!='' and s[-1]!='' :\n        if str(s[0]).lower()==str(s[-1]).lower():    \n            return is_palindrome(s[1:len(s)-1])\n    \n    return False\n", "def is_palindrome(s):\n    s = s.lower()\n    sb = s[::-1]\n    if s == sb:\n        return True\n    else:\n        return False\n", "def is_palindrome(s):\n    return s.lower() == (''.join(s[::-1])).lower()\n", "def is_palindrome(s):\n    a = s.lower()\n    b = \"\".join(reversed(a))\n    if a == b:\n        return True\n    else:\n        return False", "def is_palindrome(s):\n    s=s.lower()\n    orden1=list(s)    \n    orden2=(orden1[::-1])\n    if orden1 == orden2:\n        bool=True\n    else:\n        bool=False\n    return (bool)\n", "def is_palindrome( s ):\n    s = s.lower()\n    if len( s ) <= 1:\n        return True\n    elif s[ 0 ] != s[ -1 ]:\n        return False\n    return is_palindrome( s[ 1 : -1 ])\n", "from math import ceil\nfrom math import floor\n\n\ndef is_palindrome(s):\n    return s[:(ceil(len(s) / 2))].lower() == s[(floor(len(s) / 2)):][::-1].lower()", "import collections\n\n\ndef is_palindrome(s):\n    deq = collections.deque([c for c in s.lower()])\n    palFlag = True\n    while len(deq) > 1:\n        if deq.popleft() != deq.pop():\n            return False\n    return palFlag\n", "def is_palindrome(s):\n    return all(s[i].lower() == s[-1-i].lower() for i in range(len(s)))", "def is_palindrome(s):\n    List=list(s.lower())\n    L=len(List)\n    if L<=1:\n        return True\n    if List[0]==List[L-1]:\n        del List[0]\n        del List[L-2]\n        return is_palindrome(''.join(List))\n    else:\n        return False\n", "def is_palindrome(s):\n    s=s.lower()\n    s1=\"\".join(reversed(s))\n    if(s==s1):\n        return True\n    else:\n        return False", "def is_palindrome(s):\n    # To consider upper and lowercase\n    s = s.lower()\n    rev = s[::-1]\n    # Reversed string using splicing\n    if s == rev:\n        return True\n    else:\n        return False\n", "def is_palindrome(s):\n    x = s.lower()\n    if x[::-1] == x:\n        return True\n    else:\n        return False\n", "def is_palindrome(s: str) -> bool:\n    return s.lower() == s.lower()[::-1]\n", "def is_palindrome(s):\n    s = s.lower()\n    if s[::-1] == s:\n        return True \n    if s[::-1] != s:\n        return False\n", "def is_palindrome(s):\n    return s.lower() == s.lower()[::-1]\n    # returns True if the string reversed is similar to the original thus a palindrome\n    # lower() is required to skip over uppercase letters\n", "def is_palindrome(string):\n    s=string.lower()    \n    reversed_string = s[::-1]\n    return s == reversed_string", "def is_palindrome(s):\n    s_lowered = s.lower()\n    return s_lowered == s_lowered[::-1]\n", "def is_palindrome(s):\n    return not sum(1 for i in range(len(s)) if s.lower()[i] != s[::-1].lower()[i])\n", "def is_palindrome(s):\n    return s.lower()==''.join(list(reversed(s.lower())))\n\n", "def is_palindrome(s):\n    s_lower = s.lower()\n    return s_lower == s_lower[::-1]\n", "def is_palindrome(s):\n    lol = s.lower()\n    return lol == lol[::-1]\n", "def is_palindrome(s):\n    dni = 0\n    ri = True\n    for x in s:\n        dni -= 1\n        if x.lower() == s[dni].lower():\n           ri = True\n        else:\n            ri = False\n            break\n    return ri\n\n", "def is_palindrome(s):\n    r = s[::-1]\n    return r.lower() == s.lower()\n", "def is_palindrome(s):\n    s = s.lower()\n    return s[:len(s)//2] == s[:len(s)-len(s)//2-1:-1]\n", "def is_palindrome(s):\n    \n    l, r = 0, len(s)-1\n    \n    while l < r:\n        if s[l].lower() != s[r].lower():\n            return False\n        l += 1; r -= 1\n    return  True\n", "def is_palindrome(s):\n    s = s.lower()\n    if len( s ) <= 1:\n        return True\n    if s[ 0 ] != s[ len( s ) - 1 ]:\n        return False\n    w = s.strip( s[ 0 ] )\n    return is_palindrome( w )\n", "def is_palindrome(s):\n    s=s.lower()\n    r=s[::-1]\n    if s==r:\n        return True\n    else:\n        return False\n", "def is_palindrome(s):\n    return (lambda str: str == str[::-1])(s.lower())\n", "def is_palindrome(s):\n    import math\n    if len(s) == 1:\n        return True\n    if len(s) == 2:\n        if s[0].lower() == s[1].lower():\n            return True\n    for i in range(0, math.floor((len(s) - 1)/2)):\n        if s[i].lower() != s[len(s) - 1 - i].lower():\n            return False\n    return True\n\n", "def is_palindrome(s):\n    \n    for i in range(len(s)//2):\n        if s[i].lower() != s[-i-1].lower():\n            return False\n            break\n    return True", "def is_palindrome(s):\n    s = s.upper()\n    l = len(s)\n    for i in range(l):\n        if s[i] != s[l - 1 - i]:\n            return False\n    return True\n", "def is_palindrome(a):\n    s = a.lower()\n    if s == s[::-1]:\n        return True\n    else:\n        return False\n", "def is_palindrome(s):\n    s=s.lower()\n    n=len(s)\n    if n==1:return True\n    n=n//2\n    for i in range(1,n+1):\n        if s[i-1] != s[-i]:\n            return False\n    return True", "def is_palindrome(s):\n    s = s.lower()\n    if len(s) == 1:\n        return True\n    else:\n        A = s[:len(s)//2]\n        B = s[len(s)//2:]\n        if len(B) > len(A):\n            B=B[1:]\n        if A == B[::-1]:\n            return True\n    return False\n", "def is_palindrome(s):\n    s = s.lower()\n    return True if s == s[::-1] else False\n\n\nprint(is_palindrome('racasdecar'))\nprint(is_palindrome('racecaR'))", "def is_palindrome(s):\n    s=s.lower()\n    if len(s) == 1 or len(s)==0:\n        return True\n    if s[0] == s[-1]:\n        return is_palindrome(s[1:-1])\n    return False", "def is_palindrome(s):\n    length_array = len(s) - 1\n\n    for i in range(len(s) // 2):\n        if s[i].lower() != s[length_array - i].lower():\n            return False\n    return True\n", "def is_palindrome(s):\n    reversedstring = ''.join(reversed(s))\n    if s.lower() == reversedstring.lower():\n        return True\n    else:\n        return False", "def is_palindrome(str):\n    s = str.lower()\n    if len(s) <=1 :\n        return True\n    left = 0\n    right = len(s)-1\n    if s[left] ==   s[right] and  is_palindrome(s[left+1:right]):\n     return True\n    return False\n    \n", "def is_palindrome(s):\n    iterations = len(s) // 2\n    palindrome = True\n    for i in range(iterations-1):\n        a = s[i].lower()\n        b = s[-(i + 1)].lower()\n        if a != b:\n            palindrome = False\n            break    \n    return palindrome\n", "def is_palindrome(s):\n    s = list(s)\n    for i in range(0, len(s)):\n        s[i] = s[i].lower()\n    if s == s[::-1]:\n        return True\n    else:\n        return False", "def is_palindrome(s):\n    return True if s.capitalize() == s[::-1].capitalize() else False\n", "def is_palindrome(s):\n    emptystring = ''\n    x = s.lower()\n    for eachletter in x:\n        emptystring = eachletter + emptystring\n    return emptystring == x\n", "def is_palindrome(s):\n    s=s.lower()\n    s1=s[::-1]\n    return s==s1\n", "def is_palindrome(s):\n    s = s.upper()\n    return True if s == s[::-1] else False\n", "def is_palindrome(s):\n    s = s.lower()\n    if len(s) == 1:\n        return True\n    if len(s) % 2 != 0:\n        return (s[0:len(s) // 2 + 1] == s[:len(s) // 2 - 1:-1])\n    else:\n        return (s[:len(s) // 2] == s[:len(s) // 2 - 1:-1])\n", "def is_palindrome(s):\n    start = 0\n    end = len(s) -1\n    while start < end:\n        if s[start].lower() == s[end].lower():\n            start += 1\n            end -= 1\n        else:\n            return False\n    \n    return True\n", "def is_palindrome(s):\n    s = s.lower() \n    return s[:] == s[-1::-1]\n", "def is_palindrome(s):\n    ns = s.lower()\n    if len(ns) <= 1:\n        return True\n    if ns[0] != ns[-1]:\n        return False\n    return is_palindrome(ns[1:-1])", "def is_palindrome(s):\n    return s.casefold() == s.casefold()[::-1]\n", "def is_palindrome(s):\n    s = s.lower()\n    if(len(s)<=1):\n        return True\n    midpoint = len(s)//2\n    if(len(s)%2==1):\n        return s[:midpoint] == s[midpoint+1:][::-1]\n    return s[:midpoint] == s[midpoint:][::-1]\n", "def is_palindrome(s):\n    return s.upper() == ''.join(reversed(s.upper()))", "def is_palindrome(s):\n    s = s.casefold()\n    s = list(s)\n    if s == list(reversed(s)):\n        return True\n    else:\n        return False", "def is_palindrome(string):\n    string = string.lower()\n    if string == string[::-1] :\n        return True\n    else :\n        return False", "def is_palindrome(s):\n    b = s.lower()\n    if b != b[::-1]:\n      return False\n    else: \n      return True\n", "def is_palindrome(s):\n    s = s.upper()\n    res = ''.join(i for i in s[::-1])\n    return s == res", "def is_palindrome(s):\n    for i in range(len(s) // 2):\n        if s[i].lower() != s[~i].lower():\n            return False\n    return True\n", "def is_palindrome(s):\n    if not s: return True\n    s = s.lower()\n    i = 0\n    while i <= len(s)//2:\n        if s[i] != s[-i-1]: return False\n        i += 1\n    return True\n", "def is_palindrome(s):\n    k = list(s.lower())\n    for d, i in enumerate(k):\n        if i != k[len(k)-(d+1)] :\n            return False\n    return True\n", "def is_palindrome(s):\n    l = len(s)\n    if l == 1:\n        return True\n    for i in range(int(len(s)/2)):\n        if s[i].lower() != s[l - i - 1].lower():\n            return False\n    return True\n", "def inversa(s):\n  large = 0\n  sInversa = \"\"\n  index = -1\n  sLittle = \"\"\n  for quantity in s:\n    large += 1\n  while large >= 1:\n    sInversa += s[index]\n    index -= 1\n    large -= 1\n  for letters in sInversa:\n    if 65 <= ord(letters) <= 90:\n        sLittle += chr(ord(letters)+32)\n    else:\n        sLittle += letters\n  return sLittle\n  \ndef is_palindrome(s):\n    sPalindrome =\"\"\n    compare = inversa(s)\n    for lettersPalindrome in s:\n        if 65 <= ord(lettersPalindrome) <= 90:\n            sPalindrome += chr(ord(lettersPalindrome)+32)\n        else:\n            sPalindrome += lettersPalindrome\n    return compare == sPalindrome\n            \n", "def is_palindrome(sentence):\n    return sentence.lower() == sentence[::-1].lower()\n", "def is_palindrome(str):\n  return str.lower() == ''.join(reversed(str.lower()))\n", "def is_palindrome(s):\n    return s[:].lower() == s[::-1].lower()\n", "def is_palindrome(s):\n    palindrome = False\n    if len(s) <= 1:\n        palindrome = True\n    else:\n        for i in range(len(s) // 2):\n            if s[i].lower() == s[-i-1].lower():\n                palindrome = True\n            else:\n                palindrome = False\n                break\n    return palindrome", "def is_palindrome(s):\n    return bool(s[::-1].lower() == s.lower())", "def is_palindrome(str):\n    a = str.lower()\n    if a == a[::-1]:\n        return True\n    else:\n        return False\n"]