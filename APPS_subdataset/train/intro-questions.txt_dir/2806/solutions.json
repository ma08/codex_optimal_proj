["def whose_turn(positions):\n    return sum(ord(c) for c in positions.replace(\";\", \"\")) % 2 == 0", "def whose_turn(positions):\n    return sum(ord(c) for c in positions) & 1 == 1", "tbl = str.maketrans('', '', 'aceg1357;')\n\ndef whose_turn(positions):\n    return not len(positions.translate(tbl)) % 2\n", "def whose_turn(positions):\n    wk1,wk2,bk1,bk2 = positions.split(\";\")\n    cciw = cell_color_is_white\n    return not cciw(wk1) ^ cciw(wk2) ^ cciw(bk1) ^ cciw(bk2)\n  \ndef cell_color_is_white(cell):\n    return (ord(cell[0]) + ord(cell[1])) % 2 == 1", "import re\ndef whose_turn(positions):\n  return len(re.sub(r\"[1357;aceg]\", \"\",positions))%2==0", "def whose_turn(positions):\n  a = [int(p, 19) & 1 for p in positions.split(';')]\n  return len(set(a[:2])) == len(set(a[2:]))", "def whose_turn(positions):\n    positions = positions.split(\";\")\n    on_white_squares = [is_white_square(pos) for pos in positions]\n\n    # Player's knights on black-black or white-white => odd number of moves\n    white_pieces_match = on_white_squares[0] == on_white_squares[1]\n    black_pieces_match = on_white_squares[2] == on_white_squares[3]\n\n    # Equal number of moves => white to move\n    return white_pieces_match == black_pieces_match\n  \n\ndef is_white_square(pos):\n    x, y = ord(pos[0]) - 97, int(pos[1])\n    return x % 2 == y % 2", "def whose_turn(positions):\n    return sum(ord(file) + ord(rank) for file, rank in positions.split(\";\")) % 2 == 0", "from typing import Dict, Generator, List, Tuple\n\nK_MOVES = [\n    (a, b) \n    for a in [-2, -1, 1, 2] \n    for b in [-2, -1, 1, 2] \n    if abs(a) != abs(b)\n]\n\ndef gen_k_moves(k: Tuple[int, int]) -> Generator[Tuple[int, int], None, None]:\n    \"\"\"\n    Generates all valid knight moved from the given point\n    \"\"\"\n    kc, kr = k\n    for dc, dr in K_MOVES:\n        c, r = kc + dc, kr + dr\n        if 1 <= r <= 8 and 1 <= c <= 8:\n            yield c, r\n\ndef solve(k: Tuple[int, int]) -> Dict[Tuple[int, int], int]:\n    \"\"\"\n    Given the starting point of a knight k, return a dict of postions to minimum moves to that position\n    \"\"\"\n    solutions = {}\n    \n    edges = [k]\n    visited = set()\n    steps = 0\n    while edges:\n        visited.update(edges)\n        for edge in edges:\n            solutions[edge] = steps\n        steps += 1\n        new_edges = []\n        for edge in edges:\n            for nk in gen_k_moves(edge):\n                if nk in visited:\n                    continue\n                new_edges.append(nk)\n                visited.add(nk)\n        edges = new_edges\n    return solutions\n\nw1_solutions = solve((2, 1))\nw2_solutions = solve((7, 1))\nb1_solutions = solve((2, 8))\nb2_solutions = solve((7, 8))\n\ndef whose_turn(positions):\n    positions = [\n        (ord(s[0]) - ord('a') + 1, int(s[1])) \n        for s in positions.split(';')\n    ]\n    w1 = w1_solutions[positions[0]], w2_solutions[positions[0]]\n    w2 = w1_solutions[positions[1]], w2_solutions[positions[1]]\n    b1 = b1_solutions[positions[2]], b2_solutions[positions[2]]\n    b2 = b1_solutions[positions[3]], b2_solutions[positions[3]]\n    \n    whites = min(w1[0] + w2[1], w1[1] + w2[0])\n    blacks = min(b1[0] + b2[1], b1[1] + b2[0])\n    return (whites % 2) == (blacks % 2)", "def whose_turn(positions):\n    return sum(ord(c) for c in positions.replace(\";\", \"\")) & 1 == 0"]