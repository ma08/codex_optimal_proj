["from math import factorial as f\ncount_paths=lambda n,c:f(c[0]+abs(n-c[1]-1))//(f(abs(n-c[1]-1))*f(c[0])) if n!=1 else 0", "from math import factorial\ndef count_paths(N, coords):\n    if N==1:\n        return 0\n    x=coords[0]\n    y=N-1-coords[1]\n    return factorial(x+y)//(factorial(x)*factorial(y))", "count_paths=lambda n,C,f=__import__('math').factorial:(n!=1)*f(n+C[0]-1-C[1])//f(C[0])//f(n-1-C[1])", "def count_paths(N,C,f=lambda n:eval('*'.join(map(str,range(1,n+1))))):\n    a,y=C\n    b=N-1-y\n    return 1-(b==0)if a==0else 1-(a==0)if b==0 else f(a+b)//f(a)//f(b) ", "import math\ndef count_paths(N, coords):\n    t = N-1 - coords[1] + coords[0]\n    if t == 0:\n        return 0\n    \n    return math.factorial(t)//(math.factorial(coords[0])*math.factorial(t-coords[0]))", "import math\n\n# if you look at the matrix of possible paths...\n# [ 1,  1,  1,  0]\n# [ 4,  3,  2,  1]\n# [10,  6,  3,  1]\n# [20, 10,  4,  1]\n# ...the diagonals reflect Pascal's triangle.\n#\n# For example, 4C1 = 4, 4C2 = 6, 4C3 = 4\n# Each cell (row, col) has possible paths = dC(l-row) where:\n#    d = the ordinal of the diagonal (zero-indexed)\n#    l = the length of the diagonal\n#\n# We can calculate d and l like so:\n#    d = row + n - 1 - col\n#    l = d + 1\n#\n# Combined, we get:\n#    (row + n - 1 - col) C (n - 1 - col)\ndef count_paths(N, coords):\n    row, col = coords\n    if row == 0 and col == N-1:\n        return 0\n    \n    inverse_col = N - 1 - col\n    return choose(row + inverse_col, inverse_col)\n\n# aCb = a!/(a-b)!b!\ndef choose(n,k):\n    if k > n:\n        return 0\n    if k > n-k:\n        k = n-k\n    product = 1\n    k_list = list(range(2, k+1))\n    for i in range(n, n-k, -1):\n        if len(k_list) > 0:\n            k_index = len(k_list)-1\n            k = k_list[k_index]\n            if i % k == 0:\n                i = i // k\n                del k_list[k_index]\n        product *= i\n    for k in k_list:\n        product //= k\n    return product", "from math import factorial as f\nbino=lambda x,y: f(x)//f(y)//f(x-y)\n\ndef count_paths(N, coords):\n    d1,d2 = N - coords[1] - 1, coords[0]\n    return bino(d1+d2,min(d1,d2)) if d1+d2 else 0\n"]