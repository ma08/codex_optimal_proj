["def prime_or_composite(n):\n    if n < 4: return 'Probable Prime'\n    if n % 2 == 0: return 'Composite'\n    d, r = n - 1, 0\n    while d % 2 == 0:\n        d, r = d // 2, r + 1\n    for a in [2, 31]:\n        x = pow(a, d, n)\n        if x in (1, n - 1):\n            continue\n        for _ in range(r-1):\n            x = pow(x, 2, n)\n            if x == 1: return 'Composite'\n            if x == n-1: break\n        else: return 'Composite'\n    return 'Probable Prime'\n", "_primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\ndef try_base(a, d, n, s):\n    if pow(a, d, n) == 1:\n        return False\n    for i in range(s):\n        if pow(a, 2**i * d, n) == n-1:\n            return False\n    return True\n\ndef miller_rabin(n):\n    if n in _primes:\n        return True\n    if any(not n % p for p in _primes):\n        return False\n    d, s = n - 1, 0\n    while not d & 1:\n        d, s = d >> 1, s + 1\n    return not any(try_base(a, d, n, s) for a in _primes)\n\ndef prime_or_composite(n):\n    return \"Probable Prime\" if miller_rabin(n) else \"Composite\"", "def prime_or_composite(n):\n    from random import randrange\n    if n == 2:\n        return 'Probable Prime'\n    if not n & 1:\n        return 'Composite'\n\n    def check(a , s , d , n):\n        x = pow(a , d , n)\n        if x == 1:\n            return 'Probable Prime'\n        for i in range(s - 1):\n            if x == n - 1:\n                return 'Probable Prime'\n            x = pow(x , 2 , n)\n        return x == n - 1\n\n    s = 0\n    d = n - 1\n    while d % 2 == 0:\n        d >>= 1\n        s += 1\n\n    for i in range(2,20):\n        a = randrange(2 , n)\n        if not check(a , s , d , n):\n            return 'Composite'\n    return 'Probable Prime'", "import random\n\ndef prime_or_composite(q, k=100):\n    q = abs(q)\n    if q == 2:\n        return 'Probable Prime'\n    if q < 2 or q & 1 == 0:\n        return 'Composite'\n\n    d = (q - 1) >> 1\n    while d & 1 == 0:\n        d >>= 1\n    for i in range(k):\n        a = random.randint(1, q - 1)\n        t = d\n        y = pow(a, t, q)\n        while t != q - 1 and y != 1 and y != q - 1:\n            y = pow(y, 2, q)\n            t <<= 1\n        if y != q - 1 and t & 1 == 0:\n            return 'Composite'\n    return 'Probable Prime'", "import random\ndef is_prime(n):\n    k=100\n    if n<=1:\n        return False\n    elif n==2:\n        return True\n    if n%2==0:\n        return False\n    d=n-1\n    s=0\n    while(d%2==0):\n        s+=1\n        d//=2\n    for i in range(k):\n        a=random.randint(1,n-1)\n        if pow(a,d,n)==1:\n            continue\n        is_composite=True\n        for r in range(s):\n            if pow(a,pow(2,r)*d,n)==n-1:\n                is_composite=False\n                break\n        if is_composite:\n            return False\n    return True\n    \ndef prime_or_composite(n):\n    return 'Probable Prime' if is_prime(n) else 'Composite'", "# Python3 program Miller-Rabin primality test \nimport random  \n  \n# Utility function to do \n# modular exponentiation. \n# It returns (x^y) % p \ndef power(x, y, p): \n      \n    # Initialize result \n    res = 1;  \n      \n    # Update x if it is more than or \n    # equal to p \n    x = x % p;  \n    while (y > 0): \n          \n        # If y is odd, multiply \n        # x with result \n        if (y & 1): \n            res = (res * x) % p; \n  \n        # y must be even now \n        y = y>>1; # y = y/2 \n        x = (x * x) % p; \n      \n    return res; \n  \n# This function is called \n# for all k trials. It returns \n# false if n is composite and  \n# returns false if n is \n# probably prime. d is an odd  \n# number such that d*2<sup>r</sup> = n-1 \n# for some r >= 1 \ndef miillerTest(d, n): \n      \n    # Pick a random number in [2..n-2] \n    # Corner cases make sure that n > 4 \n    a = 2 + random.randint(1, n - 4); \n  \n    # Compute a^d % n \n    x = power(a, d, n); \n  \n    if (x == 1 or x == n - 1): \n        return True; \n  \n    # Keep squaring x while one  \n    # of the following doesn't  \n    # happen \n    # (i) d does not reach n-1 \n    # (ii) (x^2) % n is not 1 \n    # (iii) (x^2) % n is not n-1 \n    while (d != n - 1): \n        x = (x * x) % n; \n        d *= 2; \n  \n        if (x == 1): \n            return False; \n        if (x == n - 1): \n            return True; \n  \n    # Return composite \n    return False; \n  \n# It returns false if n is  \n# composite and returns true if n \n# is probably prime. k is an  \n# input parameter that determines \n# accuracy level. Higher value of  \n# k indicates more accuracy. \ndef prime_or_composite( n, k=10): \n      \n    # Corner cases \n    if (n <= 1 or n == 4): \n        return \"Composite\"; \n    if (n <= 3): \n        return \"Probable Prime\"; \n  \n    # Find r such that n =  \n    # 2^d * r + 1 for some r >= 1 \n    d = n - 1; \n    while (d % 2 == 0): \n        d //= 2; \n  \n    # Iterate given nber of 'k' times \n    for i in range(k): \n        if (miillerTest(d, n) == False): \n            return \"Composite\"\n  \n    return \"Probable Prime\"; ", "# Miller-Rabin primality test \n\nfrom random import randrange\n\ndef prime_or_composite(n):\n    if n < 10: \n        return 'Probable Prime' if n in [2, 3, 5, 7] else 'Composite'\n        \n    def miller_test(a, d): \n        p = pow(a, d, n)\n        if p == 1 or p == n - 1: \n            return False\n        \n        while d != n - 1 and p != 1 and p != n - 1: \n            p = p ** 2 % n\n            d *= 2\n            \n        return False if p == n - 1 else True\n    \n    d = n - 1\n    \n    while d % 2 == 0: \n        d >>= 1\n    \n    for i in range(8): \n        a = randrange(2, n - 1)\n        if miller_test(a, d): \n            return 'Composite'\n        \n    return 'Probable Prime'", "import random\n\ndef prime_or_composite(num):\n    for j in range(20):\n        a = random.randint(1, num - 1)\n        if pow(a, (num - 1), num) != 1:\n            return \"Composite\"\n    return \"Probable Prime\"\n"]