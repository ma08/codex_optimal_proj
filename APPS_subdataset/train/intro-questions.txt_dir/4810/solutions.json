["from operator import itemgetter\nfrom numpy import delete\n\ndef make_spanning_tree(edges, t):\n    memo, result = [], []\n    for v in sorted(edges, key=itemgetter(1), reverse=(t==\"max\")):\n        (x,y), w = v\n        \n        if x == y: continue\n        \n        i = next((i for i,s in enumerate(memo) if x in s), None)\n        j = next((j for j,s in enumerate(memo) if y in s), None)\n        \n        if i == j != None: continue\n            \n        result.append(v)\n        \n        if i == j: memo.append({x, y})\n        elif i is None: memo[j].add(x)\n        elif j is None: memo[i].add(y)\n        else:\n            memo.append(memo[i] | memo[j])\n            memo = delete(memo, [i, j]).tolist()\n\n    return result", "def make_spanning_tree(edges, t):\n    edges = sorted(edges, key=lambda x:x[1], reverse=t=='max')\n    span, vert = [], {}\n    \n    for edge in edges:\n        ((a,b),_), (subA,subB) = edge, map(vert.get, edge[0])\n        \n        if a==b or subA is not None and subA is subB:\n            continue\n        \n        if subA and subB:\n            subA |= subB\n            for v in subB: vert[v] = subA\n        else:\n            subSpan = subA or subB or set()\n            for v in (a,b):\n                subSpan.add(v)\n                vert[v] = subSpan\n        span.append(edge)\n        \n    return span", "from operator import lt, gt\n\ndef mst(edges, inf, compare, min_max):\n    Q = {v for vs, _ in edges for v in vs}\n    C = dict.fromkeys(Q, inf)\n    E = dict.fromkeys(Q)\n    while Q:\n        v = min_max(Q, key=C.get)\n        Q.discard(v)\n        candidates = ((edge, weight) for edge, weight in edges if v in edge)\n        for edge, weight in candidates:\n            v_, w = edge\n            if w == v:\n                w = v_\n            if w in Q and compare(weight, C[w]):\n                E[w], C[w] = edge, weight\n        if E[v] is not None:\n            yield E[v], C[v]\n\ndef make_spanning_tree(edges, t):\n    return list(mst(\n        edges,\n        float('inf' if t == 'min' else '-inf'),\n        lt if t == 'min' else gt,\n        min if t == 'min' else max,\n    ))", "def make_spanning_tree(edges, t):\n    id = {}\n    edges.sort(key=lambda x: x[1], reverse=t == 'max')\n    spanning_tree = []\n    for (u, v), cost in edges:\n        if u not in id: id[u] = u\n        if v not in id: id[v] = v\n        if id[u] != id[v]:\n            id = {x: y if y != id[v] else id[u] for x, y in id.items()}\n            spanning_tree.append((u + v, cost))\n    return spanning_tree", "def make_spanning_tree(edges, t):\n    edges.sort(reverse=True)\n    last_node = ord(edges[0][0][0]) - 65\n    edges.sort()\n    edges.sort(key=lambda edges: edges[1])\n\n    if(t == 'max'):\n        edges.reverse()\n    \n    nonlocal parent\n    parent = [int(x) for x in range(last_node+10000)]\n    result = []\n\n    for edge in edges:\n        startNode = ord(edge[0][0])-65\n        endnode = ord(edge[0][1])-65\n\n        if(Find(startNode) != Find(endnode)):\n            Union(startNode, endnode)\n            result.append(edge)\n\n    return result\n\ndef Find(x):\n    if(x == parent[x]):\n        return x\n    else:\n        p = Find(parent[x])\n        parent[x] = p\n        return p\n\ndef Union(x, y):\n    x = Find(x)\n    y = Find(y)\n\n    if(x != y):\n        parent[y] = x", "class DisjointSet:\n    def __init__(self):\n        self.data = {}\n        \n    def add_node(self, v):\n        self.data[v] = v\n        \n    def find(self, v):\n        if (self.data[v] == v):\n            return v\n        else :\n            return self.find(self.data[v])\n        \n    def union(self, v, w):\n        root_v = self.find(v)\n        root_w = self.find(w)\n        \n        self.data[root_v] = root_w\n        \n    def in_same_set(self, v, w):\n        root_v = self.find(v)\n        root_w = self.find(w)\n        \n        return root_v == root_w\n\ndef make_spanning_tree(edges, t):\n    edges = sorted(edges, key=lambda x: x[1], reverse = t == 'max')    \n    tree = DisjointSet()\n    output = []\n        \n    while (edges):\n        edge = edges.pop(0)\n        v, w = edge[0][0], edge[0][1]\n        if (v not in tree.data.keys()):\n            tree.add_node(v)\n        if (w not in tree.data.keys()):\n            tree.add_node(w)\n            \n        if (not tree.in_same_set(v, w)):\n            tree.union(v, w)\n            output.append(edge)\n            \n    return output", "class DisjointSet:\n    def __init__(self):\n        self.data = {}\n        \n    def add_node(self, v):\n        self.data[v] = v\n        \n    def find(self, v):\n        if (self.data[v] == v):\n            return v\n        else :\n            return self.find(self.data[v])\n        \n    def union(self, v, w):\n        root_v = self.find(v)\n        root_w = self.find(w)\n        \n        self.data[root_v] = root_w\n        \n    def in_same_set(self, v, w):\n        root_v = self.find(v)\n        root_w = self.find(w)\n        \n        return root_v == root_w\n\ndef make_spanning_tree(edges, t):\n    if (t == 'min'):\n        edges = sorted(edges, key=lambda x: x[1])    \n    elif (t == 'max'):\n        edges = sorted(edges, key=lambda x: -x[1])\n        \n    \n    tree = DisjointSet()\n    for edge in edges:\n        v, w = edge[0][0], edge[0][1]\n        if (v not in tree.data.keys()):\n            tree.add_node(v)\n        if (w not in tree.data.keys()):\n            tree.add_node(w)\n    cnt = 0\n    output = []\n    while (cnt < len(tree.data)-1):\n        edge = edges.pop(0)\n        v, w = edge[0][0], edge[0][1]\n        \n        if (not tree.in_same_set(v, w)):\n            tree.union(v, w)\n            output.append(edge)\n            cnt += 1\n            \n    return output", "from queue import PriorityQueue\n\ntaken = set()\nadj = {}\npq = PriorityQueue()\n\n\ndef process(v, order):\n    # order to be 1 or -1 to sort the priority_queue\n    taken.add(v)\n    for vi, w in adj[v]:\n        if not vi in taken:\n            pq.put((order * w, vi, v))\n\n\ndef make_spanning_tree(edges, t):\n    edges_set = set()\n    result = []\n    adj.clear()\n    taken.clear()\n    first = ''\n    order = 1 if t == 'min' else -1\n    for edge in edges:\n        u, v = edge[0]\n        edges_set.add(edge)\n        w = edge[1]\n        if u == v:\n            continue\n        if not u in adj:\n            adj[u] = []\n        if not v in adj:\n            adj[v] = []\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n        if not first:\n            first = u\n\n    process(first, order)\n    mst_cost = 0\n    while not pq.empty():\n        w, u, v = pq.get()\n        w = order * w\n        if not u in taken:\n            mst_cost += w\n            process(u, order)\n            result.append((v + u, w))\n    for ri in range(len(result)):\n        r = result[ri]\n        if not r in edges_set:\n            result[ri] = r[0][1] + r[0][0], r[1]\n            \n\n    return result  # vertices of a spanning tree\n\n", "def filtering(lst):\n    new_lst = set()\n    vertices = []\n    for item in lst:\n        if item[0][0] not in vertices:\n            vertices.append(item[0][0])\n        if item[0][1] not in vertices:\n            vertices.append(item[0][1])\n        if item[0][0] == item[0][1]:\n            continue\n        else:\n            new_lst.add(item)\n    return [new_lst, vertices]\n    \ndef poss_edg_func(vert, edges):\n    res = []\n    for edge in edges:\n        if edge[0][0] in vert and edge[0][1] not in vert:\n            res.append(edge)\n        if edge[0][1] in vert and edge[0][0] not in vert:\n            res.append(edge)\n    return res\n            \ndef make_spanning_tree(edges, t):\n    temp = filtering(edges)\n    edg, vert = temp[0], temp[1]\n    path = [eval(t)(edg, key = lambda x: x[1])]\n    while len(path) != len(vert) - 1:\n        used_vert = set([char for v in path for char in v[0]])\n        poss_edg = poss_edg_func(used_vert, edg)\n        path.append(eval(t)(poss_edg, key = lambda x: x[1]))\n    return path\n        \n    \n    \n", "def make_spanning_tree(edges, t):\n    X = [edges[0][0][0]]\n    output = []\n    while True:\n        val = float(\"inf\") if t == \"min\" else -float(\"inf\")\n        current = new_X = None\n        for node in X:\n            for edge in edges:\n                if t == \"min\":\n                    if edge[0][0] == node:\n                        if edge[1] <= val and edge[0][1] not in X:\n                            val, current, new_X = edge[1], edge, edge[0][1]\n                    elif edge[0][1] == node:\n                        if edge[1] <= val and edge[0][0] not in X:\n                            val, current, new_X = edge[1], edge, edge[0][0]\n                else:\n                    if edge[0][0] == node:\n                        if edge[1] >= val and edge[0][1] not in X:\n                            val, current, new_X = edge[1], edge, edge[0][1]\n                    elif edge[0][1] == node:\n                        if edge[1] >= val and edge[0][0] not in X:\n                            val, current, new_X = edge[1], edge, edge[0][0]\n        if new_X is None: break\n        X.append(new_X)\n        output.append(current)\n    return output\n"]