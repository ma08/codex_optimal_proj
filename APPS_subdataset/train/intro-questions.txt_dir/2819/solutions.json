["def memoized(f):\n    cache = {}\n    def wrapped(k):\n        v = cache.get(k)\n        if v is None:\n            v = cache[k] = f(k)\n        return v\n    return wrapped\n\n@memoized\ndef fibonacci(n):\n    if n in [0, 1]:\n        return n\n    return fibonacci(n - 1) + fibonacci(n - 2)", "from functools import lru_cache\n\n@lru_cache(None)\ndef fibonacci(n):\n    if n in [0, 1]:\n        return n\n    return fibonacci(n - 1) + fibonacci(n - 2)", "def fibonacci(m):\n    cache = {0:0,1:1}\n    def fib(n):\n        if n not in cache:\n            cache[n] = fib(n-1)+fib(n-2)\n        return cache[n]\n    return fib(m)\n#print fibonacci(70)\n", "memo = {}\n\ndef fibonacci(n):\n    if n in [0, 1]:\n        return n\n    if n not in memo:\n        memo[n] = fibonacci(n - 1) + fibonacci(n - 2)\n    return memo[n]", "from functools import wraps\n\n# very rudimentary implementation of a cache decorator\n# python 3's functools.lru_cache or its backport should be favored\ndef cache(f):\n    _cache = {}\n    @wraps(f)\n    def wrapped(n):\n        if n in _cache:\n            return _cache[n]\n        else:\n            result = f(n)\n            _cache[n] = result\n            return result\n    return wrapped\n    \n@cache\ndef fibonacci(n):\n    if n in [0, 1]:\n        return n\n    return fibonacci(n - 1) + fibonacci(n - 2)", "memoize = {0:0,1:1}\ndef fibonacci(n):\n    if n not in memoize:\n        memoize[n] = fibonacci(n - 1) + fibonacci(n - 2)\n    return memoize[n]", "from functools import lru_cache\n\n\n@lru_cache()\ndef fibonacci(n):\n    if n in [0, 1]:\n        return n\n    return fibonacci(n - 1) + fibonacci(n - 2)", "def fibonacci(n, cache = [0, 1]):\n    if len(cache) <= n:\n        cache.append(fibonacci(n - 1) + fibonacci(n - 2))\n    return cache[n]", "def fibonacci(n, _cache={}):\n    if n in _cache:\n        return _cache[n]\n    elif n > 1:\n        return _cache.setdefault(n, fibonacci(n-1) + fibonacci(n-2))\n    return n"]