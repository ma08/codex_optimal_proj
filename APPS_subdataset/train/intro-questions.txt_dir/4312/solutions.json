["def pick_peaks(arr):\n    pos = []\n    prob_peak = False\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i-1]:\n            prob_peak = i\n        elif arr[i] < arr[i-1] and prob_peak:\n            pos.append(prob_peak)\n            prob_peak = False\n    return {'pos':pos, 'peaks':[arr[i] for i in pos]}", "def pick_peaks(arr):\n    peak, pos = [], []\n    res = { \"peaks\":[], \"pos\":[] }\n    \n    for i in range(1, len(arr)) :\n        if arr[i]>arr[i-1] :\n            peak, pos = [arr[i]], [i]\n        \n        elif arr[i]<arr[i-1] :\n            res[\"peaks\"] += peak\n            res[\"pos\"] += pos\n            peak, pos = [], []\n    \n    return res", "def pick_peaks(arr):\n    \n    def add_peak(p):\n        peaks[\"pos\"].append(p)\n        peaks[\"peaks\"].append(arr[p])\n        \n    def is_peak(p):\n        return arr[p-1] < arr[p] > arr[p+1]\n        \n    def is_plateau_start(p):\n        return arr[p-1] < arr[p] == arr[p+1]\n        \n    def does_plateau_end_lower(p):\n        return next((val for val in arr[p+1:] if val != arr[p]), arr[p]) < arr[p]\n\n    peaks = {\"pos\":[], \"peaks\":[]}\n    for p in range(1, len(arr)-1):\n        if is_peak(p):\n            add_peak(p)\n        elif is_plateau_start(p) and does_plateau_end_lower(p):\n            add_peak(p)\n    \n    return peaks", "def pick_peaks(arr):\n  peaks = []\n  pos = []\n  current_pos = None\n  \n  for i in range(len(arr)-1):\n    if arr[i] < arr[i+1]:\n      current_pos = i+1\n    elif arr[i] > arr[i+1] and i != 0 and current_pos is not None:\n      pos += [current_pos]\n      peaks += [arr[current_pos]]\n      current_pos = None\n      \n  return {\"pos\":pos, \"peaks\":peaks}", "\n\n\ndef pick_peaks(a):\n    deltas = [(i, x2 - x1) for i, (x1, x2) in enumerate(zip(a, a[1:]), 1) if x1 != x2]\n    indexes = [i for (i, dx1), (_, dx2) in zip(deltas, deltas[1:]) if dx1 > 0 > dx2]\n    return dict(pos=indexes, peaks=[a[i] for i in indexes])\n", "def pick_peaks(arr):\n    peaks = {\"pos\":[], \"peaks\":[]}\n    for i in range(1, len(arr)):\n        next_num = next((num for num in arr[i:] if num != arr[i]), float(\"inf\"))\n        if arr[i-1] < arr[i] and next_num < arr[i]:\n            peaks[\"pos\"].append(i)\n            peaks[\"peaks\"].append(arr[i])\n    return peaks\n", "def pick_peaks(arr):\n\n    PairList = []\n\n    for i,e in enumerate(arr):\n    \n        if arr[i-1] >= e or i == 0:\n        \n            continue\n        \n        for k in arr[i:]:\n        \n            if k == e:\n            \n                continue\n                \n            elif k > e:\n            \n                break\n                \n            else:\n            \n                PairList.append([i,e])\n                break \n    \n    return {'pos':[k[0] for k in PairList], 'peaks':[k[1] for k in PairList]}", "def pick_peaks(arr):\n    prev_dex = prev_val = None\n    result = {'pos': [], 'peaks': []}\n    upwards = False\n    for i, a in enumerate(arr):\n        if prev_val == a:\n            continue\n        elif prev_val is None or prev_val < a:\n            upwards = True\n        else:\n            if prev_dex and upwards:\n                result['pos'].append(prev_dex)\n                result['peaks'].append(prev_val)\n            upwards = False\n        prev_dex = i\n        prev_val = a\n    return result\n", "import re\n\ndef pick_peaks(arr):\n    slope = \"\".join(\"u\" if b > a else \"d\" if a > b else \"p\" for a, b in zip(arr, arr[1:]))\n    positions = [m.start() + 1 for m in re.finditer(r\"up*d\", slope)]\n    peaks = [arr[pos] for pos in positions]\n    return {\"pos\": positions, \"peaks\": peaks}", "def pick_peaks(arr):\n    cast = []\n    \n    for i,e in enumerate(arr):\n        if cast and e == cast[-1][0]:#\n            continue\n        cast.append((e,i))\n        \n    doc = {\"pos\":[], \"peaks\":[]}#\n    \n    for i in range(1,len(cast)-1):\n        if cast[i-1][0] < cast[i][0] > cast[i+1][0]:\n            doc['peaks'].append(cast[i][0])\n            doc['pos'].append(cast[i][1])\n            \n    return doc", "# In this kata, you will write a function that returns the positions\n# and the values of the \"peaks\" (or local maxima) of a numeric array.\n# For example, the array arr = [0, 1, 2, 5, 1, 0] has a peak\n# at position 3 with a value of 5 (since arr[3] equals 5).\n# The output will be returned as an object with two properties: pos and peaks.\n# Both of these properties should be arrays. If there is no peak\n# in the given array, then the output should be {pos: [], peaks: []}.\n# Example: pickPeaks([3, 2, 3, 6, 4, 1, 2, 3, 2, 1, 2, 3])\n# should return {pos: [3, 7], peaks: [6, 3]} (or equivalent in other languages)\n# All input arrays will be valid integer arrays (although it could still\n# be empty), so you won't need to validate the input.\n# The first and last elements of the array will not be considered as peaks\n# (in the context of a mathematical function, we don't know what is after\n# and before and therefore, we don't know if it is a peak or not).\n# Also, beware of plateaus !!! [1, 2, 2, 2, 1] has a peak while\n# [1, 2, 2, 2, 3] does not. In case of a plateau-peak, please only\n# return the position and value of the beginning of the plateau.\n# For example: pickPeaks([1, 2, 2, 2, 1]) returns {pos: [1], peaks: [2]}\n# (or equivalent in other languages)\n\ndef sign(x):\n    if x>0:\n       return 1\n    elif x<0:\n       return -1\n    elif x==0:\n       return 0\n\ndef pick_peaks(arr):\n    pos = []\n    peaks = []\n    l = len(arr)\n# Calculate differential array    \n    diff_arr = []\n    for i in range (0, l-1):\n        diff_arr.append(sign(arr[i+1] - arr[i]))\n# Pick_Peaks\n    i = 0\n    while i < l-2:\n        k = 1\n        while sign(diff_arr[i+k]) == 0 and i+k < l-2:\n            k += 1\n        if (sign(diff_arr[i+k]) < sign(diff_arr[i]) and\n            sign(diff_arr[i]) != 0 and sign(diff_arr[i+k]) != 0):\n                pos.append(i+1)\n                peaks.append(arr[i+1])\n        i += k\n# Create Dictionary!        \n    d_pos_peaks = dict(pos=pos, peaks=peaks)    \n    return d_pos_peaks", "def pick_peaks(arr):\n    redic = { \"pos\":[], \"peaks\":[] }\n    for i in range(1,len(arr)-1):\n        if all(( arr[i] > arr[i-1], arr[i] >= arr[i+1])):\n            j = i\n            while arr[j] == arr[i] and j < len(arr)-1:\n                j += 1\n                if arr[j] < arr[i]:\n                    redic['pos'].append(i)\n                    redic['peaks'].append(arr[i])\n    return redic", "def pick_peaks(arr):\n    result = {'pos': [], 'peaks':[]}\n    increasing = False\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i-1]:\n            increasing = True\n            tmpk = arr[i]\n            tmpindx = i\n        elif arr[i] < arr[i-1]:\n            if increasing:\n                result['pos'].append(tmpindx)\n                result['peaks'].append(tmpk)\n                increasing = False\n    return result", "def pick_peaks(a):\n    a=[int(i) for i in a]\n    pred = 0\n    prov = False\n    peaks = []\n    pos = []\n    count = 0\n    spusk = True\n\n    for i in range(len(a)):\n        if pred == a[i] and spusk==False:\n            count+=1\n            prov = True\n            continue\n        if pred > a[i]:\n            if prov==True:\n                peaks.append(a[i-1])\n                pos.append(i-1-count)\n            prov=False\n            spusk=True\n        elif i!=0 and pred < a[i]:\n            prov = True\n            spusk=False\n        pred = a[i]\n        count = 0\n    d = {\"pos\": pos, \"peaks\" : peaks}\n\n    return d", "def pick_peaks(arr):\n    i, pos = len(arr) - 2, []\n    while i > 0:\n        while i > 0 and arr[i + 1] >= arr[i]:\n            i -= 1\n        while i > 0 and arr[i + 1] <= arr[i]:\n            i -= 1\n            if arr[i + 1] > arr[i]:\n                pos.append(i + 1)\n    return {'peaks': [arr[i] for i in pos[::-1]], 'pos': pos[::-1]}", "def pick_peaks(arr):\n    result = {'pos': [], 'peaks': []}\n    pos = 0\n    for i in range(1, len(arr) - 1):\n        if arr[i] != arr[pos]:\n            pos = i\n        if pos and arr[pos - 1] < arr[pos] > arr[i + 1]:\n            result['pos'].append(pos)\n            result['peaks'].append(arr[pos])\n    return result", "def pick_peaks(arr):\n    print(arr)\n    peaks = {'pos':[], 'peaks': []}\n    enum_arr = list(enumerate(arr))\n    possible_peaks = enum_arr[1:-1]\n    for point in possible_peaks:\n        current_p, current_v = point[0], point[1]\n        prior_p, prior_v = enum_arr[current_p - 1]\n        next_p, next_v = enum_arr[current_p + 1]\n        is_peak = prior_v < current_v > next_v\n        if is_peak:\n            peaks['pos'].append(current_p)\n            peaks['peaks'].append(current_v)\n        is_plateau = prior_v == current_v or current_v == next_v\n        if is_plateau:\n            is_peak = prior_v < current_v\n            i = current_p\n            while is_peak:\n                try:\n                    next = enum_arr[i + 1][1]\n                    curr = enum_arr[i][1]\n                except IndexError:\n                    break\n                next_plateau = next == curr\n                if not next_plateau:\n                    peak_end = next < curr\n                    if peak_end:\n                        peaks['pos'].append(current_p)\n                        peaks['peaks'].append(current_v)\n                        is_peak = False\n                    else:\n                        break\n                i += 1\n    return peaks", "def pick_peaks(arr):\n    pos_delta = [pd for pd in enumerate((b - a for a, b in zip(arr, arr[1:])), 1) if pd[1]]\n    positions = [a[0] for a, b in zip(pos_delta, pos_delta[1:]) if a[1] > 0 and b[1] < 0]\n    return {'pos': positions, 'peaks': [arr[p] for p in positions]}\n", "def pick_me(arr):\n    plateau = None\n\n    for i, p in enumerate(arr[1:-1]):\n        # peak as is\n        if arr[i] < p > arr[i+2]:\n            yield(i+1, p)\n            plateau = None\n\n        # start of potential plateau\n        if arr[i] < p == arr[i+2]:\n            plateau = (i+1, p)\n\n        # found end of plateau\n        if plateau and arr[i] == p > arr[i+2]:\n            yield plateau\n            plateau = None\n\n\ndef pick_peaks(arr):\n    picked = list(zip(*pick_me(arr)))\n    pos, peaks = picked if picked else ([], [])\n\n    return {\n        \"pos\": list(pos), \n        \"peaks\": list(peaks)\n    }\n", "def pick_peaks(arr):\n    res = {'pos': [], 'peaks': []}\n    for i in range(1, len(arr) - 1):\n        if arr[i - 1] < arr[i] > arr[[n for n in range(i, len(arr)) if arr[n] != arr[i] or n == len(arr) - 1][0]]:\n            res.update({'pos': res.get('pos') + [i]})\n            res.update({'peaks': res.get('peaks') + [arr[i]]})\n    return res", "def pick_peaks(arr):\n    lastind = -1\n    pos = list()\n    peaks = list()\n    status = 'init'\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i-1]:\n            status = 'rising'\n            lastind = i\n        elif arr[i] < arr[i-1]:\n            if status=='rising':\n                pos.append(lastind)\n                peaks.append(arr[i-1])\n                status = 'lol'\n    return {\"pos\": pos, \"peaks\": peaks}", "def pick_peaks(arr):\n    if not arr:\n        return {\"pos\": [], \"peaks\": []}\n    \n    pos = []\n    peaks = []\n    arr_iter = enumerate(arr)\n    curr_pos, curr_peak = next(arr_iter)\n    climbing = False\n    \n    for index, value in arr_iter:\n        if value > curr_peak:\n            curr_pos, curr_peak = index, value\n            climbing = True\n        elif value < curr_peak:\n            if climbing:\n                pos.append(curr_pos)\n                peaks.append(curr_peak)\n                climbing = False\n            curr_pos, curr_peak = index, value\n    \n    return {\"pos\": pos, \"peaks\": peaks}\n", "def pick_peaks (nums):\n    pp_dict = {'pos': [], 'peaks': []}\n    size = len(nums)\n    i = 1\n    \n    for i in range (1, size - 1):\n        if nums[i] > nums[i - 1]:\n            plateau_start = i\n            try:\n                while nums[i] == nums[i + 1]:\n                    i += 1\n                if nums[i] > nums[i + 1]:\n                    pp_dict['pos'].append (plateau_start)\n                    pp_dict['peaks'].append (nums[plateau_start])\n            except LookupError:\n                break\n    \n    return pp_dict\n                \n", "def pick_peaks(arr):\n    coords = {'pos': [i for i in range(1, len(arr) - 1) if arr[i - 1] < arr[i] >\n                    arr[[x for x in range(i, len(arr)) if arr[x] != arr[i] or x == len(arr) - 1][0]]]}\n    coords.update({'peaks':[arr[elem] for elem in coords.get('pos') ]})\n    return coords", "def pick_peaks(arr):\n    # compress arr, keeping track of position of the first occurance of a value\n    ppos = [i for i, x in enumerate(arr) if i == 0 or arr[i-1] != arr[i]]\n    pos   = [ppos[i] for i in range(1,len(ppos)-1) \\\n        if arr[ppos[i]] > arr[ppos[i-1]] and arr[ppos[i]] > arr[ppos[i+1]] ]\n    return {'pos': pos, 'peaks': [arr[i] for i in pos]}\n", "def pick_peaks(arr):\n    maximas, positions = [], []\n    for i, num in enumerate(arr):\n        same_as_num = [x == num for x in arr[i:]]\n        end = not all(same_as_num) and i + same_as_num.index(False) - 1\n        local_max = end and num > arr[i - 1] and num > arr[end + 1]\n        \n        if not (i == 0 or i == len(arr) - 1) and local_max:\n            maximas.append(arr[i])\n            positions.append(i)\n\n    return {\"pos\": positions, \"peaks\": maximas}\n", "def pick_peaks(arr):\n    pos = []\n    for i in range(1, len(arr)-1):\n        # next index with a value != current_value\n        next_i = next((n for n, v in enumerate(arr[i:]) if v != arr[i]), None)\n        if arr[i-1] < arr[i] and next_i and arr[i] > arr[i:][next_i]:\n            pos.append(i)\n    return {\n        'pos': pos,\n        'peaks': [arr[po] for po in pos], \n    }", "def next_different_value(arr, index):\n    next_index = index + 1\n    while arr[index] == arr[next_index] and next_index != len(arr) - 1:\n        next_index += 1\n    return arr[index] > arr[next_index]\n\ndef pick_peaks(arr):\n    res = {'pos': [], 'peaks': []}\n    if len(arr) < 3:\n        return res\n    def fill_res(pos, peaks):\n        res['pos'].append(pos)\n        res['peaks'].append(peaks)\n    for index, value in enumerate(arr):\n        if index not in [0, len(arr) - 1]:\n            if arr[index] > arr[index - 1] and next_different_value(arr, index):\n                fill_res(index, value)\n    return res", "def pick_peaks(arr):\n    p = []\n    z = []\n    res = {\"pos\": [], \"peaks\": []}\n    for i, k in enumerate(arr[1:-1]):\n        if k > arr[i] and k > arr[i+2]:\n            p.append(i+1)\n            z.append(k)\n        elif k == arr[i+2] and k > arr[i]:\n            n = 1\n            while True:\n                n += 1\n                if k != arr[i+n] or i+n == len(arr)-1:\n                    break\n            if k > arr[i+n]:\n                p.append(i+1)\n                z.append(k)\n    res[\"pos\"] = p\n    res[\"peaks\"] = z\n    return res", "def pick_peaks(arr):\n    out = {}\n    i, wait_pick, temp_pick = 1, 0, 0\n    while i < len(arr) - 1:\n        if arr[i] == arr[i+1] and arr[i] > arr[i-1]:\n            temp_pick = i\n            wait_pick = 1\n            i += 1   \n            continue\n        if wait_pick == 1:\n            if arr[i] > arr[i+1]:\n                out[temp_pick] = arr[temp_pick]\n                wait_pick = 0\n            elif arr[i] < arr[i+1]:\n                wait_pick = 0\n            i += 1\n        else:\n            if arr[i] > arr[i-1] and arr[i] > arr[i+1]:\n                out[i] = arr[i]\n            i += 1\n    return {\"pos\": list(out.keys()), \"peaks\": list(out.values())}", "def pick_peaks(arr):\n    pos = []\n    peaks = []\n    i = 1\n    while i < len(arr)-1:\n        if arr[i-1] < arr[i] and arr[i] > arr[i+1]: #case when there is a simple peak\n            pos.append(i); peaks.append(arr[i])\n        elif arr[i-1] < arr[i] < arr[i+1]: #case when the value of each number is incrementing\n            pass\n        elif arr[i-1] < arr[i]: #the case when we have a plato\n            if i < len(arr): #to avoid the situation of i value greater then arr len\n                for j in range(i,len(arr)-1): #we check all number to len(arr)-1 \n                    if arr[j] == arr[j+1]:    #to understand when and where the plato ends\n                        continue              #plato continues\n                    elif arr[j] < arr[j+1]:   #case when we meet the number which is greater\n                        i = j - 1             #then each plato's number\n                        break\n                    elif arr[j] > arr[j+1]:   #case when the plato has ended we simply add \n                        pos.append(i)         #the i and its value to lists\n                        peaks.append(arr[i])\n                        i = j - 1\n                        break\n        i+=1\n\n    return {'pos': pos, 'peaks': peaks}", "def pick_peaks(a):\n    po, pe = 'pos', 'peaks'\n    d = { po: [], pe: [] }\n    for n in range(2, len(a)):\n        b, P, e = n-2, n-1, n                              \n        if a[ b ] < a[ P ] >= a[ e ]:                           \n            if len(a[ P :  ]) != a[ P :  ].count(a[ P ]):    \n                if max( a[ P : ] ) >= a[ P ]  :\n                    if d[po]:\n                        if min( a[ d[po][-1] : P ] ) >= d[pe][-1]:\n                            d[po] = d[po][ : -1]\n                            d[pe] = d[pe][ : -1]\n                    d[po].append( P )\n                    d[pe].append( a[ P ] )\n    return d", "def pick_peaks(array):\n    peaks, pos = [], []\n    platpos = platpeaks = \"\"\n\n    for i in range(1, len(array) - 1):\n        if array[i - 1] < array[i] > array[i + 1]:\n            peaks.append(array[i]), pos.append(i)\n        elif array[i - 1] < array[i] == array[i + 1]:\n            platpos, platpeaks = i, array[i]\n        elif array[i - 1] == array[i] > array[i + 1] and platpos != \"\":\n            pos.append(platpos), peaks.append(platpeaks)\n\n    return{\"pos\": pos, \"peaks\": peaks}", "def pick_peaks(arr):\n    peaks = []\n    pos = []\n    i = 0\n    clean = list(arr)\n    \n    while i < len(clean)-1:\n        if i == 0 or i == len(clean)-1:\n            i = i + 1\n            pass\n        else:\n            c = 1\n            while clean[i] == clean[i+c] and i+c<len(clean)-1:\n                c = c+1\n                \n            if clean[i] > clean[i-1] and clean[i] > clean[i+c]:\n                peaks.append (clean[i])\n                pos.append(i)\n            \n            i = i+c\n\n    return {\"pos\":pos, \"peaks\":peaks}\n", "def pick_peaks(arr):\n    peak = []\n    pos = []\n    prev = 0\n    growing = False\n    for i in range(1,len(arr)):\n        if arr[prev] > arr[i] and growing:\n            peak.append(arr[prev])\n            pos.append(prev)\n            growing = False\n        elif arr[prev] < arr[i]:\n            growing = True\n        if arr[prev] == arr[i]:\n            prev = prev\n        else:\n            prev = i\n    return { 'pos' : pos, 'peaks' : peak}\n", "def pick_peaks(arr):\n    pos = []\n    peaks = []\n    for x, num in enumerate(arr):\n        if x == 0 or x == len(arr)-1:\n            continue\n        if arr[x-1] < num and arr[x+1] < num:\n            pos.append(x)\n            peaks.append(num)\n        elif arr[x-1] < num and arr[x+1] == num:\n            # checks for plateau peaks\n            i = x\n            plateau = True\n            while plateau:\n                i+= 1\n                try:\n                    if arr[i] < num:\n                        pos.append(x)\n                        peaks.append(num)\n                        plateau = False\n                    elif arr[i] > num:\n                        plateau = False\n                except IndexError:\n                    plateau = False\n                    \n    return {'pos':pos, 'peaks': peaks}\n            \n            \n        \n", "def pick_peaks(arr):\n    pos = []\n    peaks = []\n    i = 1\n    while i < len(arr) - 1:\n        if arr[i - 1] < arr[i]:\n            j = i + 1\n            while j < len(arr):\n                print(arr[i], arr[j])\n                if arr[i] > arr[j]:\n                    pos.append(i)\n                    peaks.append(arr[i])\n                    break\n                elif arr[i] == arr[j]:\n                    j += 1\n                else:\n                    break\n        i += 1\n    return {\"pos\": pos, \"peaks\": peaks}", "from itertools import groupby\ndef pick_peaks(arr):\n# remove plateaus using groupby and just remember the first occurrence position\n# build a new list called \"sequence\"\n    start = 0\n    sequence = []\n    for key, group in groupby(arr):\n        sequence.append((key, start))  # adds tuples for key and first occurrence\n        start += sum(1 for element in group) # start plus number of consequtive occurrences\n        \n    peaks = []\n    pos = [] \n# b like before tuple(value, original index), m like middle, a like after \n    for (b, bi), (m, mi), (a, ai) in zip(sequence, sequence[1:], sequence[2:]):\n        if b < m and a < m:\n            pos.append(mi)\n            peaks.append(m)\n# Build result            \n    result = {}\n    result['pos'] = pos\n    result['peaks'] = peaks\n    return result\n", "def pick_peaks(arr):\n    real = [arr[x] for x in range(len(arr) -1) if arr[x] != arr[x+1]]\n    track = [x for x in range(len(arr)-1) if arr[x] == arr[x+1]]\n    if real:\n        real.append(arr[-1])\n    pos = [x for x in range(1, len(real)-1) if (real[x] > real[x-1]) and (real[x] > real[x+1])]\n    posn = [x+1 for x in range(1,)]\n    peak = [real[x] for x in range(1, len(real)-1) if (real[x] > real[x-1]) and (real[x] > real[x+1])]\n    new = []\n    count = 0\n    a = 0\n    for i in range(len(real)):\n        if arr[i+count] != real[i]:\n            skip = 0\n            while arr[i+count] != real[i]:\n                count += 1\n                skip += 1\n            if new:\n                new.append([i + new[-1][1], skip])\n            else:\n                new.append([i, skip])\n    for j in range(len(new)):\n        for k in range(len(pos)):\n            if pos[k] >= new[j][0]:\n                pos[k] = pos[k] + new[j][1]\n\n    total = {\"pos\": pos, \"peaks\": peak}\n    return total", "def pick_peaks(arr):\n    #your code here\n    pos = []\n    peaks = []\n    plateau = []\n\n    numbers = len(arr)\n    print(\"length of array: \"+str(numbers))\n    print(\"list:\")\n    print(arr)\n\n    for number in range(numbers):\n        if number == 0 or number == (numbers - 1):\n            pass\n        else:\n            candidate = arr[number]\n            pre = arr[(number - 1)]\n            post = arr[(number + 1)]\n            if candidate > pre and candidate > post:\n                pos.append(number)\n                peaks.append(candidate)\n            elif number == 1 or number == (numbers - 2):\n                pass\n#             elif candidate == post and candidate == arr[(number + 2)] and number != (number - 1):\n            elif candidate > pre and candidate == post:  \n                if candidate >= arr[(number + 2)] and number != (number - 1) and candidate != arr[(numbers - 1)]:\n                    pos.append(number)\n                    peaks.append(candidate)\n                else:\n                    pass\n    print(\"plateau:\")\n    print(plateau)\n    answer = {}\n    answer[\"pos\"] = pos\n    answer[\"peaks\"] = peaks\n    print(answer)\n    return answer", "def pick_peaks(arr):\n    start = 0\n    sequence = []\n    ind,val=[],[]\n    posPeaks = {\n        \"pos\": [],\n        \"peaks\": [], }\n\n    from itertools import groupby\n\n    for key, group in groupby(arr):\n        sequence.append((key, start))\n        start += sum(1 for _ in group)\n\n    for (b, bi), (m, mi), (a, ai) in zip(sequence, sequence[1:], sequence[2:]):\n        if b < m and a < m:\n            ind.append(mi)\n            val.append(m)\n        \n    posPeaks[\"pos\"]=ind\n    posPeaks[\"peaks\"]=val\n    return (posPeaks)", "def pick_peaks(arr):\n    result = {\"pos\":[],\"peaks\":[]}\n    for i in range(1,len(arr)-1):\n        if arr[i]>arr[i-1] and arr[i]>arr[i+1]:\n            result[\"pos\"].append(i)\n            result[\"peaks\"].append(arr[i])\n            \n        elif arr[i]>arr[i-1] and arr[i]==arr[i+1]:\n            for k in range(i+2,len(arr)):\n                if arr[i]>arr[k]:\n                    result[\"pos\"].append(i)\n                    result[\"peaks\"].append(arr[i])\n                    break\n                elif arr[k]>arr[i]:\n                    break\n    return result\n", "def pick_peaks(arr):\n    #your code here\n    result=[]\n    resultIndex=[]\n    for element in range(len(arr)):\n        if element>0 and element!=(len(arr)-1):\n            if arr[element]>arr[element-1] and arr[element]>arr[element+1]:\n                peak=arr[element]\n                result.append(peak)\n                resultIndex.append(element)\n            elif(arr[element]>arr[element-1] and arr[element]==arr[element+1] ):\n                curr=arr[element]\n                currIndex=element\n                for next in range(element+1,len(arr)-1):\n                    if(arr[next]>arr[next+1]):\n                        result.append(curr)\n                        resultIndex.append(currIndex)\n                        break\n                    elif(arr[next]==arr[next+1]):\n                        continue\n                    else:\n                        break\n    return {\"pos\":resultIndex,\"peaks\":result}", "def pick_peaks(arr):\n    #your code here\n    result = {'pos':[], 'peaks':[]}\n    flagIndex = -1\n    for i in range(1, len(arr)-1):\n        if arr[i-1] < arr[i] > arr[i+1]:\n            result['pos'].append(i)\n            result['peaks'].append(arr[i])\n        elif arr[i-1] < arr[i] == arr[i+1]:\n            flagIndex = i\n        elif flagIndex != -1:\n            if arr[i] > arr[i+1]:\n                result['pos'].append(flagIndex)\n                result['peaks'].append(arr[flagIndex])\n                flagIndex = -1\n            elif arr[i] < arr[i+1]:\n                flagIndex = -1\n            \n    return result", "def pick_peaks(arr):\n    output = {\"pos\": [], \"peaks\": []}\n    topPos = 0\n    if len(arr) > 0:\n        topPeak = arr[0]\n        for i in range(1, len(arr)):\n            if arr[i] > arr[i-1]:\n                topPos = i\n                topPeak = arr[i]\n            elif arr[i] < arr[i-1]:\n                \"\"\" It's help to know if there was a climbing previously \"\"\"\n                if topPos > 0:\n                    output[\"pos\"].append(topPos)\n                    output[\"peaks\"].append(topPeak)\n                    topPos = 0\n    return output", "\n\ndef pick_peaks(arr):\n    out = {\n        'pos': [],\n        'peaks': []\n    }\n    if len(arr) == 0:\n        return out\n    last_i = arr[0]\n    latest_maxima = None\n    latest_maxima_pos = None\n    for pos in range(len(arr)):\n        i = arr[pos]\n        if i > last_i:\n            latest_maxima = i\n            latest_maxima_pos = pos\n        if i < last_i and latest_maxima is not None:\n            out['pos'].append(latest_maxima_pos)\n            out['peaks'].append(latest_maxima)\n            latest_maxima = None\n            latest_maxima_pos = None\n        last_i = i\n    return out", "def pick_peaks(arr):\n    dict = {\"pos\": [], \"peaks\": []}\n    \n    for i in range(1, len(arr)-1):\n        if(arr[i-1] < arr[i] and arr[i] > arr[i+1]):\n            dict[\"pos\"].append(i)\n            dict[\"peaks\"].append(arr[i])\n        \n        elif(arr[i-1] < arr[i] and (arr[i] == arr[i+1])):\n            cur = i+1\n            while cur+1 < len(arr):\n                if(arr[cur] > arr[cur+1]):\n                    dict[\"pos\"].append(i)\n                    dict[\"peaks\"].append(arr[i])\n                    break\n                if(arr[cur] < arr[cur+1]):\n                    break\n                cur+=1\n            \n        \n    return dict", "def pick_peaks(a):\n    ind = []\n    val = []\n    for i in range(1, len(a)-1):\n            if  a[i-1] < a[i] and a[i] > a[i+1]:\n                ind.append(i)\n                val.append(a[i])\n            elif a[i] > a[i-1] and a[i] == a[i+1]:\n                for j in range(i+1, len(a)-1):\n                        if a[j] == a[i] and a[j]<a[j+1]:\n                            break\n                        elif a[j] == a[i] and a[j+1]<a[j]:\n                            ind.append(i)\n                            val.append(a[i])\n                            break\n    return {'pos': ind, 'peaks': val}", "def pick_peaks(arr):\n    local_peaks = {\n        'pos': [],\n        'peaks': []\n    }\n    count = 1\n    length = len(arr)\n    while count < length - 1:\n\n        value = arr[count]\n        add_node = False\n        if value >= arr[count + 1] and value > arr[count - 1]:\n            if value == arr[count + 1]:\n                #checking if value eventually goes down\n                for i in range(2, length - count):\n                    if arr[count + i] > value:\n                        break\n                    elif arr[count + i] < value:\n                        add_node = True\n \n            else:\n                add_node = True\n     \n        if add_node:\n            local_peaks['pos'].append(count)\n            local_peaks['peaks'].append(value)           \n        count += 1\n\n    return local_peaks", "def pick_peaks(arr):     \n    l=[]\n    t=[]\n    for i in range(len(arr)-2):\n        if arr[i+1]>arr[i]:\n            k=0\n            while k+i+1<len(arr):\n                if arr[k+i+1]>arr[i+1]:\n                    break\n                if arr[k+i+1]<arr[i+1]:\n                    l.append(arr[i+1])\n                    t.append(i+1)\n                    break\n                k=k+1\n    return {'pos':t,'peaks':l}", "def pick_peaks(a):\n    pos = []\n    try:\n        for k in range(1, len(a) - 1):\n            if a[k] > a[k - 1] and a[k] > a[k + 1]:\n                pos.append(k)\n            elif a[k] > a[k - 1] and a[k] == a[k + 1]:\n                i = k + 2\n                while i < len(a) - 1 and a[i] == a[k]:\n                    i += 1\n                \n                if a[i] < a[k]:\n                    pos.append(k)\n                else:\n                    k = i\n                    \n        peaks = [a[i] for i in pos]\n        return {'pos': pos, 'peaks': peaks}\n    except IndexError:\n        print(a)\n        print('i=', i)", "def pick_peaks(arr):\n    d = {\"pos\" : [], \"peaks\" : []}\n    i = 0\n    print(arr)\n    if len(arr) > 2 and arr[0] >= arr[1]:\n        while arr[i] >= arr[i+1] and i < len(arr)-2:\n                i += 1 \n    while i < len(arr)-1:\n        if arr[i] < arr[i+1]:\n            pass   \n        elif arr[i] == arr[i+1]:\n            temp = i\n            while arr[i] == arr[i+1] and i < len(arr)-2:\n                i+=1\n            if arr[i] > arr[i+1]:\n                d[\"pos\"].append(temp)\n                d[\"peaks\"].append(arr[temp])\n                while arr[i] >= arr[i+1] and i < len(arr)-2:\n                    i += 1\n        else:\n            d[\"pos\"].append(i)\n            d[\"peaks\"].append(arr[i])\n            while arr[i] >= arr[i+1] and i < len(arr)-2:\n                i += 1\n        i+=1\n    return d", "def pick_peaks(arr):\n    #your code here\n    a_1 = []\n    a_2 = []\n\n    result_ab = {'pos': a_1, 'peaks': a_2}\n\n    for i in range(0, (len(arr)-1)):\n        if (i != 0) and (i != len(arr)-1):\n            if (arr[i] > arr[i-1]) and (arr[i] > arr[i+1]):\n                a_1.append(i)\n                a_2.append(arr[i]) \n            elif (arr[i] > arr[i-1]) and (arr[i] == arr[i+1]):\n                # elem = i\n                copy_arr = arr[:]\n                while (copy_arr[i] == copy_arr[i+1]):\n                    del copy_arr[i+1]\n                    if i != len(copy_arr)-1:\n                        if (copy_arr[i] > copy_arr[i+1]): # !!!\n                            a_1.append(i)\n                            a_2.append(arr[i]) \n                            break\n                        elif (copy_arr[i] == copy_arr[i+1]):\n                            continue\n                        else:\n                            break\n                    else:\n                        break\n            else:\n                pass\n        else:\n            pass\n\n    return result_ab\n", "def isPeak(arr, pos):\n    if pos == 0 or pos == len(arr) - 1:\n        return False\n    if arr[pos - 1] >= arr[pos]:\n        return False\n    for nextElem in arr[pos + 1:]:\n        if nextElem > arr[pos]:\n            return False\n        if nextElem < arr[pos]:\n            return True\n\ndef pick_peaks(arr):\n    result = {\"pos\": [], \"peaks\": []}\n    for pos, val in enumerate(arr):\n        if isPeak(arr, pos):\n            result[\"pos\"].append(pos)\n            result[\"peaks\"].append(val)\n    return result\n", "def pick_peaks(arr):\n    out = {}\n    pos = []\n    peaks = []\n    temp = []\n    for i, x in enumerate(arr[1:-1], start=1):\n        prev = arr[i-1]\n        nxt = arr[i+1]\n        if x > prev:\n            temp = [i, x]\n        if x < prev and temp or x > nxt and temp:\n            pos.append(temp[0])\n            peaks.append(temp[1])\n            temp.clear()\n\n    out['pos'] = pos\n    out['peaks'] = peaks\n    return out", "from itertools import groupby\n\ndef pick_peaks(arr):\n\n    result = {'pos':[], 'peaks':[]}\n    if not arr: return result\n    \n    arr = dict(enum(list(j) for i,j in groupby(arr)))         \n    keys = sorted(arr.keys())\n    \n    for i in arr:        \n        if i != keys[0] and i != keys[-1]:        \n            curr  = arr[i][0]\n            prev = arr[keys[keys.index(i) + 1]][0]\n            post     = arr[keys[keys.index(i) - 1]][0]\n            \n            if curr > post and curr > prev:\n                result['pos']   = result['pos'] + [i]\n                result['peaks'] = result['peaks'] + [arr[i][0]]\n    return result\n    \ndef enum(listA):\n    value = 0\n    for j in listA:\n        if len(j) == 1:\n            yield(value,j)\n            value += 1\n        else:\n            yield(value, j)\n            value += len(j) ", "def pick_peaks(arr):\n    obj = {\"pos\": [], \"peaks\": []}\n    \n    if len(arr) == 0:\n        return obj\n    \n    upward = True if arr[0] < arr[1] else False\n    pos = 1\n    plateau = 0\n    \n    while pos < len(arr) - 1:\n        if upward:\n            if arr[pos] == arr[pos+1]:\n                plateau += 1\n            elif arr[pos] > arr[pos+1] and arr[pos] >= arr[pos-1]:\n                obj[\"pos\"].append(pos-plateau)\n                obj[\"peaks\"].append(arr[pos])\n                upward = False\n                plateau = 0\n            else:\n                plateau = 0\n            pos += 1\n        else:\n            if arr[pos] < arr[pos+1]:\n                upward = True\n            pos += 1\n    \n    return obj", "def pick_peaks(arr):\n    a = []\n    b = []\n    for i in range(1, len(arr)-1):\n        for l in range(i, len(arr)-1):\n            if arr[l+1] > arr[i]:\n                break\n            if arr[l+1] < arr[i]:\n                if arr[i-1] < arr[i] and arr[i+1] <= arr[i]:\n                    a.append(i)\n                    b.append(arr[i])\n                    break\n    return {\"pos\":a,\"peaks\":b}", "def pick_peaks(arr):\n    print(arr)\n    obj = {\"pos\": [], \"peaks\": []}\n    if len(arr) == 0:\n        return obj\n    upward = True if arr[0] < arr[1] else False\n    pos = 1\n    plateau = 0\n    \n    while pos < len(arr) - 1:\n        if upward:\n            if arr[pos] == arr[pos+1]:\n                plateau += 1\n            elif arr[pos] > arr[pos+1] and arr[pos] >= arr[pos-1]:\n                obj[\"pos\"].append(pos-plateau)\n                obj[\"peaks\"].append(arr[pos])\n                upward = False\n                plateau = 0\n            else:\n                plateau = 0\n            pos += 1\n        else:\n            if arr[pos] < arr[pos+1]:\n                upward = True\n            pos += 1\n    \n    return obj\n    \n    \n", "def pick_peaks(arr):\n    #your code here\n    pos = []\n    prob_peak = False\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i-1]:\n            prob_peak = i\n        elif prob_peak and arr[prob_peak] > arr[i]:\n            pos.append(prob_peak)\n            prob_peak = False\n    return {\"pos\":pos, \"peaks\":[arr[i] for i in pos]}", "def pick_peaks(arr):\n    #your code here\n    pos, peaks = [], []\n    for i in range(len(arr)-2):\n        a, b, c = list(range(i, i+3))\n        if pos and peaks[-1] == arr[b]:\n            condition = True\n            for i in range(pos[-1], b):\n                condition = condition and arr[i] == arr[b]\n            if condition is True:\n                continue\n        while arr[a] == arr[b] and a > 0:\n            a -= 1\n        while arr[b] == arr[c] and c < len(arr)-1:\n            c += 1\n        if arr[a] < arr[b] and arr[b] > arr[c]:\n            pos += [b]\n            peaks += [arr[b]]\n    return {\"pos\":pos, \"peaks\":peaks}\n", "def pick_peaks(arr):\n    peaks = {'peaks': [], 'pos': []}\n    if len(arr) == 0:\n        return peaks\n    p = min(arr)\n    pos = 0\n    for i in range(2, len(arr)):\n        if arr[i-1] > arr[i-2] and arr[i-1] >= arr[i]:\n            p = arr[i-1]\n            pos = i-1\n        if arr[i] < p:\n            peaks['peaks'].append(p)\n            peaks['pos'].append(pos)\n            p = min(arr)\n            pos = 0\n    return peaks", "def pick_peaks(arr):\n    pos = []\n    peaks = []\n    if len(arr) > 0:\n        n = 0\n        peak_start = 0\n        curr_height = arr[0]\n        is_descending = True\n        for p in arr:\n            if p > curr_height:\n                is_descending = False\n                curr_height = p\n                peak_start = n\n            elif p == curr_height:\n                pass\n            elif p < curr_height:\n                if not is_descending:\n                    pos.append(peak_start)\n                    peaks.append(curr_height)\n                is_descending = True\n                curr_height = p\n            else:\n                raise Error\n            n += 1\n    return {\"pos\": pos, \"peaks\": peaks}", "def pick_peaks(arr):\n    posPeaks = {'pos': [] , 'peaks': []}\n    for i in range(1, len(arr)-1):\n        if arr[i] > arr[i-1]:\n            if arr[i] > arr[i+1]:\n                posPeaks['pos'].append(i)\n                posPeaks['peaks'].append(arr[i])\n            if arr[i] == arr[i+1]:\n                for x in range(i+2, len(arr)):\n                    if arr[x] < arr[i]:\n                        posPeaks['pos'].append(i)\n                        posPeaks['peaks'].append(arr[i])\n                        break\n                    if arr[x] > arr[i]:\n                        break\n    return posPeaks", "def pick_peaks(arr):\n    ans = {\"pos\":[],\"peaks\":[]}\n    for i in range(1,len(arr)-1):\n        start = None\n        end = None\n        if arr[i-1] == arr[i]:\n            for x in range(i,0,-1):\n                while arr[i-x] != arr[i]:\n                    start = i-x+1\n                    break\n        if arr[i+1] == arr[i]:\n            for y in range(i,len(arr)-1):\n                if arr[y] != arr[i]:\n                    end = y -1\n                    break\n                else:\n                    end = y\n        if start == None: start = i\n        if end == None: end = i\n        if arr[start-1]< arr[start] and arr[end+1] < arr[end]:\n            if start not in ans[\"pos\"]:\n                ans[\"pos\"].append(start)\n                ans[\"peaks\"].append(arr[start])\n    return ans", "def pick_peaks(arr):\n    ans = {\"peaks\" :[] ,\"pos\": []}\n    point = False\n    for i in range(len(arr)):\n        if arr[i]> arr[i-1]:\n            point = i\n        elif arr[i] < arr[i-1] and point:\n            ans[\"pos\"].append(point)\n            ans[\"peaks\"].append(arr[point])\n            point = False\n    return ans\n    #your code here\n", "def pick_peaks(arr):\n    print(arr)\n    ans = {\"pos\":[],\"peaks\":[]}\n    for i in range(1,len(arr)-1):\n        start = None\n        end = None\n        if arr[i-1] == arr[i]:\n            for x in range(i,0,-1):\n                while arr[i-x] != arr[i]:\n                    start = i-x+1\n                    break\n        if arr[i+1] == arr[i]:\n            for y in range(i,len(arr)-1):\n                if arr[y] != arr[i]:\n                    end = y -1\n                    break\n                else:\n                    end = y\n        if start == None: start = i\n        if end == None: end = i\n        if arr[start-1]< arr[start] and arr[end+1] < arr[end]:\n            if start not in ans[\"pos\"]:\n                ans[\"pos\"].append(start)\n                ans[\"peaks\"].append(arr[start])\n        print(\"i:\",i,\"val:\",arr[i],start,end)\n    return ans", "import operator\n\ndef pick_peaks(arr):\n  pos = []\n  peaks = []\n  if len(arr) < 3:\n    return { \"pos\" : [], \"peaks\" : []}\n\n  # substract\n  diff = list(map(operator.sub, arr[1:], arr[:-1]))\n\n  # deal with plateue\n  for i in range(len(diff) - 1, 0, -1):\n    if diff[i-1] == 0:\n      diff[i-1] = diff[i]\n  \n  # find peaks\n  is_peak = lambda a,b: 1 if a*b<0 and a>b else 0\n  muld = list(map(is_peak, diff[:-1], diff[1:]))\n\n  # get positions\n  pos = [i+1 for i,v in enumerate(muld) if v == 1]\n  \n  # get peaks\n  for i in pos:\n    peaks.append(arr[i])\n\n  return { \"pos\" : pos, \"peaks\" : peaks}\n", "def pick_peaks(arr):\n    pospeaks = {\"pos\":[], \"peaks\":[]}\n    \n    for i in range(1, len(arr) - 1):\n        lowerbefore = arr[i - 1] < arr[i]\n        lowerafter = False\n        for j in arr[i:]:\n            if j == arr[i]:\n                continue\n            elif j < arr[i]:\n                lowerafter = True\n                break\n            elif j > arr[i]:\n                break\n        if lowerbefore and lowerafter:\n            pospeaks[\"pos\"].append(i)\n            pospeaks[\"peaks\"].append(arr[i])\n    \n    return pospeaks", "def pick_peaks(lst):\n    res = {'pos': [], 'peaks': []}\n    idx = 0\n    for i in range(1, len(lst) - 1):\n        if lst[i] != lst[idx]:\n            idx = i\n        if idx and lst[idx - 1] < lst[idx] > lst[i + 1]:\n            res['pos'].append(idx)\n            res['peaks'].append(lst[idx])\n    return res", "def pick_peaks(arr):\n    dict = {'pos':[],'peaks':[]}\n    for i in range(1,len(arr)-1):\n        if arr[i] > arr[i-1] and arr[i] >= arr[i+1]:\n            add = True\n            if arr[i] == arr[i+1]:\n                j = i\n                done = False\n                while j < len(arr) and add and not done:\n                    if arr[j] > arr[i]:\n                        add = False\n                    elif arr[j] < arr[i]:\n                        done = True\n                    j += 1\n                if not done:\n                    add = False\n            if add:\n                dict['pos'].append(i)\n                dict['peaks'].append(arr[i])\n    return dict", "def pick_peaks(arr):\n    pos = []\n    peaks = []\n    n = 0\n\n    for i in range(1, len(arr) - 1):\n        if arr[i] > arr[i - 1] and arr[i] > arr[i + 1]:\n            pos.append(i)\n            peaks.append(arr[i])\n\n        # checking plateau cases\n        elif arr[i] > arr[i - 1] and arr[i] == arr[i + 1]:\n            n = 0\n            for j in range(i + 1, len(arr)):\n                # for the values that come after the possible plateau value\n                # check to see that it decreases after staying constant\n\n                if arr[j] == arr[i]:\n                    n += 1\n\n                else:\n                    break\n\n            if i + n + 1 < len(arr) and arr[i + n + 1] < arr[i]:\n\n                pos.append(i)\n                peaks.append(arr[i])\n\n    return {\"pos\": pos, \"peaks\": peaks}", "def pick_peaks(arr):\n    set = {'pos' : [], 'peaks' : []}\n    for i in range(1, len(arr)-1):\n        if arr[i] > arr[i-1] and arr[i] > arr[i+1]:\n            set['pos'].append(i)\n            set['peaks'].append(arr[i])\n        if arr[i] == arr[i+1] and arr[i] > arr[i-1]:\n            for x in range(i+2, len(arr)):\n                if arr[i]<arr[x]:\n                    break\n                if arr[i]>arr[x]:\n                    set['pos'].append(i)\n                    set['peaks'].append(arr[i])\n                    break\n    return set", "def pick_peaks(arr):\n    \n    print('input:{}'.format(arr))\n    if len(arr) < 1:\n        return {\"pos\":[],\"peaks\":[]}\n        \n    #your code here\n    UP     = 0\n    DOWN   = 1\n    FLAT   = 2\n    trends = [\"UP\",\"DOWN\",\"FLAT\"]\n    \n    if arr[0] == arr[1]:\n        trend = FLAT\n    elif arr[0] > arr[1]:\n        trend = DOWN\n    else:\n        trend = UP\n\n    prev = arr[0]  \n    pos = []\n    peaks=[]\n    \n    local_max = None    \n    for i in range(1,len(arr)):\n        if trend == UP:\n            if arr[i] == prev:\n                trend = FLAT\n                local_max =  i-1 #\n            elif arr[i] < prev:\n                trend = DOWN\n                pos.append(i-1)\n                peaks.append(prev)\n        elif trend ==DOWN:\n            if arr[i] == prev:\n                trend = FLAT\n                local_max =  None\n            elif arr[i] > prev:\n                trend = UP\n        elif trend == FLAT:\n            if arr[i] > prev:\n                trend = UP\n            elif arr[i] < prev:\n                if local_max != None:\n                    pos.append(local_max)\n                    peaks.append(prev)\n                trend = DOWN\n  \n        prev = arr[i]\n    \n    #terminated with flat\n    if trend == FLAT:\n        pos=pos[0:]\n        peaks=peaks[0:]\n    return {\"pos\":pos,\"peaks\":peaks}", "def pick_peaks(arr):\n    res = { \"pos\" : [], \"peaks\" : [] }\n    flag = False\n    \n    for i in range( 1, len(arr) - 1 ):\n        if flag:\n            if arr[i] == arr[i+1]:\n                continue\n            elif arr[i] > arr[i+1]:\n                res[\"pos\"].append(temp)\n                res[\"peaks\"].append(arr[i])\n                flag = False\n            else:\n                flag = False\n        \n        elif arr[i] > arr[i-1]:\n            if arr[i] > arr[i+1]:\n                res[\"pos\"].append(i)\n                res[\"peaks\"].append(arr[i])\n            elif arr[i] == arr[i+1]:\n                temp = i\n                flag = True\n                \n    return res\n", "def pick_peaks(arr):\n    r = {'pos' : [], 'peaks' : []}\n    state = 'none'\n    c = 1\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i-1]:\n            state = 'up'\n        elif arr[i] == arr[i-1]:\n            if state == 'still':\n                c+=1\n            if state == 'up':\n                state = 'still'\n        elif arr[i] < arr[i-1]:\n            if state == 'up':\n                r['pos'].append(i-1)\n                r['peaks'].append(arr[i-1])\n            elif state == 'still':\n                r['pos'].append(i-c-1)\n                r['peaks'].append(arr[i-c-1])\n            state = 'down'\n    return r", "def pick_peaks(arr):\n    pos = []\n    peaks = []\n    if arr:\n        cur = arr[0]\n        cur_pos = 0\n        for i in range(1, len(arr)):\n            if arr[i] > arr[i-1]:\n                cur = arr[i]\n                cur_pos = i\n            elif arr[i] < cur and cur_pos != 0:\n                pos.append(cur_pos)\n                peaks.append(cur)\n                cur_pos = 0\n    return {\n        'pos': pos,\n        'peaks': peaks\n    }", "def pick_peaks(arr):\n    pos, peaks = [], []\n\n    for i in range(1, len(arr) - 1):\n        if arr[i] >= arr[i + 1]:\n            k = i\n            while k < len(arr) - 2 and arr[k] == arr[k + 1]:\n                k += 1\n            if arr[i - 1] < arr[i] and arr[i] > arr[k + 1]:\n                pos.append(i)\n                peaks.append(arr[i])\n    \n    return {\"pos\": pos, \"peaks\": peaks}\n", "def pick_peaks(arr):\n    out = {'pos': [], 'peaks': []}\n    \n    for i in range(1, len(arr) - 1):\n        plateau_idx = i+1\n        if arr[i-1] < arr[i] == arr[i+1]: # might be at a plateau peak\n            while plateau_idx < len(arr):\n                if arr[plateau_idx] == arr[i]:\n                    plateau_idx += 1\n                else:\n                    break\n        if plateau_idx < len(arr) and arr[i-1] < arr[i] > arr[plateau_idx]: # unique peak\n            out['pos'].append(i)\n            out['peaks'].append(arr[i])\n    return out", "def pick_peaks(a):\n    #your code here\n    \n    previous = 0 \n    current = 0\n    \n    pos = []\n    peaks = []\n    \n    for next in range(1,len(a)):\n        if a[next] > a[current]:\n            previous = current\n            current = next\n        else:\n            if a[next] < a[current]:\n                if a[previous] < a[current]:\n                    pos.append(current)\n                    peaks.append(a[current])\n                previous = current\n                current = next\n            \n    \n    \n            \n    return {\"pos\": pos, \"peaks\": peaks}\n    \n    \n", "\ndef pick_peaks(arr):\n    pos = []\n    peaks = []\n    for x in range(len(arr)):\n        if x != 0 and x!= len(arr)-1:\n            if arr[x] > arr[x-1] and arr[x] > arr[x+1]:\n                pos.append(x)\n                peaks.append(arr[x])\n            elif arr[x] > arr[x-1] and arr[x] >= arr[x+1]:\n                \n                \n                for y in arr[x:]:\n                    print((y, x, arr[x], arr[x:]))\n                    if arr[x] > y:\n                        pos.append(x)\n                        peaks.append(arr[x])\n                        break\n                    elif arr[x]< y:\n                        break\n                \n\n    return {\"pos\": pos, \"peaks\":peaks}\n                \n", "def pick_peaks(arr):\n    pos = []\n    peaker = None\n    for i in range(1 ,len(arr)):\n        if arr[i-1] < arr[i]:\n            peaker = i\n        elif arr[i-1] > arr[i] and peaker:\n            pos.append(peaker)\n            peaker = None\n    return {'pos':pos, 'peaks':[arr[i] for i in pos]}", "def pick_peaks(arr):\n    return_dict = {\"pos\": [], \"peaks\": []}\n    fall = False\n    peak = False\n    plateaus_after_peak = False\n    plateaus = False\n    plateaus_pos = 0\n\n    for position, current in enumerate(arr):\n\n        if position == 0:\n            print(f\"[{position}] {current} - START\")\n        elif position == len(arr) - 1:\n            print(f\"[{position}] {current} - END\")\n\n        else:\n\n            next = arr[position + 1]\n            previous = arr[position - 1]\n\n            if previous > current < next:\n                fall = True\n                peak = False\n                plateaus_after_peak = False\n                plateaus = False\n                print(f\"[{position}] {current} - Fell!\")\n\n            elif previous > current > next:\n                fall = True\n                peak = False\n                plateaus_after_peak = False\n                plateaus = False\n                print(f\"[{position}] {current} - Falling...\")\n\n            elif previous < current < next:\n                fall = False\n                peak = False\n                plateaus_after_peak = False\n                plateaus = False\n                print(f\"[{position}] {current} - Rising...\")\n\n            elif previous < current == next:\n                fall = False\n                peak = True\n                plateaus_after_peak = False\n                plateaus = True\n                plateaus_pos = position\n                print(f\"[{position}] {current} - Plateaus start!\")\n\n            elif previous == current > next:\n\n                if position == 1:\n                    print(f\"[{position}] {current} - End of starting plateaus!\")\n\n                # je\u015bli nie drugi i nie przedostatni\n                elif position != 1 and position != len(arr) - 2:\n\n                    if plateaus_after_peak:\n                        fall = True\n                        peak = False\n                        plateaus_after_peak = False\n                        plateaus = False\n                        print(f\"[{position}] {current} - Plateus End after peak - Falling...\")\n\n                    else:\n                        fall = True\n                        peak = False\n                        plateaus_after_peak = False\n                        plateaus = False\n                        print(f\"[{position}] {current} - End of plateaus! Falling, saving the start of plateaus!\")\n                        return_dict[\"pos\"].append(plateaus_pos)\n                        return_dict[\"peaks\"].append(current)\n                elif position == len(arr) - 2 and current > next and not plateaus_after_peak:\n                    fall = True\n                    peak = False\n                    plateaus_after_peak = False\n                    plateaus = False\n                    print(f\"[{position}] {current} - End of plateaus! Falling, saving the start of plateaus!\")\n                    return_dict[\"pos\"].append(plateaus_pos)\n                    return_dict[\"peaks\"].append(current)\n\n            elif previous > current == next:\n                fall = False\n                peak = False\n                plateaus_after_peak = True\n                plateaus = True\n                print(f\"[{position}] {current} - Plateus start after a peak!\")\n\n            elif previous < current > next:\n                fall = False\n                peak = True\n                plateaus_after_peak = False\n                plateaus = False\n                print(f\"[{position}] {current} - Its a peak! Saving\")\n                return_dict[\"pos\"].append(position)\n                return_dict[\"peaks\"].append(current)\n\n            elif previous == current == next:\n                fall = False\n                plateaus = True\n                print(f\"[{position}] {current} - Plateus Flat!\")\n            elif previous == current < next:\n                if plateaus_after_peak:\n                    fall = True\n                    peak = False\n                    plateaus_after_peak = False\n                    plateaus = False\n                    print(f\"[{position}] {current} - Plateus End after peak - Rising...\")\n            elif plateaus:\n                if position + 1 == len(arr) - 1: #jesli nie jest przedostatni\n                    if not plateaus_after_peak:\n                        fall = False\n                        peak = True\n                        plateaus_after_peak = False\n                        plateaus = False\n                        print(f\"[{position}] {current} - Plateus Before End\")\n                        return_dict[\"pos\"].append(plateaus_pos)\n                        return_dict[\"peaks\"].append(current)\n                    else:\n                        print(f\"[{position}] {current} - X1!\")\n                else:\n                    print(f\"[{position}] {current} - X2!\")\n\n            else:\n                print(f\"[{position}] {current} - OUTSIDE!\")\n\n    return return_dict", "def pick_peaks(arr):\n    pos = []\n    peak = []\n    peaking = False\n    platu = None\n    for (count, item) in enumerate(arr):\n        try:\n            if arr[count] < arr[count + 1]:\n                peaking = True\n                platu = None\n            elif arr[count] == arr[count + 1] and peaking:\n                platu = count\n                peaking = False\n            elif peaking:\n                pos.append(count)\n                peak.append(item)\n                peaking = False\n            elif platu and arr[count+1] > arr[count]:\n                platu = None\n                peaking = True\n            elif platu and arr[count+1] < arr[count]:\n                pos.append(platu)\n                peak.append(arr[platu])\n                platu = None\n                peaking = False\n            else:\n                pass\n        except IndexError:\n            break\n    return {'pos': pos, 'peaks': peak}\n", "def pick_peaks(arr):\n    dct = {\"pos\": [], \"peaks\": []}\n    for i in range(1, len(arr) - 1):\n        if arr[i-1] < arr[i] and arr[i] > arr[i+1]:\n            dct[\"pos\"].append(i)\n    plateau_peak(arr, dct)\n    dct[\"pos\"].sort()\n    dct[\"peaks\"] = [arr[x] for x in dct[\"pos\"]]\n    return dct\n\ndef plateau_peak(arr, dct):\n    last = 0\n    for i in range(1, len(arr) - 1):\n        if arr[i] == arr[i+1]:\n            continue\n        elif arr[i] > arr[i+1] and arr[i] == arr[i-1] and arr[i] > arr[last]:\n            dct[\"pos\"].append(last+1)\n            last = i\n        else:\n            last = i", "def pick_peaks(arr):\n    if not arr: \n        return {\"pos\":[],\"peaks\":[]}\n    else: \n        peak_pos = []\n        peak_value = []\n        value = 0\n        for i in range(1,len(arr)-1):\n            if (arr[i-1] < arr[i]) and (arr[i+1] < arr[i]):\n                peak_pos.append(i)\n                peak_value.append(arr[i])\n            if (arr[i-1] < arr[i]) and (arr[i+1] == arr[i]):\n                for j in range(i+1,len(arr)):\n                    if (arr[j] < arr[i]):\n                        peak_pos.append(i)\n                        peak_value.append(arr[i])      \n                        print(('value added',i,j))\n                        break\n                    if (arr[j] > arr[i]):\n                        break\n                    \n                        \n        return {\"pos\":peak_pos,\"peaks\":peak_value}\n            \n", "def check(arr, n):\n    for num in arr:\n        if num < n: return True\n        elif num > n: return False\n    return False\n    \ndef pick_peaks(arr):\n    data = {\"pos\": [], \"peaks\": []}\n    for i, n in enumerate(arr[1:-1], 1):\n        if arr[i-1] < n >= arr[i+1] and check(arr[i:], n):\n            data[\"pos\"] += [i]\n            data[\"peaks\"] += [n]\n\n    return data", "def pick_peaks(arr):\n    pos = []\n    peaks = []\n    \n    local_max = 0\n    for i in range(1, len(arr) - 1):\n        if arr[i - 1] < arr[i]:\n            local_max = i\n        \n        if arr[i - 1] <= arr[i] > arr[i + 1] and local_max not in pos and local_max != 0:\n            pos.append(local_max)\n            peaks.append(arr[local_max])\n    \n    return {'pos': pos, 'peaks': peaks}", "def pick_peaks(arr):\n\n    pos=list()\n    peaks=list()\n    j=0\n    \n    for i in range(1, len(arr)-1):\n        \n        if (arr[i-1]<arr[i]) and (arr[i+1]<arr[i]):\n            pos.append(i)\n            peaks.append(arr[i])\n\n        elif arr[i-1]<arr[i] and arr[i]==arr[i+1] and i+1<len(arr)-1:\n            pos.append(i)\n            peaks.append(arr[i])\n            j=1\n\n        elif j==1 and ((arr[i-1]==arr[i] and arr[i]<arr[i+1]) or \\\n                       (arr[i]==arr[i+1] and i+1==len(arr)-1)):\n            pos.pop()\n            peaks.pop()\n            j=0\n\n    return {'pos': pos, 'peaks': peaks}\n", "def pick_peaks(arr):\n    results = {'pos': [], 'peaks': []}\n    \n    for i in range(1, len(arr)-1):\n        if is_peak(arr, i):\n            results['pos'].append(i)\n            results['peaks'].append(arr[i])\n    \n    return results\n\n\ndef get_direction(last, i):\n    if i > last:\n        return 1\n    elif i == last:\n        return 0\n    else:\n        return -1\n    \n    \ndef is_peak(arr, index):\n    result = False\n    cur_val = arr[index]\n    \n    if get_direction(cur_val, arr[index -1]) < 0:\n        for i in range(index, len(arr)):\n            dir = get_direction(cur_val, arr[i])\n            if dir < 0:\n                result = True\n                break\n            elif dir > 0:\n                result = False\n                break\n    \n    return result\n", "def pick_peaks(arr):\n    result = {\n        \"pos\": [],\n        \"peaks\": []\n    }\n\n    for pos, val in enumerate(arr):\n        if pos == 0 or pos == len(arr) - 1:\n            continue\n        if arr[pos+1] > val:\n            continue\n        if arr[pos-1] == val:\n            continue\n        if arr[pos+1] == val and arr[pos-1] < val:\n            for i in range(pos+1, len(arr)):\n                if arr[i] == val:\n                    continue\n                elif arr[i] > val:\n                    break\n                else:\n                    result['pos'].append(pos)\n                    result['peaks'].append(val)\n                    break\n            continue\n        if arr[pos-1] < val:\n            result['pos'].append(pos)\n            result['peaks'].append(val)\n            \n    return result\n    \n", "def pick_peaks(arr):\n    setThis = False\n    pos = []\n    peaks = []\n    print([x for x in range(len(arr))])\n    print(arr)\n    for i in range(1,len(arr)-1):\n        if arr[i] > arr[i-1] and arr[i] > arr[i+1]:\n            pos.append(i)\n            peaks.append(arr[i])\n        elif arr[i] > arr[i-1] and arr[i] == arr[i+1]:\n            j = i+1\n            while arr[j] == arr[i] and j < len(arr)-1:\n                j += 1\n            if j == len(arr) or arr[j] < arr[i] :\n                pos.append(i)\n                peaks.append(arr[i])\n                i = j\n    print(pos)\n    print(peaks)\n    res = { \"pos\": pos, \"peaks\": peaks}\n    return res"]