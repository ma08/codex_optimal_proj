["import sys\ninput = sys.stdin.readline\n\ndef search(i,j):\n    L=[]\n\n    c=0\n\n    while CHECK[i][j]==1<<30:\n        L.append((i,j))\n        \n        CHECK[i][j]=c\n\n        if MAP2[i][j]==\"U\":\n            i-=1\n        elif MAP2[i][j]==\"D\":\n            i+=1\n        elif MAP2[i][j]==\"R\":\n            j+=1\n        else:\n            j-=1\n\n        c+=1\n\n    if (i,j) in L:\n        x=CHECK[i][j]\n        y=CHECK[L[-1][0]][L[-1][1]]\n        loop=abs(x-y)+1\n\n        for x,y in L:\n            CHECK[x][y]%=loop\n            LOOP[x][y]=loop\n\n    else:\n        loop=LOOP[i][j]\n        c=CHECK[i][j]\n\n        for x,y in L[::-1]:\n            c=(c-1)%loop\n            CHECK[x][y]=c\n            LOOP[x][y]=loop\n\ndef search2(i,j):\n    Q=[(i,j)]\n    ANS=[0]*LOOP[i][j]\n\n    while Q:\n        x,y=Q.pop()\n\n        if USE[x][y]==1:\n            continue\n        \n        USE[x][y]=1\n        if MAP[x][y]==\"0\":\n            ANS[CHECK[x][y]]=1\n\n        if MAP2[x][y]==\"U\":\n            Q.append((x-1,y))\n        elif MAP2[x][y]==\"D\":\n            Q.append((x+1,y))\n        elif MAP2[x][y]==\"R\":\n            Q.append((x,y+1))\n        else:\n            Q.append((x,y-1))\n\n\n        if 0<=x+1<n and 0<=y<m and MAP2[x+1][y]==\"U\":\n            Q.append((x+1,y))\n            \n        if 0<=x-1<n and 0<=y<m and MAP2[x-1][y]==\"D\":\n            Q.append((x-1,y))\n            \n        if 0<=x<n and 0<=y+1<m and MAP2[x][y+1]==\"L\":\n            Q.append((x,y+1))\n            \n        if 0<=x<n and 0<=y-1<m and MAP2[x][y-1]==\"R\":\n            Q.append((x,y-1))\n\n    return LOOP[i][j],sum(ANS)\n\n\nt=int(input())\nfor tests in range(t):\n    n,m=list(map(int,input().split()))\n    MAP=[input().strip() for i in range(n)]\n    MAP2=[input().strip() for i in range(n)]\n\n    CHECK=[[1<<30]*m for i in range(n)]\n    LOOP=[[1<<30]*m for i in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            if CHECK[i][j]==1<<30:\n                search(i,j)\n\n                #print(i,j)\n\n    #print(CHECK)\n    #print(LOOP)\n\n    USE=[[0]*m for i in range(n)]\n\n    ANSM=0\n    ANSC=0\n\n    for i in range(n):\n        for j in range(m):\n            if USE[i][j]==0:\n                x,y=search2(i,j)\n                ANSM+=x\n                ANSC+=y\n    print(ANSM,ANSC)\n                \n            \n    \n    \n", "import sys\nfrom collections import deque\ninput = sys.stdin.readline\n\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    s = [input() for i in range(n)]\n    grid = [input() for i in range(n)]\n    robot_cnt = 0\n    black_cnt = 0\n    \n    graph = [-1] * (n * m)\n    rev_graph = [[] for i in range(n * m)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == \"U\":\n                graph[i * m + j] = (i - 1) * m + j\n                rev_graph[(i - 1) * m + j].append(i * m + j)\n            elif grid[i][j] == \"R\":\n                graph[i * m + j] = i * m + (j + 1)\n                rev_graph[i * m + (j + 1)].append(i * m + j)\n            elif grid[i][j] == \"D\":\n                graph[i * m + j] = (i + 1) * m + j\n                rev_graph[(i + 1) * m + j].append(i * m + j)\n            elif grid[i][j] == \"L\":\n                graph[i * m + j] = i * m + (j - 1)\n                rev_graph[i * m + (j - 1)].append(i * m + j)\n\n    is_start = [True] * (n * m)\n    for i in graph:\n        is_start[i] = False\n\n    is_cycle = [False] * (n * m)\n    period = [0] * (n * m)\n    for i in range(n * m):\n        if not is_start[i]:\n            continue\n        st = i\n        period[i] = 1\n        while True:\n            nxt_i = graph[i]\n            if period[nxt_i] < 0:\n                tmp = period[nxt_i]\n                break\n            if period[nxt_i] > 0:\n                tmp = -(period[i] - period[nxt_i] + 1)\n                is_cycle[nxt_i] = True\n                break\n            period[graph[i]] = period[i] + 1\n            i = graph[i]\n        i = st\n        period[i] = tmp\n        while True:\n            nxt_i = graph[i]\n            if period[nxt_i] < 0:\n                break\n            period[graph[i]] = tmp\n            i = graph[i]\n\n    # cycle without side road\n    for i in range(n * m):\n        if period[i] == 0:\n            robot_cnt += 1\n            if s[i // m][i % m] == \"0\":\n                black_cnt += 1\n                \n    # cycle with road\n    for i in range(n * m):\n        if not is_cycle[i]:\n            continue\n        MOD = - period[i]\n        period[i] = 0\n        is_black = [False] * MOD\n        if s[i // m][i % m] == \"0\":\n            is_black[0] = True\n        q = deque([i])\n        while q:\n            v = q.pop()\n            for nxt_v in rev_graph[v]:\n                if period[nxt_v] >= 0:\n                    continue\n                period[nxt_v] = (period[v] + 1) % MOD\n                if s[nxt_v // m][nxt_v % m] == \"0\":\n                    is_black[period[nxt_v]] = True\n                q.append(nxt_v)  \n        robot_cnt += MOD\n        black_cnt += sum(is_black)\n\n    print(robot_cnt, black_cnt)", "import sys\n\n_INPUT_LINES = sys.stdin.read().splitlines()\ninput = iter(_INPUT_LINES).__next__\n\n\n\ndef go():\n    # n = int(input())\n    n,m = list(map(int, input().split()))\n    c=''.join(input() for _ in range(n))\n    s=''.join(input() for _ in range(n))\n\n    nm = n * m\n    done = [False] * nm\n    groups = [None] * nm\n    phase = [-1]*nm\n\n    def step(pos,direct=None):\n        if direct is None:\n            direct=s[pos]\n        if direct=='U':\n            return pos-m\n        if direct=='D':\n            return pos+m\n        if direct=='L':\n            return pos-1\n        if direct=='R':\n            return pos+1\n\n    cyc_len={}\n\n    for i in range(nm):\n        if not done[i]:\n            same = {}\n            pos=0\n            cur=i\n            group=-1\n            pcur=None\n            while cur not in same:\n                if groups[cur] is not None:\n                    group=groups[cur]\n                    pcur=pos+phase[cur]\n                    break\n                same[cur]=pos\n                done[cur]=True\n                cur=step(cur)\n                pos+=1\n            else:\n                group=cur\n                cyc_len[group]=len(same)-same[cur]\n                pcur=pos\n\n            for ss,pos in list(same.items()):\n                groups[ss]=group\n                phase[ss]=(pcur-pos)%cyc_len[group]\n\n    blacks =  len(set((pp,gg)for cc,pp,gg in zip(c,phase,groups) if cc=='0'))\n    # print('ppp',phase)\n    # print(groups)\n    # print('--',cyc_len)\n\n    return f'{sum(cyc_len.values())} {blacks}'\n\n# x,s = map(int,input().split())\nt = int(input())\n# t = 1\nans = []\nfor _ in range(t):\n    # print(go())\n    ans.append(str(go()))\n#\nprint('\\n'.join(ans))\n", "import sys\n\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef SI(): return sys.stdin.readline()[:-1]\n\ndef main():\n    for _ in range(II()):\n        h,w=MI()\n        cc=[list(map(int,list(SI()))) for _ in range(h)]\n        ss=[SI() for _ in range(h)]\n        aa=[[0]*w for _ in range(h)]\n        mm=[[0]*w for _ in range(h)]\n        cyc=[0]\n        ci=1\n        dir=\"UDLR\"\n        dij=[(-1,0),(1,0),(0,-1),(0,1)]\n        for si in range(h):\n            for sj in range(w):\n                if aa[si][sj]!=0:continue\n                i,j=si,sj\n                d=-1\n                stack=[]\n                while aa[i][j]==0:\n                    aa[i][j]=d\n                    stack.append((i,j))\n                    d-=1\n                    di,dj=dij[dir.index(ss[i][j])]\n                    i,j=i+di,j+dj\n                if aa[i][j]>0:\n                    a=aa[i][j]\n                    dist=cyc[a]\n                    m=(mm[i][j]+1)%dist\n                    for i,j in stack[::-1]:\n                        aa[i][j]=a\n                        mm[i][j]=m\n                        m=(m+1)%dist\n                else:\n                    dist=aa[i][j]-d\n                    cyc.append(dist)\n                    m=0\n                    for i, j in stack[::-1]:\n                        aa[i][j] = ci\n                        mm[i][j]=m\n                        m=(m+1)%dist\n                    ci+=1\n        #print(cyc)\n        #p2D(aa)\n        one=[set() for _ in range(ci)]\n        for i in range(h):\n            for j in range(w):\n                if cc[i][j]==0:\n                    one[aa[i][j]].add(mm[i][j])\n        #print(one)\n        ans1=sum(cyc)\n        ans2=sum(min(ck,len(ok)) for ck,ok in zip(cyc,one))\n        print(ans1,ans2)\n\nmain()", "import sys\n\n_INPUT_LINES = sys.stdin.read().splitlines()\ninput = iter(_INPUT_LINES).__next__\n\n\n\ndef go():\n    # n = int(input())\n    n,m = map(int, input().split())\n    c=''.join(input() for _ in range(n))\n    s=''.join(input() for _ in range(n))\n\n    nm = n * m\n    done = [False] * nm\n    groups = [None] * nm\n    phase = [-1]*nm\n\n    def step(pos,direct=None):\n        if direct is None:\n            direct=s[pos]\n        if direct=='U':\n            return pos-m\n        if direct=='D':\n            return pos+m\n        if direct=='L':\n            return pos-1\n        if direct=='R':\n            return pos+1\n\n    cyc_len={}\n\n    for i in range(nm):\n        if not done[i]:\n            same = {}\n            pos=0\n            cur=i\n            group=-1\n            pcur=None\n            while cur not in same:\n                if groups[cur] is not None:\n                    group=groups[cur]\n                    pcur=pos+phase[cur]\n                    break\n                same[cur]=pos\n                done[cur]=True\n                cur=step(cur)\n                pos+=1\n            else:\n                group=cur\n                cyc_len[group]=len(same)-same[cur]\n                pcur=pos\n\n            for ss,pos in same.items():\n                groups[ss]=group\n                phase[ss]=(pcur-pos)%cyc_len[group]\n\n    blacks =  len(set((pp,gg)for cc,pp,gg in zip(c,phase,groups) if cc=='0'))\n    # print('ppp',phase)\n    # print(groups)\n    # print('--',cyc_len)\n\n    return f'{sum(cyc_len.values())} {blacks}'\n\n# x,s = map(int,input().split())\nt = int(input())\n# t = 1\nans = []\nfor _ in range(t):\n    # print(go())\n    ans.append(str(go()))\n#\nprint('\\n'.join(ans))", "import sys\nfrom collections import deque\nimport gc\n\n\ndef findCycle(source, getNbr):\n    q = deque([source])\n    parent = {source: None}\n    while q:\n        node = q.popleft()\n        for nbr in getNbr(node):\n            if nbr not in parent:\n                q.append(nbr)\n                parent[nbr] = node\n            else:\n                cycle = [node]\n                while parent[node] != nbr:\n                    node = parent[node]\n                    cycle.append(node)\n                cycle.append(nbr)\n                return cycle[::-1]\n\n\ndef markTime(cycle, getNbr):\n    cycleLen = len(cycle)\n    q = deque(cycle)\n    dist = {x: cycleLen - 1 - i for i, x in enumerate(cycle)} # distance to reach cycle[-1]\n    while q:\n        node = q.popleft()\n        d = dist[node]\n        for nbr in getNbr(node):\n            if nbr not in dist:\n                q.append(nbr)\n                dist[nbr] = (d + 1) % cycleLen\n    return dist\n\n\ndef solve(R, C, grid, directions):\n    BLACK = 0\n    drdc = {\n        \"U\": [-1, 0],\n        \"R\": [0, 1],\n        \"D\": [1, 0],\n        \"L\": [0, -1],\n    }\n\n    def getNbr(i):\n        r, c = divmod(i, C)\n        dr, dc = drdc[directions[r][c]]\n        return [(r + dr) * C + (c + dc)]\n\n    def getNbrT(i):\n        r, c = divmod(i, C)\n        ret = []\n        for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nr = r + dr\n            nc = c + dc\n            if 0 <= nr < R and 0 <= nc < C:\n                if [-dr, -dc] == drdc[directions[nr][nc]]:\n                    ret.append(nr * C + nc)\n        return ret\n\n    ans1 = 0\n    ans2 = 0\n    seen = set()\n    for i in range(R * C):\n        if i not in seen:\n            # BFS until found cycle\n            cycle = findCycle(i, getNbr)\n            uniqueTimes = len(cycle)\n            # Find all nodes going to cycle\n            # Each starting node going into cycle will have a collision timestamp mod cycle len\n            dist = markTime(cycle, getNbrT)\n            uniqueBlackTimes = set()\n            for j, t in list(dist.items()):\n                r, c = divmod(j, C)\n                if grid[r][c] == BLACK:\n                    uniqueBlackTimes.add(t)\n                seen.add(j)\n            ans1 += uniqueTimes\n            ans2 += len(uniqueBlackTimes)\n            del cycle\n            del dist\n            del uniqueBlackTimes\n\n    return str(ans1) + \" \" + str(ans2)\n\n\ndef __starting_point():\n    input = sys.stdin.readline\n\n    T = int(input())\n    for t in range(T):\n        R, C = [int(x) for x in input().split()]\n        grid = [list(map(int, input().rstrip())) for r in range(R)]\n        directions = [list(input().rstrip()) for r in range(R)]\n\n        ans = solve(R, C, grid, directions)\n        print(ans)\n\n__starting_point()"]