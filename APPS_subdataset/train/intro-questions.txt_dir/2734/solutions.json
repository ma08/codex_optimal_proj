["from itertools import combinations\nfrom math import hypot\n\ndef peaceful_yard(yard, d):\n  cats = ((i, j) for i,r in enumerate(yard) for j,c in enumerate(r) if c in 'LMR')\n  return all(hypot(q[0] - p[0], q[1] - p[1]) >= d for p,q in combinations(cats, 2))", "def peaceful_yard(yard, min_distance):\n    # Extract cat positions\n    cats = {ch: (r, c) for r, row in enumerate(yard) for c, ch in enumerate(row) if ch != \"-\"}\n    if len(cats) < 2:\n        return True\n    # Extract coordinates amd calculate euclidean distances between them\n    coords = list(cats.values())\n    euc_dist = lambda x, y: ((x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2) ** 0.5\n    r = list(range(len(coords)))\n    dists = [euc_dist(coords[i], coords[j]) for i in r for j in r if i < j]\n    # Check minimum distance against required minimum\n    return min_distance <= min(dists)\n", "def distance(xxx_todo_changeme, xxx_todo_changeme1):\n    (x, y) = xxx_todo_changeme\n    (x2, y2) = xxx_todo_changeme1\n    return ((x2 - x) ** 2 + (y2 - y) ** 2) ** 0.5\n\n\ndef peaceful_yard(yard, min_distance):\n    cats = []\n    for r, row in enumerate(yard):\n        for c, col in enumerate(row):\n            if col != '-':\n                current = (r, c)\n                if any(distance(current, cat) < min_distance for cat in cats):\n                    return False\n                cats.append(current)\n    return True\n", "def peaceful_yard(yard, min_distance):\n    cats = [x+y*1j for y, l in enumerate(yard) for x, c in enumerate(l) if c != '-']\n    return all(abs(a - b) >= min_distance for i, a in enumerate(cats) for b in cats[:i])", "def euclidean_distance(cell, goal):\n    dx = abs(cell[0] - goal[0])\n    dy = abs(cell[1] - goal[1])\n    return (dx**2 + dy**2)**.5\n\ndef peaceful_yard(yard, min_distance):\n    coord = []\n    for x in range(len(yard)):\n        for y in range(len(yard[x])):\n            if yard[x][y] in {'L','R','M'}:\n                if any(euclidean_distance(cat_pos, (x,y)) < min_distance for cat_pos in coord):\n                    return False\n                coord.append((x,y))\n    return True", "from itertools import combinations\nfrom math import hypot\n\n\ndef peaceful_yard(yard, min_distance):\n    l, yard = len(yard[0]), \"\".join(yard)\n    cats = (divmod(yard.index(c), l) for c in \"LMR\" if c in yard)\n    distances = (hypot(x2-x1, y2-y1) for (x1, y1), (x2, y2) in combinations(cats, 2))\n    return all(min_distance <= d for d in distances)\n    \n\n# one-liner\n#peaceful_yard = lambda y, m: all(m <= d for d in (hypot(x2-x1, y2-y1) for (x1, y1), (x2, y2) in combinations((divmod(i, len(y[0])) for i, c in enumerate(\"\".join(y)) if c != \"-\"), 2)))\n\n# alternatives:\n# more intuitive but much slower:\n#    cats = [divmod(i, l) for i, c in enumerate(yard) if c != \"-\"]\n# less readable but avoid imports:\n#    distances = [((x2-x1)**2 + (y2-y1)**2)**0.5 for i, (x1, y1) in enumerate(cats, 1) for (x2, y2) in cats[i:]]\n", "import math\ndef distance(pos1,pos2):\n    if pos1 and pos2:\n        return math.sqrt((pos2[0]-pos1[0])**2+(pos2[1]-pos1[1])**2)\n\ndef peaceful_yard(yard, min_distance):\n    rPos = None\n    lPos = None\n    mPos = None\n    counter = 0\n    for i in range(len(yard)):\n        if yard[i].find(\"L\") != -1:\n            lPos = (i,yard[i].find(\"L\"))\n            counter += 1\n        if yard[i].find(\"R\") != -1:\n            rPos = (i,yard[i].find(\"R\")) \n            counter += 1\n        if yard[i].find(\"M\") != -1:\n            mPos = (i,yard[i].find(\"M\"))\n            counter += 1\n    if counter <= 1:\n        return True\n    else:\n        distances = [distance(rPos,lPos), distance(lPos,mPos), distance(rPos,mPos)]\n        for dist in distances:\n            if (dist and dist < min_distance):\n                return False\n        return True", "from itertools import combinations\nfrom math import hypot\n\ndef peaceful_yard(yard, min_distance):\n    cats = [\n        (r, c)\n        for r, row in enumerate(yard)\n        for c, x in enumerate(row)\n        if x != '-'\n    ]\n    return all(\n        hypot(a-c, b-d) >= min_distance\n        for (a, b), (c, d) in combinations(cats, 2)\n    )", "from math import hypot\nfrom itertools import combinations\n\ndef peaceful_yard(yard, min_distance):\n    positions = [(yard.index(row), row.index(cat)) for row in yard if row.replace(\"-\", \"\") for cat in row.replace(\"-\", \"\")]\n    return all(hypot(x1-x0, y1-y0) >= min_distance for ((x0, y0), (x1, y1)) in combinations(positions, 2))", "def peaceful_yard(yard, min_distance):\n    from scipy.spatial.distance import euclidean\n\n    cat_positions = [(i, j) for i in range(len(yard)) \n                     for j in range(len(yard[i])) if yard[i][j] in \"LMR\"]\n\n    from itertools import combinations\n    return all(euclidean(cat1, cat2) >= min_distance \n               for cat1, cat2 in combinations(cat_positions, 2))\n"]