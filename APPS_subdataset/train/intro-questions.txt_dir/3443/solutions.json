["def correct(m, n, bits):\n    l = m*n\n    row = next((i for i in range(m) if f\"{bits[i*n:(i+1)*n]}{bits[l+i]}\".count(\"1\") % 2), None)\n    col = next((i for i in range(n) if f\"{bits[i:l:n]}{bits[l+m+i]}\".count(\"1\") % 2), None)\n    if row is col is None:\n        return bits\n    err = (l + row) if col is None else (l + m + col) if row is None else (row * n + col)\n    return f\"{bits[:err]}{int(bits[err])^1}{bits[err+1:]}\"\n", "from functools import reduce\n\ndef correct(m, n, bits):\n        \n    def getDiff(check,lines):\n        return next((i for i,(c,line) in enumerate(zip(check,lines)) if int(c) != reduce(int.__xor__, list(map(int,line)))), -1)\n\n    a = getDiff(bits[-m-n:-n], (bits[i:i+n]   for i in range(0,m*n,n)) )\n    b = getDiff(bits[-n:],     (bits[i:m*n:n] for i in range(n)) )\n    \n    if a+b != -2:\n        i    = a*n+b if a+1 and b+1 else -m-n+a if b==-1 else len(bits)-n+b\n        bits = f'{ bits[:i] }{ int(bits[i])^1 }{ bits[i+1:] }'\n        \n    return bits\n", "from functools import partial, reduce\nfrom itertools import chain\nfrom operator import xor\n\ncalc_parity = partial(reduce, xor)\n\n\ndef correct(m, n, bits):\n    bits = list(map(int, bits))\n    xs = [bits[i*n:(i+1)*n] for i in range(m)]\n    row_parity = bits[m*n:-n]\n    col_parity = bits[-n:]\n    invalid_row = invalid_col = -1\n    for i, (row, p) in enumerate(zip(xs, row_parity)):\n        if calc_parity(row) != p:\n            invalid_row = i\n            break\n\n    xs = [list(col) for col in zip(*xs)]\n    for i, (col, p) in enumerate(zip(xs, col_parity)):\n        if calc_parity(col) != p:\n            invalid_col = i\n            break\n    xs = [list(col) for col in zip(*xs)]\n\n    if invalid_row >= 0 <= invalid_col:\n        xs[invalid_row][invalid_col] = 1 - xs[invalid_row][invalid_col]\n    elif invalid_row >= 0:\n        row_parity[invalid_row] = 1 - row_parity[invalid_row]\n    elif invalid_col >= 0:\n        col_parity[invalid_col] = 1 - col_parity[invalid_col]\n\n    return \"\".join(map(str, chain(chain.from_iterable(xs), row_parity, col_parity,)))", "def correct(m, n, bits):\n    parities = lambda matrix: [sum(row) & 1 for row in matrix]\n    wrong_index = lambda a, b: next((i for i, (x, y) in enumerate(zip(a, b)) if x ^ y), None)\n    \n    bits = list(map(int, bits))\n    message, row_par, col_par = bits[:-m-n], bits[-m-n:-n], bits[-n:]\n    rows = list(zip(* [iter(message)] * n))\n    \n    actual_row, actual_col = parities(rows), parities(zip(*rows))\n    idx_row, idx_col = wrong_index(row_par, actual_row), wrong_index(col_par, actual_col)\n    \n    if idx_row is not None and idx_col is not None:\n        message[idx_row * n + idx_col] = message[idx_row * n + idx_col] ^ 1\n    elif idx_row is not None:\n        row_par[idx_row] = row_par[idx_row] ^ 1\n    elif idx_col is not None:\n        col_par[idx_col] = int(col_par[idx_col]) ^ 1\n\n    return ''.join(map(str, message + row_par + col_par))", "def correct(R,C,Q) :\n    Q = list(map(int,Q))\n    r = next((F for F,V in enumerate(Q[-R - C:-C]) if 1 & sum(Q[F * C:-~F * C]) ^ int(V)),-1)\n    c = next((F for F,V in enumerate(Q[-C:]) if 1 & sum(Q[F:R * C:C]) ^ int(V)),-1)\n    if 0 <= r or 0 <= c : Q[r - R - C if c < 0 else c + (-C if r < 0 else r * C)] ^= 1\n    return ''.join(map(str,Q))", "def correct(m, n, bits):\n    def invert(n):\n        if n == 1:\n            return 0\n        if n == 0:\n            return 1\n        else:\n            return None\n    \n    matrix = []\n    wrong_row = None\n    wrong_col = None\n    \n    n_list = [int(x) for x in bits[m * n + m:]]\n    m_list = [int(x) for x in bits[m * n:m * n + m]]\n    \n    for i in range(m):\n        row = [int(x) for x in bits[n * i: n * i + n]]\n        if sum(row) % 2 != m_list[i]:\n            wrong_row = i\n        matrix.append(row)\n    \n    col = []\n    for j in range(n):\n        for i in range(m):\n            col.append(matrix[i][j])\n        if sum(col) % 2 != n_list[j]:\n            wrong_col = j\n        col = []\n    \n    if wrong_col == None and wrong_row != None:\n        m_list[wrong_row] = invert(m_list[wrong_row])\n    elif wrong_col != None and wrong_row == None:\n        n_list[wrong_col] = invert(n_list[wrong_col])\n    elif wrong_col != None and wrong_row != None:\n        matrix[wrong_row][wrong_col] = invert(matrix[wrong_row][wrong_col])\n    \n    res = ''\n    for matrix_row in matrix:\n        res += ''.join([str(x) for x in matrix_row])\n    \n    res += ''.join([str(x) for x in m_list])\n    res += ''.join([str(x) for x in n_list])\n    return res\n", "def correct(m, n, bits):\n    res=[]\n    for i in range(0, n*m, n):\n        res.append(bits[i:i+n])\n    start=n*m\n    check=[]\n    check.append(next((i for i in range(m) if digit_sum(res[i])%2!=int(bits[start+i])), None))\n    for j in range(n):\n        string=\"\"\n        for i in range(m):\n            string+=res[i][j]\n        if digit_sum(string)%2!=int(bits[start+m+j]):\n            check.append(j)\n            break\n    if len(check)==1:\n        check.append(None)\n    if check[0]==None and check[1]==None:\n        return bits\n    elif check[1]==None:\n        temp=\"0\" if bits[start+check[0]]==\"1\" else \"1\"\n        return bits[:start+check[0]]+temp+bits[start+check[0]+1:]\n    elif check[0]==None:\n        temp=\"0\" if bits[start+m+check[1]]==\"1\" else \"1\"\n        return bits[:start+m+check[1]]+temp+bits[start+m+check[1]+1:]\n    else:\n        temp=\"0\" if res[check[0]][check[1]]==\"1\" else \"1\"\n        return bits[:check[0]*n+check[1]]+temp+bits[check[0]*n+check[1]+1:]\ndef digit_sum(s):\n    return sum(int(i) for i in s)", "import pandas as pd\n\ndef correct(m,n,s):\n    s,r,c = s[:m*n], s[m*n:m*n+m], s[-n:]\n    arr = pd.np.array(list(s)).reshape(m,n)\n    df = pd.DataFrame(arr)\n    row = ''.join(df.eq('1').sum(1).mod(2).astype(str))\n    col = ''.join(df.eq('1').sum(0).mod(2).astype(str))\n    if r != row and c != col:\n        for idx, (i,j) in enumerate(zip(row,r)):\n            if i != j:\n                x = idx\n        for idx, (i,j) in enumerate(zip(col,c)):\n            if i!= j:\n                y = idx\n\n        df = df.astype(int)\n        df.loc[x,y] ^= 1\n        return ''.join(df.astype(str).values.ravel()) + r + c\n        \n    else:   \n        return ''.join(df.values.ravel()) + row + col", "def correct(m, n, bits):\n    failed_row, failed_col = -1, -1\n    for row in range(m):\n        if sum(int(c) for c in bits[row*n:(row+1)*n]) % 2 != int(bits[m*n+row]):\n            failed_row = row\n            break\n    for col in range(n):\n        if sum(int(bits[j]) for j in range(col,len(bits)-n-m,n)) % 2 != int(bits[m*n+m+col]):\n            failed_col = col\n            break\n    if (failed_row, failed_col) == (-1, -1):\n        return bits\n    elif failed_row != -1 and failed_col != -1:\n        index = n*failed_row+failed_col\n    elif failed_row != -1:\n        index = m*n+failed_row\n    else:\n        index = m*n+m+failed_col\n    return bits[:index] + str(1-int(bits[index]))+bits[index+1:]\n        \n", "def correct(m, n, bits):\n    \n    msg = [bits[i*n : (i+1)*n] for i in range(m)]\n    msgt = [''.join([bits[i] for i in range(j, m*n, n)]) for j in range(n)]\n\n    msg_row_parity = ''.join([str(x.count('1')%2) for x in msg])\n    msg_col_parity = ''.join([str(x.count('1')%2) for x in msgt])\n\n    bits_row_parity = bits[-m-n:-n]\n    bits_col_parity = bits[-n:]\n\n    if msg_row_parity == bits_row_parity and msg_col_parity == bits_col_parity: return bits\n    if msg_row_parity == bits_row_parity: return bits[:-n] + msg_col_parity\n    if msg_col_parity == bits_col_parity: return bits[:-m-n] + msg_row_parity + bits[-n:]\n    \n    err_row = [i for i in range(m) if bits_row_parity[i] != msg_row_parity[i]][0]\n    err_col = [i for i in range(n) if bits_col_parity[i] != msg_col_parity[i]][0]\n    \n    err_bit_msg = msg[err_row][err_col]\n    cor_bit = str(abs(int(err_bit_msg) - 1))\n    msg_pos = err_row*n + err_col\n    return bits[:msg_pos] + cor_bit + bits[msg_pos+1:]"]