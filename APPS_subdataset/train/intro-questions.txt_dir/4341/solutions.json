["def solve(a,b):\n    if not (a and b): return [a, b]\n    if a >= 2*b: return solve(a%(2*b), b)\n    if b >= 2*a: return solve(a, b%(2*a))\n    return [a, b]", "def solve(a,b):\n    '''\n    Used the % operator instead of repeated subtraction of a - 2*b or b - 2*a\n    Because as long as a > 2*b, the repeated subtraction has to be done and it will \n    eventually give a % 2*b. Repeated subtration in recursion has the problem of\n    exceeding the recursion depth, so this approach is better\n    '''\n    if a == 0 or b == 0:\n       return [a,b]\n    elif a >= 2*b:\n        return solve(a % (2*b), b)\n    elif b >= 2*a:\n        return solve(a, b % (2*a))\n    else:\n        return [a,b]\n", "def solve(a, b):\n    while a and b:\n        if a >= b * 2:\n            a %= 2 * b\n        elif b >= a * 2:\n            b %= 2 * a\n        else:\n            break\n    return [a, b]", "def solve(a,b):\n    return ([a,b]           if not a or not b else\n            solve(a%(2*b),b)  if a>=2*b else\n            solve(a,b%(2*a))  if b>=2*a else\n            [a,b])", "def solve(a, b):\n    while a and b:\n        if a >= b*2 :     a = a%(b*2)\n        elif b >= a * 2 : b = b%(a*2)\n        else :            break\n    return [a,b]", "def solve(a,b):\n    return [a,b] if a*b==0 or .5<a/b<2 else solve(a%(2*b), b%(2*a))", "def solve(a,b):\n    for _ in range(0,25):\n        if b: a %= 2 * b\n        if a: b %= 2 * a\n    return [a,b]", "def solve(a,b):\n    while a and b and (a >= 2*b or b >= 2*a):\n        if b: a %= 2 * b\n        if a: b %= 2 * a\n    return [a,b]", "def solve(a,b):\n    while a and b:\n        if a >= 2*b:\n            a -= (a//(2*b))*(2*b)\n            print(a)\n        elif b >= 2*a:\n            b -= (b//(2*a))*(2*a)\n        else:\n            break\n    return [a,b]   ", "def solve(a,b):\n    if not (a and b):\n        return [a, b]\n    return solve(a % (2 * b), b) if a >= 2 * b else solve(a, b % (2 * a)) if b >= 2 * a else [a, b]\n\n"]