["from itertools import permutations\n\ndef find_mult_3(num):\n    num_list = tuple(map(int, str(num)))\n    \n    poss = set()\n    for i in range(1, len(num_list)+1):\n        poss |= set(permutations(num_list, i))\n    \n    res = set()\n    for p in poss:\n        if p[0] != 0 and sum(p) % 3 == 0:\n            res.add(p)\n\n    res = [sum(x * 10**n for n, x in enumerate(p[::-1])) for p in res]\n    return [len(res), max(res)]\n", "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom math import factorial\nfrom operator import mul\n\ndef find_mult_3(n):\n    mul_count, digits = 0, sorted(map(int, str(n)))\n    for r in range(1, len(digits) + 1):\n        for comb in sorted({c for c in combinations(digits, r) if not sum(c) % 3}):\n            dig_count = Counter(comb)\n            mul_count += (r - dig_count.get(0, 0)) * factorial(r) // reduce(mul, map(factorial, dig_count.values()), r)\n    return [mul_count, int(''.join(map(str, comb[::-1])))]", "from itertools import permutations\n\ndef find_mult_3(num):\n  ls = []\n  for i in range(1, len(str(num))+1):\n    for j in set(permutations(str(num), i)):\n      ls.append(int(''.join(j)))\n  ls = set(ls)\n  solve = [x for x in ls if x != 0 and x % 3 == 0]\n  return [len(solve), max(solve)]", "from itertools import combinations, permutations\n\ndef find_mult_3(num):\n    n = [int(c) for c in str(num)]\n    r = set()\n    for i in range(1, len(n)+1):\n        for c in combinations(n, i):\n            if sum(c) % 3 == 0:\n                r |= set([int(''.join([str(i) for i in p])) for p in permutations(c) if p[0] != 0])\n    \n    return [len(r), max(r)]", "from itertools import permutations\ndef find_mult_3(s):\n    x = []\n    for i in range(1, len(str(s))+1):\n        x += [int(''.join(p)) for p in list(set(permutations(str(s), i))) if not int(''.join(p)) %3 and p[0] != '0']\n    return [len(x), max(x)]", "from itertools import permutations\ndef find_mult_3(num):\n    # your code here\n    st=str(num)\n    val=[ int(\"\".join(i)) for j in range(1,len(st)+1) for i in set(permutations(st,j)) if int(\"\".join(i))>0 and int(\"\".join(i))%3==0  ]\n    return [len(set(val)),max(val)]", "import itertools\n\ndef find_mult_3(num):\n    total = 0\n    _max  = float(\"-inf\")\n    \n    for lst in get_combos(num):    \n        for i in lst:\n            if i[0] != \"0\":\n                number = int(\"\".join(i))\n                if number % 3 == 0:\n                    total += 1\n                    if number > _max:\n                        _max = number\n    return [total, _max]\n    \ndef get_combos(num):\n    return [set(itertools.permutations(str(num), i)) for i in range(1, len(str(num))+1)]", "from functools import reduce\n\n# get a len = 10 array with occurrences of digits\ndef num_to_arr(num):\n    s = str(num)\n    arr = [0] * 10\n    for c in s:\n        arr[int(c)] += 1\n    return arr\n\n# get an array of distinctive digits in an array as above\ndef dist_digits(arr):\n    dist = []\n    for i in range(0,10):\n        if arr[i] > 0:\n            dist.append(i)\n    return dist\n\n# get all combos given number of digits (m) and an array as above\ndef all_combos(arr, m):\n    combos = []\n    if m == 1:\n        for i in range(1,10):\n            if arr[i] > 0:\n                combos.append([i])\n        return combos\n\n    if m > sum(arr):\n        return []\n\n    digits = dist_digits(arr)\n    for d in digits:\n        nextArr = [0] * 10\n        for i in range(0,10):\n            if i == d:\n                nextArr[i] = arr[i] - 1\n            if i > d:\n                nextArr[i] = arr[i]\n        nextCombos = all_combos(nextArr, m - 1)\n        for nextComb in nextCombos:\n            nextComb.append(d)\n        combos.extend(nextCombos)\n    return combos\n\n# now give all combos with all possible numbers of digits that % 3 == 0\ndef complete_combos(arr):\n    combos = []\n    for i in range(1, len(arr)):\n        combos.extend(all_combos(arr,i))\n    return list([arr for arr in combos if sum(arr) % 3 == 0])\n\ndef fact(n, zeros = 0):\n    if n == 0: return 1\n    if n == 1: return 1\n    return (n - zeros) * fact(n - 1)\n\ndef permus(combo):\n    arr = [0] * 10\n    for digit in combo:\n        arr[digit] += 1\n    duplicates = 1\n    for i in range(0,10):\n        if arr[i] > 1:\n            duplicates *= fact(arr[i])\n    return fact(len(combo), zeros = arr[0]) // duplicates\n\ndef find_mult_3(num):\n    # your code here\n    comp_combos = complete_combos(num_to_arr(num))\n    return [sum(map(permus,comp_combos)), reduce(lambda x,y: x * 10 + y, comp_combos[-1])]\n"]