["from fractions import gcd\nimport re\n\n\nINSERTER = re.compile(r'(?<!\\d)(?=[xyt])')\nFINDER   = re.compile(r'-?\\d+')\n\n\ndef lcm(a,b):    return a*b//gcd(a,b)\ndef simplify(s): return INSERTER.sub('1', s.replace(' ',''))\n\n\ndef para_to_rect(*equations):\n    coefs = [ list(map(int, FINDER.findall(eq))) for eq in map(simplify, equations) ]\n    l     = lcm(coefs[0][1],coefs[1][1])\n    x,tx,cx, y,ty,cy = ( v*l//c[1] for c in coefs for v in c )\n    y, absY, c = -y, abs(y), cx-cy\n    \n    return \"{}x {} {}y = {}\".format(x if x!=1 else '',\n                                    '-' if y<0 else '+',\n                                    absY if absY!=1 else '',\n                                    c)", "from math import gcd\n\ndef para_to_rect(eqn1, eqn2):\n    a, b = eqn1.split('= ')[1].split('t ')\n    c, d = eqn2.split('= ')[1].split('t ')\n    if a in (\"\", \"-\"): a += '1'\n    if c in (\"\", \"-\"): c += '1'\n    a, b, c, d = map(eval, (a, b, c, d))\n    x = gcd(a, c)\n    e, f = c//x, -a//x\n    if e < 0: e, f = -e, -f\n    return f\"{e if e>1 else ''}x {'+-'[f<0]} {abs(f) if abs(f)>1 else ''}y = {e*b + f*d}\"", "import re\nfrom math import gcd\n\ndef para_to_rect(eqn1, eqn2):\n    eqn1, eqn2 = [re.sub(r'\\bt', '1t', e) for e in [eqn1, eqn2]]\n    (a,b), (c,d) = ([[int(x.replace(' ', '')) for x in re.findall('-?\\d+|[-+] \\d+', e)] for e in [eqn1, eqn2]])\n    x = c*b - a*d\n    g = gcd(gcd(c, a), x)\n    if c < 0:\n        g = -g\n    c, a, x = c//g, a//g, x//g\n    return re.sub(r'\\b1([xy])', r'\\1', f'{c}x {\"+-\"[a > 0]} {abs(a)}y = {x}')", "from fractions import gcd\ndef para_to_rect(*equations):\n    changes = [(\" \", \"\"), (\"-t\", \"-1t\"), (\"=t\", \"=+1t\"),\n               (\"+t\", \"+1t\"), (\"x=\", \"\"), (\"y=\", \"\")]\n    equationsR = []\n    for equation in equations:\n        for (s1, s2) in changes:\n            equation = equation.replace(s1, s2)\n        equationsR += equation.split(\"t\")\n    a, b, c, d = [int(n) for n in equationsR]\n    e, f, g = c, -a, b * c - a * d\n    h = gcd(gcd(e, f), g)\n    e, f, g = e // h, f // h, g // h\n    if e < 0:\n        e, f, g = -e, -f, -g\n    ysign = \"+\"\n    if f < 0:\n        ysign, f = \"-\", -f\n    return \"{}x {} {}y = {}\".format(e if abs(e) > 1 else \"-\" if e == -1 else \"\",\\\n      ysign, f if f > 1 else \"\", g)", "def extract(eq):\n    k, b = eq.split('t')\n    k = k[3:].strip()\n    k = (int(k) if k!='-' else -1) if k else 1\n    b = b.strip()\n    b = (-1 if b[0]=='-' else 1)*int(b[1:].strip()) if b else 0\n    return k, b\n\ndef quotient(x):\n    return '' if x==1 else '-' if x==-1 else str(x)\n\nfrom math import gcd\n\ndef para_to_rect(eqn1, eqn2):\n    a,b = extract(eqn1)\n    k,d = extract(eqn2)\n    l = -a\n    m = k*b-a*d\n    g = gcd(gcd(k,l),m)\n    if k*g<0:\n        g = -g\n    k //= g\n    l //= g\n    m //= g\n    return f'{quotient(k)}x {\"+-\"[l<0]} {quotient(abs(l))}y = {m}'\n", "def gcd(x,y):\n    while y:\n        x,y=y,x%y\n    return x\n    \ndef parseeq(s):\n    s=s.split()\n    a=s[2].replace('t','')\n    if a=='': a=1\n    elif a=='-': a=-1\n    else: a=int(a)\n    try:\n        b=int(s[3]+s[4])\n    except:\n        b=0\n    return a,b\n\ndef para_to_rect(eqn1, eqn2):\n    a,b=parseeq(eqn1)\n    c,d=parseeq(eqn2)\n    e=b*c-a*d\n    if c<0: a,c,e = -a,-c,-e\n    g=gcd(a,gcd(abs(c),abs(e)))\n    a,c,e=a//g,c//g,e//g\n    sign='+-'[a>0]\n    if c==1: p1=''\n    elif c=='-1': p1='-'\n    else: p1=c\n    if a==1: p2=''\n    elif a==-1: p2=''\n    else: p2=abs(a)\n    \n    return '{}x {} {}y = {}'.format(p1,sign,p2,e)\n    \n    \n", "import math\nimport re\ndef lcm(a, b):\n    return abs(a*b) // math.gcd(a, b)\ndef para_to_rect(eqn1, eqn2):\n    try:    \n        x_t = int(re.findall(\"\\\\-?\\\\d+?t\", eqn1.replace('-t', '-1t'))[0].split('t')[0])\n    except:\n        x_t = 1\n    try:\n        y_t = int(re.findall(\"\\\\-?\\\\d+?t\", eqn2.replace('-t', '-1t'))[0].split('t')[0])\n    except:\n        y_t = 1\n    \n    l = lcm(x_t, y_t)\n    x_n = abs(l//x_t) * int(re.findall('\\\\-?\\\\d+$', eqn1.replace(\" \", \"\"))[0])\n    y_n = abs(l//y_t) * int(re.findall('\\\\-?\\\\d+$', eqn2.replace(\" \", \"\"))[0])\n       \n    x, y = l//abs(x_t), l//abs(y_t)\n    \n    if((x_t * x) + (y_t * y) == 0):    \n        return '{}x + {}y = {}'.format(x if x!=1 else '', y if y!=1 else '', x_n+y_n)\n    \n    return '{}x - {}y = {}'.format(x if x not in [1, -1] else '', y if y not in [1, -1] else '', x_n-y_n)", "import re\n\nEQUATION_REGEXP = re.compile(r'^[xy]=(-?\\d*)t([+-]\\d+)$')\n\n\ndef parse_coefficient(raw_coef):\n    if not raw_coef:\n        return 1\n    elif raw_coef == '-':\n        return -1\n    return int(raw_coef)\n\n\ndef parse(equation):\n    equation = equation.replace(' ', '')\n    coefficients = EQUATION_REGEXP.match(equation).groups()\n    return list(map(parse_coefficient, coefficients))\n\n\ndef gcd(a, b):\n    return gcd(b, a % b) if b else a\n\n\ndef lcm(a, b):\n    return abs(a * b) / gcd(a, b)\n\n\ndef compile_result(mult_a, mult_b, coefs_a, coefs_b):\n    multiplier = -1 if mult_a < 0 else 1\n\n    A = mult_a * multiplier\n    A = A if A != 1 else ''   \n    \n    B = abs(mult_b) if abs(mult_b) != 1 else ''\n    B_sign = '-' if multiplier * mult_b > 0 else '+'\n    \n    C = multiplier * (mult_a * coefs_a[1] - mult_b * coefs_b[1])\n\n    return f'{A}x {B_sign} {B}y = {C}'\n\n\ndef para_to_rect(equation_a, equation_b):\n    coefs_a = parse(equation_a)\n    coefs_b = parse(equation_b)\n    parameter_lcm = int(lcm(coefs_a[0], coefs_b[0]))\n    mult_a = int(parameter_lcm / coefs_a[0])\n    mult_b = int(parameter_lcm / coefs_b[0])\n    return compile_result(mult_a, mult_b, coefs_a, coefs_b)\n    \n", "import re\nimport math\n\ndef para_to_rect(eqn1, eqn2):\n    a = re.search(r'(-?\\d*)(?=t)', eqn1)\n    if a is None:\n        a = 1\n    else:\n        if a.group(0) == '':\n            a = 1\n        elif a.group(0) == '-':\n            a = -1\n        else:\n            a = int(a.group(0))\n    c = re.search(r'(-?\\d*)(?=t)', eqn2)\n    if c is None:\n        c = 1\n    else:\n        if c.group(0) == '':\n            c = 1\n        elif c.group(0) == '-':\n            c = -1\n        else:\n            c = int(c.group(0))\n    b = re.search(r'[-\\+]? \\d*\\Z', eqn1)\n    if b is None:\n        b = 0\n    else:\n        b = int(b.group(0).replace(' ', ''))\n    d = re.search(r'[-\\+]? \\d*\\Z', eqn2)\n    if b is None:\n        d = 0\n    else:\n        d = int(d.group(0).replace(' ', ''))\n    n = (a * c) // math.gcd(a, c)\n    k = (-1 if c < 0 else 1)\n    x =  k * n // a\n    y =  -k * n // c\n    z = k * b * n // a - k * d * n // c\n    xp = '' if x == 0 else '{}x'.format('-' if x == - 1 else '' if x == 1 else abs(x))\n    yp = '' if y == 0 else '{}{}y'.format(' - ' if y < 0 else ' + ', '' if abs(y) == 1 else abs(y))\n    return '{}{} = {}'.format(xp, yp, z)", "from fractions import gcd\n\ndef para_to_rect(eqn1, eqn2):\n\n    a1, b1 = coeff(eqn1, 'x')\n    a2, b2 = coeff(eqn2, 'y')\n    \n    A = a2\n    B = -a1\n    C = b1 * a2 - a1 * b2\n    \n    g = gcd(gcd(A, B), C)\n    \n    cf = [v // g for v in [A, B, C]]\n    if cf[0] < 0: \n        cf = [-1 * v for v in cf]\n    \n    s = '+' if cf[1] >= 0 else '-'\n    cf[1] = abs(cf[1])\n    \n    a, b, c = ['' if abs(v) == 1 else str(v) for v in cf] \n    \n    return '{}x {} {}y = {}'.format(a, s, b, c)\n    \n    \ndef coeff(eq, v): \n    p1 = eq.replace(' ', '').replace(v + '=', '').split('t')\n    return list([1 if x == '' else -1 if x == '-' else int(x) for x in p1])\n"]