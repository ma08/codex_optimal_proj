["from math import sin, atan\n\ndef temps(v0, slope, d_tot):\n    GRAVITY_ACC = 9.81 * 3.6 * 60.0                   # gravity acceleration\n    DRAG = 60.0 * 0.3 / 3.6                           # force applied by air on the cyclist\n    DELTA_T = 1.0/60.0                                # in minutes\n    D_WATTS = 0.5                                     # power loss in Watts / minute\n    G_THRUST = 60 * 3.6 * 3.6                         # acceleration due to biker's power\n    MASS = 80                                         # biker's MASS\n    WATTS0 = 225                                      # initial biker's power\n\n    t = 0.0          # time in minutes\n    d = 0.0          # distance traveled in km\n    v = v0           # initial speed km/h\n    gamma = 0.0      # acceleration in km/h/minute\n    watts = WATTS0   # biker's power (watts at time t + DELTA_T is watts at time t - D_WATTS * DELTA_T)\n    slopeGravityAcc = -GRAVITY_ACC * sin(atan(slope / 100.0))\n    while (d <= d_tot):\n        t += DELTA_T\n        # new power\n        watts -= D_WATTS * DELTA_T # tiredness\n        # earth gravity due to slope and DRAG due to air resistance\n        gamma = slopeGravityAcc - DRAG * abs(v) * abs(v) / MASS\n        # acceleration due to biker's power\n        if ((watts > 0.0) and (v > 0.0)):\n            gamma += G_THRUST * watts / (v * MASS);\n        # acceleration too small -> acc = 0\n        if (abs(gamma) <= 1e-5):\n            gamma = 0.0;\n        else:\n            v += gamma * DELTA_T\n        # new distance\n        d +=  v  * DELTA_T / 60.0 # v in km/h, DELTA_T in minutes\n        # speed too slow, John stops\n        if (v - 3.0 <= 1e-2):\n            return -1\n    return round(t)\n", "from math import *\n\n# Constants:\nGRAVITY_ACC = 9.81 * 3.6 * 60.0                        # gravity acceleration\nDRAG        = 60.0 * 0.3 / 3.6                         # force applied by air on the cyclist\nDELTA_T     = 1.0 / 60.0                               # in minutes\nG_THRUST    = 60 * 3.6 * 3.6                           # pedaling thrust\nMASS        = 80.0                                     # biker's mass\nWATTS0      = 225.0                                    # initial biker's power\nD_WATTS     = 0.5   \n\ndef gamma(v, watts, slope):\n    temp = -GRAVITY_ACC * sin(atan(0.01 * slope))\n    temp = temp -  DRAG * abs(v) * abs(v)/ MASS \n    temp = temp +  G_THRUST * watts / (v * MASS)\n    if abs(temp) <= 0.00001: temp = 0\n    return temp\n\n\ndef temps(v0, slope, d_tot):\n    d = 0\n    t = 0\n    v = v0\n    watts = WATTS0\n\n    while (d < d_tot):\n        \n        watts = watts - D_WATTS * DELTA_T\n        v = v + gamma(v, watts, slope) * DELTA_T\n        d = d + v * DELTA_T/60\n        t = t  + DELTA_T\n        if v - 3.0 <= 0.01: return -1\n    \n    return round(t)", "from math import atan,sin\nGRAVITY_ACC = 9.81 * 3.6 * 60.0\nDRAG        = 60.0 * 0.3 / 3.6\nDELTA_T     = 1.0 / 60.0\nG_THRUST    = 60 * 3.6 * 3.6\nMASS        = 80.0\nWATTS0      = 225.0\nD_WATTS     = 0.5\n\ndef temps(v0, slope, d_tot):\n    t=0\n    v=v0\n    d=0\n    watts=WATTS0\n    theta=atan(slope/100)\n    while(d<d_tot):\n        t+=DELTA_T\n        watts-=D_WATTS*DELTA_T\n        gamma=G_THRUST*watts/(v*MASS)\n        gamma-=GRAVITY_ACC*sin(theta)\n        gamma-=DRAG*v*v/MASS\n        v+=gamma*DELTA_T\n        if v-3<=1e-2:\n            return -1\n        d+=v*DELTA_T/60\n    return round(t)", "import math\n\n\nGRAVITY_ACC = 9.81 * 3.6 * 60.0  # gravity acceleration\nDRAG = 60.0 * 0.3 / 3.6  # force applied by air on the cyclist\nDELTA_T = 1.0 / 60.0  # in minutes\nG_THRUST = 60 * 3.6 * 3.6  # pedaling thrust\nMASS = 80.0  # biker's mass\nWATTS0 = 225.0  # initial biker's power\nD_WATTS = 0.5  # loss of power at each deltaT\n\n\ndef temps(v0, slope, d_tot):\n    t = 0  # time\n    gamma = 0  # total acceleration with its 3 components\n    v = v0  # speed\n    d = 0  # distance travelled\n    watts = WATTS0  # biker's power\n\n    # angle of inclination\n    alpha = math.atan(slope / 100.0)\n\n    while d < d_tot:\n        if v - 3.0 <= 0.01:\n            return -1\n        t += DELTA_T\n        watts -= D_WATTS * DELTA_T\n        gamma = (-GRAVITY_ACC * math.sin(alpha)) + (-DRAG * abs(v) * abs(v) / MASS)\n        if watts > 0 and v > 0:\n            gamma += (G_THRUST * watts / (v * MASS))\n        if abs(gamma) <= 0.00001:\n            gamma = 0.0\n\n        v += (gamma*DELTA_T)\n        d += (v * DELTA_T / 60.0)\n\n    return round(t)", "import math\ndef temps(v0, slope, d_tot):\n  \n  GRAVITY_ACC = 9.81 * 3.6 * 60.0   # gravity acceleration\n  DRAG        = 60.0 * 0.3 / 3.6    # force applied by air on the cyclist\n  DELTA_T     = 1.0/60.0      # in minutes\n  G_THRUST    = 60 * 3.6 * 3.6   # pedaling thrust\n  MASS        = 80.0             #biker's mass\n  WATTS0      = 225.0            # initial biker's power\n  D_WATTS     = 0.5     \n  \n  t=0\n   \n  grav=-GRAVITY_ACC*math.sin(math.atan(slope/100))\n  print(grav)\n  \n  v=v0\n  watts=WATTS0\n  s=0\n  a=0\n  while s<=d_tot:\n    t+=DELTA_T\n    watts-=D_WATTS*DELTA_T\n\n    drag=DRAG*abs(v)*abs(v)/ MASS\n    trst=(G_THRUST*watts)/(v*MASS)\n    a=grav-drag+trst\n   # print(\"G= \",grav,\"Drag = \",drag,\" Trst= \",trst, \"## A =\", a)\n    \n    \n    #print(a)\n    if abs(a)<= 10**(-5):\n      a=0\n    \n     \n    v= v+a*DELTA_T\n    if v-3.0 <= 0.01:\n      return -1\n\n    s=s+v*DELTA_T/60\n    #print(v)\n    #print(\"s= \",s,\"v= \",v,\"a= \",a)\n  print(t,s)\n \n  return round(t)", "def temps(v0, slope, d_tot):\n    GRAVITY_ACC = 9.81 * 3.6 * 60.0  \n    DRAG        = 60.0 * 0.3 / 3.6   \n    DELTA_T     = 1.0 / 60.0         \n    G_THRUST    = 60 * 3.6 * 3.6     \n    MASS        = 80.0               \n    WATTS0      = 225.0              \n    D_WATTS     = 0.5                \n    \n    t=0\n    gamma=0\n    v=v0\n    d=0\n    watts=WATTS0\n    w=wei(slope,MASS)\n    while d<d_tot:\n        t+=DELTA_T\n        watts = watts - D_WATTS*DELTA_T\n        grav=GRAVITY_ACC*w\n        drag=DRAG*v*v/MASS\n        gamma=-grav-drag\n        if watts>0<v:\n            gamma+= G_THRUST * watts /(v*MASS)\n        if abs(gamma)<=1e-5:gamma=0\n        v=v+gamma*DELTA_T\n        d=d+v*DELTA_T/60\n        if v-3 <= 1e-2:return -1\n    return round(t)\n    \nimport math\ndef wei(slope,MASS):\n    angle= math.atan(slope/100)\n    return  math.sin(angle)", "from math import *\n#import numpy as np\n#np.set_printoptions(precision=4)\n\nGRAVITY_ACC = 9.81 * 3.6 * 60.0                        #// gravity acceleration\nDRAG        = 60.0 * 0.3 / 3.6                         #// force applied by air on the cyclist\nDELTA_T     = 1.0 / 60.0                               #// in minutes\nG_THRUST    = 60 * 3.6 * 3.6                           #// pedaling thrust\nMASS        = 80.0                                     #// biker's mass\nWATTS0      = 225.0                                    #// initial biker's power\nD_WATTS     = 0.5                                      #// loss of power at each deltaT\n\ndef temps(v0, slope, d_tot):\n    t,d,v,watts = 0,0,v0,WATTS0    \n    def nextAcc():\n        a= - GRAVITY_ACC * slope/sqrt(10000+slope**2) - DRAG * abs(v) ** 2 / MASS + G_THRUST * watts / (v * MASS)\n        return a if abs(a)>1e-5 else 0\n    def nextVel():\n        return v+gamma*DELTA_T\n    def nextPow():\n        return watts - D_WATTS * DELTA_T\n    def nextDist():\n        return d+v*DELTA_T/60+.5*gamma*(DELTA_T/60)**2  # distance travelled = v*t + .5*a*t**2\n    def nextT():\n        return t+DELTA_T    \n    gamma=nextAcc()\n    \n    while(d_tot-d>0 and v - 3. > 1e-2):        \n        t=nextT()\n        v=nextVel()\n        watts=nextPow()\n        gamma=nextAcc()\n        d=nextDist()\n    return -1 if v -3. <1e-2 else int(round(t)) \n", "import math\ndef temps(v0, slope, d_tot):\n    time = 0\n    gamma = 0\n    v = v0\n    d = 0\n    watts = 225.0\n    while True:\n        gamma = 0\n        if d >= d_tot:\n            return round(time)\n        if (v - 3.0) <= 0.01:\n            return -1\n        watts -= (0.5 * (1.0 / 60.0))\n        angle = math.atan(slope / 100)\n        gamma -= 9.81 * 3.6 * 60.0 * math.sin(angle)\n        gamma -= (60.0 * 0.3 / 3.6) * abs(v) * abs(v) / 80.0\n        if watts > 0 and v > 0:\n            gamma += 60 * 3.6 * 3.6 * watts / (v * 80.0)\n        if abs(gamma) <= 0.00001:\n            gamma = 0\n        v += (gamma * (1.0 / 60.0))\n        d += (v * (1.0 / 60.0) / 60.0)\n        time += (1.0 / 60.0)", "from math import atan, sin\ndef temps(v, slope, d_tot):\n    answer = 0\n    travelled = 0\n    mass = 80\n    power = 225\n    power_loss = 0.5 / 60\n    angle = atan(slope / 100)\n    gravity_acc = 9.81 * 3.6 * 60\n    gravityParallel = gravity_acc * sin(angle)\n    drag = 60 * 0.3 / 3.6\n    g_thrust = 60 * 3.6 * 3.6\n    while travelled < d_tot:\n        answer += 1\n        airDrag = drag * v * v / mass\n        thrust = 0\n        if power > 0 and v > 0:\n            thrust = g_thrust * power / v / mass\n        gamma = - gravityParallel - airDrag + thrust\n        if abs(gamma) <= 1e-5:\n            gamma = 0\n        v += gamma / 60\n        if v - 3 <= 1e-2:\n            return -1\n        travelled += v / 60 / 60\n        power -= power_loss\n    return round(answer / 60)", "import math\n\ndef temps(v0, slope, d_tot):\n    GRAVITY_ACC = 9.81 * 60.0 * 3.6\n    DRAG = 60.0 * 0.3 / 3.6  # air drag\n    DELTA_T = 1.0 / 60.0\n    G_THRUST = 60 * 3.6 * 3.6\n    MASS = 80.0\n    WATTS0 = 225.0\n    D_WATTS = 0.5\n    DELTA_P = D_WATTS * DELTA_T\n    SLOPE = math.sin(math.atan(slope / 100.0))  # slope and slope(percentage)\n\n    p = WATTS0               # cyclist power\n    v = v0                   # actual speed\n    a, d, t = 0.0, 0.0, 0.0  # acceleration, distance, time\n    while d < d_tot:\n        t += DELTA_T\n        p -= DELTA_P\n        a = -GRAVITY_ACC * SLOPE - DRAG * v ** 2 / MASS\n        if v > 0 and p > 0:\n            a += p * G_THRUST / v / MASS\n        if abs(a) <= 1e-5:\n            a = 0\n        v += a * DELTA_T\n        if v - 3.0 < 0.01:\n            return -1\n        d += v * DELTA_T / 60\n    return int(round(t, 0))"]