["l, m, p = [1], 10 ** 7, []\nfor n in range(2, int(m ** .5) + 1):\n    l = [n*n + j for j in [0]+l]\n    p += [int(k) for k in map(str, l[1:]) if k == k[::-1]]\np = sorted(set(p))\n\nfrom bisect import bisect_left\ndef values(n): return bisect_left(p, n)", "def values(n):\n    pal = set()\n    for i in range(1, int(n**0.5)):\n        sos = i*i\n        while sos < n:\n            i += 1\n            sos += i*i\n            if str(sos)==str(sos)[::-1] and sos < n:\n                pal.add(sos)\n    return len(pal)", "from bisect import bisect\n\nis_pal = lambda s: s == s[::-1]\n\nN, temp = 2500, set()\nfor x in range(1, N):\n    val = x**2\n    for y in range(x+1, N):\n        val += y**2\n        if val not in temp and is_pal(str(val)):\n            temp.add(val)\nresult = sorted(temp)\n\ndef values(n):\n    return bisect(result, n)", "sumSquaresToN = lambda n: n*(n+1)*(2*n+1)//6\n\nmemo = set()\n\ndef values(n):\n    lastMax = max(memo) if memo else 0\n    if lastMax >= n:\n        return sum( x < n for x in memo )\n    \n    top = int( (1 + (1+2*(n-1))**.5) // 2 )           # Value of the top number for a sum of two consecutive squares under n: (top-1)**2 + top**2 <= n    \n    for a in range(top, 1, -1):\n        va = sumSquaresToN(a)                         # sum of squares of 1, 2, 3, ..., a\n        if va <= lastMax: break                       # va is greater than all the values generated with the inner loop, so if too small to generate new values, exit\n\n        for b in range(a-2, -1, -1):\n            v = va - sumSquaresToN(b)                 # current value\n            if v >= n: break                          # going down with the values of b, v increase at each execution. Allow to exit the loop when generated values become to big (and useless for the current call)\n            if v == int(str(v)[::-1]): memo.add(v)\n            \n    return len(memo)", "found = set([5, 55, 77, 181, 313, 434, 505, 545, 595, 636, 818, 1001, 1111, 1441, 1771, 4334, 6446, 17371, 17871, 19691, 21712, 41214, 42924, 44444, 46564, 51015, 65756, 81818, 97679,\n          99199, 108801, 127721, 137731, 138831, 139931, 148841, 161161, 166661, 171171, 188881, 191191, 363363, 435534, 444444, 485584, 494494, 525525, 554455, 554455, 629926, 635536,\n          646646, 656656, 904409, 923329, 944449, 964469, 972279, 981189, 982289, 1077701, 1224221, 1365631, 1681861, 1690961, 1949491, 1972791, 1992991, 2176712, 2904092, 3015103, 3162613,\n          3187813, 3242423, 3628263, 4211124, 4338334, 4424244, 4776774, 5090905, 5258525, 5276725, 5367635, 5479745, 5536355, 5588855, 5603065, 5718175, 5824285, 6106016, 6277726, 6523256,\n          6546456, 6780876, 6831386, 6843486, 6844486, 7355537, 8424248, 9051509, 9072709, 9105019, 9313139, 9334339, 9343439, 9343439, 9435349, 9563659, 9793979, 9814189, 9838389, 9940499])\n\ndef values(n):\n    return sum(i<n for i in found)\n\n\n\n#this is how i achieved that :D\n'''\n#generate palindomre upto 10**digits quickly\ndef generate_palindromes(digits):\n    batches = [None,\n               [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],\n               [0, 11, 22, 33, 44, 55, 66, 77, 88, 99]]\n\n    for n in range(3, digits + 1):\n        batch = []\n        mid = [batches[k] for k in range(1, len(batches)) if [not k & 1, k & 1][n & 1]]\n        for side in range(1, 10):\n            for p in mid:\n                for inner in p:\n                    number = str(side) + str(inner).center(n - 2, '0') + str(side)\n                    batch.append(int(number))\n        batches.append(batch[:])\n\n    return sum(batches[1:], [])\n\n\nx = generate_palindromes(7)\nx = set(x[:10] + x[11:])\n\nfound = []\nfor i in range(1, 2000):\n    sq = i * i\n    for j in range(i + 1, 2000):\n        sq += j * j\n        if sq in x:\n            found.append(sq)\n'''", "def values(high):\n    s = set()\n    num = 1\n    while num * num < high:\n        temp = num + 1\n        total = num * num + temp * temp\n        while total < high:\n            if str(total) == str(total)[::-1]:\n                s.add(total)\n            temp += 1\n            total += temp * temp\n        num += 1\n    return len(s)", "found = set([5, 55, 77, 181, 313, 434, 505, 545, 595, 636, 818, 1001, 1111, 1441, 1771, 4334, 6446, 17371, 17871, 19691, 21712, 41214, 42924, 44444, 46564, 51015, 65756, 81818, 97679,\n          99199, 108801, 127721, 137731, 138831, 139931, 148841, 161161, 166661, 171171, 188881, 191191, 363363, 435534, 444444, 485584, 494494, 525525, 554455, 554455, 629926, 635536,\n          646646, 656656, 904409, 923329, 944449, 964469, 972279, 981189, 982289, 1077701, 1224221, 1365631, 1681861, 1690961, 1949491, 1972791, 1992991, 2176712, 2904092, 3015103, 3162613,\n          3187813, 3242423, 3628263, 4211124, 4338334, 4424244, 4776774, 5090905, 5258525, 5276725, 5367635, 5479745, 5536355, 5588855, 5603065, 5718175, 5824285, 6106016, 6277726, 6523256,\n          6546456, 6780876, 6831386, 6843486, 6844486, 7355537, 8424248, 9051509, 9072709, 9105019, 9313139, 9334339, 9343439, 9343439, 9435349, 9563659, 9793979, 9814189, 9838389, 9940499])\n\ndef values(n):\n    return sum(i<n for i in found)", "def values(limit):\n    palindromes = set()\n    for sequence_item in range(1, int(limit**0.5)):\n        squares_sum = sequence_item**2\n        while squares_sum < limit:\n            sequence_item += 1\n            squares_sum += sequence_item**2\n            if str(squares_sum)==str(squares_sum)[::-1] and squares_sum < limit:\n                palindromes.add(squares_sum)\n    return len(palindromes)", "def values(n):\n    p = set()\n    for i in range(1, int(n**0.5)):\n        q = i*i\n        while q < n:\n            i=i+ 1\n            q =q+ i*i\n            if str(q)==str(q)[::-1] and q < n:\n                p.add(q)\n    return len(p)", "def values(limit):\n    def is_palindrome(n):\n        n = str(n)\n        if len(n) in [0, 1]:\n            return True\n        return n[0] == n[-1] and is_palindrome(n[1:-1])\n\n    print(\"Limit: {}\".format(limit))\n    current = 2\n    totals = [1]\n    list_pal = []\n    while True:\n        number = current ** 2 + totals[-1]\n        totals = [i for i in totals if number - i < limit]\n        if len(totals) == 1 and totals != [1]:\n            break\n        for i in totals[:-1]:\n            if is_palindrome(number - i) and not (number - i) in list_pal and limit > (number - i):\n                list_pal.append(number - i)\n        if is_palindrome(number) and not number in list_pal and limit > number:\n            list_pal.append(number)\n        totals.append(number)\n        current += 1\n    print(\"Number of Palindrome in list: {}\".format(len(list_pal)))\n    print(\"List of Palindrome: {}\".format(list_pal))\n    return len(list_pal)"]