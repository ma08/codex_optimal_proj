["import numpy as np\n\ndef getMatrixProduct(a, b):\n    try:\n        return np.matmul(a, b).tolist()\n    except:\n        return - 1", "def getMatrixProduct(a, b):\n    if len(a[0]) != len(b):\n        return -1\n    result = [[0 for i in range(len(b[0]))] for j in range(len(a))]\n    for i in range(len(a)):\n        for j in range(len(b[0])):\n            for k in range(len(b)):\n                result[i][j] += a[i][k] * b[k][j]\n    return result", "def getMatrixProduct(a, b):\n    if len(a[0]) != len(b):\n        return -1\n    return [[sum(m*n for m,n in zip(a_row, b_col)) for b_col in zip(*b)] for a_row in a]", "import numpy as np\n\ndef getMatrixProduct(a, b):\n    try:\n        return (np.matrix(a) * np.matrix(b)).tolist()\n    except ValueError:\n        return -1", "getMatrixProduct=lambda a,b:-((len(a)and len(a[0]))!=len(b))or[[sum(x*y for x,y in zip(r,c))for c in zip(*b)]for r in a]", "getMatrixProduct=lambda a, b:-1 if len(list(zip(*a)))!=len(b) else [[sum(k*l for k,l in zip(i,j)) for j in zip(*b)]for i in a]", "from numpy import matrix\n\ndef get_matrix_product(a, b):\n    m1, m2 = matrix(a), matrix(b)\n    return ( m1 * m2 ).tolist() if m1.shape[1] == m2.shape[0] else -1\n\n\ngetMatrixProduct = get_matrix_product", "def getMatrixProduct(A, B):\n    rows_A = len(A)\n    cols_A = len(A[0])\n    rows_B = len(B)\n    cols_B = len(B[0])\n\n    if cols_A != rows_B:\n      print( \"Cannot multiply the two matrices. Incorrect dimensions.\")\n      return -1\n\n    # Create the result matrix\n    # Dimensions would be rows_A x cols_B\n    C = [[0 for row in range(cols_B)] for col in range(rows_A)]\n    print(C)\n\n    for i in range(rows_A):\n        for j in range(cols_B):\n            for k in range(cols_A):\n                C[i][j] += A[i][k] * B[k][j]\n    return C", "import numpy as np\ndef getMatrixProduct(a, b):\n    try: return np.dot(a, b).tolist()\n    except: return -1\n", "def getMatrixProduct(a, b):\n    \"\"\"If a and b can be multiplied, returns the product of a and b as a two-dimensional array. Otherwise returns -1.\"\"\"\n    # Get dimensions\n    arl, acl = len(a), len(a[0])\n    brl, bcl = len(b), len(b[0])\n    # Validate compatible dimensions\n    if acl != brl:\n        return -1\n    # Handy data extraction lambdas\n    row = lambda ar, n: ar[n]\n    col = lambda ar, n: [r[n] for r in ar]\n    # Sum of the products of parallel arrays\n    prod_sum = lambda ar1, ar2: sum((v1 * v2 for v1, v2 in zip(ar1, ar2)))\n    # Answer!\n    return [[prod_sum(row(a, r), col(b, c)) for c in range(bcl)] for r in range(arl)]\n"]