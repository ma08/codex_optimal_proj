["def binary_simulation(s, q):\n    out,n,s = [],int(s,2),len(s)\n    for cmd,*i in q:\n        if cmd=='I':\n            a,b=i\n            n ^= (1<<b-a+1)-1<<s-b\n        else:\n            out.append( str(int(0 < 1<<s-i[0] & n )) )\n    return out", "import numpy as np\n\ndef binary_simulation(s, b):\n    a, r = np.fromiter(map(int, s), dtype=np.int), []\n    for x in b:\n        if x[0] == \"Q\":\n            r.append(str(a[x[1]-1]))\n        else:\n            i, j = x[1:]\n            a[i-1:j] ^= 1\n    return r", "def binary_simulation(s, q):\n    x, l, result = int(s, 2), len(s), []\n    for op in q:\n        if op[0] == 'I':\n            i, j = op[1:]\n            x ^= (1 << j-i+1)-1 << l-j\n        else:\n            result.append(str(x >> l-op[1] & 1))\n    return result", "def binary_simulation(bits, seq):\n    arr = [0 for _ in range(len(bits) + 1)]\n    display = []\n    for grp in seq:\n        if grp[0] == 'I':\n            arr[grp[1] - 1] += 1\n            arr[grp[2]] += -1\n        else:\n            display.append('01'[sum(arr[:grp[1]]) + int(bits[grp[1] - 1]) & 1])\n    return display", "def binary_simulation(s, q):\n    o, l, n = [], len(s), int(s, 2)\n    for c, *_ in q:\n        if c == 'Q':\n            i, = _\n            o.append(str(n >> l-i & 1))\n        else:\n            i, j = _\n            n ^= (1<<l-i+1) - (1<<l-j)\n    return o", "def binary_simulation(s,r):\n    ix = tuple(1 << n for n in range(len(s)+1))[::-1]\n    tome = []\n    n = int(s,2)\n    for v,*x in r:\n        if v == 'I':\n            n ^= ix[x[0]-1] - ix[x[1]]\n        else:\n            tome.append(str(min(1,n&ix[x[0]])))\n    return tome", "def binary_simulation(s, q):\n    \n    outlst=[]\n    for op in q:\n        ini=op[1]-1\n        \n        if op[0]=='Q':\n            outlst.append(s[ini])\n        elif op[0]=='I':\n            transl=s[ini:op[2]].maketrans('01','10')\n            s=s[:ini]+s[ini:op[2]].translate(transl)+s[op[2]:]\n    return outlst\n    \n", "def binary_simulation(Q,S) :\n    Q,L,R = int(Q,2),len(Q),[]\n    for S in S :\n        if S[0] < 'L' :\n            Q ^= (1 << L - S[1] + 1) - 1\n            Q ^= (1 << L - S[2]) - 1\n        else :\n            R.append('1' if Q & (1 << L - S[1]) else '0')\n    return R", "def binary_simulation(s, q):\n    n=int(s[::-1],2)\n    r=[]\n    for x in q:\n        if x[0]=='I':\n            _,a,b=x\n            n^=((1<<(b-a+1))-1)<<(a-1)\n        else:\n            _,a=x\n            r+=['01'[n&(1<<(a-1))>0]]\n    return r", "def binary_simulation(s, q):\n    s = '0'+s\n    ans = []\n    for val in q:\n        if val[0] == 'I':\n            s = s[:val[1]] + s[val[1] : val[2]+1].translate(''.maketrans('01', '10')) + s[val[2]+1:]\n        elif val[0] == 'Q':         \n            ans.append(s[val[1]])         \n    return ans"]