["from itertools import islice, count\n\ndef u1():\n    a = {1:1, 2:1}\n    yield a[1]\n    yield a[2]\n    for n in count(3):\n        a[n] = a[n-a[n-1]] + a[n-a[n-2]]\n        yield a[n]\n    \ndef length_sup_u_k(n, k):\n    return len(list(filter(lambda x: x >= k, islice(u1(), 1, n))))\n    \ndef comp(n):\n    return sum(k1 < k0 for k0, k1 in zip(list(islice(u1(), 1, n)), list(islice(u1(), 2, n))))", "def u_list(index):\n    out = [1, 1]\n    for i in range(2, index):\n        out.append(out[i-out[-1]] + out[i-out[-2]])\n    return out\n\ndef length_sup_u_k(n, k):\n    return sum([1 for x in u_list(n) if x >= k])\n    \ndef comp(n):\n    us = u_list(n)\n    return sum([1 for i in range(n-1) if us[i] > us[i+1]])\n", "S,C = [1,1],[0,0]\n\ndef length_sup_u_k(n, k):  return update(n) or sum(v>=k for v in S[:n])\ndef comp(n):               return update(n) or C[n-1]\n\ndef update(n):\n    for _ in range(n+1-len(S)):\n        S.append( S[-S[-2]] + S[-S[-1]] )\n        C.append( C[-1] + (S[-2]>S[-1]) )\n", "def length_sup_u_k(n, k):\n    u = {1: 1, 2: 1}\n    \n    count = 0\n    if k == 1:\n        count += 2\n    for i in range(3, n+1):\n        u[i] = u[i - u[i-1]] + u[i - u[i-2]]\n        if u[i] >= k: count += 1\n    return count\n    \ndef comp(n):\n    u = {1: 1, 2: 1}\n    count = 0\n    for i in range(3, n+1):\n        u[i] = u[i - u[i-1]] + u[i - u[i-2]]\n        if u[i] < u[i-1]: count += 1\n    return count", "def length_sup_u_k(n, k):\n    return len(list(filter(lambda x: x >= k, create(n))))\n\ndef create(n):\n    seq = []\n    for i in range(n):\n        seq.append(generate_term(i, seq))\n    return seq\n    \ndef generate_term(i, seq):\n    if i == 0 or i == 1:\n        return 1\n    return seq[i - seq[i-1]] + seq[i - seq[i-2]]\n    \ndef comp(n):\n    count = 0\n    seq = []\n    for i in range(n):\n        seq.append(generate_term(i, seq))\n        if i != 0:\n            if seq[i] < seq[i-1]:\n                count += 1\n    return count", "def length_sup_u_k(n, k):\n    return sum(i >= k for i in u(n))\n\ndef comp(n):\n    ui = u(n)\n    return sum(x > y for y,x in zip(ui[1:], ui[:-1]))\n    \ndef u(n):\n    if n == 1:\n        return 1\n    elif n == 2:\n        return 1\n    else:\n        seq = [1,1]\n        for i in range(2, n):\n            seq.append(seq[i-seq[i-1]] + seq[i-seq[i-2]])\n            \n        return seq\n", "def length_sup_u_k(n, k):\n    return len([x for x in fibSeq(n) if x >= k])\n\n\ndef comp(n):\n    seq = fibSeq(n)\n    return len([x for x in range(1,len(seq)) if seq[x] < seq[x-1]])\n\n\ndef fibSeq(n):\n    sequence = [1,1]\n\n    for i in range(2,n):\n        sequence.append(sequence[i-sequence[i-1]] + sequence[i-sequence[i-2]])\n    return sequence", "def length_sup_u_k(n, k):\n    count = 0\n    u_ = u(n)\n    for i in range(2,n+1):\n        if u_[i] >= k:\n            count += 1\n    return count\n    \ndef comp(n):\n    count = 0\n    u_ = u(n)\n    for i in range(2,n+1):\n        if u_[i] < u_[i-1]:\n            count += 1\n    return count\n\ndef u(n):\n    u = [0, 1, 1]\n    for i in range(3, n+1):\n        u.append(u[i - u[i - 1]] + u[i - u[i - 2]])\n    return u\n    \n    #     if n == 1 or n == 2:\n    #         return 1\n    #     return u(n - u(n-1)) + u(n - u(n-2))\n", "def length_sup_u_k(n, k):\n    a=[1,1]\n    count = 0\n    for i in range(2,n):\n        a.append(a[i-a[i-1]]+a[i-a[i-2]])\n        if a[i] >= k:\n            count +=1\n    return count\ndef comp(n):\n    a=[1,1]\n    count = 0\n    for i in range(2,n):\n        a.append(a[i-a[i-1]]+a[i-a[i-2]])\n        if a[i] < a[i-1]:\n            count +=1\n    return count", "\ndef length_sup_u_k(n, k):\n    greater_num=0\n    \n    number_table=[]\n    for index in range(0, n):\n        if index <= 1:\n            number_table.append(1)\n        else:\n            first_index = number_table[index - 1]\n            last_index = number_table[index - 2]\n            new_number = number_table[index - first_index] + number_table[index - last_index]\n            number_table.append(new_number)\n        if number_table[index] >= k:\n            greater_num +=1\n    return greater_num\n    \ndef comp(n):\n    pred_suck_count = 0\n    number_table=[]\n    for index in range(0, n):\n        if index <= 1:\n            number_table.append(1)\n            continue\n        else:\n            first_index = number_table[index - 1]\n            last_index = number_table[index - 2]\n            new_number = number_table[index - first_index] + number_table[index - last_index]\n            number_table.append(new_number)\n        if number_table[index] < number_table[index - 1]:\n            pred_suck_count += 1\n            \n    return pred_suck_count\n"]