["def self_converge(number):\n    n, cycle = str(number), set()\n    while n not in cycle:\n        cycle.add(n)\n        s = ''.join(sorted(n))\n        n = '%0*d' % (len(n), int(s[::-1]) - int(s))\n    return -1 if not int(n) else len(cycle)", "def self_converge(n, seen=None):\n    s, seen = \"\".join(sorted(str(n))), set() if seen is None else seen\n    s = f\"{int(s[::-1]) - int(s):0{len(s)}d}\"\n    return len(seen) + 1 if int(s) and s in seen else self_converge(s, seen | {s}) if int(s) else -1\n", "def self_converge(n):\n    s, seen = str(n), set()\n    while not s in seen:\n        seen.add(s)\n        s = \"\".join(sorted(s))\n        s = f\"{int(s[::-1]) - int(s):0{len(s)}d}\"\n    return len(seen) if int(s) else -1\n", "def self_converge(number):\n    digits_num = len(str(number))\n    count = 0\n    prev = []\n    while number not in prev:\n        prev.append(number)\n        digits = [c for c in str(number)]\n        n_asc = int(''.join(sorted(digits, reverse=False)))\n        n_desc = int(''.join(sorted(digits, reverse=True)))\n        while len(str(n_desc))<digits_num:\n            n_desc *=10\n        number = n_desc-n_asc\n        if number==0:\n            return -1\n        count += 1\n    return count", "def self_converge(number, seen=None):\n    number = str(number)\n    digits = ''.join(sorted(number))\n    result = '{{:0{}}}'.format(len(number)).format(int(digits[::-1]) - int(digits))\n    if int(result) == 0:\n        return -1\n    elif seen and result in seen:\n        return len(seen) + 1\n    else:\n        return self_converge(result, (seen or []) + [result])", "def self_converge(number):\n  digits = len(str(number))\n  if digits < 3 or number % int('1' * digits) == 0: return -1\n  fmtstr = '%%0%dd' % digits\n  log = [ number ]\n  while True:\n    nstr = fmtstr % number\n    low = int(''.join(sorted(nstr)))\n    high = int(''.join(sorted(nstr, reverse=True)))\n    nextn = high - low\n    if nextn in log: return len(log)\n    log.append(nextn)\n    number = nextn\n", "\ndef self_converge(number):\n    def sub_converge(n, l, min_length):\n        digits = [d for d in str(n)]\n        while len(digits) < min_length:\n            digits.append('0')\n        asc = sorted(digits)\n        desc = asc[::-1]\n        if asc == desc:\n            return -1\n        next = int(\"\".join(desc)) - int(\"\".join(asc))\n        if next in l:\n            return len(l) + 1\n        else:\n            return sub_converge(next, l + [next], min_length)\n    return sub_converge(number, [], len(str(number)))", "from itertools import count\n\ndef self_converge(p):\n    width = len(str(p))\n    previous = set()\n    for i in count(1):\n        s = sorted(str(p).ljust(width, '0'))\n        n = int(''.join(reversed(s))) - int(''.join(s))\n        if n is 0:\n            return -1\n        if n in previous:\n            return i\n        p = n\n        previous.add(n)\n", "def rec(n, seen):\n    if n == '0'*len(n): return -1\n    seen.add(n)\n    res = str(int(''.join(sorted(n, reverse=True))) - int(''.join(sorted(n)))).zfill(len(n))    \n    if res in seen: return len(seen)\n    return rec(res, seen)\n    \ndef self_converge(number):\n    return rec(str(number), set())", "def self_converge(number,z=0,counter=0,previous=[]): return (lambda sol: -1 if sol==0 else counter if number in previous else self_converge(sol,len(str(number)) if z==0 else z,counter+1,previous+[number]))((lambda n: int(\"\".join(sorted(n,reverse=True)))-int(\"\".join(sorted(n))))(str(number).zfill(z)))\n#one-liner and recursive solution: KAME-HAME-HAA!!!!\n"]