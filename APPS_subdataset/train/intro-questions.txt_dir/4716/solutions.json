["def distribution_of(golds):\n    g = golds[:]\n    turn, total = 0, [0, 0]\n    while g:\n        total[turn % 2] += g.pop(-(g[0] < g[-1]))\n        turn += 1\n    return total\n", "from collections import deque\ndef distribution_of(golds):\n    g = deque(golds)\n    s = [0, 0]\n    t = 0\n    while g:\n        s[t] += (g.popleft, g.pop)[g[0] < g[-1]]()\n        t ^= 1\n    return list(s)", "def distribution_of(golds):\n    ind, beggars = [0, len(golds)-1], [0, 0]\n    for n in range(len(golds)):\n        i = golds[ind[0]] < golds[ind[1]]\n        beggars[n%2] += golds[ind[i]]\n        ind[i] += (-1)**i\n    return beggars", "def distribution_of(golds):\n    g = golds[:]\n    turn, total, i, j = 0, [0, 0], 0, len(g) - 1\n    while i <= j:\n        total[turn % 2] += max(g[i], g[j])\n        if g[j] > g[i]:\n            j -= 1\n        else:\n            i += 1\n        turn += 1\n    return total", "def take_one(golds):\n    if len(golds) > 1 and golds[0] >= golds[-1]:\n        return golds.pop(0)\n    else:\n        return golds.pop() if golds else 0\n        \n        \ndef distribution_of(golds):\n    golds = golds[:]\n    a = b = 0\n    while golds:\n        a += take_one(golds)\n        b += take_one(golds)\n    return [a, b]", "def distribution_of(golds):\n    golds = golds[:]\n    take = lambda: golds.pop(0 if golds[0] >= golds[-1] else -1) if golds else 0\n    a = b = 0\n    while golds:\n        a += take()\n        b += take()\n    return [a, b]", "def distribution_of(piles):\n    i, gold = False, [0, 0]\n    while piles:\n        gold[i], piles = (gold[i]+piles[-1], piles[:-1]) if piles[-1] > piles[0] else (gold[i]+piles[0], piles[1:])\n        i = not i\n    return gold", "distribution_of=lambda g,r=[0,0],c=0: r if not len(g) else distribution_of(*([g[:-1],[r[0],r[1]+g[-1]],0] if g[-1]>g[0] else [g[1:],[r[0],r[1]+g[0]],0])) if c else distribution_of(*([g[:-1],[r[0]+g[-1],r[1]],1] if g[-1]>g[0] else [g[1:],[r[0]+g[0],r[1]],1]))", "def distribution_of(gold):\n    # Make gold a copy of gold because otherwise it breaks the random checks\n    gold, beggargold = gold.copy(), [0, 0]\n    for pile in range(len(gold)):\n        if pile % 2 == 0:\n            beggargold[0] += (gold.pop(0) if gold[0] >= gold[-1] else gold.pop())\n        else:\n            beggargold[1] += (gold.pop(0) if gold[0] >= gold[-1] else gold.pop())\n    return beggargold\n", "def distribution_of(golds):\n    ab = [0, 0]\n    g = golds[:]\n    for i in range(len(g)):\n        ab[i%2] += max(g[0], g[-1])\n        g.pop(-1) if g[-1] > g[0] else g.pop(0)\n    return ab", "def distribution_of(golds):\n    gg=golds[:]\n    out=[0,0]\n    pos=0\n    for _ in range(len(gg)):\n        if gg[0]>=gg[-1]:\n            out[pos]+=(gg.pop(0)) \n        else:\n            out[pos]+=(gg.pop(-1))\n        pos=not pos\n    return out\n", "def distribution_of(golds):\n    g = golds[:]\n    i, beggars = 0,[0,0]\n    while g:\n        beggars[i%2] += g.pop(-(g[0] < g[-1]))\n        i+=1\n    return beggars", "def distribution_of(golds):\n    g = golds[:]\n    total = [0,0]\n    turn = 0\n    while len(g) > 0:\n        if g[0] >= g[-1]:\n            value = g.pop(0)\n        else:\n            value = g.pop(-1)      \n        total[turn % 2] += value    \n        turn += 1\n    return total", "def distribution_of(golds):\n    golds_list = golds[:]\n    a = []\n    b = []\n    turn = 1\n    while len(golds_list) > 0:\n        if golds_list[0] >= golds_list[-1]:\n            value = golds_list.pop(0)\n        else:\n            value = golds_list.pop(-1)\n        if turn % 2 == 1:\n            a.append(value)\n        else:\n            b.append(value)\n        turn += 1\n    return [sum(a), sum(b)]", "def distribution_of(golds):\n    gold_list = golds[:]        \n    isA = True\n    amount = [0 ,0]\n    \n    while len(gold_list) != 0:\n        if (gold_list[0] > gold_list[-1]) or (gold_list[0] == gold_list[-1]):\n            if isA:\n                amount[0] += gold_list[0]\n            else:\n                amount[1] += gold_list[0]\n            gold_list.pop(0)\n        else:\n            if isA:\n                amount[0] += gold_list[-1]\n            else:\n                amount[1] += gold_list[-1]\n            gold_list.pop(-1)\n        isA = not isA\n\n    return amount", "def distribution_of(golds):\n    g = golds[::]\n    R = [0,0]\n    toggle = 0\n    currentVar = 'A'\n    while g:\n        if g[-1] > g[0]:\n            R[toggle] += g.pop(-1)\n        else:\n            R[toggle] += g.pop(0)\n        toggle = 1 - toggle\n\n    return R", "def distribution_of(golds):\n    a,b,i=0,0,0\n    golds_c=golds[:]\n    while golds_c:\n        m=golds_c.pop(0) if golds_c[0]>=golds_c[-1] else golds_c.pop()\n        if i%2:b+=m\n        else:a+=m\n        i+=1\n    return [a,b]", "def distribution_of(golds):\n    p,g,player=0,golds[:],[0,0]\n    while g: player[p],p = player[p]+g.pop(-1 if g[0]<g[-1] else 0),1-p\n    return player", "def distribution_of(g):\n    golds = g.copy()\n    print(golds)\n    a=0\n    b=0\n    while golds:\n        if golds[0] >= golds[-1]:\n            a += golds.pop(0)\n        else:\n            a += golds.pop(-1)\n        if not golds:\n            break\n        if golds[0] >= golds[-1]:\n            b += golds.pop(0)\n        else:\n            b += golds.pop(-1)\n    return [a, b]", "def distribution_of(golds):\n    out, n, g = [0,0], 0, golds[::] #never directly edit supplied lists\n    for i in range(len(golds)):\n        if g[n] < g[-1]: x = g.pop()\n        else:            x, n = g[n], n+1\n        out[i&1] += x\n    return out"]