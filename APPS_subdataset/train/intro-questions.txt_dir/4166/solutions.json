["import math\n\ndef divisors(n):\n    divs = [1]\n    for i in range(2,int(math.sqrt(n))+1):\n        if n%i == 0:\n            divs.extend([i,n//i])\n    divs.extend([n])\n    return list(set(divs))\n\ndef solve(p):\n    for d in sorted(divisors(p-1)):\n        if pow(10, d, p) == 1:\n            return \"{}-sum\".format(d)\n            break\n        elif pow(10, d, p) == p-1:\n            return \"{}-altsum\".format(d)\n            break\n", "import collections\nimport itertools\n\ndef prime_factors(n):\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            n /= i\n            yield i\n        else:\n            i += 1\n\n    if n > 1:\n        yield n\n\ndef prod(iterable):\n    result = 1\n    for i in iterable:\n        result *= i\n    return result\n\n\ndef get_divisors(n):\n    pf = prime_factors(n)\n\n    pf_with_multiplicity = collections.Counter(pf)\n\n    powers = [\n        [factor ** i for i in range(count + 1)]\n        for factor, count in pf_with_multiplicity.items()\n    ]\n\n    for prime_power_combo in itertools.product(*powers):\n        yield prod(prime_power_combo)\n\ndef rem(n, p):\n    v = 1\n    for i in range(0, n // 1000):        \n        v = v * (10 ** 1000)\n        v = v % p\n    v = v * (10 ** (n % 1000))\n    v = v % p\n    return v\n        \n\ndef solve(p):\n    nl = list(get_divisors(p-1))\n    nl = [int(x) for x in nl]\n    nl = sorted(nl)\n    \n    for n in nl:\n        if rem(n, p) == 1:\n            return str(n) + '-sum'\n        if rem(n, p) == p - 1:\n            return str(n) + '-altsum'", "def solve(p):\n    result = 0\n    for i in range(1, int(p ** 0.5) + 1):\n        if (p - 1) % i:\n            continue\n        if pow(10, i, p) == 1:\n            result = i\n            break\n        j = (p - 1) // i\n        if pow(10, j, p) == 1:\n            result = j\n    if pow(10, result // 2, p) == p - 1:\n        return f'{result // 2}-altsum'\n    else:\n        return f'{result}-sum'", "def solve(p):\n    \"\"\"See codewars.com kata Divisible by primes.\"\"\"\n    n = p - 1\n    for f in factors(n):\n        m = n // f\n        if pow(10, m, p) == 1:\n            n = m\n    return '%d-altsum' % (n // 2) if n % 2 == 0 else '%d-sum' % n\n\n\ndef factors(n):\n    m = 2\n    while m * m <= n:\n        while n % m == 0:\n            yield m\n            n //= m\n        m += 1 if m == 2 else 2\n    if n > 1:\n        yield n\n", "def solve(p):\n    n = p - 1\n    while n % 2 == 0 and pow(10, n, p) == 1:\n        n //= 2\n    s = pow(10, n, p)\n    for p2 in factors_gen(n):\n        if pow(10, n // p2, p) == s:\n            n //= p2\n    return ('%d-sum' if s == 1 else '%d-altsum') % n\n\n\ndef factors_gen(n):\n    while n % 2 == 0:\n        yield 2\n        n //= 2\n    k = 3\n    while k * k <= n:\n        while n % k == 0:\n            yield k\n            n //= k\n        k += 2\n    if n > 1:\n        yield n", "def solve(p):\n    d2 = -1\n    for d in range(1, int(p ** 0.5) + 1):\n        if (p - 1) % d == 0:\n            k = pow(10, d, p)\n            if k == 1:\n                return f'{d}-sum'\n            elif k == p - 1:\n                return f'{d}-altsum'\n            t = (p - 1) // d\n            k = pow(10, t, p)\n            if k == 1 or k == p - 1:\n                d2 = t\n    return f'{d2}-sum' if pow(10, d2, p) == 1 else f'{d2}-altsum'\n", "from math import floor, sqrt\n\ndef solve(p):\n    def powmod(x, n):\n        res, cur = 1, x\n        while n:\n            if n & 1 == 1:\n                res = (res * cur) % p\n            cur = (cur * cur) % p\n            n = n >> 1\n        return res\n\n    def invert(x):\n        return powmod(x, p - 2)\n\n    BLOCK = 1000\n    base = 10\n\n    baby = dict()\n    bcur = base % p\n    for i in range(1, BLOCK):\n        if bcur not in baby:\n            baby[bcur] = i\n        else:\n            break\n        bcur = (bcur * base) % p\n\n    step = invert(powmod(base, BLOCK))\n    pcur = 1\n    for j in range(0, p, BLOCK):\n        ans = []\n        def try_use(num, typ):\n            if num in baby:\n                totnum = j + baby[num]\n                if totnum > 0:\n                    ans.append((totnum, typ))\n            if num == 1 and j > 0:\n                ans.append((j, typ))\n\n        try_use(pcur, 'sum')\n        try_use(((p - 1) * pcur) % p, 'altsum')\n\n        if ans:\n            return '%d-%s' % min(ans)\n\n        pcur = (pcur * step) % p\n", "def solve(p):\n    i, ans = 1, 0\n    while i * i <= p - 1:\n        if (p - 1) % i == 0:\n            j = (p - 1) // i\n            if pow(10, i, p) == 1:\n                ans = i\n                break\n            if pow(10, j, p) == 1:  ans = j\n        i += 1\n    if pow(10, ans // 2, p) == p - 1: ans = str(ans // 2) + '-altsum'\n    else: ans = str(ans) + '-sum'\n    return ans"]