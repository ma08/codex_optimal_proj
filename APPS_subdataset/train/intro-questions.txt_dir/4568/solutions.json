["from functools import reduce\n\ndef find_min_max_product(arr, k):        \n    if k <= len(arr):\n        arr   = sorted(arr, key=abs)\n        lasts = arr[-k:]\n        v1    = reduce(int.__mul__, lasts)\n        v0    = reduce(int.__mul__, arr[:k])\n        \n        first_SameOrOpp   = [next((v for v in lasts              if cmp(v<0, v1<0) ), None) for cmp in (int.__eq__, int.__ne__)]\n        prevVal_OppOrSame = [next((v for v in reversed(arr[:-k]) if cmp(v<0, v1<0) ), None) for cmp in (int.__ne__, int.__eq__)]\n        \n        ans = [v0,v1] + [ v1*n//f for f,n in zip(first_SameOrOpp, prevVal_OppOrSame) if None not in (f,n) ]\n        \n        return min(ans), max(ans)\n", "from functools import reduce\nfrom operator import mul\n\ndef find_min_max_product(arr, k):\n    if k > len(arr): return None\n    \n    if k == 1: return min(arr), max(arr)\n    \n    if k == len(arr):\n        prod = reduce(mul, arr)\n        return prod, prod\n    \n    arr = sorted(arr)\n    prods = []\n    for i in range(k+1):\n        nums = arr[:k-i] + (arr[-i:] if i else [])\n        prods.append(reduce(mul, nums))\n    \n    return min(prods), max(prods)", "def find_min_max_product(arr, k):\n    n = len(arr)\n    if (k>n):\n        return None\n    \n    t_plus =[]\n    t_minus = []\n    res = []\n    for to in arr:\n        if (to==0):\n            res.append(0)\n        elif to>0:\n            t_plus.append(to)\n        else:\n            t_minus.append(to)\n            \n    t_plus.sort()\n    t_minus.sort()\n    \n    for to in t_plus:\n        res.append(to)\n    for to in t_minus:\n        res.append(to)\n    \n    ans = 1\n    \n    for i in range(k):\n        ans = ans*res[i];\n        \n    ans_min = ans\n    ans_max = ans\n    \n    for i in range(n-k+1):\n        ans = 1\n        for j in range(i,i+k):\n            ans=ans*res[j]\n            \n        ans_min = min(ans,ans_min)\n        ans_max = max(ans,ans_max)\n    \n    \n    return (ans_min,ans_max)\n", "def find_min_max_product(arr, k):\n    if k > len(arr): return None\n    arr.sort(key=abs, reverse=True)\n    neg, pos, prod = None, None, 1\n    for i in range(k):\n        if arr[i] < 0: neg = arr[i]\n        if arr[i] > 0: pos = arr[i]\n        prod *= arr[i]\n    neg1, pos1 = None, None\n    for i in range(k, len(arr)):\n        if not neg1 and arr[i] < 0: neg1 = arr[i]\n        if not pos1 and arr[i] > 0: pos1 = arr[i]\n        if neg1 and pos1: break\n    candidates = [prod]\n    if neg and pos1: candidates.append(prod // neg * pos1)\n    if pos and neg1: candidates.append(prod // pos * neg1)\n    if not (neg and neg1 and pos and pos1):\n        prod = 1\n        for i in range(-k, 0): prod *= arr[i]\n        candidates.append(prod)\n    return min(candidates), max(candidates)", "from operator import mul\nfrom functools import reduce\nfrom collections import deque\nfrom itertools import compress\nfrom heapq import nsmallest, nlargest\n\ndef find_min_max_product(arr, k):\n    if k <= len(arr):\n        large = nlargest(k, arr)[::-1]\n        small = nsmallest(min(k, len(arr) - k), arr)\n        darr = small + large\n        mask = deque([0] * len(small) + [1] * len(large))\n        res = []\n        for b in range(len(darr)):\n            res.append(reduce(mul, compress(darr, mask)))\n            mask.rotate(-1)\n        return min(res), max(res)", "from functools import reduce\nfrom fractions import Fraction\n\ndef index(l,x,f):\n    return f((i for i,v in enumerate(l) if (v>0)==(x>0)), default=None)\n\ndef find_min_max_product(arr, k):\n    if k>len(arr): return None\n    if len(arr)==1: return (arr[0],arr[0])\n    arr = sorted(arr, key=lambda n:(abs(n),-n))\n    prod = reduce(lambda a,b: a*b, arr[-k:], 1)\n    if(all((n>0)==(arr[0]>0) for n in arr)): return tuple(sorted([reduce(lambda a,b: a*b, arr[-k:], 1),reduce(lambda a,b: a*b, arr[:k], 1)]))\n    if min(k,len(arr)-k)==0: return (prod,prod)\n    ln,le,rn,re = [index(arr[:-k],1,max),index(arr[:-k],-1,max),index(arr[-k:],1,min),index(arr[-k:],-1,min)]\n    try: antiprod = int(prod*min([Fraction(arr[l],arr[r-k]) for l,r in [(le,rn),(ln,re)] if None not in (l,r)], default=prod//next(n for n in arr[:-k] if n!=0)))\n    except: antiprod = 0\n    return tuple(sorted([prod,antiprod]))", "def find_min_max_product(arr, k):\n    \n    if k>len(arr):\n        return None\n    \n    if k==1:\n        return min(arr), max(arr)\n    \n    if k==len(arr):\n        res = eval('*'.join([str(i) for i in arr]))\n        return res, res\n    \n    arr = sorted(arr)\n    \n    arr_abs = sorted([abs(i) for i in arr])\n    max_abs = max(arr_abs)\n    pos = len([i for i in arr if i > 0])\n    pos_all = [i for i in arr if i > 0]\n    neg_all = [i for i in arr if i < 0]\n    neg = len([i for i in arr if i < 0])\n    zer = len([i for i in arr if i == 0])\n\n    if pos==0 and zer==0 and k%2==0:\n        min_both = arr[-k:]\n        max_both = arr[:k] \n        \n    if pos==0 and zer==0 and k%2!=0:\n        min_both = arr[:k]\n        max_both = arr[-k:]\n        \n    if pos==0 and zer!=0 and k%2==0:\n        min_both = [0]\n        max_both = arr[:k]\n        \n    if pos==0 and zer!=0 and k%2!=0:\n        min_both = arr[:k]\n        max_both = [0]\n        \n    if neg==0 and zer==0:\n        min_both = arr[:k]\n        max_both = arr[-k:] \n        \n    if neg==0 and zer!=0:\n        min_both = [0]\n        max_both = arr[-k:]  \n        \n    if pos!=0 and neg!=0:\n        for_sort = sorted([[i, abs(i)] for i in arr], key=lambda i:i[1])\n        for_sort = [i[0] for i in for_sort]\n\n        all_pos = [i for i in for_sort if i>0]\n        all_neg = [i for i in for_sort if i<0]\n        \n        max_pos = [i for i in for_sort[-k:] if i>0]\n        max_neg = [i for i in for_sort[-k:] if i<0]\n        \n        for i in range(len(all_pos)-len(max_pos)):\n            max_pos.insert(0,0)\n            \n        for i in range(len(all_neg)-len(max_neg)):\n            max_neg.insert(0,0)\n        \n        pos_reserve = [a-b for a,b in zip(all_pos,max_pos)]\n        neg_pos_reserve = [a-b for a,b in zip(all_neg,max_neg)]\n\n        pos_reserve = [i for i in pos_reserve if not i==0]\n        neg_pos_reserve = sorted([i for i in neg_pos_reserve if not i==0])\n        max_pos = [i for i in max_pos if not i==0]\n        max_neg = [i for i in max_neg if not i==0]\n        \n        max_pos_alt = [i for i in for_sort[-k:] if i>0]\n        max_neg_alt = [i for i in for_sort[-k:] if i<0]\n\n        if len(max_neg)>0 and len(max_neg)%2 and len(pos_reserve)>0:\n            max_neg.pop(0)\n            max_pos.append(pos_reserve[-1])\n            if len(max_pos_alt)>0 and len(neg_pos_reserve)>0:\n                max_pos_alt.pop(0)\n                max_neg_alt.append(neg_pos_reserve[0])\n        elif len(max_neg)>0 and len(max_neg)%2 and len(pos_reserve)==0:\n            max_pos.pop(0)\n            max_neg.append(neg_pos_reserve[0])\n        elif len(max_neg)==1 and len(neg_pos_reserve)>0:\n            max_pos.pop(0)\n            max_neg.append(neg_pos_reserve[0])\n        elif len(max_neg)==1 and len(pos_reserve)>0:\n            max_neg.pop(0)\n            max_pos.append(pos_reserve[0])\n\n        \n        min_pos = [i for i in for_sort[-k:] if i>0]\n        min_neg = [i for i in for_sort[-k:] if i<0]\n\n        for i in range(len(all_pos)-len(min_pos)):\n            min_pos.insert(0,0)\n            \n        for i in range(len(all_neg)-len(min_neg)):\n            min_neg.insert(0,0)\n        \n        neg_reserve = [a-b for a,b in zip(all_neg,min_neg)]\n        pos_reserve_neg = [a-b for a,b in zip(all_pos,min_pos)]\n        \n        neg_reserve = sorted([i for i in neg_reserve if not i==0])\n        pos_reserve_neg = [i for i in pos_reserve_neg if not i==0]\n        \n        pos_reserve_neg_alt = pos_reserve_neg\n        \n        min_pos = [i for i in min_pos if not i==0]\n        min_neg = [i for i in min_neg if not i==0]\n\n        min_pos_alt = [i for i in for_sort[-k:] if i>0]\n        min_neg_alt = [i for i in for_sort[-k:] if i<0]\n\n        if not len(min_neg)%2:\n            if len(min_neg_alt)>0 and len(pos_reserve_neg_alt)>0:\n                min_neg_alt.pop(0)\n                min_pos_alt.append(pos_reserve_neg_alt[-1])\n            try:\n                min_neg.append(neg_reserve[0])\n                min_pos.pop(0)\n            except:\n                try:\n                    min_neg.pop(0)\n                    min_pos.append(pos_reserve_neg[-1])\n                except:\n                    pass\n                \n        elif not len(min_neg)%2 and 0 in arr:\n            min_neg.append(0)\n\n        max_both = max_pos+max_neg\n        max_both_alt = max_pos_alt+max_neg_alt\n        \n        min_both = min_pos+min_neg\n        min_both_alt = min_pos_alt+min_neg_alt\n         \n    mn = eval('*'.join([str(i) for i in min_both]))\n    mx = eval('*'.join([str(i) for i in max_both]))\n    \n    try:\n        mx_alt = eval('*'.join([str(i) for i in max_both_alt]))\n    except:\n        mx_alt = -10**1000\n         \n    try:\n        mn_alt = eval('*'.join([str(i) for i in min_both_alt]))\n    except:\n        mn_alt = 10**1000\n        \n    \n    return min(mn,mn_alt), max(mx,mx_alt)", "from operator import mul\nfrom itertools import accumulate\n\ndef A(li): return list(accumulate(li, mul))\n\ndef find_min_max_product(arr, k):\n    if len(arr) < k:return\n    \n    arr = sorted(arr)[::-1]\n    positive = [i for i in arr if i > 0]\n    negative = [i for i in arr if i <= 0][::-1]\n    neg, pos = A(negative), A(positive) \n    \n    maximum = get(pos, neg, A(arr), [], max, k)\n    minimum = get(pos, A(negative[::-1]), A(arr[::-1]), neg, min, k)\n    \n    return (minimum, maximum)\n\ndef get(pm, nm, tm, nm1, func, k):\n    return func([func([nm[i] * pm[k - i - 2]] + ([nm1[i] * pm[k - i - 2]] if nm1 else [])) for i in range(len(nm)) if  0<=k-i-2<len(pm)]\n               +[func(i[k - 1] for i in [pm, nm, tm, nm1] if k - 1 < len(i))])", "import random, math\n\n# even if k is on the order of n, the average case is O(n)\n# worst case is O(n^2)\ndef find_min_max_product(arr, k):\n    if k < 1 or k > len(arr) or len(arr) == 0:\n        return None\n    \n    # get k largest values (by absolute value)\n    # and also construct a list of all the other values\n    k_vals, other_vals = partition_around_k(arr, k, True)\n        \n    largest_product = 1\n    smallest_positive_k_val = None\n    smallest_negative_k_val = None\n    # single loop through arr, so still O(n)\n    for num in k_vals:\n        # calculate the largest possible product by absolute value\n        largest_product *= num\n        # get the smallest positive and smallest negative values in k_vals\n        if num > 0 and (smallest_positive_k_val == None or num < smallest_positive_k_val):\n            smallest_positive_k_val = num\n        if num < 0 and (smallest_negative_k_val == None or num > smallest_negative_k_val):\n            smallest_negative_k_val = num\n    \n    # min and max are the same\n    if k == len(arr):\n        return largest_product, largest_product\n    \n    # if the largest product was positive: now find the largest negative product\n    # if the largest product was negative: now find the largest positive product\n    other_min_or_max = negate_product(arr, largest_product, smallest_negative_k_val, smallest_positive_k_val, other_vals)\n\n    # if there was no way to flip the sign, instead find the smallest product by absolute value\n    if other_min_or_max == None:\n        # this mirrors the logic above, except with the seek_largest param flipped\n        k_vals, other_vals = partition_around_k(arr, k, False)\n        smallest_product = 1\n        for num in k_vals:\n            smallest_product *= num\n        other_min_or_max = smallest_product\n\n    # always return the min followed by max\n    if largest_product > other_min_or_max:\n        return other_min_or_max, largest_product\n    else:\n        return largest_product, other_min_or_max\n\n# find the other min or max by flipping one of its factors from positive to negative or vice versa\ndef negate_product(arr, largest_product, smallest_negative_k_val, smallest_positive_k_val, other_vals):\n    other_min_or_max = None\n    need_min = largest_product > 0\n    negate_removed = None\n    positive_removed = None\n    if smallest_negative_k_val != None:\n        negate_removed = largest_product // smallest_negative_k_val\n    if smallest_positive_k_val != None:\n        positive_removed = largest_product // smallest_positive_k_val\n    \n    # single loop through arr, so still O(n)\n    for num in other_vals:\n        # calculate new possible product\n        if num >= 0 and negate_removed != None:\n            product = negate_removed * num\n        elif num <= 0 and positive_removed != None:\n            product = positive_removed * num\n        else:\n            continue\n        \n        # update the min or max\n        if other_min_or_max == None:\n            other_min_or_max = product\n            continue\n        is_product_better = product < other_min_or_max if need_min else product > other_min_or_max\n        if is_product_better:\n            other_min_or_max = product\n            \n    return other_min_or_max\n\n# find k-th largest element, by distance from zero\n# average case O(n), worst case is O(n^2)\ndef quick_select_absolute_k(arr, k, seek_largest):\n    # base cases\n    if len(arr) == 1:\n        return arr[0]\n    if k == 1:\n        return find_absolute_extreme(arr, seek_largest)\n    \n    pivot_index = pick_pivot_index(arr, 0, len(arr) - 1)\n    smaller = []\n    larger = []\n    same = []\n    for num in arr:\n        if abs(num) < abs(arr[pivot_index]):\n            smaller.append(num)\n        elif abs(num) > abs(arr[pivot_index]):\n            larger.append(num)\n        else:\n            if seek_largest:\n                larger.append(num)\n            else:\n                smaller.append(num)\n            same.append(num)\n    \n    # everything remaining is duplicates\n    if len(same) == len(arr):\n        return arr[0]\n    \n    preferred_array = larger if seek_largest else smaller\n    other_array = smaller if seek_largest else larger\n    if len(preferred_array) >= k:\n        return quick_select_absolute_k(preferred_array, k, seek_largest)\n    else:\n        return quick_select_absolute_k(other_array, k - len(preferred_array), seek_largest)\n\n# change to median-of-medians to improve worst case from O(n^2) to O(n)\ndef pick_pivot_index(arr, min, max):\n    return random.randint(min, max)\n    \ndef find_absolute_extreme(arr, seek_largest):\n    extreme = None\n    for num in arr:\n        if extreme == None:\n            extreme = num\n        elif seek_largest and abs(extreme) < abs(num):\n            extreme = num\n        elif not seek_largest and abs(extreme) > abs(num):\n            extreme = num\n    return extreme\n\ndef partition_around_k(arr, k, seek_largest):\n    k_val = quick_select_absolute_k(arr, k, seek_largest)\n    k_vals = []\n    k_val_copies = []\n    other_vals = []\n    # single loop through arr, so still O(n)\n    for num in arr:\n        if abs(num) > abs(k_val):\n            if seek_largest:\n                k_vals.append(num)\n            else:\n                other_vals.append(num)\n        elif abs(num) < abs(k_val):\n            if seek_largest:\n                other_vals.append(num)\n            else:\n                k_vals.append(num)\n        else:\n            k_val_copies.append(num)\n    \n    # handling for duplicates\n    remainder = k - len(k_vals)\n    for i in range(remainder):\n        k_vals.append(k_val_copies[i])\n    for i in range(remainder, len(k_val_copies)):\n        other_vals.append(k_val_copies[i])\n    \n    return k_vals, other_vals", "from functools import reduce\nfrom typing import List, Optional, Tuple\n\ndef find_min_max_product(arr: List[int], kpi: int) -> Optional[Tuple[int, int]]:\n\n    if kpi <= len(arr):\n        mul = []\n        arr.sort()\n        for _ in range(kpi):\n            mul.append(reduce(lambda x, y: x * y, arr[0:kpi], 1))\n            mul.append(reduce(lambda x, y: x * y, arr[-kpi:], 1))\n            arr = [arr[-1]] + arr[:-1]\n        return min(mul), max(mul)\n    return None"]