["def pack_bagpack(scores, weights, capacity):\n    load = [0] * (capacity + 1)\n    for score, weight in zip(scores, weights):\n        load = [max(l, weight <= w and load[w - weight] + score)\n                for w, l in enumerate(load)]\n    return load[-1]", "def pack_bagpack(S,W,C) :\n    M = [0] * (1 + C)\n    for F,V in enumerate(S) :\n        M = [max(U,M[T - W[F]] + V if W[F] <= T else 0) for T,U in enumerate(M)]\n    return M[-1]", "def pack_bagpack(scores,weights,capacity):\n    sols=[[0 for j in range(capacity+1)] for i in range(len(scores)+1)]\n    scores.insert(0, 0)\n    weights.insert(0, 0)\n    for y,iy in enumerate(sols[1:],1):\n        for x,ix in enumerate(iy[1:],1):\n            if weights[y]<=x:\n                sols[y][x]=max(scores[y]+sols[y-1][x-weights[y]],sols[y-1][x])\n            else:\n                sols[y][x]=sols[y-1][x]\n    return sols[-1][-1]", "import numpy as np\n\ndef pack_bagpack(scores, weights, capacity):\n    print(len(scores))\n    print(capacity)\n    n = len(scores)\n    dp = np.zeros((n + 1, capacity + 1))\n    for i in range(1, n + 1):\n        for j in range(capacity + 1):\n            if j >= weights[i - 1]:\n                dp[i][j] = (max(dp[i - 1][j], dp[i - 1][j - weights[i - 1]] + scores[i - 1]))\n            else:\n                dp[i][j] = dp[i - 1][j]\n    return dp[n][capacity];           ", "import sys\nprint((sys.getrecursionlimit()))\n\ndef pack_bagpack(scores, weights, capacity):\n\n    if capacity >= sum(weights):\n        return sum(scores)\n\n    print(('{},{},{}'.format(scores, weights, capacity)))\n    items = [(i, j) for i, j in zip(scores, weights)]\n    def fetchBestMax(toConsider, avail, memo = {}):\n        if (len(toConsider), avail) in memo:\n            result = memo[(len(toConsider), avail)]\n        elif toConsider == [] or avail == 0:\n            result = (0, ())\n        elif toConsider[0][1] > avail:\n            #Explore right branch only\n            result = fetchBestMax(toConsider[1:], avail, memo)\n        else:\n            nextItem = toConsider[0]\n            #Explore left branch\n            withVal, withToTake =fetchBestMax(toConsider[1:], avail - nextItem[1], memo)\n            withVal += nextItem[0]\n            #Explore right branch\n            withoutVal, withoutToTake = fetchBestMax(toConsider[1:], avail, memo)\n            #Choose better branch\n            if withVal > withoutVal:\n                result = (withVal, withToTake + (nextItem,))\n            else:\n                result = (withoutVal, withoutToTake)\n        memo[(len(toConsider), avail)] = result\n        return result\n    \n    \n    maxVal = fetchBestMax(items, capacity)\n    print((\"maxVal\", maxVal))\n    return maxVal[0]\n", "def pack_bagpack(val, wt, W):\n    n = len(val) \n    K = [[0 for x in range(W+1)] for x in range(n+1)] \n    for i in range(n+1): \n        for w in range(W+1): \n            if i==0 or w==0: \n                K[i][w] = 0\n            elif wt[i-1] <= w: \n                K[i][w] = max(val[i-1] + K[i-1][w-wt[i-1]],  K[i-1][w]) \n            else: \n                K[i][w] = K[i-1][w] \n  \n    return K[n][W]", "def pack_bagpack(val, w, t):\n    if sum(w) <= t : return sum(val)\n    matrix = [[0 for _ in range(t + 1)] for _ in range(len(w) + 1)]\n    for i in range(1, len(w) + 1):\n        for j in range(1, t + 1):\n            matrix[i][j] = matrix[i-1][j] if j<w[i-1] else max(matrix[i-1][j],val[i-1]+matrix[i-1][j-w[i-1]])\n    return matrix[-1][-1]", "import time\ndef pack_bagpack(scores, weights, capacity):\n    \"\"\"\n    \u6c42\u6700\u5927\u5206\u6570\n    :param scores:   \u884c\u674e\u8bc4\u5206\u5217\u8868\n    :param weights:  \u884c\u674e\u91cd\u91cf\u5217\u8868\n    :param capacity: \u9650\u5236\u91cd\u91cf\n    :return: \u6700\u5927\u5206\u6570\n\n    1\uff09\u6309\u7167\u5747\u5206\u5012\u5e8f\u6392\u5217\n    2) \u9012\u5f52\u7ec4\u5408\n        max_value = max(\u5305\u542b\u81ea\u5df1\u7684\u6700\u5927\u503c, \u8df3\u8fc7\u81ea\u5df1\u7684\u6700\u5927\u503c)\n    3) \u5f97\u51fa\u6700\u4f18\n    \"\"\"\n    start_time = time.time()\n    # \u7ec4\u5408\n    lst = list(zip(scores, weights))\n\n    # 1) \u5012\u5e8f\u6392\u5217 >> \u5747\u5206 = \u5206\u6570/\u91cd\u91cf\n    lst_sorted = sorted(lst, key=lambda x: x[0], reverse=True)\n\n    cache_dict = {}\n\n    def calc_item(index, weight_last):\n        if index >= len(lst_sorted) or weight_last <= 0:\n            return 0\n        current = lst_sorted[index]\n\n        cache_key = \"{}-{}\".format(index, weight_last)\n\n        if cache_key not in cache_dict:\n            # \u7b97\u4e0a\u5f53\u524d\u7684\u6700\u5927\u7ed3\u679c\n            score_with_current = 0\n            if weight_last >= current[1]:\n                score_with_current = current[0] + calc_item(index + 1, weight_last - current[1])\n            # \u8df3\u8fc7\u5f53\u524d\u7684\u6700\u5927\u7ed3\u679c\n            score_no_current = calc_item(index + 1, weight_last)\n\n            # \u7f13\u5b58\u5f53\u524d\u7684\u4f4d\u7f6e\u548c\u5269\u4f59\u91cd\u91cf\u7684\u503c, \u8ba9\u4ee5\u540e\u7684\u9012\u5f52\u4e0d\u518d\u91cd\u590d\u8ba1\u7b97\u7c7b\u4f3c\u7ed3\u679c\n            cache_dict[cache_key] = max(score_with_current, score_no_current)\n            \n        return cache_dict[cache_key]\n\n    final_score = calc_item(0, capacity)\n\n    print(\"score: {}  duration---> {}\".format(final_score,time.time() - start_time))\n    # 3) \u5f97\u51fa\u6700\u4f18\n    return final_score", "def pack_bagpack(scores, weights, capacity):\n    dp=[[0,[]] for i in range(capacity+1)]\n    for j in range(1,len(scores)+1):\n        r = [[0,[]] for i in range(capacity+1)]\n        for i in range(1,capacity+1):\n            c,p = weights[j-1], scores[j-1]\n            if c<=i and p+dp[i-c][0]>dp[i][0]: r[i]=[p+dp[i-c][0], dp[i-c][1]+[j-1]]\n            else: r[i]=dp[i]\n        dp = r\n    return dp[-1][0]", "def pack_bagpack(scores, weights, capacity):\n    loads = [0] * (capacity + 1)\n    for score, weight in zip(scores, weights):\n        loads = [max(l, weight <= w and loads[w - weight] + score) for w, l in enumerate(loads)]\n    return loads[-1]"]