["from itertools import combinations\n\n\ndef isRect(a,b,c):\n    X,Y,Z = sorted( sum( (q-p)**2 for p,q in zip(p1,p2)) for p1,p2 in [(a,b), (a,c), (b,c)] )\n    return X+Y == Z\n\ndef count_rect_triang(points):\n    return sum( isRect(*c) for c in combinations(set(map(tuple, points)), 3) )", "from itertools import combinations\n\ndef count_rect_triang(points):\n    result = 0\n    for (x1,y1),(x2,y2),(x3,y3) in combinations(set(map(tuple, points)), 3):\n        d1 = (x1 - x2)**2 + (y1 - y2)**2\n        d2 = (x2 - x3)**2 + (y2 - y3)**2\n        d3 = (x3 - x1)**2 + (y3 - y1)**2\n        d1, d2, d3 = sorted((d1, d2, d3))\n        result += (d1 + d2 == d3)\n    return result", "from itertools import combinations\n\ndef ok(a, b, c):\n    (x1,y1),(x2,y2),(x3,y3) = a,b,c\n    d1,d2,d3 = (x1-x2)**2+(y1-y2)**2, (x1-x3)**2+(y1-y3)**2, (x2-x3)**2+(y2-y3)**2\n    d1,d2,d3 = sorted([d1,d2,d3])\n    return d1+d2 == d3\n    \ndef count_rect_triang(points):\n    return sum(ok(pa, pb, pc) for pa, pb, pc in combinations(set(map(tuple, points)), 3))", "f=lambda t,r=2:[sorted,iter][r-2](abs(sum(p)-2*p[-1])**2for p in map([list,f][r-2],__import__('itertools').combinations(t, r)))\ncount_rect_triang=lambda p:sum(d<1e-9for d in f({x + 1j*y for x,y in p}, 3))", "from itertools import combinations\n\ndef count_rect_triang(points):\n    return sum(1\n        for ps in combinations(set(map(tuple, points)), 3)\n        for p0, p1, p2 in ((ps[0], ps[1], ps[2]), (ps[1], ps[2], ps[0]), (ps[2], ps[1], ps[0]))\n        if (p1[0]-p0[0])*(p2[0]-p0[0]) + (p1[1]-p0[1])*(p2[1]-p0[1]) == 0)", "from itertools import product\n\ndef count_rect_triang(points):\n    return sum(1\n        for p0, p1, p2 in product(set(map(tuple, points)), repeat=3)\n        if p0 != p1 != p2 != p0 and (p1[0]-p0[0])*(p2[0]-p0[0]) + (p1[1]-p0[1])*(p2[1]-p0[1]) == 0\n        ) // 2", "def dist(ps):\n    p1, p2, p3 = ps\n    x = (p1[0]-p2[0])**2+(p1[1]-p2[1])**2\n    y = (p1[0]-p3[0])**2+(p1[1]-p3[1])**2\n    z = (p2[0]-p3[0])**2+(p2[1]-p3[1])**2\n    return sorted([x, y, z])\n\nfrom itertools import combinations\ndef count_rect_triang(points):\n    if len(points) < 3:\n        return 0\n    ps = []\n    for i in points:\n        if i not in ps:\n            ps.append(i)\n    c = 0\n    for i in combinations(ps, 3):\n        temp = dist(i)\n        if round(temp[-1], 4) == round(temp[0]+temp[1], 4):\n            c += 1\n    return c", "from itertools import combinations\ndef count_rect_triang(points):\n    n=0\n    points_set=set()\n    for p in points:\n        points_set.add(tuple(p))\n    for (x1,y1),(x2,y2),(x3,y3) in combinations(points_set,3):\n        l1,l2,l3=sorted([(x2-x1)**2+(y2-y1)**2,(x3-x2)**2+(y3-y2)**2,(x1-x3)**2+(y1-y3)**2])\n        if l1+l2==l3:\n            n+=1\n    return n", "from itertools import combinations\n\ndef count_rect_triang(points):\n    ans = 0\n    for c in combinations(set(map(tuple, points)), 3):\n        dist = [(p[0][0] - p[1][0])**2 + (p[0][1] - p[1][1])**2 for p in combinations(c, 2)]\n        ans += sum(dist) == max(dist) * 2\n    return ans"]