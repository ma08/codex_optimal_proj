["def make_triangle(m,n):\n    lns, sm = 0, 0\n    while sm < n - m + 1:\n        lns += 1\n        sm += lns\n    if sm > n - m + 1: return \"\"\n    matrix = [[0] * (i + 1) for i in range(lns)]\n    y, x, s = 0, 0, 0\n    ds = ((1, 1), (0, -1), (-1, 0))\n    dy, dx = ds[s]\n    for i in range(m, n + 1):\n        matrix[y][x] = str(i % 10)\n        if not 0 <= y + dy < len(matrix) or not 0 <= x + dx < len(matrix[y + dy]) or matrix[y + dy][x + dx]:\n            s += 1\n            dy, dx = ds[s % 3]\n        y, x = y + dy, x + dx\n    return \"\\n\".join(\" \".join(ln).center(len(matrix[-1]) * 2 - 1).rstrip() for ln in matrix)", "from itertools import cycle\nfrom math import sqrt\n\n\ndef make_triangle(start, end):\n    rows = sqrt(8 * (end - start) + 9) / 2 - .5\n\n    if not rows.is_integer():\n        return ''\n\n    rows = int(rows)\n    row, col, value = -1, -1, start\n\n    directions = cycle([(1, 0), (0, -1), (-1, 1)])\n    triangle = [[''] * n for n in range(1, rows + 1)]\n\n    for times in range(rows, 0, -1):\n        cur_dir = next(directions)\n\n        for _ in range(times):\n            row += cur_dir[0]\n            col += cur_dir[1]\n\n            triangle[row][col] = str(value % 10)\n            value += 1\n\n    return \"\\n\".join(' ' * (rows - i - 1) + ' '.join(r) for i, r in enumerate(triangle))\n", "from itertools import cycle\n\nMOVES = ((1,1),(0,-1),(-1,0))\n\ndef make_triangle(m,n):\n    X = ((1+8*(n-m+1))**.5-1) / 2\n    if X%1: return ''\n    \n    X   = int(X)\n    tri = [[-1]*(i+1) for i in range(int(X))]\n    x,y,v,moves = 0, 0, m%10, cycle(MOVES)\n    dx,dy = next(moves)\n    for _ in range(n-m+1):\n        tri[x][y] = str(v)\n        v = (v+1)%10\n        if not (0<=x+dx<X and 0<=y+dy<X) or tri[x+dx][y+dy]!=-1:\n            dx,dy = next(moves)\n        x+=dx ; y+=dy\n    return '\\n'.join(' '*(X-i-1)+' '.join(row) for i,row in enumerate(tri))", "def make_triangle(m,n):\n    size = ((8*(n-m+1)+1)**.5-1)/2\n    if size % 1 : return ''\n    \n    grid = [[' ' for _ in range(int(size)*2-1)] for _ in range(int(size))]\n    i,j = 0,int(size-1)\n    grid[i][j] = str(m%10)\n    \n    while m<n:\n        for inc,dec in [(1,1),(0,-2),(-1,1)]:\n            while 0<=i+inc<size and 0<=j+dec<size*2-1 and grid[i+inc][j+dec].isspace():\n                i, j, m = i+inc, j+dec, m+1\n                grid[i][j] = str(m%10)\n                \n    return '\\n'.join([''.join(i).rstrip() for i in grid])", "def make_triangle(m, n):\n    \"\"\"\n    makeTriangle produces a \u2206 in a special sequence of numbers.\n    m is the starting point and n is the finishibg one.\n    The final digit of each number is taken as a character in making the \u2206.\n    This functions returns a \u2206 as a string if possible with the given input else, returns an empty string.\n    \"\"\"\n\n    #Type check for arguments\n    if (type(m)!=type(0)) or (type(n)!=type(0)):\n        raise TypeError(\"m and n should be int\")\n    #Value check for arguments\n    if m >= n:\n        raise ValueError(\"m not < n\")\n\n    chars = [str(i)[-1] for i in range(m, n+1)]\n    #chars contains all the characters that will make up the \u2206.\n    \n    #Can this set of chars make a \u2206.\n    row, charc = 0, 0 #ncpr is the no. of rows in a \u2206. And charc is the no. of characters a \u2206 of specific side length contains. Both initially set to 0.\n\n    while True:\n        #The loop will break if the \u2206 is possible else, will cause the function to return an empty string.\n        row += 1; charc = 0\n        for j in range(1, row): charc += j\n        if len(chars) == charc: row -= 1; break\n        if len(chars) < charc: return ''\n    \n    #\u2206 generation\n    lor = [[' ' for j in range(i)] for i in range(1, row+1)] #lor contains all the rows of the \u2206 as white strings.\n    #For Step-1 to work\n    i1,sp, b = 0, 0, -1\n    #For Step-2 to work\n    c = 2\n    i2, l = row-c, 0\n    #For Step-3 to work\n    i3, j= row-2, 0\n    while True: \n        if len(chars)==0: break\n        #Step-1\n        while i1 <= row-1:\n            lor[i1][b] = chars[0]\n            chars.pop(0)\n            i1 += 1\n        i1 = sp+2; b -= 1\n        if len(chars)==0: break\n        #Step-2\n        while i2 >= l:\n            lor[row-1][i2] = chars[0]\n            chars.pop(0)\n            i2 -= 1\n        row -= 1; c += 1; i2 = row-c; l += 1\n        if len(chars)==0: break\n        #Step-3\n        while i3 > sp:\n            lor[i3][j] = chars[0]\n            chars.pop(0)\n            i3 -= 1\n        i3 = row-2; j += 1; sp += 2\n    l = ''\n    for i in lor:\n        if i==lor[0]:\n            l += ' '*(len(lor)-len(i))+i[0]+'\\n'\n            continue\n        for j in range(len(i)):\n            if j==0:\n                l += ' '*(len(lor)-len(i))+i[j]+' '\n            elif j==len(i)-1:\n                l += i[j]\n            else:\n                l += i[j]+' '\n        if i!=lor[-1]:\n            l += '\\n'\n    return l", "def make_triangle(m,n):\n    count=0\n    rec=n-m+1\n    for i in range(1,99999999):\n        count+=i\n        if count>rec:\n            return \"\"\n        elif count==rec:\n            limit=i\n            break\n    right=limit\n    left=0\n    triangle=[[\" \"]*i for i in range(1,limit+1)]  \n    while m<=n:\n        for i in range(left,right):\n            triangle[i+left][i]=str(m%10)\n            m+=1\n        right-=1\n        for i in range(right-1,left-1,-1):\n            triangle[right+left][i]=str(m%10)\n            m+=1\n        right-=1\n        for i in range(right,left,-1):\n            triangle[i+left][left]=str(m%10)\n            m+=1\n        left+=1\n    res=[]\n    for j,i in enumerate(triangle):\n        res.append(\" \"*(limit-(j)-1)+\" \".join(i))\n    return \"\\n\".join(res)", "def make_triangle(n,m):\n    layers = layer(m-n+1)\n    if layers == False:\n        return \"\"\n    board = []\n    for i in range(layers):\n        board.append([\"\"]*(i+1))\n    triangle = make(n%10,board,0,0,len(board))\n    return tri_print(triangle)\n    \ndef layer(n):\n    a = 0\n    layer = 0\n    for i in range(1,n):\n        a+= i\n        layer += 1\n        if a == n:\n            return layer\n        elif a > n:\n            return False\n        else:\n            continue\ndef tri_print(board):\n    sentence = \"\"\n    for i in range(len(board)):\n        sentence += \" \"*(len(board)-1-i)\n        for j in range(len(board[i])):\n            sentence+= str(board[i][j]) + \" \"\n        sentence = sentence[:-1] + \"\\n\"\n    return sentence[:-1]\n    \n    \ndef make(n,board,row,col,x):\n    for i in range(row,x):\n        if board[i][col] == \"\":\n            board[i][col] = n\n            if n == 9:\n                n = 0\n            else:\n                n+=1\n        col +=1\n    for j in range(x-1,-1,-1):\n        if board[x-1][j] == \"\" :\n            board[x-1][j] = n\n            n_col = j\n            if n == 9:\n                n = 0\n            else:\n                n+=1\n    if check(board):\n        return board\n    for z in range(x-1,row,-1):\n        if board[z][n_col] == \"\":\n            board[z][n_col] = n\n            rw,cl = z,n_col\n            if n == 9:\n                n = 0\n            else:\n                n+=1\n                \n    if not check(board):\n        return make(n,board,rw,cl,x-1)\n    return board\n\ndef check(board):\n    for i in board:\n        for j in i:\n            if j == \"\" :\n                return False\n    return True", "def make_triangle(start, end):\n    from itertools import cycle\n    from math import sqrt\n\n    rows = sqrt(8 * (end - start) + 9) / 2 - .5\n    if not rows.is_integer():\n        return ''\n\n    rows = int(rows)\n    row, col, fill = -1, -1, start\n    ls = [[''] * n for n in range(1, rows+1)]\n    directions = cycle([(1, 1), (0, -1), (-1, 0)])\n\n    for i in range(rows):\n        dir = next(directions)\n\n        for j in range(rows-i):\n            row += dir[0]\n            col += dir[1]\n            ls[row][col] = str(fill%10)\n            fill += 1\n\n    return '\\n'.join(' ' * (rows-i-1) + ' '.join(r) for i, r in enumerate(ls))\n", "import numpy as np\ndef make_triangle(m,n):\n    num=n-m+1\n    level=int((num*2)**(1.0/2))\n    if level*(level+1)/2!=num:\n        return \"\"\n    else:\n        level_max=level*2-1\n        npres=np.full((level,level_max),' ')\n        l,p,f=0,level_max//2,int(str(m)[-1])\n        for i in range(num):\n            npres[l][p]=f\n            f=(f+1)%10\n            if p>=level_max//2 and l!=level-1:\n                if npres[l+1][p+1]==' ':\n                    l+=1\n                    p+=1\n                else:\n                    p-=2\n                    level-=1\n            elif l==level-1 and p>0:\n                if npres[l][p-2]==' ':\n                    p-=2\n                else:\n                    p+=1\n                    l-=1\n            elif (p<level_max//2 and l!=level-1) or( l==level-1 and p==0):\n                if npres[l - 1][p + 1] == ' ':\n                    p+=1\n                    l-=1\n                else:\n                    l+=1\n                    p+=1\n        res='\\n'.join(''.join(str(x) for x in n).rstrip() for n in npres.tolist() )\n        return res", "def make_triangle(m,n):\n    if n == m:\n        return m\n\n    else:\n        Num = len(range(m,n+1))\n\n        elNum = 0\n        k = 1\n        while elNum < Num:\n            k += 1\n            elNum = int(k*(k+1)/2)\n        \n        if elNum != Num:\n            return \"\"\n    \n    Lyr = (k-1)//3 + 1\n\n\n    L1 = []\n    for i in range(k):\n        L1.append([])\n        for j in range(k+i):\n            L1[-1].append(\" \")\n        L1[-1].append(\"\\n\")\n\n    el = m-1\n\n    for CLyr in range(Lyr):\n        topR = 2*CLyr\n        topC = -2*(CLyr+1)\n        \n        CSize = k - 3*CLyr\n\n        for i in range(CSize):\n            el += 1\n            L1[topR+i][-2*(1+CLyr)] = str(el % 10)\n\n        for i in range(CSize-1):\n            el += 1\n            L1[topR+CSize-1][-4-2*(i+CLyr)] = str(el % 10)\n\n        for i in range(CSize-2):\n            el += 1\n            L1[topR+CSize-1-1-i][i+1+CLyr*3] = str(el % 10)\n\n    L2 = [e for inner_list in L1 for e in inner_list][:-1]\n    return \"\".join(L2)"]