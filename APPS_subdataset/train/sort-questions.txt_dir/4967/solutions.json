["def knapsack(capacity, items):\n    ratios = [float(item[1]) / item[0] for item in items]\n    collection = [0] * len(items)\n    space = capacity\n    while any(ratios):\n        best_index = ratios.index(max(ratios))\n        if items[best_index][0] <= space:\n            collection[best_index] += 1\n            space -= items[best_index][0]\n        else:\n            ratios[best_index] = 0\n    return collection", "def knapsack(c, items):\n    qtys = [0 for i in items]\n    weights = sorted(items, reverse=True, key=lambda (size, value): float(value)/size)\n    for (size, value) in weights:\n        qty = c // size\n        qtys[items.index((size, value))] = qty\n        c -= qty * size\n    return qtys", "def knapsack(capacity, items):\n    r = [0] * len(items)\n    for i, item in sorted(enumerate(items), key=lambda x: x[1][1] / float(x[1][0]), reverse=True):\n        while capacity >= item[0]:\n            capacity -= item[0]\n            r[i] += 1\n    return r", "def knapsack(capacity, items):\n  sortItems = sorted(items, key=lambda tup: (tup[1] / float(tup[0])))[::-1]\n  sortCount = [(i[0], i[1], 0) for i in sortItems]\n  rCap = capacity\n  for i in range(len(sortCount)) :\n    while rCap >= sortCount[i][0] :\n      sortCount[i] = (sortCount[i][0], sortCount[i][1], sortCount[i][2] + 1)\n      rCap -= sortCount[i][0]\n  counts = [sortCount[sortItems.index(i)][2] for i in items]\n  return counts", "def knapsack(capacity, items):\n    quantities = [0] * len(items)\n    for idx, (size, value) in sorted(enumerate(items),\n                key=lambda it: it[1][1] / it[1][0], reverse=True):\n        quantities[idx], capacity = divmod(capacity, size)\n    return quantities", "def knapsack(capacity, items):\n    arr = sorted(enumerate(items), key = lambda x: x[1][1]/x[1][0], reverse = True)\n    sack = [0]*len(items)\n    \n    for j, (w, v) in arr:\n        if w <= capacity:\n            sack[j], capacity = divmod(capacity, w)\n    \n    return sack", "def knapsack(capacity, items):\n    ratios = [float(item[1]) / item[0] for item in items]\n    collection = [0] * len(items)\n    space = capacity\n    while True:\n        best_index = ratios.index(max(ratios))\n        if items[best_index][0] <= space:\n            collection[best_index] += 1\n            space -= items[best_index][0]\n        else:\n            ratios[best_index] = 0\n        if all(ratio == 0 for ratio in ratios):\n            return collection", "def knapsack(capacity, items):\n    liste = sorted([ x+(i,) for i,x in enumerate(items)], key= lambda x: x[1]/x[0], reverse = True)\n    result = [0]*len(items)\n    for s,v,i in liste :\n        if capacity >= s :\n            result[i] = int(capacity/s)\n            capacity -= result[i]*s\n    return result", "def knapsack(capacity, items):\n    res = [0] * len(items)\n    vsi = sorted(((v / s, s, c) for c, (s, v) in enumerate(items)), reverse=True)\n    for _, s, c in vsi:\n        res[c], capacity = divmod(capacity, s)\n    return res", "def knapsack(capacity, items):\n    L = sorted((-y/x, x, i) for i,(x,y) in enumerate(items))\n    res = [0]*len(L)\n    for _, x, i in L:\n        res[i], capacity = divmod(capacity, x)\n    return res"]