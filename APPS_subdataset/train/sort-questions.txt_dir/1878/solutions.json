["class Solution:\n     def maxChunksToSorted(self, arr):\n         \"\"\"\n         :type arr: List[int]\n         :rtype: int\n         \"\"\"\n         res = 0\n         temp = sorted(arr)\n         sum1, sum2 = 0, 0\n         for i in range(0,len(arr)):\n             sum1 += arr[i]\n             sum2 += temp[i]\n             if(sum1 == sum2):\n                 res += 1\n         return res\n", "import collections\n class Solution:\n     '''\n     >>> sol = Solution()\n     >>> sol.maxChunksToSorted([2,1,3,4,4])\n     4\n     >>> sol.maxChunksToSorted([4, 3, 2, 1, 0])\n     1\n     >>> sol.maxChunksToSorted([0, 1])\n     2\n     '''\n     def maxChunksToSorted(self, arr):\n         \"\"\"\n         :type arr: List[int]\n         :rtype: int\n         \"\"\"\n         counter = collections.Counter()\n         arrtup = []\n         for num in arr:\n             counter[num] += 1\n             arrtup.append((num, counter[num]))\n         arrsorted = sorted(arrtup)\n         ans, maxnum = 0, (0, 0)\n         for x, y in zip(arrtup, arrsorted):\n             maxnum = max(maxnum, x)\n             if maxnum == y:\n                 ans += 1\n \n         return ans\n \n", "from itertools import accumulate\n \n \n class Solution:\n     def maxChunksToSorted(self, arr):\n         right_min = list(accumulate(arr[::-1], lambda m, a: min(m, a)))[::-1]\n         right_min = right_min[1:] + [float('inf')]\n         left_max = list(accumulate(arr, lambda m, a: max(m, a)))\n         return sum(1 for x, y in zip(left_max, right_min) if x <= y)", "class Solution:\n     def maxChunksToSorted(self, arr):\n         \"\"\"\n         :type arr: List[int]\n         :rtype: int\n         \"\"\"\n         mxvs, mnvs = [-1] * len(arr), [10**8 + 1] * len(arr)\n         for i, v in enumerate(arr):\n             if i == 0:\n                 mxvs[i] = arr[i]\n             else:\n                 mxvs[i] = max(mxvs[i-1], v)\n         for i in range(len(arr))[::-1]:\n             if i == len(arr) - 1:\n                 mnvs[i] = arr[i]\n             else:\n                 mnvs[i] = min(mnvs[i+1], arr[i])\n         \n         cnt = 0\n         for i in range(len(arr)):\n             if mxvs[i] <= (mnvs[i+1] if i < len(arr) - 1 else 10**8 + 1):\n                 cnt += 1\n         return cnt\n", "class Solution:\n     def maxChunksToSorted(self, arr):\n         \"\"\"\n         :type arr: List[int]\n         :rtype: int\n         \"\"\"\n         stack = []\n         for num in arr:\n             if len(stack)==0 or stack[-1] <= num:\n                 stack.append(num)\n             else:\n                 maxnum = stack.pop()\n                 while len(stack)>0 and stack[-1]>num:\n                     stack.pop()\n                 stack.append(maxnum)\n         return len(stack)", "class Solution:\n     def maxChunksToSorted(self, arr):\n         \"\"\"\n         :type arr: List[int]\n         :rtype: int\n         \"\"\"\n         arr_index=sorted(list(range(len(arr))), key=arr.__getitem__)\n         ans = ma = 0\n         for i, x in enumerate(arr_index):\n             ma = max(ma, x)\n             if ma == i: ans += 1\n         return ans\n", "class Solution:\n     def maxChunksToSorted(self, arr):\n         \"\"\"\n         :type arr: List[int]\n         :rtype: int\n         \"\"\"\n         stack = []\n         for e in reversed(arr):\n             min_so_far = e\n             while True:\n                 if len(stack) == 0 or e <= stack[-1][0]:\n                     stack.append([min_so_far, e])\n                     break\n                 if e > stack[-1][1]:\n                     min_so_far = min(min_so_far, stack.pop()[0])\n                 else:\n                     stack[-1][0] = min(min_so_far, stack[-1][0])\n                     break\n                     \n         return len(stack)", "import math\n class Solution:\n     def maxChunksToSorted(self, arr):\n         count = 0\n \n         minVal = [0] * len(arr)\n         minSofar = math.inf\n         for idx in reversed(range(len(arr))):\n             minVal[idx] = min(minSofar, arr[idx])\n             minSofar = minVal[idx]\n \n         maxSofar = -math.inf\n         for idx in range(len(arr)):\n             maxSofar = max(maxSofar, arr[idx])\n             if idx == len(arr) - 1:\n                 count += 1\n             elif maxSofar <= minVal[idx+1]:\n                 count+=1\n \n \n         return count", "class Solution:\n     def maxChunksToSorted(self, arr):\n         \"\"\"\n         :type arr: List[int]\n         :rtype: int\n         \"\"\"\n         \n         sarr = sorted(arr)\n         table = {}\n         for i, n in enumerate(sarr):\n             if n not in table:\n                 table[n] = [i, i]\n             else:\n                 table[n][1] += 1\n         \n         c = -1\n         chunks = 0\n         for i, n in enumerate(arr):\n             c = max(c, table[n][0])\n             if table[n][0] < table[n][1]:\n                 table[n][0] += 1\n             if c == i:\n                 chunks += 1\n         return chunks", "class Solution:\n     def maxChunksToSorted(self, arr):\n         \"\"\"\n         :type arr: List[int]\n         :rtype: int\n         \"\"\"\n         \n         if arr is None:\n             return 0\n         \n         if len(arr) < 2:\n             return len(arr)\n         \n         # Preprocess suffix min\n         suffix_min = [float('inf')] * len(arr)\n         suffix_min[-1] = arr[-1]\n         suffix_max = [float('-inf')] * len(arr)\n         suffix_max[-1] = arr[-1]\n         for index in range(len(arr) - 2, -1, -1):\n             suffix_min[index] = min(arr[index + 1], suffix_min[index + 1])\n             suffix_max[index] = max(arr[index + 1], suffix_max[index + 1])\n         \n         index = 0\n         chunk_count = 0\n         \n         print(suffix_min)\n         \n         while index < len(arr):\n             chunk_count += 1\n             if arr[index] > suffix_min[index]:\n                 j = index\n                 running_max = arr[j]\n                 while j < len(arr) and running_max > suffix_min[j]:\n                     running_max = max(running_max, arr[j])\n                     j += 1\n                 # Now j is at the index where all the following elements are greater than or equal to arr[j]\n                 index = j + 1\n             else:\n                 index += 1\n         \n         return chunk_count", "class Solution:\n     def maxChunksToSorted(self, arr):\n         \"\"\"\n         :type arr: List[int]\n         :rtype: int\n         \"\"\"\n         t = arr[0]\n         left_max = []\n         \n         for x in arr:\n             t = max(t, x)\n             left_max.append(t)\n             \n         t = arr[-1]\n         right_min = []\n         for i in range(len(arr) - 1, -1, -1):\n             t = min(arr[i], t)\n             right_min.append(t)\n         \n         count = 1\n         \n         # print(right_min) \n         # print(left_max)\n \n         for i in range(0, len(arr) - 1):\n             if left_max[i] <= right_min[len(arr) - i -2]:\n                 count += 1\n                 \n         return count", "class Solution:\n     def maxChunksToSorted(self, arr):\n         \"\"\"\n         :type arr: List[int]\n         :rtype: int\n         \"\"\"\n         dict = {}           #\u5b58\u50a8\u6392\u5e8f\u540e\u7684\u6bcf\u4e2a\u5143\u7d20\u7684\u4f4d\u7f6e\n         sortedArr = sorted(arr)\n         for i in range(len(sortedArr)):\n             if(sortedArr[i] not in dict):\n                 dict[sortedArr[i]] = [i]\n             else:\n                 dict[sortedArr[i]].append(i)\n \n         position = []       #\u5b58\u50a8\u6bcf\u4e2a\u5143\u7d20\u76f8\u5bf9\u6392\u5e8f\u540e\u7684\u6570\u7ec4\u5e94\u8be5\u79fb\u52a8\u7684\u8ddd\u79bb\n         for i, val in enumerate(arr):\n             position.append(dict[val][0] - i)\n             dict[val].pop(0)           #\u53ef\u80fd\u6709\u91cd\u590d\u5143\u7d20\uff0c\u90a3\u4e48\u5728\u4f7f\u7528\u5b8c\u4e00\u4e2a\u5143\u7d20\u540e\uff0c\u5c31\u628a\u4f7f\u7528\u8fc7\u7684\u5143\u7d20\u4f4d\u7f6e\u5220\u9664\n \n \n         maxNum = 0\n         i = 0\n         ifPlusMinus = 0         #\u7528\u4e8e\u5224\u65ad\u662f\u5426\u9700\u8981\u79fb\u52a80\u4f4d\u7f6e\u7684\u6570\u5305\u542b\u5728\u9700\u8981\u5de6\u53f3\u90fd\u79fb\u52a8\u7684\u6570\u4e4b\u95f4\uff0c\u5982[4,3,2,1,0]\n                                 #\u8be5\u6570\u7ec4\u4e2d2\u662f\u4e0d\u79fb\u52a8\u7684\uff0c\u4f46\u56e0\u4e3a4\uff0c3\u548c1\uff0c0\u90fd\u8981\u79fb\u52a8\uff0c\u6240\u4ee5\u4e0d\u80fd\u5355\u72ec\u53e6\u7b97\n         maxIdealPosition = 0   #\u7528\u4e8e\u5b58\u50a8\u8981\u79fb\u52a8\u5b50\u6570\u7ec4\u4e2d\u5de6\u4fa7\u5143\u7d20\u5411\u53f3\u79fb\u52a8\u7684\u6700\u5927\u8ddd\u79bb\n         while(i < len(position)):\n             if(position[i] == 0 and ifPlusMinus == 0):\n                 maxNum += 1\n                 i += 1\n             elif(position[i] > 0 and ifPlusMinus == 0):     #\u8981\u79fb\u52a8\u7684\u5b50\u6570\u7ec4\u4e2d\u5904\u4e8e\"\u6700\u5de6\u9762\u6700\u5f00\u59cb\u4f4d\u7f6e\"\u9700\u8981\"\u53f3\u79fb\"\u7684\u6570\uff0c\u5b83\u4e00\u5b9a\u4f1a\u5339\u914d\u5230\u6700\u53f3\u4fa7position\u662f\u8d1f\u6570\u7684\u6570\n                 ifPlusMinus = 1\n                 maxIdealPosition = i + position[i]\n                 i += 1\n             elif(position[i] >= 0 and ifPlusMinus == 1):    #\u5904\u4e8e\u8981\u79fb\u52a8\u5b50\u6570\u7ec4\u7684\"\u4e2d\u95f4\u4f4d\u7f6e\"\n                 if(i + position[i] > maxIdealPosition):     #\u67e5\u770b\u662f\u5426\u9700\u8981\u66f4\u65b0maxIdealPosition\u503c\uff0c\u5982arr=[1,2,0,3],position=[1,1,-2,0]\n                     maxIdealPosition = i + position[i]\n                 i += 1\n             elif(position[i] <0 and ifPlusMinus == 1):      #\u5904\u4e8e\u8981\u79fb\u52a8\u5b50\u6570\u7ec4\u7684\"\u672b\u5c3e\u4f4d\u7f6e\"\n                 if(i < len(position) - 1):\n                     if(position[i+1] < 0):\n                         i += 1\n                     elif(position[i+1] >= 0):\n                         if(i == maxIdealPosition):        #\u5224\u65ad\u662f\u5426\u5df2\u626b\u63cf\u5230\u8981\u79fb\u52a8\u6570\u7ec4\u4e2d\u9700\u8981\u53f3\u79fb\u6570\u7ec4\u7684\u6700\u5927\u7406\u60f3\u4f4d\u7f6e\n                             maxNum += 1\n                             ifPlusMinus = 0\n                             maxIdealPosition = 0\n                         i += 1\n                 else:\n                     maxNum += 1\n                     ifPlusMinus = 0\n                     i += 1\n \n         return maxNum", "class Solution:\n     def maxChunksToSorted(self, arr):\n         \"\"\"\n         :type arr: List[int]\n         :rtype: int\n         \"\"\"\n         from collections import Counter\n         s = sorted(arr)\n \n         i = 0\n         a_nums = Counter()\n         b_nums = Counter()\n         total = 0\n         while i < len(arr):\n             a_nums[arr[i]] += 1\n             b_nums[s[i]] += 1\n             if a_nums == b_nums:\n                 a_nums.clear()\n                 b_nums.clear()\n                 total += 1\n             i += 1\n \n         return total"]