["class Solution:\n    def minSwap(self, A: List[int], B: List[int]) -> int:\n        \n        n = len(A)\n        \n        if n == 1:\n            return 0\n        \n        dp = [[float('inf'), float('inf')] for _ in range(n)]\n        dp[0] = [0,1] #[natural, swapped]\n        \n        for i in range(1, n):\n            if A[i-1] < A[i] and B[i-1] < B[i]:\n                dp[i] = [dp[i-1][0], dp[i-1][1]+1]\n            if A[i-1] < B[i] and B[i-1] < A[i]:\n                dp[i] = [min(dp[i][0],dp[i-1][1]), min(dp[i][1],dp[i-1][0]+1)]\n                \n        print(dp)\n                \n\n        return min(dp[-1])\n", "class Solution:\n    def minSwap(self, A, B):\n        # \u8fd9\u9053\u9898\u662f\u8bf4A\u548cB\u7684swap\u662f\u76f8\u5bf9\u5e94\u7684\u4f4d\u7f6eswap\n        # index\u7684\u904d\u5386\u662f\u540c\u65f6\u904d\u5386A\u548cB\u7684\n        \n        # \u72b6\u6001\u5c31\u662f\u5f53\u524d\u5904\u7406\u7684\u662f\u7b2c\u51e0\u4f4d + \u8fd9\u4e00\u4f4d\u662f\u4e0d\u662fswap\u8fc7\u6765\u7684\n        #                 start^       swapped^\n        return self._dfs(A, B, start=0, swapped=False, memo={})\n    \n    def _dfs(self, A, B, start, swapped, memo):\n        if start == len(A):\n            return 0\n        \n        key = (start, swapped)\n        if key in memo:\n            return memo[key]\n\n        res = 2 ** 31 - 1\n        prev_a = A[start - 1] if start > 0 else -2 ** 31 - 1\n        prev_b = B[start - 1] if start > 0 else -2 ** 31 - 1\n        \n        if A[start] > prev_a and B[start] > prev_b:\n            res = min(res, self._dfs(A, B, start + 1, False, memo))\n        \n        # \u6ce8\u610f\u8fd9\u91cc\u4e0d\u80fd\u8df3\u8fc7\n        # \u5426\u5219\u4f1a\u6f0f\u6389\u4e00\u4e9bcase\n        if A[start] > prev_b and B[start] > prev_a:\n            A[start], B[start] = B[start], A[start]\n            res = min(res, self._dfs(A, B, start + 1, True, memo) + 1)\n            A[start], B[start] = B[start], A[start]\n        \n        memo[key] = res\n        return res", "class Solution:\n    def minSwap(self, A: List[int], B: List[int]) -> int:\n        n=len(A)\n        mem = {}\n        def rec(index,ifSwapped):\n            if index==n:\n                return 0\n            elif (index,ifSwapped) in mem:\n                return mem[(index,ifSwapped)]\n            else:\n                ans=float('inf')\n                #Don't swap if possible\n                if A[index]>A[index-1] and B[index]>B[index-1]:\n                    ans=min(ans,rec(index+1,0))\n                #Swap if possible\n                if A[index]>B[index-1] and B[index]>A[index-1]:\n                    A[index],B[index]=B[index],A[index] #Swap\n                    ans=min(ans,1+rec(index+1,1))\n                    A[index],B[index]=B[index],A[index] #Swap them back\n                mem[(index,ifSwapped)]=ans\n                return ans\n            \n        ans=float('inf')\n        ans=min(ans,rec(1,0))\n        A[0],B[0]=B[0],A[0]\n        ans=min(ans,1+rec(1,1))\n        A[0],B[0]=B[0],A[0]\n        \n        return ans", "class Solution:\n    def minSwap(self, A: List[int], B: List[int]) -> int:\n        \n        no, yes, n = 0, 1, len(A)\n        for i in range(1, n):\n            no_u, yes_u = n, n\n            if A[i-1] < A[i] and B[i-1] < B[i]:\n                no_u, yes_u = no, yes + 1\n            if A[i-1] < B[i] and B[i-1] < A[i]:\n                no_u = min(no_u, yes)\n                yes_u = min(yes_u, no+1)  \n            \n            no, yes = no_u, yes_u\n        return min(no, yes)", "class Solution:\n    def minSwap(self, A: List[int], B: List[int]) -> int:\n        N = len(A)\n        not_swap, swap = 0, 1\n        for i in range(1, N):\n            not_swap2 = swap2 = N \n            if A[i - 1] < A[i] and B[i - 1] < B[i]:\n                swap2 = swap + 1\n                not_swap2 = not_swap\n            if A[i - 1] < B[i] and B[i - 1] < A[i]:\n                swap2 = min(swap2, not_swap + 1)\n                not_swap2 = min(not_swap2, swap)\n            swap, not_swap = swap2, not_swap2\n        return min(swap, not_swap)", "class Solution:\n    def minSwap(self, A, B):\n        N = len(A)\n        #keep, swap = [0] * N, [0] * N\n        #keep, swap = [N] * N, [N] * N\n        keep, swap = [_ for _ in range(N)], [_ for _ in range(N)]\n        swap[0] = 1                                      # important!\n        for i in range(1, N):\n            if A[i] > A[i-1] and B[i] > B[i-1]:\n                keep[i] = keep[i-1]                      # keep, keep\n                swap[i] = swap[i-1] + 1                  # swap, swap\n            if A[i] > B[i-1] and B[i] > A[i-1]:\n                swap[i] = min(swap[i], keep[i-1] + 1)    # keep, swap\n                keep[i] = min(keep[i], swap[i-1])        # swap, keep\n        return min(keep[-1], swap[-1])\n    \nclass Solution:\n    def minSwap(self, A, B):\n        N = len(A)\n        keep, swap = [_ for _ in range(N)], [_ for _ in range(N)]\n        swap[0] = 1\n        for i in range(1, N):\n            if A[i] > A[i-1] and B[i] > B[i-1]:\n                keep[i] = keep[i-1]\n                swap[i] = swap[i-1] + 1\n            if A[i] > B[i-1] and B[i] > A[i-1]:\n                if keep[i-1] + 1 < swap[i]: swap[i] = keep[i-1] + 1\n                if swap[i-1] < keep[i]: keep[i] = swap[i-1]\n        return min(keep[-1], swap[-1])"]