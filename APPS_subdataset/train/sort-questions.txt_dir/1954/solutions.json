["class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        \n\n        def fulfill_skills(skills, person):\n            remaining_skills = deque()\n            for skill in skills:\n                if skill not in people[person]:\n                    remaining_skills.appendleft(skill)\n            return remaining_skills\n\n        # BFS by # of people\n        # can reduce expansion by searching rarest skills first\n\n        # map required skills to people\n        # has_skill[\\\"java\\\"] == a list of people (int index into people) who have that skill\n        has_skill = dict()\n        for person, skills in enumerate(people):\n            for skill in skills:\n                experts = has_skill.get(skill, [])\n                experts.append(person)\n                has_skill[skill] = experts\n\n\n        # sort skills by rarity\n        rare_skills = [(len(people), skill)  for (skill, people) in list(has_skill.items())]\n        rare_skills.sort()\n        rare_skills = [skill for _, skill in rare_skills]\n\n\n        for i in range(1, 17):\n            # stack holds pairs:\n            #   (skills, team)\n            stack = [ (deque(rare_skills), []) ]\n            while stack:\n                skills, team = stack.pop()\n                # print(skills, team)\n                if not skills:\n                    return team\n\n                if len(team) + 1 > i:\n                    continue\n                # choose a member to fulfill next rarest skill\n                skill = skills[0]\n                for person in has_skill[skill]:\n                    remaining_skills = fulfill_skills(skills, person)\n                    stack.append( (remaining_skills, team + [person]) )\n            # print(f\\\"i {i} failed\\\")\n\n        return -1\n", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        skillsMap = {s: i for i, s in enumerate(req_skills)}\n        peopleSkills = collections.defaultdict(set)\n        for i, p in enumerate(people):\n            for s in p:\n                peopleSkills[skillsMap[s]].add(i)\n        n = len(req_skills)\n        \n        memo = {}\n        res = []\n        \n        \n        self.dfs(1 << n, memo, peopleSkills, res, n, people, skillsMap)\n        return memo[1 << n]\n    \n    \n    def dfs(self, state, memo, peopleSkills, res, n, people, skillsMap):\n        # print(bin(state)[1:])\n        if state == 2 ** (n+1) - 1:\n            return []\n        \n        if state in memo:\n            return memo[state]\n        \n        currState = list(bin(state)[3:])\n        mini = float('inf')\n        ans = []\n        i = currState.index('0')\n        for p in peopleSkills[i]:\n            for s in people[p]:\n                currState[skillsMap[s]] = '1'\n\n            nextState = int('1' + ''.join(currState), 2)\n            # print(bin(state), currState, p, nextState)\n            temp = self.dfs(nextState, memo, peopleSkills, res, n, people, skillsMap)\n            currState = list(bin(state)[3:])\n            # print(p, state, nextState, temp)\n            if len(temp) < mini:\n                mini = len(temp)\n                ans = [p] + temp\n        # print(ans)\n        memo[state] = ans\n        return ans\n                \n        \n        \n", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        p_skills = [set() for _ in people]\n        for i, p in enumerate(people):\n            p_skills[i] = set(p)\n        res = [0] * 17\n        def dfs(idx=0, path=[], has=set()):\n            nonlocal res\n            if idx == len(req_skills):\n                res = path\n            elif req_skills[idx] in has:\n                dfs(idx + 1, path, has)\n            elif len(path) + 1 < len(res):\n                for i, p in enumerate(people):\n                    if req_skills[idx] in p_skills[i]:\n                        dfs(idx + 1, path + [i], has | p_skills[i])\n        dfs()\n        return res\n", "\\\"\\\"\\\"\nmake a dictionary that is {skill  : people}\nwhile still have skills\n   find the rarest skill \n        option- iterate over the dictionary of skills (O(n_skills))\n   for each person with the skill:\n        add them, then combine them with the smallest Sufficient team from the remaining skills (recursion)\n        pick the smallest of these\n\\\"\\\"\\\"\nfrom collections import defaultdict\n\nclass KeyToSetDict(object):\n    def __init__():\n        self.dict = {}\n        self.sets = []\n    \nclass Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        skills_to_people = defaultdict(list)\n        \n        people = [set(p) for p in people]\n        \n        def add_person(i):\n            for skill in people[i]:\n                skills_to_people[skill].append(i)\n                \n        for i in range(len(people)):\n            add_person(i)\n        \n        \n        def remove_person(i):\n            for skill in people[i]:\n                skills_to_people[skill].remove(i)\n        \n        def inner(req_skills):\n            if len(req_skills) == 0:\n                return []\n            \n            # find (one of) the rarest skill\n            rarest_skill = req_skills[0]\n            count = len(skills_to_people[rarest_skill])\n            for skill in req_skills[1:]:\n                if len(skills_to_people[skill]) <= count:\n                    rarest_skill = skill\n                    count = len(skills_to_people[skill])\n\n        \n            result = []\n            min_team_size = len(people)\n            \n            people_with_skill = skills_to_people[rarest_skill][:]\n            for i in people_with_skill:\n                remove_person(i)\n                sub_req_skills = [x for x in req_skills if x not in set(people[i])]\n                remaining_members = inner(sub_req_skills)\n                if  len(remaining_members) + 1 <= min_team_size :\n                    remaining_members.append(i)\n                    result = remaining_members\n                    min_team_size = len(result)\n                add_person(i)\n                    \n                \n            return result\n        \n        return inner(req_skills)", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        skill2num = {}\n        for i, skill in enumerate(req_skills):\n            skill2num[skill] = i\n        \n        p2s = [0] * len(people)\n        for i, p in enumerate(people):\n            skills = 0\n            for skill in p:\n                if skill in skill2num:\n                    skills += (1 << skill2num[skill])\n            p2s[i] = skills\n        \n        N = len(req_skills)\n        dp = [1000000000] * (1 << N)\n        dp[0] = 0\n        ans = [[] for i in range(1 << N)]\n        \n        for i in range(len(people)):\n            dp2 = dp.copy()\n            for skill in range(1 << N):\n                new_skills = skill | p2s[i]\n                if dp2[new_skills] > dp[skill] + 1:\n                    dp2[new_skills] = dp[skill] + 1\n                    ans[new_skills] = list(ans[skill])\n                    ans[new_skills].append(i)\n            dp = dp2\n        \n        return ans[(1 << N) - 1]", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        def convertToNum(people: List[str]) -> int:\n            ans = 0\n            for skill in people:\n                ans |= 1 << (dic[skill])\n            return ans\n        \n        dic = {v: i for i, v in enumerate(req_skills)}\n        target = (1 << len(req_skills)) - 1\n        dp = {v : [] for v in range(1, target+1)}\n        for i, people_skill in enumerate(people):\n            skill = convertToNum(people_skill)\n            dp[skill] = [i]\n            for key in list(dp.keys()):\n                if key != skill and len(dp[key]) > 0 and i not in dp[key]:\n                    new_skill = key | skill\n                    if len(dp[new_skill]) > len(dp[key]) + 1 or len(dp[new_skill]) == 0:\n                        temp = [v for v in dp[key]]\n                        temp.append(i)\n                        dp[new_skill] = temp\n        \n        return dp[target]\n        \n            \n        \n", "import heapq\nfrom copy import deepcopy\nfrom typing import List\n\n\nclass Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        person_bits = self.calculatePersonBits(req_skills, people)\n        n = len(req_skills)\n        dp = {\n            0: set()\n        }\n        q = []\n        heapq.heappush(q, 0)\n\n        while len(q) > 0:\n            index = heapq.heappop(q)\n            for i in range(len(people)):\n                if i not in dp[index]:\n                    new_index = index | person_bits[i]\n                    if new_index not in dp:\n                        heapq.heappush(q, new_index)\n                        dp[new_index] = deepcopy(dp[index])\n                        dp[new_index].add(i)\n                    elif len(dp[new_index]) > 1 + len(dp[index]):\n                        dp[new_index] = deepcopy(dp[index])\n                        dp[new_index].add(i)\n\n        return list(dp[(2 ** n) - 1])\n\n    def calculatePersonBits(self, req_skills, people):\n        skills = {}\n        i = 0\n        for skill in req_skills:\n            skills[skill] = 2 ** i\n            i += 1\n\n        result = []\n        for person in people:\n            total = 0\n            for skill in person:\n                total |= skills[skill]\n            result.append(total)\n\n        return result\n", "from collections import deque\n\nclass Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        # bit mask for people visited and bit mask for skills obtained\n        # each bit mask (set), remember extra skills needed\n        # remember every visited bit mask\n        q = deque()\n        skill_to_index = {}\n        for i, skill in enumerate(req_skills):\n            skill_to_index[skill] = i\n            \n        all_skills = (1 << len(req_skills)) - 1\n        people_skills = [0] * len(people)\n        dp = {}\n        \n        for i in range(len(people)):\n            for skill in people[i]:\n                people_skills[i] |= 1 << skill_to_index[skill]\n            q.appendleft([1 << i, people_skills[i]])\n            dp[people_skills[i]] = 1\n        \n        def count(bitmask):\n            res = []\n            for i in range(len(people)):\n                if (1 << i) & bitmask:\n                    res.append(i)\n            return res\n        \n        while q:\n            bitmask, skills = q.pop()\n            \n            if skills == all_skills:\n                return count(bitmask)\n            \n            for i in range(len(people)):\n                nbitmask = (1 << i) | bitmask\n                nskills = people_skills[i] | skills\n                if nskills not in dp or dp[nskills] > dp[skills] + 1:\n                    dp[nskills] = dp[skills] + 1\n                    q.appendleft([nbitmask, people_skills[i] | skills])\n        \n        return []\n", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        def convertToNum(people: List[str]) -> int:\n            ans = 0\n            for skill in people:\n                ans |= 1 << (dic[skill])\n            return ans\n        \n        dic = {v: i for i, v in enumerate(req_skills)}\n            \n        dp = {v : [] for v in range(1, 1 << len(req_skills))}\n        for i, people_skill in enumerate(people):\n            skill = convertToNum(people_skill)\n            dp[skill] = [i]\n            for key in list(dp.keys()):\n                if key != skill and len(dp[key]) > 0 and i not in dp[key]:\n                    new_skill = key | skill\n                    if len(dp[new_skill]) > len(dp[key]) + 1 or len(dp[new_skill]) == 0:\n                        temp = [v for v in dp[key]]\n                        temp.append(i)\n                        dp[new_skill] = temp\n        \n        return dp[(1 << len(req_skills)) - 1]\n        \n            \n        \n", "class Solution:\n    # dp\n    # bit_manipulation\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        # build a dict for skills\n        N, skill_dict = len(req_skills), {}\n        for i in range(N):\n            skill_dict[req_skills[i]] = i\n        # what is dp[i] = [], i is the bit expression of skills, value is a list of people with skills which i required\n        dp = [list(range(len(people))) for _ in range(1 << N)]\n        dp[0] = []\n\n        # loop all people\n        for i in range(len(people)):\n            # get all skills of ith people\n            skill = 0\n            for s in people[i]:\n                skill |= (1 << skill_dict[s])\n\n            for k, v in enumerate(dp):\n                # k is the skills, so new_skill is the new skills when add ith people to this list\n                new_skill = k | skill\n                # if skills increased and groups has less people, then updat dp\n                if new_skill != k and len(v) + 1 < len(dp[new_skill]):\n                    dp[new_skill] = v + [i]\n\n        return dp[(1 << N) - 1]\n\n\n", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        # \u4e3askills\u5efa\u7acb\u5b57\u5178\n        n = len(req_skills)\n        d = dict()\n        for i in range(n):\n            d[req_skills[i]] = i\n        # \u6240\u6709\u72b6\u6001\n        dp = [list(range(len(people))) for _ in range(1 << n)]\n        dp[0] = []\n        # \u904d\u5386\u6240\u6709\u4eba\n        for i in range(len(people)):\n            # \u6c42\u8fd9\u4e2a\u4eba\u7684\u6280\u80fd\n            skill = 0\n            for s in people[i]:\n                skill |= (1 << d[s])\n            for k, v in enumerate(dp):\n                # \u628a\u8fd9\u4e2a\u4eba\u52a0\u5165\u8fdb\u6765\u4ee5\u540e\u7684\u56e2\u961f\u6280\u80fd\n                new_skills = k | skill\n                # \u5982\u679c\u56e2\u961f\u6280\u80fd\u56e0\u6b64\u800c\u589e\u52a0 \u5e76\u4e14\u589e\u52a0\u540e\u7684\u4eba\u6570\u6bd4\u65b0\u6280\u80fd\u539f\u6765\u7684\u4eba\u6570\u5c11 \u5219\u66f4\u65b0\u7b54\u6848\n                if new_skills != k and len(dp[new_skills]) > len(v) + 1:\n                    dp[new_skills] = v + [i]\n        return dp[(1 << n) - 1]\n", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        skills = dict(zip(req_skills,list(range(len(req_skills)))))\n        target = (1<<len(req_skills))-1\n        for p in range(len(people)):\n            temp = 0\n            for s in people[p]:\n                temp |= (1<<skills[s])\n            people[p] = temp\n            \n        \\\"\\\"\\\"\n        dp[i][j]: min people to have skills of j using first i people\n        dp[0][0] = 0\n        dp[i][j][k] = min(dp[i-1][j][k],dp[i-1][j]+1)\n        \n        \\\"\\\"\\\"\n        \n        dp = [[float(\\\"inf\\\"),[]] for _ in range(1+target)]\n        dp[0] = (0,[])\n        \n        for r in range(len(people)):\n            for c in range(target,-1,-1):\n                #print(dp)\n                #if dp[c][0] != float(\\\"inf\\\"):\n                if dp[c][0]+1<dp[c|people[r]][0]:\n                    dp[c|people[r]][0] = dp[c][0]+1\n                    dp[c|people[r]][1] = dp[c][1]+[r]\n        return dp[-1][1]\n        \n        \n        \n            \n            ", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        n, m = len(req_skills), len(people)\n        key = {v: i for i, v in enumerate(req_skills)}\n        \n        @functools.lru_cache(None)\n        def helper(cur = 0):\n            if cur == (1 << n) - 1:\n                return []\n            ans = math.inf\n            res = []\n            for i, p in enumerate(people):\n                his_skill = 0\n                for skill in p:\n                    if skill in key:\n                        his_skill |= 1 << key[skill]\n                if his_skill | cur == cur:\n                    continue\n                temp = helper(cur | his_skill)\n                if len(temp) + 1 < ans:\n                    res = temp + [i]\n                    ans = len(temp) + 1\n            return res\n        return helper()", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        \n        # Firstly, convert all the sublists in people into sets for easier processing.\n        for i, skills in enumerate(people):\n            people[i] = set(skills)\n        \n        # Remove all skill sets that are subset of another skillset, by replacing the subset with an\n        # empty set. We do this rather than completely removing, so that indexes aren't \n        # disrupted (which is a pain to have to sort out later).\n        for i, i_skills in enumerate(people):\n            for j, j_skills in enumerate(people):\n                if i != j and i_skills.issubset(j_skills):\n                    people[i] = set()\n        \n        # Now build up a dictionary of skills to the people who can perform them. The backtracking algorithm\n        # will use this.\n        skills_to_people = collections.defaultdict(set)\n        for i, skills in enumerate(people):\n            for skill in skills:\n                skills_to_people[skill].add(i)\n            people[i] = set(skills)\n        \n        # Keep track of some data used by the backtracking algorithm.\n        self.unmet_skills = set(req_skills) # Backtracking will remove and readd skills here as needed.\n        self.smallest_length = math.inf # Smallest team length so far.\n        self.current_team = [] # Current team members.\n        self.best_team = [] # Best team we've found, i,e, shortest team that covers skills/\n        \n\\t\\t# Here is the backtracking algorithm.\n        def meet_skill(skill=0):\n\\t\\t\\t# Base case: All skills are met.\n            if not self.unmet_skills:\n\\t\\t\\t\\t# If the current team is smaller than the previous we found, update it.\n                if self.smallest_length > len(self.current_team):\n                    self.smallest_length = len(self.current_team)\n                    self.best_team = self.current_team[::] # In Python, this makes a copy of a list.\n                return # So that we don't carry out the rest of the algorithm.\n                        \n            # If this skill is already met, move onto the next one.\n            if req_skills[skill] not in self.unmet_skills:\n                return meet_skill(skill + 1)\n\\t\\t\\t\\t# Note return is just to stop rest of code here running. Return values\n\\t\\t\\t\\t# are not caught and used.\n            \n            # Otherwise, consider all who could meet the current skill.\n            for i in skills_to_people[req_skills[skill]]:\n                \n\\t\\t\\t\\t# Add this person onto the team by updating the backtrading data.\n                skills_added_by_person = people[i].intersection(self.unmet_skills)\n                self.unmet_skills = self.unmet_skills - skills_added_by_person\n                self.current_team.append(i)\n                \n\\t\\t\\t\\t# Do the recursive call to further build the team.\n                meet_skill(skill + 1)\n                \n                # Backtrack by removing the person from the team again.\n                self.current_team.pop()\n                self.unmet_skills = self.unmet_skills.union(skills_added_by_person)\n        \n\\t\\t# Kick off the algorithm.\n        meet_skill()        \n        return self.best_team \n", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        skills = dict(zip(req_skills,list(range(len(req_skills)))))\n        target = (1<<len(req_skills))-1\n        for p in range(len(people)):\n            temp = 0\n            for s in people[p]:\n                temp |= (1<<skills[s])\n            people[p] = temp\n            \n        \\\"\\\"\\\"\n        dp[i][j]: min people to have skills of j using first i people\n        dp[0][0] = 0\n        dp[i][j][k] = min(dp[i-1][j][k],dp[i-1][j]+1)\n        \n        \\\"\\\"\\\"\n        \n        dp = [[float(\\\"inf\\\"),[]] for _ in range(1+target)]\n        dp[0] = (0,[])\n        \n        for r in range(len(people)):\n            for c in range(target,-1,-1):\n                #print(dp)\n                if dp[c][0] != float(\\\"inf\\\"):\n                    if dp[c][0]+1<dp[c|people[r]][0]:\n                        dp[c|people[r]][0] = dp[c][0]+1\n                        dp[c|people[r]][1] = dp[c][1]+[r]\n        return dp[-1][1]\n        \n        \n        \n            \n            ", "import functools\nclass Solution():\n    def smallestSufficientTeam(self, req_skills, people):\n        # 1:14\n        # as we know skills are less  we can use bit to represent stage\n        # lets use skills acquired statge to be 1\n        # bits and dp question\n        skills = dict()\n        for i, v in enumerate(req_skills):\n            skills[v] = i\n        n = len(people)\n        desiredskills = 2**len(skills)-1\n        peopleskills=[]\n        for p in people:\n            mask=0\n            for skill in p:\n                mask|=1<<skills[skill]\n            peopleskills.append(mask)\n            \n                \n            \n        @functools.lru_cache(None)\n        def helper(i, teamskills):\n            nonlocal n, desiredskills\n            ans = float('inf')\n            rlist = []\n            if teamskills == desiredskills:\n                return 0, None\n            if i == n:\n                return float('inf'), None\n            # i will never reach n as answer exists\n            # 2 options now\n            # either we pick ith person or not\n            # if we pick\n            newteamskills = teamskills | peopleskills[i]\n            \n            # for skill in people[i]:\n            #     skillpos = skills[skill]\n            #     # set this bit to 1 in newpendingskills\n            #     # and with zero\n            #     newteamskills = newteamskills | (1 << skillpos)\n\n            pickans, picklist = helper(i+1, newteamskills)\n            pickans += 1\n\n            if pickans < ans:\n                ans = pickans\n                rlist = [i]\n                if picklist:\n                    rlist.extend(picklist)\n            pickans, picklist = helper(i+1, teamskills)\n            if pickans < ans:\n                ans = pickans\n                if picklist:\n                    rlist = picklist[:]\n                else:\n                    rlist = None\n            return ans, rlist\n        return helper(0, 0)[1]", "#[Runtime: 2236 ms, faster than 10.62%] DP\n#O(N * 2^R) N: number of people, R: number of skills\n#f(i, S): the minimum people count to use first i people to fulfill state S\n#state S is a binary set which is a combinations of skills\n#f(N, all 1) = 0,  f(N, not all 1) = inf\n#return f(-1, 0)\n#f(i, S) = min( f(i+1, S) , 1+f(i+1, S + req_skill[i])\n#WA: [\\\"gvp\\\",\\\"jgpzzicdvgxlfix\\\",\\\"kqcrfwerywbwi\\\",\\\"jzukdzrfgvdbrunw\\\",\\\"k\\\"]\n#[[],[],[],[],[\\\"jgpzzicdvgxlfix\\\"],[\\\"jgpzzicdvgxlfix\\\",\\\"k\\\"],[\\\"jgpzzicdvgxlfix\\\",\\\"kqcrfwerywbwi\\\"],[\\\"gvp\\\"],[\\\"jzukdzrfgvdbrunw\\\"],[\\\"gvp\\\",\\\"kqcrfwerywbwi\\\"]]\nfrom math import inf\ndef memorized(f):\n    memo = {}\n    def helper(*arg):\n        if arg not in memo:\n            memo[arg] = f(*arg)\n        return memo[arg]\n    return helper\nclass Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        N, MASK = len(people), (1 << len(req_skills))-1\n        skill2id, child = {skill: i for i, skill in enumerate(req_skills)}, {}\n        people = [sum(1 << skill2id[skill] for skill in skills) for skills in people]\n        @memorized\n        def dp(i: int, status: int) -> int:\n            if i >= N:\n                return 0 if status == MASK else inf\n            not_choose, choose = dp(i+1, status), 1 + dp(i+1, status | people[i])\n            if not_choose <= choose:\n                child[(i, status)] = (i+1, status)\n                return not_choose\n            else:\n                child[(i, status)] = (i+1, status | people[i])\n                return choose\n        i, mask, res = -1, 0, []\n        dp(i, mask)\n        #collect answer\n        while mask < MASK:\n            if child[(i, mask)] != (i+1, mask):\n                res.append(i)\n            i, mask = child[(i, mask)]\n        return res", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        d = {}\n        for i,s in enumerate(req_skills):\n            d[s] = i\n        \n        p = []\n        for s in people:\n            c = 0\n            for t in s:\n                c |= 1 << d[t]\n            p.append(c)\n        # print(p)\n        \n        self.tar = 2**len(req_skills) -1\n        self.r_len = len(people)\n        self.r = []\n        def dfs(l, t, cur):\n            # print(l, t, cur, self.r)\n            if cur == self.tar and len(l) < self.r_len:\n                self.r_len = len(l)\n                self.r = l.copy()\n                return\n            elif len(l) >= self.r_len or t > len(req_skills):\n                return\n            if cur & (1 << t):\n                dfs(l, t+1, cur)\n            for i,k in enumerate(p):\n                if k & (1 << t) and not i in l:\n                    tmp = cur\n                    l.append(i)\n                    cur |= k\n                    dfs(l, t+1, cur)\n                    cur = tmp\n                    l.pop()\n            \n        dfs([], 0, 0)\n        \n        return self.r", "import functools\n\n\nclass Solution():\n    def smallestSufficientTeam(self, req_skills, people):\n        # 1:14\n        # as we know skills are less  we can use bit to represent stage\n        # lets use skills acquired statge to be 1\n        # bits and dp question\n        skills = dict()\n        for i, v in enumerate(req_skills):\n            skills[v] = i\n        n = len(people)\n        desiredskills = 2**len(skills)-1\n        @functools.lru_cache(None)\n        def helper(i, teamskills):\n            nonlocal n, desiredskills\n            ans = float('inf')\n            rlist = []\n            if teamskills == desiredskills:\n                return 0, None\n            if i == n:\n                return float('inf'), None\n            # i will never reach n as answer exists\n            # 2 options now\n            # either we pick ith person or not\n            # if we pick\n            newteamskills = teamskills\n            for skill in people[i]:\n                skillpos = skills[skill]\n                # set this bit to 1 in newpendingskills\n                # and with zero\n                newteamskills = newteamskills | (1 << skillpos)\n\n            pickans, picklist = helper(i+1, newteamskills)\n            pickans += 1\n\n            if pickans < ans:\n                ans = pickans\n                rlist = [i]\n                if picklist:\n                    rlist.extend(picklist)\n            pickans, picklist = helper(i+1, teamskills)\n            if pickans < ans:\n                ans = pickans\n                if picklist:\n                    rlist = picklist[:]\n                else:\n                    rlist = None\n            return ans, rlist\n        return helper(0, 0)[1]", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        peopleLen = len(people)\n        skillsLen = len(req_skills)\n        maskFull = (1 << skillsLen)-1\n        newPeople = []\n        for p in people:\n            newPeople.append(set(p))\n        \n        dp = {}\n        \n        def findPeople(m0, i0):\n            if m0 == maskFull:\n                return []\n            if i0 == peopleLen:\n                return None\n            if (m0, i0) in dp:\n                return dp[(m0, i0)]\n            nextM = m0\n            for j in range(skillsLen):\n                if m0 >> j & 1 == 1:\n                    continue\n                if req_skills[j] in newPeople[i0]:\n                    nextM |= 1 <<j\n            ans = None\n            if nextM != m0:\n                subAns = findPeople(nextM, i0+1)\n                if subAns != None:\n                    ans = subAns + [i0]\n            subAns = findPeople(m0, i0+1)\n            if ans == None or subAns != None and len(subAns) < len(ans):\n                ans = subAns\n            dp[(m0, i0)] = ans\n            return ans\n        \n        return findPeople(0, 0)", "#[Runtime: 1872 ms, faster than 12.67%] DP\n#O(N * 2^R) N: number of people, R: number of skills\n#f(i, S): the minimum people count to use first i people to fulfill state S\n#state S is a binary set which is a combinations of skills\n#f(N, all 1) = 0,  f(N, not all 1) = inf\n#return f(-1, 0)\n#f(i, S) = min( f(i+1, S) , 1+f(i+1, S + req_skill[i])\n#WA: [\\\"gvp\\\",\\\"jgpzzicdvgxlfix\\\",\\\"kqcrfwerywbwi\\\",\\\"jzukdzrfgvdbrunw\\\",\\\"k\\\"]\n#[[],[],[],[],[\\\"jgpzzicdvgxlfix\\\"],[\\\"jgpzzicdvgxlfix\\\",\\\"k\\\"],[\\\"jgpzzicdvgxlfix\\\",\\\"kqcrfwerywbwi\\\"],[\\\"gvp\\\"],[\\\"jzukdzrfgvdbrunw\\\"],[\\\"gvp\\\",\\\"kqcrfwerywbwi\\\"]]\nfrom math import inf\nfrom functools import reduce\nfrom operator import or_\ndef memorized(f):\n    memo = {}\n    def helper(*arg):\n        if arg not in memo:\n            memo[arg] = f(*arg)\n        return memo[arg]\n    return helper\nclass Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        N, MASK = len(people), (1 << len(req_skills))-1\n        skill2id, child = {skill: i for i, skill in enumerate(req_skills)}, {}\n        people = [reduce(operator.or_, (1 << skill2id[skill] for skill in skills), 0) for skills in people]\n        @memorized\n        def dp(i: int, status: int) -> int:\n            if i >= N:\n                return 0 if status == MASK else inf\n            not_choose, choose = dp(i+1, status), 1 + dp(i+1, status | people[i])\n            if not_choose <= choose:\n                child[(i, status)] = (i+1, status)\n                return not_choose\n            else:\n                child[(i, status)] = (i+1, status | people[i])\n                return choose\n        i, mask, res = -1, 0, []\n        dp(i, mask)\n        #collect answer\n        while mask < MASK:\n            if child[(i, mask)] != (i+1, mask):\n                res.append(i)\n            i, mask = child[(i, mask)]\n        return res", "class Solution:\n    def smallestSufficientTeam(self, req_skills, people):\n        n, m = len(req_skills), len(people)\n        key = {v: i for i, v in enumerate(req_skills)}\n        dp = {0: []}\n        for i, p in enumerate(people):\n            his_skill = 0\n            for skill in p: his_skill |= 1 << key[skill]\n            if his_skill == 0 or his_skill in dp and len(dp[his_skill]) == 1: continue\n            sn = copy.deepcopy(list(dp.items()))\n            for skill_set, need in sn:\n                with_him = skill_set | his_skill\n                if with_him == skill_set: continue\n                if with_him not in dp or len(dp[with_him]) > len(need) + 1:\n                    dp[with_him] = need + [i]\n        return dp[(1 << n) - 1]", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        p_skills = [set() for _ in people]\n        for i, p in enumerate(people):\n            p_skills[i] = set(p)\n        res = [0] * 17\n        def dfs(idx=0, path=[], has=set()):\n            nonlocal res\n            if idx == len(req_skills):\n                res = path\n            elif req_skills[idx] in has:\n                dfs(idx + 1, path, has)\n            elif len(path) + 1 < len(res):\n                for i, p in enumerate(people):\n                    if req_skills[idx] in p_skills[i]:\n                        # intersection = has & p_skills[i]\n                        # has |= p_skills[i]\n                        # new = h\n                        dfs(idx + 1, path + [i], has | p_skills[i])\n                        # has -= {x for x in p_skills[i] if x not in intersection}\n        dfs()\n        return res\n", "from collections import defaultdict\nfrom functools import lru_cache\n\nclass Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        req_skills = set(req_skills)\n        d = {}\n        for i, x in enumerate(req_skills):\n            d[x] = i\n        \n        @lru_cache(None)\n        def dfs(state, idx):\n            if state == 2 ** len(req_skills) - 1:\n                return 0, []\n            if idx == len(people):\n                return float('inf'), []\n            out = dfs(state, idx + 1)\n            new_state = state\n            for skill in people[idx]:\n                new_state |= 1 << d[skill]\n            new = dfs(new_state, idx + 1)\n            if out[0] < new[0] + 1:\n                return out\n            return new[0] + 1, [idx] + new[1]\n        \n        return dfs(0, 0)[1]\n", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        p_skills = [set() for _ in people]\n        for i, p in enumerate(people):\n            p_skills[i] = set(p)\n        # people.sort(key=lambda x: -len(set(x) & set(req_skills)))\n        # # print(people)\n        res = [0] * 17\n        def dfs(idx=0, path=[], has=set()):\n            nonlocal res\n            if idx == len(req_skills):\n                res = path\n            elif req_skills[idx] in has:\n                dfs(idx + 1, path, has)\n            elif len(path) + 1 < len(res):\n                for i, p in enumerate(people):\n                    if req_skills[idx] in p_skills[i]:\n                        # intersection = has & p_skills[i]\n                        # has |= p_skills[i]\n                        # new = h\n                        dfs(idx + 1, path + [i], has | p_skills[i])\n                        # has -= {x for x in p_skills[i] if x not in intersection}\n        dfs()\n        return res\n", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        p_skills = [set() for _ in people]\n        for i, p in enumerate(people):\n            p_skills[i] = set(p)\n        # people.sort(key=lambda x: -len(set(x) & set(req_skills)))\n        # # print(people)\n        res = [0] * 17\n        def dfs(idx=0, path=[], has=set()):\n            nonlocal res\n            if idx == len(req_skills):\n                res = path\n            elif req_skills[idx] in has:\n                dfs(idx + 1, path, has)\n            elif len(path) + 1 < len(res):\n                for i, p in enumerate(people):\n                    if req_skills[idx] in p_skills[i]:\n                        intersection = has & p_skills[i]\n                        has |= p_skills[i]\n                        dfs(idx + 1, path + [i], has)\n                        has -= {x for x in p_skills[i] if x not in intersection}\n        dfs()\n        return res\n", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        num_skills, team_queue = len(req_skills), collections.deque()\n        bit_map, people_map = {req_skills[i]:i for i in range(num_skills)}, collections.defaultdict(list)\n        for i, lst in enumerate(people):\n            person_bit = 0\n            for l in lst:\n                person_bit = person_bit | (1<<bit_map[l])\n            for l in lst:\n                people_map[bit_map[l]].append((i, person_bit))\n        \n        team_queue.append((0, []))\n        while team_queue:\n            bits, team = team_queue.popleft()\n            min_idx = 0\n            while min_idx < num_skills and (bits & (1 << min_idx)):\n                min_idx += 1\n            if min_idx == num_skills:\n                return team\n            \n            for p, person_bit in people_map[min_idx]:\n                team_queue.append((bits | person_bit, team + [p]))\n        \n        return []", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        \n        res = [''] * 17\n        n = len(req_skills)\n        def dfs(idx, has, path):\n            nonlocal res\n            if idx == n:\n                res = path\n            elif req_skills[idx] in has:\n                dfs(idx + 1, has, path)\n            else:\n                if len(path) + 1 < len(res):\n                    for i, p in enumerate(people):\n                        p = set(p)\n                        if req_skills[idx] in p:\n                            union = p & has\n                            has |= p\n                            dfs(idx + 1, has, path + [i])\n                            has -= p\n                            has |= union\n        dfs(0, set(), [])\n        return res\n                        \n        \n        \n        # n = len(req_skills)\n        # key = {v: i for i, v in enumerate(req_skills)}\n        # dp = {0: []}\n        # for i, p in enumerate(people):\n        #     his_skill = 0\n        #     for skill in p:\n        #         if skill in key:\n        #             his_skill |= 1 << key[skill]\n        #     for skill_set, need in list(dp.items()):\n        #         with_him = skill_set | his_skill\n        #         if with_him == skill_set: continue\n        #         if with_him not in dp or len(dp[with_him]) > len(need) + 1:\n        #             dp[with_him] = need + [i]\n        # return dp[(1 << n) - 1]\n", "from collections import defaultdict\n\nclass Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        def backtrack(i, people_added, skills_added):\n            nonlocal result\n            if i == len(req_skills):\n                result = people_added\n            elif req_skills[i] in skills_added:\n                backtrack(i+1, people_added, skills_added)\n            else:\n                if not result or len(people_added) < len(result) - 1:\n                    for k in range(len(people)):\n                        p = set(people[k])\n                        if req_skills[i] in p:\n                            union = p & skills_added\n                            backtrack(i+1, people_added + [k], skills_added | p)\n                            skills_added |= union\n        result = []\n        backtrack(0, [], set())\n        return result\n", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        \n        res = [''] * 17\n        n = len(req_skills)\n        def dfs(idx, has, path):\n            nonlocal res\n            if idx == n:\n                res = path\n            elif req_skills[idx] in has:\n                dfs(idx + 1, has, path)\n            else:\n                if len(path) + 1 < len(res):\n                    for i, p in enumerate(people):\n                        p = set(p)\n                        if req_skills[idx] in p:\n                            union = p & has\n                            has |= p\n                            dfs(idx + 1, has, path + [i])\n                            has -= p\n                            has |= union\n        dfs(0, set(), [])\n        return res\n                        \n", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        \n        res = [''] * 17\n        n = len(req_skills)\n        def dfs(idx, has, path):\n            nonlocal res\n            if idx == n:\n                res = path\n            elif req_skills[idx] in has:\n                dfs(idx + 1, has, path)\n            else:\n                if len(path) + 1 < len(res):\n                    for i, p in enumerate(people):\n                        p = set(p)\n                        if req_skills[idx] in p:\n                            union = p & has\n                            has |= p\n                            dfs(idx + 1, has, path + [i])\n                            has -= p\n                            has |= union\n        dfs(0, set(), [])\n        return res\n\n            \n            \n        \n\n                        \n", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        \n        def fulfill_skills(skills, person):\n            remaining_skills = deque()\n            for skill in skills:\n                if skill not in people[person]:\n                    remaining_skills.appendleft(skill)\n            return remaining_skills\n\n        # BFS by # of people\n        # can reduce expansion by searching rarest skills first\n\n        # map required skills to people\n        # has_skill[\\\"java\\\"] == a list of people (int index into people) who have that skill\n        has_skill = dict()\n        for person, skills in enumerate(people):\n            for skill in skills:\n                experts = has_skill.get(skill, [])\n                experts.append(person)\n                has_skill[skill] = experts\n\n\n        # sort skills by rarity\n        rare_skills = [(len(people), skill)  for (skill, people) in list(has_skill.items())]\n        rare_skills.sort()\n        rare_skills = [skill for _, skill in rare_skills]\n\n\n        # queue holds pairs:\n        #   (skills, team)\n        q = deque()\n        q.append( (deque(rare_skills), []) )\n        while q:\n            skills, team = q.popleft()\n            print((skills, team))\n            if not skills:\n                return team\n\n            # choose a member to fulfill next rarest skill\n            skill = skills[0]\n            for person in has_skill[skill]:\n                remaining_skills = fulfill_skills(skills, person)\n                q.append( (remaining_skills, team + [person]) )\n\n\n        return -1\n", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        n, m = len(req_skills), len(people)\n        key = {v: i for i, v in enumerate(req_skills)}\n        dp = {0: []}\n        for i, p in enumerate(people):\n            his_skill = 0\n            for skill in p:\n                if skill in key:\n                    his_skill |= 1 << key[skill]\n            if his_skill == 0:\n                continue\n            if his_skill in dp and len(dp[his_skill]) == 1:\n                continue\n            for skill_set, need in list(dp.items()):\n                with_him = skill_set | his_skill\n                if with_him == skill_set: continue\n                if with_him not in dp or len(dp[with_him]) > len(need) + 1:\n                    dp[with_him] = need + [i]\n        return dp[(1 << n) - 1]", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        p_skills = [set() for _ in people]\n        for i, p in enumerate(people):\n            p_skills[i] = set(p)\n        people.sort(key=lambda x: -len(set(x) & set(req_skills)))\n        res = [0] * 17\n        def dfs(idx=0, path=[], has=set()):\n            nonlocal res\n            if idx == len(req_skills):\n                res = path\n            elif req_skills[idx] in has:\n                dfs(idx + 1, path, has)\n            elif len(path) + 1 < len(res):\n                for i, p in enumerate(people):\n                    if req_skills[idx] in p_skills[i]:\n                        intersection = has & p_skills[i]\n                        has |= p_skills[i]\n                        dfs(idx + 1, path + [i], has)\n                        has -= {x for x in p_skills[i] if x not in intersection}\n        dfs()\n        return res\n", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        m = {val: i for i, val in enumerate(req_skills)}\n        n = len(req_skills)\n        skills = [reduce(lambda a, b: a + b, [1 << m[s] for s in row] or [0]) for row in people]\n        final_state = reduce(lambda a, b: a + b, [1 << i for i in range(n)])\n        dp = {0: []}\n        for i, skill in enumerate(skills):\n            for prev_state, team in dp.copy().items():\n                new_state = prev_state | skill\n                if new_state == prev_state: continue\n                if new_state not in dp or len(team) + 1 < len(dp[new_state]):\n                    dp[new_state] = team + [i]\n        \n        return dp[final_state] ", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        lrs = len(req_skills)\n        skills = collections.defaultdict(list)\n        peo_skills = []\n        for i,skill in enumerate(people):\n            for s in skill:\n                skills[s].append(i)\n        self.res = [0]*(lrs+1)       \n        def dfs(idx,cover,path):\n            if idx==lrs:\n                self.res = path\n            if idx>=lrs: return\n            if req_skills[idx] in cover: \n                dfs(idx+1,cover,path)\n            if len(path)+1<len(self.res):\n                for p in skills[req_skills[idx]]:                 \n                    p_s = set(people[p])\n                    new_cover = cover|p_s\n                    dfs(idx+1,new_cover,path+[p])\n        dfs(0,set(),[])\n        return self.res\n                    \n\n            \n            \n        \n\n                        \n", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        lrs = len(req_skills)\n        skills = collections.defaultdict(list)\n        peo_skills = []\n        for i,skill in enumerate(people):\n            for s in skill:\n                skills[s].append(i)\n        self.res = [0]*(lrs+1)       \n        def dfs(idx,cover,path):\n            if idx==lrs:\n                self.res = path\n            if idx>=lrs: return\n            if req_skills[idx] in cover: \n                dfs(idx+1,cover,path)\n            if len(path)+1<len(self.res):\n                for p in skills[req_skills[idx]]:                 \n                    p_s = set(people[p])\n                    union = cover&p_s\n                    cover |= p_s\n                    dfs(idx+1,cover,path+[p])\n                    cover -=p_s\n                    cover |= union\n        dfs(0,set(),[])\n        return self.res\n                    \n\n            \n            \n        \n\n                        \n", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        \n        dic = {x: i for i, x in enumerate(req_skills)}\n        dp = {0:[]}\n        for i, p in enumerate(people):\n            his = 0\n            for skill in p:\n                his |= (1 << dic[skill])\n            for s in list(dp.keys()):\n                new = his | s\n                if new == s:\n                    continue\n                if new not in dp or len(dp[new]) > len(dp[s]) + 1:\n                    dp[new] = dp[s] + [i]\n        return dp[(1 << len(req_skills)) - 1]", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        key = {v: i for i, v in enumerate(req_skills)}\n        dp = {0: tuple()}\n        for i, p in enumerate(people):\n            his_skill = 0\n            for skill in p:\n                if skill in key:\n                    his_skill |= 1 << key[skill]\n            for skill_set, need in list(dict(dp).items()):\n                with_him = skill_set | his_skill\n                if with_him == skill_set: continue\n                if with_him in dp and len(dp[with_him]) <= len(need) + 1: continue\n                dp[with_him] = need + tuple([i])\n        return dp[(1 << len(req_skills)) - 1]\n", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        \n        from collections import defaultdict\n\n        g = defaultdict(list)\n\n        for i, skills in enumerate(people):\n            for s in skills:\n                g[s].append(i)\n\n        memo = {}\n        def helper(skills, group):\n            if not skills:\n                return set()\n            \n            if tuple(skills) in memo:\n                return memo[tuple(skills)]\n            \n            \n            new_group = None\n            s = list(skills)[0]\n            for ind in g[s]:\n                if ind in group:\n                    continue\n                    \n                comb = helper(skills - set(people[ind]), group | {ind}) | {ind}\n                if not new_group or len(comb) < len(new_group):\n                    new_group = comb\n            # print(new_group)\n            memo[tuple(skills)] = new_group\n            return new_group\n\n        return helper(set(req_skills), set())\n", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        n, m = len(req_skills), len(people)\n        key = {v: i for i, v in enumerate(req_skills)}\n        dp = {0: []}\n        for i, p in enumerate(people):\n            his_skill = 0\n            for skill in p:\n                if skill in key:\n                    his_skill |= 1 << key[skill]\n            for skill_set, need in list(dict(dp).items()):\n                with_him = skill_set | his_skill\n                if with_him == skill_set: continue\n                if with_him not in dp or len(dp[with_him]) > len(need) + 1:\n                    dp[with_him] = need + [i]\n        return dp[(1 << n) - 1]\n", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        key = {v : k for k, v in enumerate(req_skills)}\n        dp = {0: []}\n        for i, skills in enumerate(people):\n            person_skill = 0\n            for skill in skills:\n                person_skill |= 1 << (key[skill])\n            for skill_set, need in list(dict(dp).items()):\n                nxt_skill_set = skill_set | person_skill\n                if nxt_skill_set == skill_set: continue\n                if nxt_skill_set in dp and len(dp[nxt_skill_set]) <= len(need) + 1: continue\n                dp[nxt_skill_set] = need + [i]\n        return dp[(1 << len(req_skills)) - 1]\n        \n        \n        \n        \n        \n        \n        \n", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n         \n        n, m = len(req_skills), len(people)\n        key = {v: i for i, v in enumerate(req_skills)}\n        dp = {0: []}\n        for i, p in enumerate(people):\n            his_skill = 0\n            for skill in p:\n                if skill in key:\n                    his_skill |= 1 << key[skill]\n            if his_skill == 0:\n                continue\n            # if his_skill in dp and len(dp[his_skill]) == 1:\n            #     continue\n            for skill_set, need in list(dp.items()):\n                with_him = skill_set | his_skill\n                if with_him == skill_set: \n                    continue\n                if with_him not in dp or len(dp[with_him]) > len(need) + 1:\n                    dp[with_him] = need + [i]\n        return dp[(1 << n) - 1]\n                \n            \n            \n     \n        \n        \n        \n\n        \n\n", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        \n#         res = [''] * 17\n#         n = len(req_skills)\n#         def dfs(idx, has, path):\n#             nonlocal res\n#             if idx == n:\n#                 res = path\n#             elif req_skills[idx] in has:\n#                 dfs(idx + 1, has, path)\n#             else:\n#                 if len(path) + 1 < len(res):\n#                     for i, p in enumerate(people):\n#                         p = set(p)\n#                         if req_skills[idx] in p:\n#                             union = p & has\n#                             has |= p\n#                             dfs(idx + 1, has, path + [i])\n#                             has -= p\n#                             has |= union\n#         dfs(0, set(), [])\n#         return res\n                        \n        \n        \n        n = len(req_skills)\n        key = {v: i for i, v in enumerate(req_skills)}\n        dp = {0: []}\n        for i, p in enumerate(people):\n            his_skill = 0\n            for skill in p:\n                if skill in key:\n                    his_skill |= 1 << key[skill]\n            for skill_set, need in list(dp.items()):\n                with_him = skill_set | his_skill\n                if with_him == skill_set: continue\n                if with_him not in dp or len(dp[with_him]) > len(need) + 1:\n                    dp[with_him] = need + [i]\n        return dp[(1 << n) - 1]", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        n, m = len(req_skills), len(people)\n        key = {v: i for i, v in enumerate(req_skills)}\n        dp = {0: []}\n        for i, p in enumerate(people):\n            his_skill = 0\n            for skill in p:\n                if skill in key:\n                    his_skill |= 1 << key[skill]\n            for skill_set, need in list(dp.items()):\n                with_him = skill_set | his_skill\n                if with_him == skill_set: continue\n                if with_him not in dp or len(dp[with_him]) > len(need) + 1:\n                    dp[with_him] = need + [i]\n        return dp[(1 << n) - 1]", "class Solution:\n    def smallestSufficientTeam(self, req_skills, people):\n        n, m = len(req_skills), len(people)\n        key = {v: i for i, v in enumerate(req_skills)}\n        dp = {0: []}\n        for i, p in enumerate(people):\n            his_skill = 0\n            for skill in p: his_skill |= 1 << key[skill]\n            for skill_set, need in list(dp.items()):\n                with_him = skill_set | his_skill\n                if with_him == skill_set: continue\n                if with_him not in dp or len(dp[with_him]) > len(need) + 1: dp[with_him] = need + [i]\n        return dp[(1 << n) - 1]", "class Solution:\n    def smallestSufficientTeam(self, req_skills, people):\n        countReqSkills, memo = len(req_skills), {0: []}\n        skillToIndex = {v: i for i, v in enumerate(req_skills)}\n        for i, ithSkills in enumerate(people):\n            ithSkillsBitmap = 0\n            for skill in ithSkills: ithSkillsBitmap |= 1 << skillToIndex[skill]\n            for skillsBitmap, reqPpl in list(memo.items()):\n                skillsBitmapAddI = skillsBitmap | ithSkillsBitmap\n                if skillsBitmapAddI == skillsBitmap: continue\n                if skillsBitmapAddI not in memo or len(reqPpl) + 1 < len(memo[skillsBitmapAddI]): memo[skillsBitmapAddI] = reqPpl + [i]\n        return memo[(1 << countReqSkills) - 1]", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        n, m = len(req_skills), len(people)\n        key = {v: i for i, v in enumerate(req_skills)}\n        dp = {0: []}\n        for i, p in enumerate(people):\n            his_skill = 0\n            for skill in p:\n                if skill in key:\n                    his_skill |= 1 << key[skill]\n            for skill_set, need in list(dp.items()):\n                with_him = skill_set | his_skill\n                if with_him == skill_set: continue\n                if with_him not in dp or len(dp[with_him]) > len(need) + 1:\n                    dp[with_him] = need + [i]\n        return dp[(1 << n) - 1]\n", "# 5.05\nclass Solution:\n        \n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        dp={0:[]}\n        reqSkills={v:k for k,v in enumerate(req_skills)}\n        for i,curSkills in enumerate(people):\n            curMask=0\n            for skill in curSkills:\n                curMask|=1<<reqSkills[skill]\n            for mask,team in list(dp.items()):\n                m=mask|curMask\n                if m==mask:\n                    continue\n                if m not in dp or 1+len(team)<len(dp[m]):\n                    dp[m]=team+[i]\n        return dp[(1<<len(req_skills))-1]\n                \n# class Solution:\n#     def __init__(self):\n#         self.minCnt=math.inf\n#         self.minTeam=[]\n        \n#     def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n#         skills,team,skillsets,pids=set(req_skills),set(),set(),[]\n#         people\n#         for i,p in enumerate(people):\n#             p=frozenset(p)\n#             if not p or p in skillsets:\n#                 continue\n#             skillsets.add(p)\n#             pids.append(i)\n            \n#         def dfs(skills, team):\n#             if len(team)>self.minCnt:\n#                 return\n#             if not skills and len(team)<self.minCnt:\n#                 self.minCnt=len(team)\n#                 self.minTeam=list(team)\n#             ps=sorted(((p,skills.intersection(people[p])) for p in pids if p not in team),\\\\\n#                       key=lambda x:len(x[1]),reverse=True)\n#             for p,curSkills in ps:\n#                 if not curSkills:\n#                     break\n#                 team.add(p)\n#                 skills-=curSkills\n#                 dfs(skills,team)\n#                 team.remove(p)\n#                 skills.update(curSkills)\n#         dfs(skills,team)\n#         return self.minTeam\n", "from functools import lru_cache\nclass Solution:\n    def smallestSufficientTeam(self, l1: List[str], l2: List[List[str]]) -> List[int]:\n        \n\n        n = len(l1)\n        l2 = [set(i) for i in l2]\n        \n        index = {}\n        for i in range(n):\n            index[l1[i]] = i\n\n        @lru_cache(None)\n        def dp(mask, i):\n            # if mask == 2 ** n - 1:return set()\n            if i == n:\n                return set() if mask == 2 ** n - 1 else set(range(len(l2)))\n            \n                        \n            curr = set(range(len(l2)))\n            \n            if (mask >> i) & 1 == 1:\n                temp = dp(mask, i + 1)\n                if len(temp) < len(curr):curr = temp\n            \n            \n            for ind, j in enumerate(l2):\n                if l1[i] in j:\n                    masknow = mask\n                    for k in j:\n                        if (masknow >> index[k]) & 1 == 0:\n                            masknow += (1 << index[k])\n                    temp = set([ind]) | dp(masknow, i + 1)\n                    \n                    if len(temp) < len(curr):curr = temp\n            return curr\n                        \n        return sorted(list(dp(0, 0)))\n", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        n = len(req_skills)\n        skill_to_idx = {s: idx for idx, s in enumerate(req_skills)}\n        \n        skills = []\n        for p in people:\n            mask = 0\n            for s in p:\n                mask |= (1 << skill_to_idx[s])\n            skills.append(mask)\n\n            \n        dp = {0:[]}\n        for i in range(len(people)):\n            tmp = dp.copy()\n            for s, p in list(dp.items()):\n                ns = s | skills[i]\n                if ns not in tmp or len(p) + 1 < len(tmp[ns]):\n                    tmp[ns] = p + [i]\n            dp = tmp\n            \n        return dp[(1 << n ) - 1]\n", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        # Use dp and use bit to map the skill\n        mapping = {v:i for i,v in enumerate(req_skills)}\n        record = {0:[]}\n        for i, p in enumerate(people):\n            skills = 0\n            for s in p:\n                if s in mapping:\n                    skills |= 1<<mapping[s]\n            for v,l in list(record.items()):\n                withThis = v|skills\n                if withThis == v:continue\n                if withThis not in record or len(record[withThis]) > len(l)+1:\n                    record[withThis] = l+[i]\n        return record[(1<<len(req_skills))-1]\n            \n        \n        \n        \n#         skills = set(req_skills)\n#         res = []\n#         def recursive(index,team):\n#             if index == len(people):\n#                 if set(got.keys()) == skills:res.append(team)\n#             else:\n#                 for i in range(index,len(people)):\n#                     for s in people[i]:\n#                         got[s] += 1\n#                     recursive(i+1,team+[i])\n#                     for s in people[i]:\n#                         got[s] -= 1\n#                         if got[s] == 0:\n#                             del got[s]\n                        \n#         got = collections.defaultdict(int)\n#         recursive(0,[])\n#         res.sort(key=lambda x:len(x))\n#         return res[0]\n", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        dp = {\n            0: []\n        }\n        \n        skill_to_index = {skill: i for i, skill in enumerate(req_skills)}\n        for i, skills in enumerate(people):\n            mask = 0\n            for skill in skills:\n                mask |= 1 << (skill_to_index[skill])\n            keys = list(dp.keys())\n            for filled_req in keys:\n                new_filled_req = filled_req | mask\n                if (new_filled_req not in dp) or (len(dp[new_filled_req]) > len(dp[filled_req]) + 1):\n                    dp[new_filled_req] = dp[filled_req] + [i]\n        return dp[(1 << len(req_skills))-1]", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        skillIdx = {}\n        dp = {}\n        dp[0] = []\n        \n        for idx, skill in enumerate(req_skills):\n            skillIdx[skill] = idx\n        \n        for idx, personSkills in enumerate(people):\n            skillBits = 0\n            for skill in personSkills:\n                skillBits |= 1 << skillIdx[skill]\n            for prevSkills, _ in list(dp.items()):\n                newSkills = prevSkills | skillBits\n                if newSkills == prevSkills:\n                    continue\n                if newSkills not in dp or len(dp[newSkills]) > len(dp[prevSkills]) + 1:\n                    dp[newSkills] = dp[prevSkills] + [idx]\n        \n        return dp[(1 << len(req_skills)) - 1]\n", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        skill_idx = {s: i for i, s in enumerate(req_skills)}\n        n = len(req_skills)\n        \n        def encode(p):\n            res = 0\n            for sk in p:\n                res |= 1 << skill_idx[sk]\n            return res\n        \n        people_code = [encode(p) for p in people]\n        target = (1 << n) - 1\n        people_arr = 0\n        m = len(people)\n        \n        \n        covers = {0: []}\n        for i, pcode in enumerate(people_code):\n            for code, people_arr in list(covers.copy().items()):\n                new_code = pcode | code\n                \n                if new_code == code or (new_code in covers and len(people_arr) >= len(covers[new_code])):\n                    continue\n                covers[new_code] = people_arr + [i]\n        return covers[target]\n                    \n            \n        \n                    \n        \n                \n            \n", "class Solution:\n    \n    def rec(self, rs, rdic, people, ret, rett, unis):\n        if len(set(unis)) == len(rs):\n            if len(ret) < len(rett):\n                return ret\n            \n        if len(ret) >= len(rett):\n            return rett\n        \n        for r,v in list(rs.items()):\n            if r not in set(unis):\n                for p in rdic[r]:\n                    rett = self.rec(rs, rdic, people, ret + [p], rett, unis + people[p])\n                break\n        return rett\n                \n        \n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        rdic = {}\n        rs = {}\n        for r in req_skills:\n            rdic[r] = []\n            rs[r] = 0\n        \n        for i in range(len(people)):\n            for r in range(len(people[i])):\n                rdic[people[i][r]].append(i)\n        \n        rett = [i for i in range(len(people))]\n        return self.rec(rs, rdic, people, [], rett, [])\n        \n        \n            \n        \n        \n        \n        \n", "class Solution:\n    from collections import defaultdict\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        dic={req_skills[rs]:2**rs for rs in range(len(req_skills))}\n        dp=(defaultdict(list))\n        m_pp=[]\n        for pp in range(len(people)):\n            # temp=dp.copy()\n            res=0\n            for itr_pp in people[pp]:\n                res+=dic[itr_pp]\n            # print(res, people[pp])\n            if res!=0:\n                keys=list(dp.keys())\n                dp[res]=[pp]\n                for j in keys:\n                    if len(dp[j])>0:\n                        sum_=j|res\n                        if len(dp[sum_])==0 or len(dp[sum_])>len(dp[j]+[pp]):\n                                dp[sum_]=dp[j]+[pp]\n                # dp=temp\n        # def recur(idx,val,res):\n        #     if len(dp[val])==0 or len(dp[val])>len(res):\n        #         dp[val]=res\n        #     if len(dp[val])<len(res):return\n        #     if idx==len(m_pp):return\n        #     for i in range(idx,len(m_pp)):\n        #         # print(res,[i])\n        #         if m_pp[i]==0:continue\n        #         recur(i+1,val|m_pp[i],res+[i])\n        # recur(0,0,[])\n        # print(dp)\n        return dp[2**len(req_skills)-1]\n", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        hm = {v:i for i, v in enumerate(req_skills)}\n        dp = {0:[]}\n        \n        for i, skills in enumerate(people):\n            p_skills = 0\n            for sk in skills:\n                if sk in hm:\n                    p_skills |= 1<<(hm[sk])\n                    \n            for sks, need in list(dp.items()):\n                now = sks|p_skills\n                \n                if now not in dp or len(dp[now])>len(need)+1:\n                    dp[now] = need+[i]\n                    \n        return dp[(1<<len(req_skills))-1]\n", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        lrs = len(req_skills)\n        skills = collections.defaultdict(list)\n        peo_skills = []\n        for i,skill in enumerate(people):\n            for s in skill:\n                skills[s].append(i)\n        self.res = [0]*(lrs+1)       \n        def dfs(idx,cover,path):\n            if idx==lrs:\n                self.res = path\n            elif idx>=lrs: return\n            elif req_skills[idx] in cover: \n                dfs(idx+1,cover,path)\n            else:\n                if len(path)+1<len(self.res):\n                    for p in skills[req_skills[idx]]:                 \n                        p_s = set(people[p])\n                        union = cover&p_s\n                        cover |= p_s\n                        dfs(idx+1,cover,path+[p])\n                        cover -=p_s\n                        cover |= union\n        dfs(0,set(),[])\n        return self.res\n                    \n\n            \n            \n        \n\n                        \n", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        def convertToNum(people: List[str]) -> int:\n            ans = 0\n            for skill in people:\n                ans |= 1 << (dic[skill])\n            return ans\n        \n        dic = {v: i for i, v in enumerate(req_skills)}\n        target = (1 << len(req_skills)) - 1\n        dp = dict()\n        for i, people_skill in enumerate(people):\n            skill = convertToNum(people_skill)\n            temp = dict()\n            temp[skill] = [i]\n            for key in list(dp.keys()):\n                if key != skill:\n                    new_skill = key | skill\n                    if new_skill not in list(dp.keys()) or len(dp[new_skill]) > len(dp[key]) + 1:\n                        t = [v for v in dp[key]]\n                        t.append(i)\n                        if new_skill not in list(temp.keys()) or len(temp[new_skill]) > len(t):\n                            temp[new_skill] = t\n                                \n            dp.update(temp)\n        \n        return dp[target]\n        \n            \n        \n", "class Solution:\n    from collections import defaultdict\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        dic={req_skills[rs]:2**rs for rs in range(len(req_skills))}\n        dp=(defaultdict(list))\n        m_pp=[]\n        for pp in range(len(people)):\n            # temp=dp.copy()\n            res=0\n            for itr_pp in people[pp]:\n                res+=dic[itr_pp]\n            # print(res, people[pp])\n            if res!=0:\n                dp[res]=[pp]\n                keys=list(dp.keys())\n                for j in keys:\n                    if len(dp[j])>0:\n                        sum_=j|res\n                        if len(dp[sum_])==0 or len(dp[sum_])>len(dp[j]+[pp]):\n                                dp[sum_]=dp[j]+[pp]\n                # dp=temp\n        # def recur(idx,val,res):\n        #     if len(dp[val])==0 or len(dp[val])>len(res):\n        #         dp[val]=res\n        #     if len(dp[val])<len(res):return\n        #     if idx==len(m_pp):return\n        #     for i in range(idx,len(m_pp)):\n        #         # print(res,[i])\n        #         if m_pp[i]==0:continue\n        #         recur(i+1,val|m_pp[i],res+[i])\n        # recur(0,0,[])\n        # print(dp)\n        return dp[2**len(req_skills)-1]\n", "class Solution:\n    def smallestSufficientTeam(self, req_skills, people):\n        n, m = len(req_skills), len(people)\n        key = {v: i for i, v in enumerate(req_skills)}\n        dp = {0: []}\n        for i, p in enumerate(people):\n            his_skill = 0\n            for skill in p:\n                if skill in key:\n                    his_skill |= 1 << key[skill]\n            for skill_set, need in list(dp.items()):\n                with_him = skill_set | his_skill\n                if with_him not in dp or len(dp[with_him]) > len(need) + 1:\n                    dp[with_him] = need + [i]\n        return dp[(1 << n) - 1]\n", "#skillsets[skillset] = team, is a sufficient team to cover the skillset.\n#For each people, update skillsets with all current combinations in skillsets.\nclass Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        skillid = {skill: i for i, skill in enumerate(req_skills)}\n        skillsets = {0: []}\n        for i, p in enumerate(people):\n            #create people[i]'s skill mask\n            skillmask = 0\n            for skill in p:\n                if skill in skillid:\n                    skillmask |= (1 << skillid[skill])\n            #combine\n            current_skillsets = list(skillsets.keys())\n            for skillset in current_skillsets:\n                within_i = skillset | skillmask\n                if within_i not in skillsets or len(skillsets[within_i]) > len(skillsets[skillset])+1:\n                    skillsets[within_i] = skillsets[skillset] + [i]\n        c, mult = 0, 1\n        for i in range(len(req_skills)):\n            c += mult\n            mult *= 2\n        return skillsets[c]\n", "class Solution:\n    from collections import defaultdict\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        dic={req_skills[rs]:2**rs for rs in range(len(req_skills))}\n        dp=defaultdict(list)\n        m_pp=[]\n        for pp in range(len(people)):\n            temp=dp.copy()\n            res=0\n            for itr_pp in people[pp]:\n                res+=dic[itr_pp]\n            # print(res, people[pp])\n            if res!=0:\n                temp[res]=[pp]\n                for j,v in list(dp.items()):\n                    if len(temp[j])>0:\n                        sum_=j|res\n                        if len(temp[sum_])==0 or len(temp[sum_])>len(temp[j]+[pp]):\n                                temp[sum_]=temp[j]+[pp]\n                dp=temp\n        # def recur(idx,val,res):\n        #     if len(dp[val])==0 or len(dp[val])>len(res):\n        #         dp[val]=res\n        #     if len(dp[val])<len(res):return\n        #     if idx==len(m_pp):return\n        #     for i in range(idx,len(m_pp)):\n        #         # print(res,[i])\n        #         if m_pp[i]==0:continue\n        #         recur(i+1,val|m_pp[i],res+[i])\n        # recur(0,0,[])\n        # print(dp)\n        return dp[2**len(req_skills)-1]\n", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        n, m = len(req_skills), len(people)\n        dic = {v: i for i, v in enumerate(req_skills)}\n        dp = {0: []}\n        for i, p in enumerate(people):\n            cur_skill = 0\n            for s in p:\n                if s in dic:\n                    cur_skill |= 1 << dic[s]\n            for skill_set, team in list(dp.items()):\n                new_skill = skill_set | cur_skill\n                if new_skill != skill_set:\n                    if new_skill not in dp or len(team) + 1 < len(dp[new_skill]):\n                        dp[new_skill] = team + [i]\n        return dp[(1 << n) - 1]\n", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        skill_idx = {s: i for i, s in enumerate(req_skills)}\n        n = len(req_skills)\n        \n        def encode(p):\n            res = 0\n            for sk in p:\n                res |= 1 << skill_idx[sk]\n            return res\n        \n        people_code = [encode(p) for p in people]\n        target = (1 << n) - 1\n        people_arr = 0\n        m = len(people)\n        \n        \n        covers = {0: []}\n        for i, pcode in enumerate(people_code):\n            for code, people_arr in list(covers.copy().items()):\n                new_code = pcode | code\n                if new_code in covers and len(people_arr) >= len(covers[new_code]):\n                    continue\n                covers[new_code] = people_arr + [i]\n        return covers[target]\n                    \n            \n        \n                    \n        \n                \n            \n", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        ##dp[i][state]: state: 0 ---- 2^n,  n = len(req_skills)\n        ##dp[i][state] if state all included in people[i] --> dp[i-1][state]\n        ##dp[i][state - subset] if subset in people[i] --> dp[i-1][state-subset] + 1\n        \\\"\\\"\\\"\n        m = len(req_skills)\n        n = len(people)\n        states = 1<<(m)\n        skill_index = {}\n        for i,skill in enumerate(req_skills):\n            skill_index[skill] = i\n        mypeople = []\n        for p in people:\n            myp = 0\n            for skill in p:\n                myp ^= (1 << skill_index[skill])\n            mypeople.append(myp)\n        \n        dp = [float(\\\"inf\\\") for _ in range(states)]\n        parent = [(-1, -1) for _ in range(states)]\n        dp[0] = 0\n        \n        for i in range(n):\n            skill = mypeople[i]\n            if skill == 0:\n                continue\n            #for j in range(states)\uff1a\n            #    if dp[i-1][j] != float(\\\"inf\\\"):\n            #        dp[i][j] = dp[i-1][j]\n\n            for j in range(states-1, -1, -1):\n                if  dp[j] + 1 < dp[j|skill]:\n                    dp[j | skill] = dp[j] + 1\n                    parent[j | skill] = (j, i)\n                    print(\\\"parent\\\", parent)\n                if dp[i-1][j] + 1 < dp[i-1][j|skill] and dp[i-1][j] + 1 < dp[i][j|skill]:\n                    parent[j|skill] = (j, i-1)\n                dp[i][j|skill] = min(dp[i][j|skill], dp[i-1][j|skill], dp[i-1][j] + 1)\n            print(i, dp)\n                \n        #print(\\\"dp\\\", dp)\n        #print(\\\"parents\\\", parent)\n        ans = []\n        t = states - 1\n        while t > 0:\n            ans.append(parent[t][1])\n            t = parent[t][0]\n        print(\\\"ans\\\", ans)\n        ans.reverse()\n        return ans\n        \\\"\\\"\\\"\n        m, n = len(req_skills), len(people)\n        key = {v:i for i,v in enumerate(req_skills)}\n        #print(m, n, key)\n        paths = {0: []} \n        for i, who in enumerate(people):\n            his_skill = 0\n            for skill in people[i]:\n                if skill in key:\n                    his_skill |= (1 << key[skill])\n            \n            for skills, path in list(paths.items()):\n                new_skill = skills | his_skill\n                if new_skill == skills: continue\n                if new_skill not in paths or len(paths[new_skill]) > len(path) + 1:\n                    paths[new_skill] = path + [i]\n            #print(i, \\\"paths\\\", paths)\n        return paths[(1 << m) - 1]\n            \n        \n            \n                ", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        dic = {v: i for i, v in enumerate(req_skills)}\n        dp = dict()\n        for i, people_skill in enumerate(people):\n            skill = 0\n            for single_skill in people_skill:\n                skill |= 1 << (dic[single_skill])\n            dp[skill] = [i]\n            for key, value in list(dp.items()):\n                if key != skill:\n                    new_skill = key | skill\n                    if new_skill not in list(dp.keys()) or len(dp[new_skill]) > len(dp[key]) + 1:\n                        dp[new_skill] = dp[key] + [i]\n        \n        return dp[(1 << len(req_skills)) - 1]\n        \n            \n        \n", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        skill_id_map = {skill: 1<<i for i, skill in enumerate(req_skills)}\n        \n        # key: bit representation of union of skills.\n        # value: indices of people that comprise the smallest sufficient team.\n        ids_indices_map = { 0: [] }\n\n        for index, person_skills in enumerate(people):\n            person_ids = 0\n            for skill in person_skills:\n                person_ids |= skill_id_map[skill]\n            \n            new_ids_indices_map = ids_indices_map.copy()\n            for ids, indices in ids_indices_map.items():\n                new_ids = ids | person_ids\n                new_indices = indices + [index]\n                if len(new_indices) <= len(new_ids_indices_map.get(new_ids, new_indices)):\n                    new_ids_indices_map[new_ids] = new_indices\n            \n            ids_indices_map = new_ids_indices_map\n        return ids_indices_map[2 ** len(req_skills) - 1]", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:        \n        n = len(req_skills)\n        m = len(people)\n        key = {v:i for i, v in enumerate(req_skills)}\n        dp = {0 : []}\n        \n        for i, p in enumerate(people):\n            his_skill = 0\n            for skill in p:\n                his_skill |= 1 << key[skill]\n            \n            \n            for skill_set, need in list(dp.items()):\n                with_him = skill_set | his_skill\n                if with_him not in dp or len(dp[with_him]) > len(need) + 1:\n                    dp[with_him] = need + [i]\n                    \n        return dp[(1 << n) - 1]\n    \n    \n    \n    \n        # n, m = len(req_skills), len(people)\n        # key = {v: i for i, v in enumerate(req_skills)}\n        # dp = {0: []}\n        # for i, p in enumerate(people):\n        #     his_skill = 0\n        #     for skill in p:\n        #         if skill in key:\n        #             his_skill |= 1 << key[skill]\n        #     if his_skill == 0:\n        #         continue\n        #     # if his_skill in dp and len(dp[his_skill]) == 1:\n        #     #     continue\n        #     for skill_set, need in list(dp.items()):\n        #         with_him = skill_set | his_skill\n        #         if with_him == skill_set: continue\n        #         if with_him not in dp or len(dp[with_him]) > len(need) + 1:\n        #             dp[with_him] = need + [i]\n        # return dp[(1 << n) - 1]\n                \n            \n            \n     \n        \n        \n        \n\n        \n\n", "from collections import Counter, defaultdict, OrderedDict, deque\nfrom bisect import bisect_left, bisect_right\nfrom functools import reduce, lru_cache\nfrom typing import List\nimport itertools\nimport math\nimport heapq\nimport string\ntrue = True\nfalse = False\nMIN, MAX, MOD = -0x3f3f3f3f, 0x3f3f3f3f, 1000000007\n\n\n#\n# @lc app=leetcode id=1125 lang=python3\n#\n# [1125] Smallest Sufficient Team\n#\n# https://leetcode.com/problems/smallest-sufficient-team/description/\n#\n# algorithms\n# Hard (46.48%)\n# Total Accepted:    8.6K\n# Total Submissions: 18.5K\n# Testcase Example:  '[\\\"java\\\",\\\"nodejs\\\",\\\"reactjs\\\"]\\\n[[\\\"java\\\"],[\\\"nodejs\\\"],[\\\"nodejs\\\",\\\"reactjs\\\"]]'\n#\n# In a project, you have a list of required skills req_skills,\u00a0and a list of\n# people.\u00a0 The i-th person people[i]\u00a0contains a list of skills that person\n# has.\n#\n# Consider a sufficient team: a set of people such that for every required\n# skill in req_skills, there is at least one person in the team who has that\n# skill.\u00a0 We can represent these teams by the index of each person: for\n# example, team = [0, 1, 3] represents the people with skills people[0],\n# people[1], and people[3].\n#\n# Return any\u00a0sufficient team of the smallest possible size, represented by the\n# index of each person.\n#\n# You may return the answer in any order.\u00a0 It is guaranteed an answer\n# exists.\n#\n#\n# Example 1:\n# Input: req_skills = [\\\"java\\\",\\\"nodejs\\\",\\\"reactjs\\\"], people =\n# [[\\\"java\\\"],[\\\"nodejs\\\"],[\\\"nodejs\\\",\\\"reactjs\\\"]]\n# Output: [0,2]\n# Example 2:\n# Input: req_skills = [\\\"algorithms\\\",\\\"math\\\",\\\"java\\\",\\\"reactjs\\\",\\\"csharp\\\",\\\"aws\\\"],\n# people =\n# [[\\\"algorithms\\\",\\\"math\\\",\\\"java\\\"],[\\\"algorithms\\\",\\\"math\\\",\\\"reactjs\\\"],[\\\"java\\\",\\\"csharp\\\",\\\"aws\\\"],[\\\"reactjs\\\",\\\"csharp\\\"],[\\\"csharp\\\",\\\"math\\\"],[\\\"aws\\\",\\\"java\\\"]]\n# Output: [1,2]\n#\n#\n# Constraints:\n#\n#\n# 1 <= req_skills.length <= 16\n# 1 <= people.length <= 60\n# 1 <= people[i].length, req_skills[i].length, people[i][j].length\u00a0<= 16\n# Elements of req_skills and people[i] are (respectively) distinct.\n# req_skills[i][j], people[i][j][k] are\u00a0lowercase English letters.\n# Every skill in people[i]\u00a0is a skill in req_skills.\n# It is guaranteed a sufficient team exists.\n#\n#\n#\nclass Solution:\n    def smallestSufficientTeam(self, req_skills: List[str],\n                               people: List[List[str]]) -> List[int]:\n        len_req, len_people = len(req_skills), len(people)\n        skill2index = dict((s, i) for i, s in enumerate(req_skills))\n        dp = {0: []}\n        for i, p in enumerate(people):\n            cur_skill = reduce(lambda a, b: a | (1 << skill2index[b]), p, 0)\n            for skill_set in list(dp.keys()):\n                need = dp[skill_set]\n                hire_him = skill_set | cur_skill\n                if hire_him not in dp or len(dp[hire_him]) > len(need) + 1:\n                    dp[hire_him] = need + [i]\n        return dp[(1 << len_req) - 1]\n\n\nsol = Solution()\n\n# req_skills = [\\\"java\\\",\\\"nodejs\\\",\\\"reactjs\\\"], people = [[\\\"java\\\"],[\\\"nodejs\\\"],[\\\"nodejs\\\",\\\"reactjs\\\"]]\nreq_skills, people = [\n    \\\"algorithms\\\", \\\"math\\\", \\\"java\\\", \\\"reactjs\\\", \\\"csharp\\\", \\\"aws\\\"\n], [[\\\"algorithms\\\", \\\"math\\\", \\\"java\\\"], [\\\"algorithms\\\", \\\"math\\\", \\\"reactjs\\\"],\n    [\\\"java\\\", \\\"csharp\\\", \\\"aws\\\"], [\\\"reactjs\\\", \\\"csharp\\\"], [\\\"csharp\\\", \\\"math\\\"],\n    [\\\"aws\\\", \\\"java\\\"]]\n", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:        \n        n = len(req_skills)\n        m = len(people)\n        key = {v:i for i, v in enumerate(req_skills)}\n        dp = {0 : []}\n        \n        for i, p in enumerate(people):\n            his_skill = 0\n            for skill in p:\n                his_skill |= 1 << key[skill]\n            if his_skill == 0:\n                continue\n            \n            \n            for skill_set, need in list(dp.items()):\n                with_him = skill_set | his_skill\n                if with_him not in dp or len(dp[with_him]) > len(need) + 1:\n                    dp[with_him] = need + [i]\n                    \n        return dp[(1 << n) - 1]\n    \n    \n    \n    \n        # n, m = len(req_skills), len(people)\n        # key = {v: i for i, v in enumerate(req_skills)}\n        # dp = {0: []}\n        # for i, p in enumerate(people):\n        #     his_skill = 0\n        #     for skill in p:\n        #         if skill in key:\n        #             his_skill |= 1 << key[skill]\n        #     if his_skill == 0:\n        #         continue\n        #     # if his_skill in dp and len(dp[his_skill]) == 1:\n        #     #     continue\n        #     for skill_set, need in list(dp.items()):\n        #         with_him = skill_set | his_skill\n        #         if with_him == skill_set: continue\n        #         if with_him not in dp or len(dp[with_him]) > len(need) + 1:\n        #             dp[with_him] = need + [i]\n        # return dp[(1 << n) - 1]\n                \n            \n            \n     \n        \n        \n        \n\n        \n\n", "from functools import reduce\n\nimport operator\n\nclass Solution:\n  def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n    # n: num skills\n    n = len(req_skills)\n    # z: target\n    z = (1 << n) - 1\n    # rs: hash of skill to integer \n    rs = {x: 1 << i for i, x in enumerate(req_skills)}\n    # ps: hash people skill to integer\n    ps = list(map(lambda p: reduce(operator.__or__, map(lambda s: rs[s], p), 0), people))\n    # d: skillset to smallest sufficient team\n    d = {0: []}\n    # O(2^N M), N = num of skills, M = num of people\n    for i, s in enumerate(ps):\n      p = {}\n      for x in d:\n        y = x | s\n        if y not in p or len(d[x]) < len(p[y]):\n          p[y] = d[x] + [i]\n      for y in p:\n        if y not in d or len(p[y]) < len(d[y]):\n          d[y] = p[y]\n    return d[z]", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        n = len(req_skills)\n        res = {}\n        res[0] = set()\n        skill_map = {v: i for i, v in enumerate(req_skills)}\n        print(skill_map)\n        \n        for p, skills in enumerate(people):\n            curr_skill = 0\n            for skill in skills:\n                curr_skill |= (1 << skill_map[skill])\n            # print(curr_skill)\n            \n            nr = {}\n            for s, t in res.items():\n                k = curr_skill | s\n                nt = t | {p}\n                if k not in res:\n                    if k not in nr or len(nr[k]) > len(nt): nr[k] = nt\n                elif len(res[k]) > len(nt):\n                    res[k] = nt\n            res.update(nr)\n            # print(res, nr)\n        \n        return list(res[(1 << n) - 1])", "class Solution:            \n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        l = len(req_skills)\n        index_dict = {item : i for i, item in enumerate(req_skills)}\n        mydict = {0 : []}\n        for i, person in enumerate(people):\n            skill_list = ['0']*l\n            for skill in person:\n                index = index_dict[skill]\n                skill_list[index] = '1'\n            num = int(''.join(skill_list), 2)\n            new_dict = {key: list(item) for key, item in list(mydict.items())}\n            for key in list(mydict.keys()):\n                new_num = key | num\n                if new_num in new_dict:\n                    if len(new_dict[new_num]) > 1 + len(mydict[key]):\n                        new_dict[new_num] = mydict[key] + [i,]\n                else:\n                    new_dict[new_num] = mydict[key] + [i,]\n            mydict = new_dict\n        return mydict[2**l-1]\n                                    \n            \n                \n", "class Solution:\n    def smallestSufficientTeam(self, \\\\\n                               req_skills: List[str], \\\\\n                               people: List[List[str]]) -> List[int]:\n        \n        N = len(req_skills)\n        P = len(people)\n        \n        skill_id_map = {skill:idx for idx,skill in enumerate(req_skills)}\n        def get_ssid(skills):\n            ssid = 0\n            for skill in skills:\n                idx = skill_id_map[skill]\n                ssid |=  (1 << idx)\n            return ssid\n                \n        people_ssid_map = {\n            idx:get_ssid(skills) for idx,skills in enumerate(people)\n        }\n            \n        dpv = [sys.maxsize] * (2**N)\n        dpv[0] = 0\n        dps = [[] for _ in range(2**N)]\n        \n        for ssid in range(2**N):\n            if dpv[ssid] == sys.maxsize:\n                continue\n            for peepsid in range(P):\n                skillset_id = people_ssid_map[peepsid]\n                \n                new_ssid = (ssid | skillset_id)\n                if new_ssid != ssid:\n                    if 1 + dpv[ssid] < dpv[new_ssid]:\n                        dpv[new_ssid] = 1 + dpv[ssid]\n                        dps[new_ssid] = dps[ssid] + [peepsid]\n                    \n        #print(dpv)\n                    \n        return dps[(2**N) - 1]\n                    \n                    \n                \n            \n        ", "from collections import defaultdict\n\nclass Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        def backtrack(i, people_added, skills_added):\n            nonlocal result\n            if i == len(req_skills):\n                result = list(people_added)\n            elif i in skills_added:\n                backtrack(i+1, people_added, skills_added)\n            else:\n                if len(people_added) < len(result) - 1:\n                    for k, skills_ix in list(skills_dict.items()):\n                        if i in skills_ix:\n                            backtrack(i+1, people_added + [k], skills_added | skills_ix)\n                            \n        result = list(range(len(req_skills)+1))\n        req_skills_ix_map = {skill: i for i, skill in enumerate(req_skills)}\n        skills_dict = {i: set([req_skills_ix_map[skill] for skill in skills]) for i, skills in enumerate(people)}\n        backtrack(0, [], set())\n        return result\n", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        n = len(req_skills)\n        target = (1<<n)-1\n        s_i = {s:i for i,s in enumerate(req_skills)}\n        # skill cost\n        dp = {0:[]}\n        for j,row in enumerate(people):\n            mask = 0\n            new_dp = dp.copy()\n            for s in row:\n                mask|= (1<<s_i[s])\n            for curr,cost in dp.items():\n                new_mask = curr|mask\n                if new_mask not in new_dp:\n                    new_dp[new_mask] = cost+[j]\n                else:\n                    new_dp[new_mask] = min(new_dp[new_mask],cost+[j],key=len)\n            dp = new_dp\n        return dp[target]", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        L = len(req_skills)\n        \n        d = {}\n        mask = 1\n        for i in req_skills:\n            d[i] = mask\n            mask <<= 1\n        \n        p = [0] * len(people)\n        for i, lst in enumerate(people):\n            p[i] += sum([d[j] for j in lst])\n    \n        @functools.lru_cache(None)\n        def dp(mask):\n            if mask == 2 ** L - 1:\n                return []\n\n            smallest = float(\\\"inf\\\")\n            ret = []\n            for i, skills in enumerate(p):\n                if mask & skills != skills:\n                    tmp = dp(mask | skills)\n                    if len(tmp) < smallest:\n                        smallest = len(tmp)\n                        ret = [i] + tmp\n            return ret\n        \n        return dp(0)", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        L = len(req_skills)\n        \n        d = {}\n        mask = 1\n        for i in req_skills:\n            d[i] = mask\n            mask <<= 1\n        \n        p = [0] * len(people)\n        for i, lst in enumerate(people):\n            p[i] += sum([d[j] for j in lst])\n            \n        print(p)\n    \n        @functools.lru_cache(None)\n        def dp(mask):\n            if mask == 2 ** L - 1:\n                return []\n\n            smallest = float(\\\"inf\\\")\n            ret = []\n            for i, skills in enumerate(p):\n                if mask & skills != skills:\n                    tmp = dp(mask | skills)\n                    if len(tmp) < smallest:\n                        smallest = len(tmp)\n                        ret = [i] + tmp\n            return ret\n        \n        return dp(0)", "class Solution:\n    def smallestSufficientTeam(self, skills: List[str], people: List[List[str]]) -> List[int]:\n        skill2idx = {skill:i for i,skill in enumerate(skills)}\n        for i in range(len(people)):\n            mask = 0\n            for skill in people[i]:\n                mask |= (1 << skill2idx[skill])\n            people[i] = mask\n        stop = (1 << len(skills)) - 1\n        \n        @lru_cache(None)\n        def dfs(i, mask):\n            if mask == stop:\n                return ()\n            \n            if i == len(people):\n                return None\n            \n            ans1 = dfs(i+1, mask)\n            ans2 = dfs(i+1, mask | people[i])\n            if ans2 is not None:\n                ans2 = (i,) + ans2\n                \n            if ans1 is None:\n                return ans2\n            elif ans2 is None:\n                return ans1\n            else:\n                return min(ans1, ans2, key=len)\n        \n        return dfs(0, 0)", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        \n        pmasks = []\n        for p in people:\n            mask = 0\n            for skill in p:\n                idx = req_skills.index(skill)\n                mask ^= 1 << idx\n            pmasks.append(mask)\n        M = pow(2, len(req_skills)) - 1\n        \n        @functools.lru_cache(maxsize=None)\n        def dfs(mask):\n            if mask == M:\n                return []\n            ret = None\n            \n            for i, p in enumerate(pmasks):\n                if mask|p != mask:\n                    ppl = dfs(mask|p)\n                    if ppl != None and (not ret or len(ret) > len(ppl) + 1):\n                        ret = [i] + ppl\n                        #print(i, ppl)\n            #print(mask, ret)\n            return ret\n        \n        #print(M, pmasks)\n        return dfs(0)", "from functools import lru_cache\nfrom collections import defaultdict\nimport math\nclass Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        mp = defaultdict(int)\n        for i, skill in enumerate(req_skills):\n            mp[skill] = i\n        skills = []\n        for p in people:\n            mask = 0\n            for skill in p:\n                mask |= 1 << mp[skill]\n            skills.append(mask)\n\n        @lru_cache(None)\n        def search(i: int, required: int) -> int:\n            if required == 0:\n                return 0\n            if i == len(people):\n                return math.inf\n            return min(search(i + 1, required), 1 + search(i + 1, required ^ (required & skills[i])))\n        \n        def get_team(i: int, required: int, ans: list):\n            if i == len(people):\n                return\n            if search(i + 1, required) > 1 + search(i + 1, required ^ (required & skills[i])):\n                ans.append(i)\n                get_team(i + 1, required ^ (required & skills[i]), ans)\n            else:\n                get_team(i + 1, required, ans)\n        \n        ans = []\n        get_team(0, (1 << len(req_skills)) - 1, ans)\n        return ans", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        N, M = len(req_skills), len(people)\n        NN = 1 << N\n        skill2id = {jj: ii for ii, jj in enumerate(req_skills)}\n        team = {ii: [] for ii in range(NN)}\n        dp = [-1] * NN\n        dp[0] = 0\n\n        for ii in range(M):\n            idx = 0\n            for s in people[ii]:\n                if s in skill2id:\n                    idx = idx | (1 << skill2id[s])\n            for jj in range(NN):\n                if dp[jj] < 0:\n                    continue\n                x = jj | idx\n                if dp[x] == -1 or dp[x] > dp[jj] + 1:\n                    # print(ii, jj, x, team)\n                    dp[x] = dp[jj] + 1\n                    team[x] = team[jj].copy()\n                    team[x].append(ii)\n        # print(team)\n        return team[NN - 1]\n", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        skill_id = {skill: i for i, skill in enumerate(req_skills)}\n        def getSkillSetId(skills):\n            res = 0\n            for skill in skills:\n                if skill in skill_id:\n                    res |= (1 << skill_id[skill])\n            return res\n        \n        req_skills = getSkillSetId(req_skills)\n        people = list(map(getSkillSetId, people))\n        \n        @functools.lru_cache(None)\n        def dfs(req_skills, pid):\n            if req_skills == 0:\n                return [0, []]\n            elif pid == -1:\n                return [float('inf'), []]\n            else:\n                sol1 = dfs(req_skills, pid - 1)\n                sol2 = dfs(req_skills & (~people[pid]), pid - 1)\n                if sol2[0] + 1 < sol1[0]:\n                    return [sol2[0] + 1, sol2[1] + [pid]]\n                else:\n                    return sol1\n        return dfs(req_skills, len(people) - 1)[1]\n        \n    \n    def smallestSufficientTeam_II(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        \n        skill_id = {skill:idx for idx, skill in enumerate(req_skills)}\n        \n        def getSkillId(skill_set):\n            res = 0\n            for skill in skill_set:\n                res = res | ((1 << skill_id[skill]) if skill in skill_id else 0)\n            return res\n        \n        people = [getSkillId(skills) for skills in people]\n        req_skills = getSkillId(req_skills)\n        \n        @functools.lru_cache(maxsize = None)\n        def dfs(req_skills, pid):\n            if req_skills == 0:\n                return [0, []]\n            elif pid == len(people):\n                return [float('inf'), []]\n            else:\n                sol1 = dfs(req_skills, pid + 1)\n                sol2 = dfs(req_skills & ( ~people[pid]), pid + 1)\n                if sol2[0] + 1 < sol1[0]:\n                    return [sol2[0] + 1, [pid] + sol2[1]]\n                else:\n                    return sol1\n        \n        return dfs(req_skills, 0)[1]\n", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        # Similar to Knapsack problem. First use a binary string to represent a skill set, with target being 2^n-1 (if 3 skills are required, target will be 111). \n        # dp[i][j] := min people to reach skill set represented by binary string using first i people\n        # dp[0][0] = 0\n        # dp[i][j | k] = min(dp[i-1][j | k], dp[i-1][j] + 1), where k is the ith person's skillset.\n        # if you have a skillset k of 100 and current j is 001, you can achieve a skillset new j of 100 | 001 = 101. So j of 101 can be achieved either with selecting me which is dp[i-1][j] + 1, or not selecting me - which is equivalent to achieving skillset of j | k with i-1 people, so dp[i-1][j|k]. Now we need to keep a pt (parent child relationship) to later link all the nodes we have traveled to get to the optimal answer dp[n][2^n-1].\n        n = len(req_skills)\n        target = (1<<n)-1\n        skills = []\n        for p in people:\n            mask = 0\n            for s in p:\n                mask |= 1 << req_skills.index(s)\n            skills.append(mask)\n        dp = [float('inf') for _ in range(1 << n)]\n        pt = [0 for _ in range(1 << n)]\n        dp[0] = 0\n        for i in range(len(people)):\n            k = skills[i]\n            if k == 0:\n                continue\n            for j in range(target+1)[::-1]:\n                if dp[j] + 1 < dp[j|k]:\n                    dp[j|k] = dp[j]+1\n                    pt[j|k] = (j, i) # (parent, current)\n        t = target\n        ans = []\n        while t:\n            ans.append(pt[t][1])\n            t = pt[t][0]\n        return ans\n                \n", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        allneed = (1 << len(req_skills) ) - 1\n\n        stoi = {}\n        for i, s in enumerate(req_skills):\n            stoi[s] = 1 << i\n        \n        def serialize(arr):\n            res = 0\n            for s in arr:\n                res = res | stoi[s]\n            return res\n        \n        ppl = []\n        for i,p in enumerate(people):\n            ppl.append(serialize(p))\n        \n        tempmax = [0] * (len(req_skills) + 1)\n        \n        @lru_cache(None)\n        def helper(needed):\n            if needed == 0: return []\n            shortest = tempmax\n            for i, person in enumerate(ppl):\n                if (person & needed) > 0:\n                    sofar = [i] + helper((person ^ allneed) & needed)\n                    if (len(sofar) < len(shortest)):\n                        shortest = sofar\n            return shortest\n        \n        return helper(allneed)\n", "from functools import lru_cache\n\nclass Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        ids = {}\n        sid = 0\n        skills = 0\n        for skill in req_skills:\n            ids[skill] = sid\n            skills = skills | (1 << sid)\n            sid += 1\n\n        n = len(people)\n\n        @lru_cache(None)\n        def dp(i, needed_skills):\n            if needed_skills == 0:\n                return []\n            if i == n:\n                return None\n\n            a = dp(i + 1, needed_skills)\n\n            next_needed_skills = needed_skills\n            for s in people[i]:\n                if s in ids:\n                    j = ids[s]\n                    next_needed_skills = (next_needed_skills & ~(1 << j))\n\n            b = None\n            if next_needed_skills != needed_skills:\n                b = dp(i + 1, next_needed_skills)\n\n            if a is not None and b is not None:\n                if len(a) < len(b) + 1:\n                    return a\n                else:\n                    return [i] + b\n\n            if a is None and b is None:\n                return None\n\n            return ([i] + b) if a is None else a\n\n        return dp(0, skills)\n\n\n\n", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        skills = []\n        for p in people:\n            cur = 0\n            for skill in p:\n                for i, req_skill in enumerate(req_skills):\n                    if skill == req_skill:\n                        cur |= (1 << i)\n            skills.append(cur)\n        \n        n = len(req_skills)\n        target = (1 << n) - 1\n        dp = [1000000 for i in range(target + 1)]\n        dp[0] = 0\n        # parent[k] = (j, i) means the skillset represented by k is constructed from skilset represented by j plus the skillset of ith people. from j to k we use i. In this way we can construct the result backward and \n        parent = [0] * (target + 1)\n        \n        for i in range(len(people)):\n            k = skills[i]\n            if k == 0:\n                continue\n            \n            for j in reversed(list(range(target))):\n                if dp[j | k] > dp[j] + 1:\n                    dp[j | k] = dp[j] + 1\n                    parent[j | k] = (j, i)\n        \n        t = target\n        result = []\n        while t:\n            result.append(parent[t][1])\n            t = parent[t][0]\n        return result\n        \n", "from functools import lru_cache\n\nclass Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        ids = {}\n        sid = 0\n        skills = 0\n        for skill in req_skills:\n            ids[skill] = sid\n            skills = skills | (1 << sid)\n            # print(sid, 1 << sid)\n            sid += 1\n\n        # print(ids)\n        # print(skills)\n\n        n = len(people)\n\n        @lru_cache(None)\n        def dp(i, left):\n            if left == 0:\n                return []\n            if i == n:\n                return None\n\n            a = dp(i + 1, left)\n\n            for s in people[i]:\n                if s in ids:\n                    j = ids[s]\n                    left = (left & ~(1 << j))\n\n            b = dp(i + 1, left)\n\n            if a is not None and b is not None:\n                if len(a) < len(b) + 1:\n                    return a\n                else:\n                    return [i] + b\n\n            if a is None and b is None:\n                return None\n\n            return ([i] + b) if a is None else a\n\n        return dp(0, skills)\n", "from functools import lru_cache\n\nclass Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        n = len(req_skills)\n        all_skills = (1 << n) - 1\n        max_team = [0] * len(people)\n\n        def construct_mask(skills):\n            mask = 0\n            for skill in skills:\n                mask |= 1 << req_skills.index(skill)\n            return mask\n\n        people = [construct_mask(skills) for skills in people]\n\n        @lru_cache(maxsize=None)\n        def min_team(idx, skills):\n            if skills == all_skills:\n                return []\n\n            if idx >= len(people):\n                return None\n\n            team = max_team\n            for i in range(idx, len(people)):\n                temp_mask = skills | people[i]\n                if temp_mask == skills:\n                    continue\n\n                other_people = min_team(i + 1, temp_mask)\n                if other_people is None:\n                    continue\n\n                if len(other_people) + 1 < len(team):\n                    team = [i] + other_people\n\n            return team\n\n        return min_team(0, 0)", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        #return what people to use \n        #dp[i][j] : min people to has skill set of j using first i people\n        #dp[0][0] = 0\n        # n skillset, total combine: 2^n -1\n        n = len(req_skills)\n        target = ( 1<<n ) - 1\n        dic = {x: index for index, x in enumerate(req_skills)} \n        skillsMap = []\n        for i in people:\n            mask = 0\n            for sk in i:\n                mask |=(1<< dic[sk])\n            skillsMap.append(mask)\n        dp = [float('inf')]  * (1<<n)\n        par = [(0,0)] *(1<<n)\n        dp[0] = 0\n        for i, k in enumerate(skillsMap):\n            if k != 0:\n                for j in range(target, -1, -1):\n                    if dp[j] + 1 < dp[j | k]:\n                        dp[j|k] = dp[j] + 1\n                        par[j|k] = (j, i)\n                        \n        res = []\n        while target:\n            res.append(par[target][1])\n            target = par[target][0]\n        return res\n", "class Solution:\n    from collections import defaultdict\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        dic={req_skills[rs]:2**rs for rs in range(len(req_skills))}\n        dp={i:[] for i in range(2**len(req_skills))}\n        m_pp=[]\n        for pp in range(len(people)):\n            # temp=dp.copy()\n            res=0\n            for itr_pp in people[pp]:\n                res+=dic[itr_pp]\n            # print(res, people[pp])\n            if res!=0:\n                dp[res]=[pp]\n                for j in list(dp.keys()):\n                    if len(dp[j])>0:\n                        sum_=j|res\n                        if len(dp[sum_])==0 or len(dp[sum_])>len(dp[j]+[pp]):\n                                dp[sum_]=dp[j]+[pp]\n                # dp=temp\n        # def recur(idx,val,res):\n        #     if len(dp[val])==0 or len(dp[val])>len(res):\n        #         dp[val]=res\n        #     if len(dp[val])<len(res):return\n        #     if idx==len(m_pp):return\n        #     for i in range(idx,len(m_pp)):\n        #         # print(res,[i])\n        #         if m_pp[i]==0:continue\n        #         recur(i+1,val|m_pp[i],res+[i])\n        # recur(0,0,[])\n        # print(dp)\n        return dp[2**len(req_skills)-1]\n", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        INT_MAX = 2147483647\n        n = len(req_skills)\n        pskills = list()\n        target = (1 << n) - 1\n        dp = [INT_MAX for i in range(target+1)]\n        parent = [list() for i in range(target+1)]\n        umap = dict()\n        \n        for i in range(n):\n            umap[req_skills[i]] = i\n        \n        for p in people:\n            mask = 0\n            for sk in p:\n                mask |= (1<<umap[sk])\n            pskills.append(mask)\n            \n        dp[0] = 0\n        pLen = len(people)\n        for i in range(pLen):\n            k = pskills[i]\n            if k == 0:\n                continue\n            for j in range(target+1):\n                if (dp[j|k] > dp[j]+1):\n                    dp[j|k] = dp[j] + 1\n                    parent[j|k] = [j, i]\n        \n        t = target\n        result = list()\n        while t > 0:\n            result.append(parent[t][1])\n            t = parent[t][0]\n        return result", "from collections import defaultdict\n\nclass Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        def backtrack(i, people_added, skills_added):\n            nonlocal result\n            if i == len(req_skills):\n                result = list(people_added)\n            elif req_skills[i] in skills_added:\n                backtrack(i+1, people_added, skills_added)\n            else:\n                if len(people_added) < len(result) - 1:\n                    for k, skills in list(skills_dict.items()):\n                        if req_skills[i] in skills:\n                            backtrack(i+1, people_added + [k], skills_added | skills)\n                            \n        result = list(range(len(req_skills)+1))\n        skills_dict = {i: set(skills) for i, skills in enumerate(people)}\n        backtrack(0, [], set())\n        return result\n", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        n, m = len(req_skills), len(people)\n        key = {v: i for i, v in enumerate(req_skills)}\n        dp = [[]] + [None] * ((1 << n) - 1)\n        for i, p in enumerate(people):\n            his_skill = 0\n            for skill in p:\n                if skill in key:\n                    his_skill |= 1 << key[skill]\n            for k in range(len(dp)-1, -1, -1):\n                with_him = k | his_skill\n                if with_him == k or dp[k] is None: continue\n                if not dp[with_him] or len(dp[k]) + 1 < len(dp[with_him]):\n                    dp[with_him] = dp[k] + [i]\n        return dp[(1 << n) - 1]", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        dic={req_skills[rs]:2**rs for rs in range(len(req_skills))}\n        dp=[[] for i in range(2**len(req_skills))]\n        m_pp=[]\n        for pp in range(len(people)):\n            res=0\n            for itr_pp in people[pp]:\n                res+=dic[itr_pp]\n            # print(res, people[pp])\n            if res!=0:\n                dp[res]=[pp]\n            m_pp.append(res)\n        # def recur(idx,val,res):\n        #     if len(dp[val])==0 or len(dp[val])>len(res):\n        #         dp[val]=res\n        #     if len(dp[val])<len(res):return\n        #     if idx==len(m_pp):return\n        #     for i in range(idx,len(m_pp)):\n        #         # print(res,[i])\n        #         if m_pp[i]==0:continue\n        #         recur(i+1,val|m_pp[i],res+[i])\n        for i in range(len(m_pp)):\n            if m_pp[i]==0:continue\n            for j in range(len(dp)):\n                if len(dp[j])>0:\n                    sum_=j|m_pp[i]\n                    if len(dp[sum_])==0 or len(dp[sum_])>len(dp[j]+[i]):\n                            dp[sum_]=dp[j]+[i]\n        # recur(0,0,[])\n        return dp[-1]\n", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        l = len(req_skills)\n        skill_to_idx = {s:i for i, s in enumerate(req_skills)}\n        \n        \n        @functools.lru_cache(None)\n        def dfs(cur_skill, idx):\n            if cur_skill == 2**l-1:\n                return ()\n            if idx == len(people):\n                return None\n            \n            cur = 0\n            for skill in people[idx]:\n                if skill in skill_to_idx and 1 << skill_to_idx[skill] & cur_skill == 0:\n                    cur |= 1 << skill_to_idx[skill]\n            ret = dfs(cur_skill, idx+1)\n            if cur != 0:\n                tmp = dfs(cur_skill | cur, idx+1)\n                if tmp != None and ret != None:\n                    ret = min(ret, tuple([idx, *tmp]), key=len)\n                elif tmp != None:\n                    ret = tuple([idx, *tmp])\n            return ret\n        ret = dfs(0, 0)\n        return ret\n", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        dic={req_skills[rs]:2**rs for rs in range(len(req_skills))}\n        dp=[[] for i in range(2**len(req_skills))]\n        m_pp=[]\n        for pp in range(len(people)):\n            res=0\n            for itr_pp in people[pp]:\n                res+=dic[itr_pp]\n            # print(res, people[pp])\n            if res!=0:\n                dp[res]=[pp]\n            m_pp.append(res)\n        # def recur(idx,val,res):\n        #     if len(dp[val])==0 or len(dp[val])>len(res):\n        #         dp[val]=res\n        #     if len(dp[val])<len(res):return\n        #     if idx==len(m_pp):return\n        #     for i in range(idx,len(m_pp)):\n        #         # print(res,[i])\n        #         if m_pp[i]==0:continue\n        #         recur(i+1,val|m_pp[i],res+[i])\n        for i in range(len(m_pp)):\n            if m_pp[i]==0:continue\n            # print('-------')\n            dp[m_pp[i]]=[i]\n            for j in range(len(dp)):\n                if len(dp[j])>0:\n                    sum_=j|m_pp[i]\n                    # # if sum_==0:continue\n                    # if j==len(dp)-1:\n                    #     print(j,m_pp[i],j^sum_)\n                    if len(dp[sum_])==0 or len(dp[sum_])>len(dp[j]+[i]):\n                            dp[sum_]=dp[j]+[i]\n                \n#                 # tgt=dp[res|i]\n#                 dp[m_pp[j]|m_pp[i]]=list(set(dp[m_pp[j]]+dp[m_pp[i]]))\n#                 # if len(tgt)==0 or len(tgt)>len(new):dp[res|i]=new\n        # recur(0,0,[])\n        # for i in range(len(dp)):\n        #     print(i,dp[i])\n        # print(dp[-1])\n        return dp[-1]\n", "#[] DP\n#O(N * 2^R) N: number of people, R: number of skills\n#f(i, S): the minimum people count to use first i people to fulfill state S\n#state S is a binary set which is a combinations of skills\n#f(N, all 1) = 0,  f(N, not all 1) = inf\n#return f(-1, 0)\n#f(i, S) = min( f(i+1, S) , 1+f(i+1, S + req_skill[i])\ndef memorized(f):\n    memo = {}\n    def helper(*arg):\n        if arg not in memo:\n            memo[arg] = f(*arg)\n        return memo[arg]\n    return helper\nclass Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        N, MASK = len(people), (1 << len(req_skills))-1\n        skill2id, child = {skill: i for i, skill in enumerate(req_skills)}, {}\n        people = [sum(1 << skill2id[skill] for skill in skills) for skills in people]\n        @memorized\n        def dp(i: int, status: int) -> int:\n            \\\"\\\"\\\"return the path to get into (i, status) node\\\"\\\"\\\"\n            if i >= N:\n                return [] if status == MASK else None\n            not_choose, choose = dp(i+1, status), dp(i+1, status | people[i])\n            if not_choose is not None and (choose is None or len(not_choose) <= len(choose) + 1):\n                return not_choose\n            else: #NOTE: handle the case that choose is None, too\n                return choose + [i] if choose is not None else None\n        return dp(-1, 0)", "from functools import lru_cache\nfrom collections import defaultdict\nimport math\nclass Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        mp = defaultdict(int)\n        for i, skill in enumerate(req_skills):\n            mp[skill] = i\n        skills = []\n        for p in people:\n            mask = 0\n            for skill in p:\n                mask |= 1 << mp[skill]\n            skills.append(mask)\n\n        @lru_cache(None)\n        def search(i: int, required: int) -> int:\n            if required == 0:\n                return 0\n            if i == len(people):\n                return math.inf\n            return min(search(i + 1, required), 1 + search(i + 1, required ^ (required & skills[i])))\n        \n        ans = []\n        required = (1 << len(req_skills)) - 1\n        for i in range(len(people)):\n            if search(i + 1, required) > 1 + search(i + 1, required ^ (required & skills[i])):\n                ans.append(i)\n                required ^= required & skills[i]\n        return ans", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        n = len(req_skills)\n        target = (1<<n)-1\n        skills = []\n        for p in people:\n            mask = 0\n            for s in p:\n                mask |= 1 << req_skills.index(s)\n            skills.append(mask)\n        dp = [float('inf')/2 for _ in range(1 << n)]\n        pt = [0 for _ in range(1 << n)]\n        dp[0] = 0\n        for i in range(len(people)):\n            k = skills[i]\n            if k == 0:\n                continue\n            for j in range(target+1)[::-1]:\n                if dp[j] + 1 < dp[j|k]:\n                    dp[j|k] = dp[j]+1\n                    pt[j|k] = (j, i) # (parent, current)\n        t = target\n        ans = []\n        while t:\n            ans.append(pt[t][1])\n            t = pt[t][0]\n        return ans\n                \n", "class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        s2i = {}\n        for i, skill in enumerate(req_skills):\n            s2i[skill] = i\n        \n        n = len(people)\n        p2n = [0] * n\n        for i, p in enumerate(people):\n            temp = 0\n            for skill in p:\n                temp |= 1 << s2i[skill]\n            p2n[i] = temp\n        \n        goal = (1 << len(req_skills)) - 1\n        dp = [sys.maxsize] * (goal + 1)\n        dp[0] = 0\n        saves = [[] for i in range(goal + 1)]\n\n        for i in range(n):\n            skill = p2n[i]\n            for skillset in range(goal + 1):\n                new_skill = skillset | skill\n                if dp[new_skill] > dp[skillset] + 1:\n                    dp[new_skill] = dp[skillset] + 1\n                    saves[new_skill] = list(saves[skillset])\n                    saves[new_skill].append(i)\n                    \n        return saves[goal]\n", "from collections import defaultdict\nfrom functools import lru_cache\n\nclass Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        req_skills = set(req_skills)\n        d = {}\n        for i, x in enumerate(req_skills):\n            d[x] = i\n        \n        @lru_cache(None)\n        def dfs(state, idx):\n            if state == 2 ** len(req_skills) - 1:\n                return []\n            if idx == len(people):\n                return [0] * 100\n            out = dfs(state, idx + 1)\n            new_state = state\n            for skill in people[idx]:\n                new_state |= 1 << d[skill]\n            new = dfs(new_state, idx + 1)\n            if len(out) < len(new) + 1:\n                return out\n            return [idx] + new\n        \n        return dfs(0, 0)\n"]