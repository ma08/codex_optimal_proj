["from collections import defaultdict\ndef shortestPath(gra, srs, des):\n    Q, paths, d = [[0, srs]], [], defaultdict(list)\n    while Q: \n        vrt = Q.pop(0)\n        if vrt[-1] == des: \n            paths.append(vrt)\n            continue\n        for v, c in gra[vrt[-1]].items():\n            if v not in vrt:\n                Q.append([vrt[0]+c] + vrt[1:] + [v])\n\n    for i in paths: d[i[0]].append(i[1:])   \n        \n    ml, f = len(min(d[min(d)], key = len)), []\n\n    for i in d[min(d)]:\n        if len(i) == ml:\n            f.append(i)\n    return [sorted(i) for i in f] if len(f) > 2 else f", "def shortestPath(topology, startPoint, endPoint):\n    stack, shortest, paths = [(1, [startPoint])], float(\"inf\"), []\n    while stack:\n        acc, path = stack.pop()\n        point = path[-1]\n        if point == endPoint:\n            if acc <= shortest:\n                paths.append((acc, path))\n                shortest = acc\n            continue\n        points = topology.get(point)\n        for p in points: \n            if p not in path:\n                stack.append((acc + points[p] + 1, path + [p]))\n    return sorted([path for val, path in paths if val == shortest])", "from heapq import heappush as push, heappop as pop\n\ndef shortestPath(topology, startPoint, endPoint):\n    current, res = [], (float('inf'), None, [])\n    push(current, (0, 1, [startPoint]))\n    while current:\n        time, size, path = pop(current)\n        if time > res[0] or time == res[0] and size > res[1]:\n            return res[2]\n        if path[-1] == endPoint:\n            if time < res[0] or size < res[1]:\n                res = (time, size, [path])\n            else:\n                res[2].append(path)\n        else:\n            for k,v in topology[path[-1]].items():\n                if k not in path:\n                    push(current, (time+v, size+1, path+[k]))\n    return \"No path\"", "from collections import defaultdict, deque    #using dijkstra\ndef shortestPath(topology, start, end):\n    vertices = defaultdict(list)\n    edges, distance_, parent_ = {}, {}, {}\n    \n    for i, j in topology.items():\n        distance_[i] = float('inf')\n        parent_[i] = None\n        for k, l in j.items():\n            vertices[i].append(k)\n            edges[(i, k)] = l\n    \n    distance_[start] = 0\n    Q = deque([[(start, 0), distance_, parent_]])\n    pairs, PATHS = set(), set()\n    while Q:\n        (node, cost), distance, parent = Q.popleft()\n        while distance:\n            if node == end : break\n            for neighbour in vertices[node]:\n                if neighbour in distance:\n                    dis = cost + edges[(node, neighbour)]\n                    if dis < distance[neighbour]:\n                        distance[neighbour] = dis\n                        parent[neighbour] = node\n    \n            del distance[node]\n            node, cost = min(distance.items(), key=lambda x: x[1])\n            for i, j in distance.items():\n                if (i, node) not in pairs and j == cost and i != node:\n                    pairs.add((i, node))\n                    Q.append([(i, j), distance.copy(), parent.copy()])\n        \n        path, node = [], end\n        while node != start:\n            path.insert(0, node)\n            node = parent[node]\n    \n        PATHS.add((start,) + tuple(path))\n    \n    return sorted(list(map(list,PATHS)))", "import queue\ndef shortestPath(topology, startPoint, endPoint):\n    q = queue.Queue()\n    q.put([startPoint, [startPoint],0])\n    routes = []\n\n    while not q.empty():\n        current_node, path, cost = q.get()\n        if current_node == endPoint:\n            routes.append((path, cost))\n        for point, distance in list(topology[current_node].items()):\n            new_path = path.copy()\n            if point not in path:\n                new_path += [point]\n                q.put([point,new_path,cost+topology[current_node][point]])\n    lowest_cost = min(routes, key=lambda x : x[1])\n    other_lowest_cost = [x[0] for x in routes if x[1] == lowest_cost[1] and len(x[0]) == len(lowest_cost[0])]\n    return other_lowest_cost\n", "def shortestPath(topology, startPoint, endPoint):\n    print(topology)\n    print(startPoint)\n    print(endPoint)\n\n    visitedNodes = {}; #node name, node path\n    boarderNodes = {startPoint:{'path': [[startPoint]], 'cost':0}}; #node name, node path, node cost\n    \n    #do greedy first search\n    #loop while boarder not empty\n    while(len(boarderNodes)>0):\n        #expand unknown node with lowest cost\n        cost = None\n        node = ''\n        for boarderNodeName, boarderNodeDict in list(boarderNodes.items()):\n            if(cost == None):\n                node = boarderNodeName\n                cost = boarderNodeDict['cost']\n            elif(boarderNodeDict['cost']<cost):\n                node = boarderNodeName\n                cost = boarderNodeDict['cost']\n                \n        path = boarderNodes[node]['path']\n        visitedNodes[node] = path\n        del boarderNodes[node]\n        \n        # add to boarder at right spot/ update cost values if necessary\n        for neighborNode, neighborCost in list(topology[node].items()):\n            if (not neighborNode in visitedNodes)and(not neighborNode in boarderNodes):\n                boarderNodes[neighborNode] = {'path': [[]] ,'cost': cost+neighborCost}\n                addPath(boarderNodes,neighborNode,path)\n            elif (not neighborNode in visitedNodes)and(neighborNode in boarderNodes):\n                if(boarderNodes[neighborNode]['cost'] > cost+neighborCost):\n                    boarderNodes[neighborNode]['cost'] = cost+neighborCost\n                    boarderNodes[neighborNode]['path'] = [[]]\n                    addPath(boarderNodes,neighborNode,path)\n                elif(boarderNodes[neighborNode]['cost'] == cost+neighborCost):\n                    mergePath(boarderNodes,neighborNode,path,topology)\n        \n        # goal check -> is goal in visited Nodes\n        if endPoint in visitedNodes:\n            return visitedNodes[endPoint];\n        \n        #EndLoop\n\n    return 0\n        \ndef addPath(boarderNodes,neighborNode,path):\n    boarderNodes[neighborNode]['path'] = []\n    for i in path:\n        line = []\n        for j in i:\n            line.append(j)\n        line.append(neighborNode)\n        boarderNodes[neighborNode]['path'].append(line)\n        \ndef mergePath(boarderNodes,neighborNode,path,topology):\n    smallest = len(topology);\n    for i in path:\n        if(len(i)+1 < smallest):\n            smallest = len(i)+1\n    for i in boarderNodes[neighborNode]['path']:\n        if(len(i) < smallest):\n            smallest = len(i)\n\n    for i in path:\n        line = []\n        for j in i:\n            line.append(j)\n        line.append(neighborNode)\n        boarderNodes[neighborNode]['path'].append(line)\n        \n    for i in boarderNodes[neighborNode]['path']:\n        if(len(i) > smallest):\n            boarderNodes[neighborNode]['path'].remove(i)\n    \n    \n    \n    \n    \n    \n", "\ndef shortestPath(topology, startPoint, endPoint):\n    '''\n    Problem description: https://www.codewars.com/kata/5709aa85fe2d012f1d00169c/train/python\n    Made intentionally with 2 classes: PathFinder and TimeFinder\n    For simulating real-life project structure, covering unittests, multiprocessing etc.\n    '''\n\n    class PathFinder:\n        def __init__(self, topology, start_point, end_point):\n            self.start_point = start_point\n            self.end_point = end_point\n            self.tplg = topology\n\n            self.next_step = None\n            self.considered_path = None\n            self.backtrack = [{self.start_point: [*self.tplg[self.start_point].keys()]}]\n            self.history = self.start_point\n            self.finished_paths = []\n\n        def solve(self):\n\n            def try_forward():\n                get_next_step()\n                self.considered_path = self.history + self.next_step\n\n                if self.next_step == self.end_point:\n                    self.finished_paths.append(self.considered_path)\n                    try_backward()\n                elif self.next_step not in self.history:\n                    clean_backtrack()\n                    add_new_crossroad_to_backtrack()\n                    self.history = self.considered_path\n                    try_forward()\n                else:\n                    try_backward()\n\n            def try_backward():\n                clean_backtrack()\n                try_forward()\n\n            def clean_backtrack():\n                del list(self.backtrack[-1].values())[0][-1]\n                directions_left_to_consider_at_last_path = list(self.backtrack[-1].values())[0]\n                last_path = [*self.backtrack[-1].keys()][0]\n                if not directions_left_to_consider_at_last_path and len(last_path) > 1:\n                    del self.backtrack[-1]\n                    last_path = [*self.backtrack[-1].keys()][0]\n                    self.history = last_path\n\n            def add_new_crossroad_to_backtrack():\n                self.backtrack.append({self.considered_path: [*self.tplg[self.next_step].keys()]})\n\n            def get_next_step():\n                self.next_step = list(self.backtrack[-1].values())[0][-1]\n\n            def execute():\n                try:\n                    try_forward()\n                except IndexError:\n                    pass\n\n            execute()\n            return self.finished_paths\n\n\n    def compute_path_time(path):\n        '''Computes time for given path after its validated in PathFinder'''\n        def get_time(previous_step, next_step):\n            return topology[previous_step][next_step]\n        def get_next_pair_of_steps(path, iter_no):\n            return path[iter_no], path[iter_no+1]\n\n        time = 0\n        for iter_no in range(len(path)-1):\n            time += get_time(*get_next_pair_of_steps(path, iter_no))\n        return time\n\n    finished_paths = PathFinder(topology, startPoint, endPoint).solve()\n    path_time_dict = {path: compute_path_time(path) for path in finished_paths}\n\n    def adjust_for_codewars_requirements(path_time_dict):\n        '''\n        1. Return list of lists containing waypoints\n        2. If 2 paths are equally time consuming, then pick the one with fewer waypoints\n        3. If there are still multiple solutions complying with 2nd requirement, sort them in alphabetical order\n        '''\n        shortest_time = min(path_time_dict.values())\n        paths_with_shortest_time = [path for path in path_time_dict.keys() if path_time_dict[path]==shortest_time]\n        minimum_waypoint_number = min([len(path) for path in paths_with_shortest_time])\n        paths_with_minimum_waypoint_number = list(filter(lambda x: len(x) == minimum_waypoint_number, paths_with_shortest_time))\n        adjusted = [[waypoint for waypoint in path] for path in sorted(paths_with_minimum_waypoint_number)]\n        return adjusted\n\n    return adjust_for_codewars_requirements(path_time_dict)", "def shortestPath(topology, startPoint, endPoint):\n    graph = {}\n    for key, value in topology.items():\n        values=[]\n        for k, v in value.items():\n            values.append(k)\n        graph[key]=values\n            \n    paths=find_all_paths(graph, startPoint, endPoint)\n    if len(paths)==0:\n        return []\n    pathsAndDistances=[]\n    for path in paths:\n        distance=0\n        for i,waypoint in enumerate(path):\n            if i < len(path)-1:\n                distance += topology[waypoint][path[i+1]]\n        pathsAndDistances.append((distance,path))\n    pathsAndDistances=[t for t in pathsAndDistances if t[0]==min(pathsAndDistances)[0]]\n    length=1000\n    for p in pathsAndDistances:\n        if len(p[1])<length:\n            length=len(p[1])\n    answer=[]\n    for p in pathsAndDistances:\n        if len(p[1])==length:\n            answer.append(p[1])\n    return answer\n    \ndef find_all_paths(graph, start, end, path=[]):\n        path = path + [start]\n        if start == end:\n            return [path]\n        if start not in graph:\n            return []\n        paths = []\n        for node in graph[start]:\n            if node not in path:\n                newpaths = find_all_paths(graph, node, end, path)\n                for newpath in newpaths:\n                    paths.append(newpath)\n        return paths", "def find_all_paths(topology,start,end,path = []):\n    if start not in topology: return None\n    path = path + [start]\n    if start == end: return [path]\n\n    paths = []\n    for node in topology[start]:\n        if node not in path:\n            e_path = find_all_paths(topology,node,end,path)\n            for p in e_path: paths.append(p)\n    return paths\n\ndef distance(topology):\n    dist = {}\n    for element in topology:\n        for node in topology[element]:\n            dist[(element,node)] = topology[element][node]\n    return dist\n\ndef calculate_path_distance(path,distances):\n    path_dic = {}\n    for p in path:\n        d = 0\n        for i in range(0,len(p)-1):\n            d = d + distances[tuple(p[i:i+2])]\n        path_dic[tuple(p)] = d\n    return path_dic\n\ndef calculate_short_distance(paths_with_distance):\n    shortest = []\n    multiple_opt = {}\n    shortest_opt = []\n    values = sorted(paths_with_distance.values())\n    for item in list(paths_with_distance.items()):\n        if item[1] == values[0]: shortest.append(list(item[0]))\n    if len(shortest) > 1:\n        for i in shortest:\n            multiple_opt[tuple(i)] = len(i)\n        options = sorted(multiple_opt.values())\n        for e in list(multiple_opt.items()):\n            if e[1] == options[0]: shortest_opt.append(list(e[0]))\n        shortest_opt.sort()\n        return shortest_opt\n    return shortest\n\ndef shortestPath(topology, start, end):\n    path = find_all_paths(topology,start,end)\n    distances = distance(topology)\n    path_d = calculate_path_distance(path,distances)\n    return calculate_short_distance(path_d)"]