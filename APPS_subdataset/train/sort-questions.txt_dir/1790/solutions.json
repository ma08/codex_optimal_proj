["from collections import deque\nclass Graph():\n\n    def __init__(self, vertices_num):\n        self.v = vertices_num\n\n    def adjmat_2_graph(self, adjm):\n        d = {f'A{i}': [] for i in range(self.v)}\n        for i, j in enumerate(adjm):\n            for k, l in enumerate(j):\n                if l : d[f'A{i}'].append((f'A{k}', l))\n        return d\n\n    def graph_2_mat(self, graph):\n        mat = [[0 for _ in range(self.v)] for _ in range(self.v)]\n        for i, j in graph.items():\n            for k, l in j:\n                mat[int(i[1])][int(k[1])] = l\n        return mat\n\n    def graph_2_list(self, graph):\n        return [[i, j] for i, j in sorted(graph.items())]\n\n    def list_2_graph(self, lst):\n        return {i: x for i, x in lst}\n\n    def mat_2_list(self, mat):\n        return self.graph_2_list(self.adjmat_2_graph(mat))\n\n    def list_2_mat(self, lst):\n        return self.graph_2_mat(self.list_2_graph(lst))\n\n    def find_all_paths(self, graph, start, end):\n        graph = {i: [k[0] for k in j] for i, j in graph.items()}\n        Q, paths = deque([[start, []]]), []\n        while Q:\n            node, path = Q.popleft()\n            path.append(node)\n\n            if node == end:\n                paths.append('-'.join(path))\n\n            for n in graph[node]:\n                if n not in path:\n                    Q.append([n, path[:]])\n        return sorted(paths, key=len)", "class Graph():\n\n    def __init__(self, vertices_num):\n        self.v = vertices_num\n        self.nodes = [f\"A{i}\" for i in range(self.v)]\n        self.ids = {x:i for i,x in enumerate(self.nodes)}\n\n    # from adjacency matrix to dictionary\n    def adjmat_2_graph(self, adjm):\n        return {self.nodes[i]:[(self.nodes[j], x) for j,x in enumerate(row) if x] for i,row in enumerate(adjm)}\n        \n    # from dictionary to adjacency matrix\n    def graph_2_mat(self, graph):\n        result = [[0]*self.v for _ in range(self.v)]\n        for i,L in graph.items():\n            for j,x in L:\n                result[self.ids[i]][self.ids[j]] = x\n        return result\n    \n    # from dictionary to adjacency list    \n    def graph_2_list(self, graph):\n        return list(map(list, sorted(graph.items())))\n        \n    # from adjacency list to dictionary\n    def list_2_graph(self, lst):\n        return dict(lst)\n        \n    # from adjacency matrix to adjacency list    \n    def mat_2_list(self, mat):\n        return self.graph_2_list(self.adjmat_2_graph(mat))\n    \n    # from adjacency list to adjacency matrix\n    def list_2_mat(self, lst):\n        return self.graph_2_mat(self.list_2_graph(lst))\n    \n    @staticmethod\n    def gen(graph, start, end, seen):\n        if start == end:\n            yield [end]\n        else:\n            for k,v in graph[start]:\n                if k not in seen:\n                    for L in Graph.gen(graph, k, end, seen|{k}):\n                        yield [start] + L\n        \n    # find all path from node start_vertex to node end_vertex\n    def find_all_paths(self, graph, start_vertex, end_vertex):\n        return sorted(map('-'.join, Graph.gen(graph, start_vertex, end_vertex, {start_vertex})), key=lambda x: (len(x), x))", "class Graph():\n\n    def __init__(self, vertices_num):\n        # number of nodes (integer)\n        self.v = vertices_num\n        \n    def sort_adj_list(self, lst):\n        res=[]\n        for l in lst:\n            res.append([l[0], sorted(l[1])])\n        return sorted(res)\n\n    def adjmat_2_graph(self, adjm):\n        if len(adjm) != self.v: return \"Dimension error\"\n        # list of nodes from \"A0\", \"A1\" ... to \"A index (vertices_num - 1)\"\n        nodes = ['A' + str(i) for i in range(0, self.v)]\n        graph = {}\n        for n, v in enumerate(nodes):\n            voisin = []\n            for i, dist in enumerate(adjm[n]):\n                if dist != 0:\n                    voisin.append((nodes[i], dist))\n            graph[v] = voisin\n        self.graph = graph\n        return graph\n        \n    def graph_2_mat(self, graph):\n        nodes = sorted(graph.keys())\n        adjm = []\n        for node in nodes:\n            L = [0] * len(nodes)\n            parcours = graph[node]\n            for voisin, dist in parcours:\n                L[nodes.index(voisin)] = dist\n            adjm.append(L)\n        return adjm\n        \n    def graph_2_list(self, graph):\n        r = [[k, graph[k]] for k in sorted(graph.keys())]\n        return self.sort_adj_list(r)    \n    \n    def list_2_graph(self, lst):\n        if len(lst) != self.v: return \"Dimension error\"\n        dct = {}\n        for l in lst:\n            dct[l[0]]= l[1]\n        return dct\n        \n    def mat_2_list(self, mat):\n        if len(mat) != self.v: return \"Dimension error\"\n        return self.graph_2_list(self.adjmat_2_graph(mat))\n    \n    def list_2_mat(self, lst):\n        if len(lst) != self.v: return \"Dimension error\"\n        return self.graph_2_mat(self.list_2_graph(lst))\n        \n    def find_all_paths_aux(self, start, end, path=[]):\n        graph = self.graph\n        path = path + [start]\n        if start == end:\n            return [path]\n        if start not in graph:\n            return []\n        paths = []\n        for vertex in list([x[0] for x in graph[start]]):\n            if vertex not in path:\n                extended_paths = self.find_all_paths_aux(vertex, end, path)\n                for p in extended_paths: \n                    paths.append(p)\n        return paths\n    def find_all_paths(self, graph, start, end):\n        self.graph = graph\n        paths = self.find_all_paths_aux(start, end)\n        paths = list([\"-\".join(x) for x in paths])\n        return sorted(sorted(paths, key=str), key=len)\n", "class Graph():\n\n    def __init__(self, vertices_num):\n        # number of nodes (an integer)\n        self.v = vertices_num\n        # (maybe not useful here) : list of nodes from \"A0\", \"A1\" ... to \"A index (vertices_num - 1)\"\n        self.nodes = None\n\n    # from adjacency matrix to dictionary\n    def adjmat_2_graph(self, matrix):\n        dictionary = {}\n        step = 0\n        for row in matrix:\n            dictionary[f\"A{step}\"] = []\n            column = 0\n            for value in row:\n                if value:\n                    dictionary[f\"A{step}\"].append((f\"A{column}\", value))\n                column += 1\n            step += 1\n        return dictionary\n        \n    # from dictionary to adjacency matrix\n    def graph_2_mat(self, dictionary):\n        matrix = []\n        step = 0\n        while step < len(dictionary):\n            row = [0] * len(dictionary)\n            for edge in dictionary[f\"A{step}\"]:\n                row[int(edge[0][1])] = edge[1]\n            matrix.append(row)\n            step += 1\n        return matrix\n    \n    # from dictionary to adjacency list    \n    def graph_2_list(self, dictionary):\n        list = []\n        step = 0\n        while step < len(dictionary):\n            vertex = [f\"A{step}\", dictionary[f\"A{step}\"]]\n            list.append(vertex)\n            step += 1\n        return list\n        \n    # from adjacency list to dictionary\n    def list_2_graph(self, list):\n        dictionary = {}\n        for vertex in list:\n            dictionary[vertex[0]] = vertex[1]\n        return dictionary\n        \n    # from adjacency matrix to adjacency list    \n    def mat_2_list(self, matrix):\n        list = []\n        step = 0\n        for row in matrix:\n            vertex = [f\"A{step}\", []]\n            column = 0\n            for value in row:\n                if value:\n                    vertex[1].append((f\"A{column}\", value))\n                column += 1\n            list.append(vertex)\n            step += 1\n        return list\n    \n    # from adjacency list to adjacency matrix\n    def list_2_mat(self, list):\n        matrix = []\n        step = 0\n        while step < len(list):\n            for vertex in list:\n                if vertex[0] == f\"A{step}\":\n                    row = [0] * len(list)\n                    for edge in vertex[1]:\n                        row[int(edge[0][1])] = edge[1]\n                    matrix.append(row)\n                    step += 1\n        return matrix\n        \n    # find all path from node start_vertex to node end_vertex\n    def find_all_paths(self, dictionary, start, end):\n        def dfs(dictionary, start, end, path = []):\n            path = path + [start]\n            if start == end:\n                return [path]\n            if start not in dictionary:\n                return []\n            paths = []\n            for edge in dictionary[start]:\n                if edge[0] not in path:\n                    newpaths = dfs(dictionary, edge[0], end, path)\n                    for newpath in newpaths:\n                        paths.append(newpath)\n            return paths\n        paths = dfs(dictionary, start, end)\n        return sorted(sorted([\"-\".join(path) for path in paths], key = str), key = len)\n        \n", "class Graph():\n    \n    def __init__(self, vertices_num):\n        # number of nodes (an integer)\n        self.v = vertices_num\n        # (maybe not useful here) : list of nodes from \"A0\", \"A1\" ... to \"A index (vertices_num - 1)\"\n        self.nodes = None\n    \n    # from adjacency matrix to dictionary\n    def adjmat_2_graph(self, adjm):\n        d = {}\n        for indice, ligne in enumerate(adjm):\n            print((indice, ligne))\n            cle = 'A'+str(indice)\n            laliste = []\n            for indiceVoisin, nombre in enumerate(ligne):\n                if nombre:\n                    t = ('A'+str(indiceVoisin), nombre)\n                    laliste.append(t)\n            d[cle] = laliste\n        return d\n    \n    # from dictionary to adjacency matrix\n    def graph_2_mat(self, graph):\n        m = [[0 for k in range(self.v)] for i in range(self.v)]\n        for noeud in graph:\n            indice = int(noeud[1:])\n            for voisin in graph[noeud]:\n                indiceVoisin = int(voisin[0][1:])\n                distance = voisin[1]\n                m[indice][indiceVoisin] = distance\n        return m\n    \n    # from dictionary to adjacency list    \n    def graph_2_list(self, graph):\n        m = []\n        for noeud in graph:\n            laliste = [noeud, graph[noeud]]\n            m.append(laliste)\n        m.sort()\n        return m\n    \n    # from adjacency list to dictionary\n    def list_2_graph(self, lst):\n        d = {}\n        for elt in lst:\n            cle = elt[0]\n            laliste = elt[1]\n            d[cle] = laliste\n        return d\n            \n            \n    # from adjacency matrix to adjacency list    \n    def mat_2_list(self, mat):\n        d = self.adjmat_2_graph(mat)\n        adj = self.graph_2_list(d)\n        return adj\n    \n    # from adjacency list to adjacency matrix\n    def list_2_mat(self, lst):\n        d = self.list_2_graph(lst)\n        a = self.graph_2_mat(d)\n        return a\n        \n    \n    \n    # find all path from node start_vertex to node end_vertex\n    def find_all_paths(self, graph, start_vertex, end_vertex):\n        if start_vertex == end_vertex : return [end_vertex]\n        start_vertex = int(start_vertex[1:])\n        end_vertex = int(end_vertex[1:])\n        lesChemins = []\n        m = self.graph_2_mat(graph)\n        noeuds = list(range(self.v))\n        \n        pile = [  [start_vertex]]\n        while pile:\n            chemin = pile.pop()\n            dernier = chemin[-1]\n            lesVoisins = [k for k in noeuds if m[dernier][k]>0 and k not in chemin]\n            for voisin in lesVoisins:\n                if voisin == end_vertex:\n                    bonChemin = chemin.copy()\n                    bonChemin.append(voisin)\n                    bonChemin = ['A'+str(k) for k in bonChemin]\n                    lesChemins.append( '-'.join(bonChemin)  )\n                else :\n                    leChemin = chemin.copy()\n                    leChemin.append(voisin)\n                    pile.append(leChemin)\n                    \n        lesChemins.sort()\n        lesChemins.sort(key = len)\n        return lesChemins\n\n", "class Graph():\n\n    def __init__(self, vertices_num):\n        # number of nodes (an integer)\n        self.v = vertices_num\n        # (maybe not useful here) : list of nodes from \"A0\", \"A1\" ... to \"A index (vertices_num - 1)\"\n        self.nodes = None\n\n    # from adjacency matrix to dictionary\n    def adjmat_2_graph(self, adjm): \n        gra = {}\n        for vern, i in enumerate(adjm): \n            tem = []\n            for ind, v in enumerate(i): \n                if v != 0: \n                    tem.append(('A{}'.format(ind), v))\n                    gra['A{}'.format(vern)] = tem\n        return gra    \n        \n    # from dictionary to adjacency matrix\n    def graph_2_mat(self, graph): \n        mat = [[0 for _ in range(len(graph))] for _ in range(len(graph))] \n        for k, v in graph.items():\n            for i in v: \n                mat[int(k[1])][int(i[0][1])] = i[1]\n\n        return mat\n    # from dictionary to adjacency list    \n    def graph_2_list(self, graph): \n        return sorted([[k, v] for k, v in graph.items()], key = lambda x: x[0])\n        \n    # from adjacency list to dictionary\n    def list_2_graph(self, lst): \n        return {i[0]:i[1] for i in lst}\n        \n    # from adjacency matrix to adjacency list    \n    def mat_2_list(self,mat):\n        lst = []\n        for ind, v in enumerate(mat): \n            tem = []\n            for ind1, i in enumerate(v): \n                if i != 0: \n                    tem.append(('A{}'.format(ind1), i))\n            lst.append(['A{}'.format(ind), tem])\n        return sorted(lst, key = lambda x: x[0])\n    \n    # from adjacency list to adjacency matrix\n    def list_2_mat(self, lst):\n        mat = [[0 for _ in range(len(lst))] for _ in range(len(lst))] \n        for i in lst: \n            for j in i[1]:\n                mat[int(i[0][1])][int(j[0][1])] = j[1]\n        return mat\n        \n    # find all path from node start_vertex to node end_vertex\n    def find_all_paths(self, graph, start_vertex, end_vertex):\n        all_paths = []\n        sta = [[start_vertex]]\n        while sta: \n            a = sta.pop()\n            if a[-1] == end_vertex:\n                all_paths.append(a)\n                continue\n            for i in graph[a[-1]]:\n                if i[0] not in a: \n                    sta.append(a + [i[0]])\n        return ['-'.join([i for i in p]) for p in sorted(sorted(all_paths), key = len)]", "class Graph():\n\n    def __init__(self, vertices_num):\n        # number of nodes (an integer)\n        self.v = vertices_num\n        # (maybe not useful here) : list of nodes from \"A0\", \"A1\" ... to \"A index (vertices_num - 1)\"\n        self.nodes = None\n\n    # from adjacency matrix to dictionary\n    def adjmat_2_graph(self, adjm):\n        g = {f'A{x}': [] for x in range(self.v)}\n        for i in range(self.v):\n            for j in range(self.v):\n                if adjm[i][j] != 0:\n                    g[f'A{i}'].append((f'A{j}', adjm[i][j]))\n        return g\n    \n    # from dictionary to adjacency matrix\n    def graph_2_mat(self, graph):\n        m = [[0 for j in range(self.v)] for i in range(self.v)]\n        for x in range(self.v):\n            for g in graph[f'A{x}']:\n                m[x][int(g[0][1:])] = g[1]\n        return m\n\n    # from dictionary to adjacency list    \n    def graph_2_list(self, graph):\n        return sorted([[key, val]for key, val in list(graph.items())])\n\n    # from adjacency list to dictionary\n    def list_2_graph(self, lst):\n        return {el[0]: el[1] for el in lst}\n\n    # from adjacency matrix to adjacency list    \n    def mat_2_list(self, mat):\n        return self.graph_2_list(self.adjmat_2_graph(mat))    \n    \n    # from adjacency list to adjacency matrix\n    def list_2_mat(self, lst):\n        return self.graph_2_mat(self.list_2_graph(lst))    \n\n    # find all path from node start_vertex to node end_vertex\n    def find_all_paths(self, graph, start_vertex, end_vertex):\n        paths = [[start_vertex]]\n        new_paths = []\n        res = []\n        if start_vertex == end_vertex: return [start_vertex]\n        while paths:\n            for p in paths:\n                for t in graph[p[-1]]:\n                    if t[0] == end_vertex:\n                        res.append(\"-\".join(p + [t[0]]))\n                        continue\n                    if t[0] in p:\n                        continue\n                    else:\n                        new_paths.append(p + [t[0]])\n            paths.clear()\n            paths, new_paths = new_paths, paths\n        return res\n", "class Graph():\n    def __init__(self, vertices_num):\n        pass\n\n    # from adjacency matrix to dictionary\n    @staticmethod\n    def adjmat_2_graph(adjm):\n        nodes_dct = {}\n        for row, weights in enumerate(adjm):\n            edges = [('A'+str(col), w) for col, w in enumerate(weights) if w > 0]\n            nodes_dct['A'+str(row)] = edges\n\n        return nodes_dct\n\n    @staticmethod\n    def graph_2_mat(graph):\n        g_size = len(list(graph.keys()))\n        matrix = [[0 for _ in range(g_size)] for _ in range(g_size)]\n\n        for vname, edges in list(graph.items()):\n            v = int(vname[1:])\n            for e in edges:\n                u = int(e[0][1:])\n                matrix[u][v] = e[1]\n\n        return matrix\n\n    @staticmethod\n    def graph_2_list(graph):\n        return [[k, v] for k, v in sorted(graph.items())]\n\n    # from adjacency list to dictionary\n    @staticmethod\n    def list_2_graph(lst):\n        return dict((vertex[0], vertex[1]) for vertex in lst)\n\n    @staticmethod\n    def mat_2_list(mat):\n        return Graph.graph_2_list(Graph.adjmat_2_graph(mat))\n\n    @staticmethod\n    def list_2_mat(lst):\n        return Graph.graph_2_mat(Graph.list_2_graph(lst))\n\n    @staticmethod\n    def find_all_paths(graph, start_vertex, end_vertex):\n        if start_vertex == end_vertex:\n            return [start_vertex]\n\n        paths = []\n        def find(path):\n            for e in graph[path[-1]]:\n                v = e[0]\n                if v not in path:\n                    new_path = path[:] + [v]\n                    if v == end_vertex:\n                        paths.append(new_path)\n                    else:\n                        find(new_path)\n\n        find([start_vertex])\n\n        l = list(['-'.join(p) for p in paths])\n        return sorted(sorted(l, key=str), key=len)\n", "class Graph():\n\n    def __init__(self, vertices_num):\n        self.v = vertices_num\n\n    # from adjacency matrix to dictionary\n    def adjmat_2_graph(self, adjm):\n        if len(adjm) != self.v: return \"Dimension error\"\n        nodes = ['A' + str(i) for i in range(0, self.v)]\n        graph = {}\n        for n, v in enumerate(nodes):\n            voisin = []\n            for i, dist in enumerate(adjm[n]):\n                if dist != 0:\n                    voisin.append((nodes[i], dist))\n            graph[v] = voisin\n        self.graph = graph\n        return graph\n\n    # from dictionary to adjacency matrix\n    def graph_2_mat(self, graph):\n        result = [[0] * self.v for _ in range(self.v)]\n        for k, links in graph.items():\n            for n, d in links:\n                result[int(k[1:])][int(n[1:])] = d\n        return result\n\n    # from dictionary to adjacency list\n    def graph_2_list(self, graph):\n        return list(map(list, sorted(graph.items())))\n\n    # from adjacency list to dictionary\n    def list_2_graph(self, lst):\n        return {k: a for k, a in lst}\n\n    # from adjacency matrix to adjacency list\n    def mat_2_list(self, mat):\n        return self.graph_2_list(self.adjmat_2_graph(mat))\n\n    # from adjacency list to adjacency matrix\n    def list_2_mat(self, lst):\n        return self.graph_2_mat(self.list_2_graph(lst))\n\n    # find all path from node start_vertex to node end_vertex\n    def find_all_paths(self, graph, start_vertex, end_vertex):\n        pths = []; st = [[start_vertex]]\n        while st:\n            top = st.pop()\n            if top[-1] == end_vertex:\n                pths.append('-'.join(top))\n                continue\n            for n, _ in graph[top[-1]]:\n                if n not in top:\n                    st.append(top + [n])\n        return sorted(sorted(pths), key=len)", "class Graph():\n\n    def __init__(self, vertices_num):\n        self.v = vertices_num\n        self.nodes = [f'A{n}' for n in range(vertices_num)]\n\n    # adjacency matrix to dictionary\n    def adjmat_2_graph(self, adjm):\n        return {\n            self.nodes[src_index]: [\n                (self.nodes[dst_index], weight)\n                for dst_index, weight in enumerate(weights)\n                if weight > 0\n            ]\n            for src_index, weights in enumerate(adjm)\n            if any(weight > 0 for weight in weights)\n        }\n        \n    # dictionary to adjacency matrix\n    def graph_2_mat(self, graph):\n        result = [[0 for _ in range(self.v)] for _ in range(self.v)]\n        for src, edges in graph.items():\n            src_index = self.nodes.index(src)\n            for dst, weight in edges:\n                dst_index = self.nodes.index(dst)\n                result[src_index][dst_index] = weight\n        return result\n    \n    # dictionary to adjacency list    \n    def graph_2_list(self, graph):\n        return sorted([\n            [src, edges]\n            for src, edges in graph.items()\n        ], key=lambda x: x[0])\n        \n    # adjacency list to dictionary\n    def list_2_graph(self, lst):\n        return {\n            src: edges\n            for src, edges in lst\n        }\n        \n    # adjacency matrix to adjacency list    \n    def mat_2_list(self, mat):\n        return self.graph_2_list(self.adjmat_2_graph(mat))\n    \n    # adjacency list to adjacency matrix\n    def list_2_mat(self, lst):\n        return self.graph_2_mat(self.list_2_graph(lst))\n        \n    # all paths from node start_vertex to node end_vertex\n    def find_all_paths(self, graph, start_vertex, end_vertex, seen=None):\n        if start_vertex == end_vertex and seen is None: # Non-recursive case only\n            return [start_vertex]\n\n        if seen is None:\n            seen = set()\n        seen = seen | {start_vertex}\n        next_options = [dst for dst, weight in graph.get(start_vertex, []) if dst not in seen]\n        paths = [\n            start_vertex + '-' + path\n            for option in next_options\n            for path in self.find_all_paths(graph, option, end_vertex, seen)\n        ]\n        if end_vertex in next_options:\n            paths.append(start_vertex + '-' + end_vertex)\n\n        return sorted(sorted(paths, key=str), key=len)"]