["class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        return sorted(range(lo, hi + 1), key='\u5bd2\u5bd2\u5bd3\u5bd9\u5bd4\u5bd7\u5bda\u5be2\u5bd5\u5be5\u5bd8\u5be0\u5bdb\u5bdb\u5be3\u5be3\u5bd6\u5bde\u5be6\u5be6\u5bd9\u5bd9\u5be1\u5be1\u5bdc\u5be9\u5bdc\u5c41\u5be4\u5be4\u5be4\u5c3c\u5bd7\u5bec\u5bdf\u5bdf\u5be7\u5be7\u5be7\u5bf4\u5bda\u5c3f\u5bda\u5bef\u5be2\u5be2\u5be2\u5c3a\u5bdd\u5bea\u5bea\u5bea\u5bdd\u5bdd\u5c42\u5c42\u5be5\u5bf2\u5be5\u5bf2\u5be5\u5be5\u5c3d\u5c3d\u5bd8\u5bed\u5bed\u5bed\u5be0\u5be0\u5be0\u5c38\u5be8\u5c45\u5be8\u5be0\u5be8\u5be8\u5bf5\u5bf5\u5bdb\u5be8\u5c40\u5c40\u5bdb\u5bdb\u5bf0\u5bf0\u5be3\u5bf0\u5be3\u5c2e\u5be3\u5be3\u5c3b\u5c3b\u5bde\u5c48\u5beb\u5beb\u5beb\u5beb\u5beb\u5c29\u5bde\u5bf8\u5bde\u5c36\u5c43\u5c43\u5c43\u5c17\u5be6\u5bde\u5bf3\u5bf3\u5be6\u5be6\u5bf3\u5bf3\u5be6\u5c31\u5be6\u5c00\u5c3e\u5c3e\u5c3e\u5c00\u5bd9\u5c4b\u5bee\u5bee\u5bee\u5bee\u5bee\u5bfb\u5be1\u5c2c\u5be1\u5bfb\u5be1\u5be1\u5c39\u5c39\u5be9\u5c46\u5c46\u5c46\u5be9\u5be9\u5be1\u5be1\u5be9\u5bf6\u5be9\u5c27\u5bf6\u5bf6\u5bf6\u5c08\u5bdc\u5c34\u5be9\u5be9\u5c41\u5c41\u5c41\u5c15\u5bdc\u5c03\u5bdc\u5c4e\u5bf1\u5bf1\u5bf1\u5c22\u5be4\u5bf1\u5bf1\u5bf1\u5be4\u5be4\u5c2f\u5c2f\u5be4\u5bfe\u5be4\u5bfe\u5c3c\u5c3c\u5c3c\u5bfe\u5bdf\u5c49\u5c49\u5c49\u5bec\u5bec\u5bec\u5c49\u5bec\u5be4\u5bec\u5bf9\u5bec\u5bec\u5c2a\u5c2a\u5bdf\u5bf9\u5bf9\u5bf9\u5bdf\u5bdf\u5c37\u5c37\u5c44\u5bec\u5c44\u5c06\u5c44\u5c44\u5c18\u5c18\u5be7\u5c06\u5bdf\u5bdf\u5bf4\u5bf4\u5bf4\u5c51\u5be7\u5c25\u5be7\u5c51\u5bf4\u5bf4\u5bf4\u5c06\u5be7\u5be7\u5c32\u5c32\u5be7\u5be7\u5c01\u5c01\u5c3f\u5c01\u5c3f\u5c13\u5c3f\u5c3f\u5c01\u5c01\u5bda\u5c4c\u5c4c\u5c4c\u5bef\u5bef\u5bef\u5c20\u5bef\u5c4c\u5bef\u5be7\u5bef\u5bef\u5bfc\u5bfc\u5be2\u5bef\u5c2d\u5c2d\u5be2\u5be2\u5bfc\u5bfc\u5be2\u5bfc\u5be2\u5c0e\u5c3a\u5c3a\u5c3a\u5bfc\u5bea\u5bef\u5c47\u5c47\u5c47\u5c47\u5c47\u5c09\u5bea\u5c1b\u5bea\u5c47\u5be2\u5be2\u5be2\u5bfc\u5bea\u5bf7\u5bf7\u5bf7\u5bea\u5bea\u5c28\u5c28\u5bf7\u5c54\u5bf7\u5bf7\u5bf7\u5bf7\u5c09\u5c09\u5bdd\u5bea\u5c35\u5c35\u5bea\u5bea\u5bea\u5c61\u5c42\u5c04\u5c42\u5bea\u5c42\u5c42\u5c16\u5c16\u5bdd\u5c42\u5c04\u5c04\u5bdd\u5bdd\u5c4f\u5c4f\u5bf2\u5c4f\u5bf2\u5c4f\u5bf2\u5bf2\u5c23\u5c23\u5be5\u5c4f\u5bf2\u5bf2\u5bf2\u5bf2\u5bf2\u5c04\u5be5\u5bff\u5be5\u5bff\u5c30\u5c30\u5c30\u5bff\u5be5\u5be5\u5bff\u5bff\u5be5\u5be5\u5bff\u5bff\u5c3d\u5c11\u5c3d\u5c0c\u5c3d\u5c3d\u5bff\u5bff\u5be0\u5bf2\u5c4a\u5c4a\u5c4a\u5c4a\u5c4a\u5c4a\u5bed\u5c0c\u5bed\u5c1e\u5bed\u5bed\u5c4a\u5c4a\u5bed\u5be5\u5be5\u5be5\u5bed\u5bed\u5bfa\u5bfa\u5bed\u5bfa\u5bed\u5c57\u5c2b\u5c2b\u5c2b\u5c57\u5be0\u5c57\u5bfa\u5bfa\u5bfa\u5bfa\u5bfa\u5bf2\u5be0\u5c0c\u5be0\u5c07\u5c38\u5c38\u5c38\u5bfa\u5c45\u5bed\u5bed\u5bed\u5c45\u5c45\u5c07\u5c07\u5c45\u5bed\u5c45\u5c07\u5c19\u5c19\u5c19\u5c33\u5be8\u5c45\u5c07\u5c07\u5be0\u5be0\u5be0\u5bfa\u5bf5\u5c52\u5bf5\u5c52\u5bf5\u5bf5\u5c52\u5c52\u5be8\u5bf5\u5c26\u5c26\u5be8\u5be8\u5c52\u5c52\u5bf5\u5bf5\u5bf5\u5bed\u5bf5\u5bf5\u5c07\u5c07\u5be8\u5c02\u5be8\u5be8\u5c33\u5c33\u5c33\u5c5f\u5be8\u5c02\u5be8\u5c5f\u5c02\u5c02\u5c02\u5c33\u5c40\u5be8\u5c02\u5c02\u5c40\u5c40\u5c14\u5c14\u5c40\u5c0f\u5c40\u5bf5\u5c02\u5c02\u5c02\u5c0f\u5bdb\u5bf5\u5c4d\u5c4d\u5c4d\u5c4d\u5c4d\u5c0f\u5bf0\u5c4d\u5bf0\u5c4d\u5bf0\u5bf0\u5c21\u5c21\u5bf0\u5bf0\u5c4d\u5c4d\u5bf0\u5bf0\u5be8\u5be8\u5bf0\u5be8\u5bf0\u5c02\u5bfd\u5bfd\u5bfd\u5c5a\u5be3\u5bfd\u5bf0\u5bf0\u5c2e\u5c2e\u5c2e\u5bfd\u5be3\u5c5a\u5be3\u5bf0\u5bfd\u5bfd\u5bfd\u5c29\u5be3\u5bfd\u5bfd\u5bfd\u5be3\u5be3\u5c0f\u5c0f\u5c3b\u5c0a\u5c3b\u5bf0\u5c3b\u5c3b\u5bfd\u5bfd\u5beb\u5bf0\u5bf0\u5bf0\u5c48\u5c48\u5c48\u5bf0\u5c48\u5c0a\u5c48\u5c48\u5c48\u5c48\u5c0a\u5c0a\u5beb\u5c1c\u5c1c\u5c1c\u5beb\u5beb\u5c48\u5c48\u5be3\u5c0a\u5be3\u5c17\u5be3\u5be3\u5bfd\u5bfd\u5beb\u5c55\u5bf8\u5bf8\u5bf8\u5bf8\u5bf8\u5c17\u5beb\u5c55\u5beb\u5c55\u5c29\u5c29\u5c29\u5c55\u5bf8\u5beb\u5c55\u5c55\u5bf8\u5bf8\u5bf8\u5bf8\u5bf8\u5bf0\u5bf8\u5bf0\u5c0a\u5c0a\u5c0a\u5c55\u5bde\u5c05\u5beb\u5beb\u5c36\u5c36\u5c36\u5bf8\u5beb\u5c62\u5beb\u5c36\u5beb\u5beb\u5c62\u5c62\u5c43\u5c05\u5c05\u5c05\u5c43\u5c43\u5beb\u5beb\u5c43\u5c05\u5c43\u5c62\u5c17\u5c17\u5c17\u5c31\u5bde\u5c12\u5c43\u5c43\u5c05\u5c05\u5c05\u5c12\u5bde\u5c12\u5bde\u5bf8\u5c50\u5c50\u5c50\u5bf8\u5bf3\u5c50\u5c50\u5c50\u5bf3\u5bf3\u5c50\u5c50\u5bf3\u5c50\u5bf3\u5c12\u5c24\u5c24\u5c24\u5c7c\u5be6\u5bf3\u5c50\u5c50\u5bf3\u5bf3\u5bf3\u5c12\u5bf3\u5beb\u5bf3\u5beb\u5bf3\u5bf3\u5c05\u5c05\u5be6\u5c00\u5c00\u5c00\u5be6\u5be6\u5c00\u5c00\u5c31\u5bf3\u5c31\u5c5d\u5c31\u5c31\u5c00\u5c00\u5be6\u5c5d\u5be6\u5be6\u5c00\u5c00\u5c00\u5c31\u5be6\u5c2c\u5be6\u5c00\u5c00\u5c00\u5c00\u5c5d\u5c3e\u5be6\u5c12\u5c12\u5c3e\u5c3e\u5c0d\u5c0d\u5c3e\u5bf3\u5c3e\u5c6a\u5c00\u5c00\u5c00\u5c0d\u5be1\u5bf3\u5bf3\u5bf3\u5c4b\u5c4b\u5c4b\u5c6a\u5c4b\u5bf3\u5c4b\u5c0d\u5c4b\u5c4b\u5c4b\u5c4b\u5bee\u5c4b\u5c0d\u5c0d\u5bee\u5bee\u5c1f\u5c1f\u5bee\u5c1f\u5bee\u5c39\u5c4b\u5c4b\u5c4b\u5c1a\u5bee\u5c0d\u5be6\u5be6\u5be6\u5be6\u5be6\u5c1a\u5bee\u5c00\u5bee\u5c58\u5bfb\u5bfb\u5bfb\u5c58\u5bee\u5bfb\u5bfb\u5bfb\u5bee\u5bee\u5c58\u5c58\u5c2c\u5c58\u5c2c\u5bfb\u5c2c\u5c2c\u5c58\u5c58\u5be1\u5bee\u5c58\u5c58\u5bfb\u5bfb\u5bfb\u5c27\u5bfb\u5bfb\u5bfb\u5bfb\u5bfb\u5bfb\u5bf3\u5bf3\u5be1\u5c0d\u5c0d\u5c0d\u5be1\u5be1\u5c08\u5c08\u5c39\u5bee\u5c39\u5c65\u5c39\u5c39\u5bfb\u5bfb\u5c46\u5c65\u5bee\u5bee\u5bee\u5bee\u5bee\u5c84\u5c46\u5c65\u5c46\u5bee\u5c08\u5c08\u5c08\u5c65\u5c46\u5c46\u5bee\u5bee\u5c46\u5c46\u5c08\u5c08\u5c1a\u5c65\u5c1a\u5c00\u5c1a\u5c1a\u5c34\u5c34\u5be9\u5c15\u5c46\u5c46\u5c08\u5c08\u5c08\u5c46\u5be1\u5c15\u5be1\u5c08\u5be1\u5be1\u5bfb\u5bfb\u5bf6\u5c53\u5c53\u5c53\u5bf6\u5bf6\u5c53\u5c53\u5bf6\u5c53\u5bf6\u5c15\u5c53\u5c53\u5c53\u5c46\u5be9\u5c53\u5bf6\u5bf6\u5c27\u5c27\u5c27\u5c53\u5be9\u5c7f\u5be9\u5c27\u5c53\u5c53\u5c53\u5bf6\u5bf6\u5bf6\u5bf6\u5bf6\u5bf6\u5bf6\u5bee\u5bee\u5bf6\u5bee\u5bf6\u5bee\u5c08\u5c08\u5c08\u5c53\u5be9\u5c03\u5c03\u5c03\u5be9\u5be9\u5be9\u5c60\u5c34\u5c03\u5c34\u5bf6\u5c34\u5c34\u5c60\u5c60\u5be9\u5c34\u5c03\u5c03\u5be9\u5be9\u5c60\u5c60\u5c03\u5be9\u5c03\u5bf6\u5c03\u5c03\u5c34\u5c34\u5c41\u5c2f\u5be9\u5be9\u5c03\u5c03\u5c03\u5c03\u5c41'.__getitem__)[k - 1]", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        return sorted(list(range(lo, hi + 1)), key=[1, 1, 2, 8, 3, 6, 9, 17, 4, 20, 7, 15, 10, 10, 18, 18, 5, 13, 21, 21, 8, 8, 16, 16, 11, 24, 11, 112, 19, 19, 19, 107, 6, 27, 14, 14, 22, 22, 22, 35, 9, 110, 9, 30, 17, 17, 17, 105, 12, 25, 25, 25, 12, 12, 113, 113, 20, 33, 20, 33, 20, 20, 108, 108, 7, 28, 28, 28, 15, 15, 15, 103, 23, 116, 23, 15, 23, 23, 36, 36, 10, 23, 111, 111, 10, 10, 31, 31, 18, 31, 18, 93, 18, 18, 106, 106, 13, 119, 26, 26, 26, 26, 26, 88, 13, 39, 13, 101, 114, 114, 114, 70, 21, 13, 34, 34, 21, 21, 34, 34, 21, 96, 21, 47, 109, 109, 109, 47, 8, 122, 29, 29, 29, 29, 29, 42, 16, 91, 16, 42, 16, 16, 104, 104, 24, 117, 117, 117, 24, 24, 16, 16, 24, 37, 24, 86, 37, 37, 37, 55, 11, 99, 24, 24, 112, 112, 112, 68, 11, 50, 11, 125, 32, 32, 32, 81, 19, 32, 32, 32, 19, 19, 94, 94, 19, 45, 19, 45, 107, 107, 107, 45, 14, 120, 120, 120, 27, 27, 27, 120, 27, 19, 27, 40, 27, 27, 89, 89, 14, 40, 40, 40, 14, 14, 102, 102, 115, 27, 115, 53, 115, 115, 71, 71, 22, 53, 14, 14, 35, 35, 35, 128, 22, 84, 22, 128, 35, 35, 35, 53, 22, 22, 97, 97, 22, 22, 48, 48, 110, 48, 110, 66, 110, 110, 48, 48, 9, 123, 123, 123, 30, 30, 30, 79, 30, 123, 30, 22, 30, 30, 43, 43, 17, 30, 92, 92, 17, 17, 43, 43, 17, 43, 17, 61, 105, 105, 105, 43, 25, 30, 118, 118, 118, 118, 118, 56, 25, 74, 25, 118, 17, 17, 17, 43, 25, 38, 38, 38, 25, 25, 87, 87, 38, 131, 38, 38, 38, 38, 56, 56, 12, 25, 100, 100, 25, 25, 25, 144, 113, 51, 113, 25, 113, 113, 69, 69, 12, 113, 51, 51, 12, 12, 126, 126, 33, 126, 33, 126, 33, 33, 82, 82, 20, 126, 33, 33, 33, 33, 33, 51, 20, 46, 20, 46, 95, 95, 95, 46, 20, 20, 46, 46, 20, 20, 46, 46, 108, 64, 108, 59, 108, 108, 46, 46, 15, 33, 121, 121, 121, 121, 121, 121, 28, 59, 28, 77, 28, 28, 121, 121, 28, 20, 20, 20, 28, 28, 41, 41, 28, 41, 28, 134, 90, 90, 90, 134, 15, 134, 41, 41, 41, 41, 41, 33, 15, 59, 15, 54, 103, 103, 103, 41, 116, 28, 28, 28, 116, 116, 54, 54, 116, 28, 116, 54, 72, 72, 72, 98, 23, 116, 54, 54, 15, 15, 15, 41, 36, 129, 36, 129, 36, 36, 129, 129, 23, 36, 85, 85, 23, 23, 129, 129, 36, 36, 36, 28, 36, 36, 54, 54, 23, 49, 23, 23, 98, 98, 98, 142, 23, 49, 23, 142, 49, 49, 49, 98, 111, 23, 49, 49, 111, 111, 67, 67, 111, 62, 111, 36, 49, 49, 49, 62, 10, 36, 124, 124, 124, 124, 124, 62, 31, 124, 31, 124, 31, 31, 80, 80, 31, 31, 124, 124, 31, 31, 23, 23, 31, 23, 31, 49, 44, 44, 44, 137, 18, 44, 31, 31, 93, 93, 93, 44, 18, 137, 18, 31, 44, 44, 44, 88, 18, 44, 44, 44, 18, 18, 62, 62, 106, 57, 106, 31, 106, 106, 44, 44, 26, 31, 31, 31, 119, 119, 119, 31, 119, 57, 119, 119, 119, 119, 57, 57, 26, 75, 75, 75, 26, 26, 119, 119, 18, 57, 18, 70, 18, 18, 44, 44, 26, 132, 39, 39, 39, 39, 39, 70, 26, 132, 26, 132, 88, 88, 88, 132, 39, 26, 132, 132, 39, 39, 39, 39, 39, 31, 39, 31, 57, 57, 57, 132, 13, 52, 26, 26, 101, 101, 101, 39, 26, 145, 26, 101, 26, 26, 145, 145, 114, 52, 52, 52, 114, 114, 26, 26, 114, 52, 114, 145, 70, 70, 70, 96, 13, 65, 114, 114, 52, 52, 52, 65, 13, 65, 13, 39, 127, 127, 127, 39, 34, 127, 127, 127, 34, 34, 127, 127, 34, 127, 34, 65, 83, 83, 83, 171, 21, 34, 127, 127, 34, 34, 34, 65, 34, 26, 34, 26, 34, 34, 52, 52, 21, 47, 47, 47, 21, 21, 47, 47, 96, 34, 96, 140, 96, 96, 47, 47, 21, 140, 21, 21, 47, 47, 47, 96, 21, 91, 21, 47, 47, 47, 47, 140, 109, 21, 65, 65, 109, 109, 60, 60, 109, 34, 109, 153, 47, 47, 47, 60, 16, 34, 34, 34, 122, 122, 122, 153, 122, 34, 122, 60, 122, 122, 122, 122, 29, 122, 60, 60, 29, 29, 78, 78, 29, 78, 29, 104, 122, 122, 122, 73, 29, 60, 21, 21, 21, 21, 21, 73, 29, 47, 29, 135, 42, 42, 42, 135, 29, 42, 42, 42, 29, 29, 135, 135, 91, 135, 91, 42, 91, 91, 135, 135, 16, 29, 135, 135, 42, 42, 42, 86, 42, 42, 42, 42, 42, 42, 34, 34, 16, 60, 60, 60, 16, 16, 55, 55, 104, 29, 104, 148, 104, 104, 42, 42, 117, 148, 29, 29, 29, 29, 29, 179, 117, 148, 117, 29, 55, 55, 55, 148, 117, 117, 29, 29, 117, 117, 55, 55, 73, 148, 73, 47, 73, 73, 99, 99, 24, 68, 117, 117, 55, 55, 55, 117, 16, 68, 16, 55, 16, 16, 42, 42, 37, 130, 130, 130, 37, 37, 130, 130, 37, 130, 37, 68, 130, 130, 130, 117, 24, 130, 37, 37, 86, 86, 86, 130, 24, 174, 24, 86, 130, 130, 130, 37, 37, 37, 37, 37, 37, 37, 29, 29, 37, 29, 37, 29, 55, 55, 55, 130, 24, 50, 50, 50, 24, 24, 24, 143, 99, 50, 99, 37, 99, 99, 143, 143, 24, 99, 50, 50, 24, 24, 143, 143, 50, 24, 50, 37, 50, 50, 99, 99, 112, 94, 24, 24, 50, 50, 50, 50, 112].__getitem__)[k - 1]\n", "from heapq import heappush, heappop\n\nclass Solution:\n    dp = {}\n    \n    \n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        heap = []\n        \n        for i in range(lo, hi+1):\n            heappush(heap, [self.getPower(i), i])\n        \n        if len(heap) < k:\n            return -1\n        \n        result = heappop(heap)\n        for i in range(1, k):\n            result = heappop(heap)\n            \n        return result[1]\n        \n        \n        \n    def getPower(self, n: int) -> int:\n        if n == 1:\n            return 1\n        \n        if n in self.dp:\n            return self.dp[n]\n        \n        result = 0\n        \n        if n % 2 == 0:\n            result = 1 + self.getPower(n // 2)\n        else:\n            result = 1 + self.getPower(n * 3 + 1)\n            \n        self.dp[n] = result\n        return result", "from functools import lru_cache\nclass Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        \n        res = []\n        for i in range(lo, hi + 1):\n            res.append((self.power(i), i))\n        res.sort()\n        return res[k - 1][1]\n\n    @lru_cache\n    def power(self, num):\n        if num == 1:\n            return 0\n        if num % 2 == 0:\n            return 1 + self.power(num // 2)\n        else:\n            return 1 + self.power(3 * num + 1)\n        \n        # res = 0\n        # while num != 1:\n        #     if num % 2 == 0:\n        #         num /= 2\n        #     else:\n        #         num = 3 * num + 1\n        #     res += 1\n        # return res\n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        d={}\n        for i in range(lo,hi+1):\n            c=0\n            t=i\n            while(i!=1):\n                if i%2==0:\n                    i=i//2\n                    c+=1\n                    \n                else:\n                    i=3*i+1\n                    c+=1\n            d[t]=c\n        f=sorted(list(d.items()),key=lambda kv: kv[1])\n        return f[k-1][0]\n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        \n        def helper(x):\n            steps=0\n            while x!=1:\n                if x&1:\n                    x=x*3+1\n                else: x//=2\n                steps+=1\n            return steps\n        \n        lookup={}\n        for x in range(lo,hi+1):\n            lookup[x]=helper(x)\n        ans=sorted(lookup.items(),key=lambda x:x[1])\n        return ans[k-1][0]", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        res = []\n        for num in range(lo, hi+1):\n            steps = 0\n            tmp = num\n            while num > 1:\n                if num%2:\n                    num = 3*num + 1\n                else:\n                    num //= 2   \n                steps += 1\n            res.append((steps, tmp))\n        res.sort()\n        return res[k-1][1]", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        \n        def helper(x):\n            steps=0\n            while x!=1:\n                if x&1:\n                    x=x*3+1\n                else: x//=2\n                steps+=1\n            return steps\n        \n        lookup={}\n        for x in range(lo,hi+1):\n            lookup[x]=helper(x)\n        return sorted(lookup.items(),key=lambda x:x[1])[k-1][0]", "from functools import lru_cache\nclass Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        @lru_cache\n        def helper(x):\n            steps=0\n            while x!=1:\n                if x&1:\n                    x=x*3+1\n                else: x//=2\n                steps+=1\n            return steps\n        \n        lookup={}\n        for x in range(lo,hi+1):\n            lookup[x]=helper(x)\n        return sorted(lookup.items(),key=lambda x:x[1])[k-1][0]", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        count = 0\n        answers = []\n        numbers = []\n        memo ={}\n        for number in range(lo,hi+1):\n            original = number\n            numbers.append(numbers)\n            count = 0\n            while number != 1:\n                if number % 2 == 0:\n                    number = number //2\n                    count = count + 1\n                else:\n                    number = 3* number + 1\n                    count = count + 1\n            memo[original]=count\n        \n        sort_memo = sorted(list(memo.items()), key=lambda x: x[1], reverse=False)\n        return sort_memo[k-1][0]\n        \n        \n        \n        \n        \n        \n#create a range from lo to hi\n#while k does not equal 1 do the formula\n#each tiomke add 1 to count\n\n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        d   =   {}\n        for i in range(lo,hi+1):\n            self.pow(i,i,d,0)\n            #print(d)\n        d1  =   OrderedDict(sorted(list(d.items()),key=lambda x:x[1]))\n        l   =   list(d1.keys())\n        return l[k-1]\n            \n    def pow(self,n1,n,d,c):\n        if n    ==  1:\n            d[n1]   =   c\n            return \n        if  n%2 ==0:\n            n   =   n/2\n        elif n%2    ==  1:\n            n   =   n*3 +   1\n        c   +=  1\n        if n in d:\n            d[n1]   =   c   +   d[n]\n            return\n        self.pow(n1,n,d,c)\n        \n            \n            \n", "class Solution:\n    def power(self, number: int):\n        count = 0\n        while number > 1:\n            if number % 2:\n                number = 3 * number + 1\n            else:\n                number //= 2\n            count += 1\n        return count\n        \n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        numbers_power = sorted([(self.power(number), number) for number in range(lo, hi + 1)])\n        return numbers_power[k - 1][1]\n", "class Solution:\n    \n    def get_power(self, n):\n        \n        num = 0\n        \n        while n != 1:\n            \n            if n % 2 == 0:\n                n //= 2\n            else:\n                n = 3 * n + 1\n            num += 1\n            \n        return num\n    \n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        \n        power = {}\n        \n        for i in range(lo, hi + 1):\n            power[i] = self.get_power(i)\n            \n        return sorted(list(power.keys()), key=lambda x: power[x])[k-1]\n            \n            \n            \n", "cache = {1: 0}\nclass Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        def get_power(x, count = 0):\n            if x in cache:\n                return cache[x] + count\n            return get_power(x * 3 + 1 if (x & 1) else x // 2, count + 1)\n        cache.update({i:get_power(i) for i in range(lo, hi + 1) if i not in cache})\n        return sorted((x for x in list(cache.items()) if lo <= x[0] <= hi), key=lambda x:x[1])[k - 1][0]\n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        res = {}\n        if(lo==1 and hi==1 and k==1):\n            return 1\n        \n        def count_steps(x):\n            cnt = 0\n            if(x==1):\n                return cnt;\n            while(x>1):\n                if x%2 == 0:\n                    x = x//2\n                else:\n                    x = x*3 + 1\n                cnt+=1\n            return cnt\n        \n        for i in range(lo,hi+1):\n            res[i] = count_steps(i)\n        return sorted(list(res.items()),key = lambda x:x[1])[k-1][0]\n\n", "def power_value(x):\n    pv = 0\n    while x != 1:\n        if x % 2 == 0:\n            x = x // 2\n        else:\n            x = 3 * x + 1\n        pv += 1\n    return pv\n\nclass Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        power_values = []\n        for x in range(lo, hi+1):\n            pv_x = power_value(x)\n            power_values.append((x,pv_x))\n        return sorted(power_values, key=lambda e: e[1])[k-1][0]\n                \n            \n            \n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        def power(n):\n            counter = 0\n            while n!=1:\n                counter+=1\n                if n %2 == 0:\n                    n = n//2\n                else:\n                    n = 3*n+1\n            return counter\n        key = [x for x in range(lo,hi+1)]\n        value = [power(x) for x in key]\n        ans = list(zip(key,value))\n        sorted_ans = sorted(ans , key = lambda t:t[1])\n        return sorted_ans[k-1][0]\n", "from collections import defaultdict\nclass Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        # adj=defaultdict(set)\n        po = dict()\n        for i in range(lo,hi+1):\n            temp=0\n            curr=i\n            while curr!=1:\n                if curr&1:\n                    child=curr*3+1\n                else:\n                    child=curr//2\n                # adj[curr].add(child)\n                curr=child\n                temp+=1\n            po[i]=temp\n        \n        res=sorted(po.items(),key = lambda x : x[1])\n        return res[k-1][0]", "class Solution:\n    def __init__(self):\n        self.cached_pv = {}\n\n    def power_value(self, x):\n        x_orig = x\n        if x in self.cached_pv:\n            return self.cached_pv[x]\n        pv = 0\n        while x != 1:\n            if x % 2 == 0:\n                x = x // 2\n            else:\n                x = 3 * x + 1\n            pv += 1\n        self.cached_pv[x_orig] = pv\n        return pv\n\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        power_values = []\n        for x in range(lo, hi+1):\n            pv_x = self.power_value(x)\n            power_values.append((x,pv_x))\n        return sorted(power_values, key=lambda e: e[1])[k-1][0]\n                \n            \n            \n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        dict = defaultdict()\n        for i in range(lo,hi+1):\n            steps=0\n            j=i\n            while i!=1:\n                if i%2==0:\n                    i=i//2\n                else:\n                    i = 3*i + 1\n                \n                steps+=1\n                \n            dict[j] = steps\n            \n        dict = sorted(dict.items(), key=lambda x: x[1])\n\n            \n        return dict[k-1][0]", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        def power(n):\n            counter = 0\n            while n!=1:\n                counter+=1\n                if n %2 == 0:\n                    n = n//2\n                else:\n                    n = 3*n+1\n            return counter\n        ans = [(x,power(x)) for x in range(lo,hi+1)]\n        sorted_ans = sorted(ans , key = lambda t:t[1])\n        return sorted_ans[k-1][0]\n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        def fun(n):\n            if n==1:return 0\n            ans=0\n            while n>1:\n                if n%2==0:\n                    n//=2\n                else:\n                    n=n*3+1\n                ans+=1\n            ans+=1\n            return ans\n        ans=[] \n        for i in range(lo,hi+1):\n            ans.append([i,fun(i)])\n        ans.sort(key=lambda x:x[1])\n        for i in range(k):\n            if i==k-1:\n                return ans[i][0]\n        \n", "class Solution:\n    power = {}\n    def get_power(self, num):\n        if num == 1:\n            return 0\n        if num in self.power:\n            return self.power[num]\n        if num % 2 == 0:\n            self.power[num] = self.get_power(num // 2) + 1\n        else:\n            self.power[num] = self.get_power(3 * num + 1) + 1\n        \n        return self.power[num]\n    \n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        power_vals = {\n            val: self.get_power(val) for val in range(lo, hi+1)\n        }\n        vals = [k for k, v in sorted(power_vals.items(), key=lambda x: (x[1], x[0]))]\n        return vals[k-1]", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        \n        \n        lst = []\n        def power(s) -> int:\n            count =0\n            while s!=1:\n                \n                if s%2 ==0:\n                    s = s//2\n                    count = count + 1\n                else:\n                    s = 3*s +1\n                    count = count+1\n            \n            return count, s\n        \n        for i in range(lo, hi+1):\n            \n            lst.append((i,power(i)))\n            \n            \n        \n        \n        lst.sort(key = lambda x : x[1])\n        return lst[k-1][0]\n            \n            \n        \n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        def power(x):\n            r = 0\n            while x > 1:\n                if x % 2 == 0:\n                    # x /= 2\n                    x >>= 1\n                else:\n                    x = 3*x + 1\n                r += 1\n            return r\n        \n        array = (i for i in range(lo, hi+1))\n        array = sorted(array, key=lambda x: power(x))\n        \n        return array[k-1]", "class Solution:\n    def calc(self, num):\n        count = 0 \n        while num != 1:\n            if num % 2 == 0:\n                num = num // 2\n            else:\n                num = 3 * num + 1\n            count += 1\n        return count\n    \n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        counts = []\n        keys = [i for i in range(lo, hi+1)]\n        dict = {}\n        \n        for i in range(lo, hi+1):\n            ans = self.calc(i)\n            counts.append(ans)\n            \n        for key in keys:\n            for count in counts:\n                dict[key] = count\n                counts.remove(count)\n                break\n                \n        dict = {k:v for k, v in sorted(list(dict.items()), key = lambda item: item[1])}\n        final = [key for key in list(dict.keys())]\n        return final[k-1]\n            \n            \n", "class Solution:\n    def getKth(self, lo, hi, k):\n        dic={}\n        for n in range(lo,hi+1):\n            steps = self.countStep(n)\n            dic[n] = steps\n        return sorted(dic.items(), key=lambda x:(x[1],x[0]))[k-1][0]\n\n    def countStep(self,m):\n        step=0\n        while m!=1:\n            if m%2==0:\n                m //= 2\n            else:\n                m = m*3 + 1\n            step += 1\n        return step", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        def power(x):\n            res=0\n            while(x!=1):\n                if x%2==0:\n                    x=x>>1\n                else:\n                    x=x*3+1\n                res+=1\n            return res\n        x=sorted([i for i in range(lo,hi+1)],key=power)\n        return x[k-1]", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        arr = []\n        for i in range(lo, hi + 1):\n            counter = 0\n            num = i\n            while num != 1:\n                if num % 2 == 1:\n                    num = 3 * num + 1\n                else:\n                    num = num // 2\n                counter += 1\n            arr.append([i, counter])\n        arr.sort()\n        for i in arr:\n            i[0], i[1] = i[1], i[0]\n        arr.sort()\n        return arr[k - 1][1]", "import heapq\n\nclass Solution:\n    \n    def calculateSteps(self, num):\n        count = 0\n        while num > 1:\n            if num%2==0:\n                num = num//2\n            else:\n                num = (3*num) + 1\n            count+=1\n        return count\n    \n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        vals = []\n        for num in range(lo, hi+1):\n            heapq.heappush(vals, (self.calculateSteps(num), num))\n        \n        print(vals)\n        count = 1\n        val = None\n        while count < k:\n            heapq.heappop(vals)\n            count+=1\n        return heapq.heappop(vals)[1]\n            \n        \n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        \n        res = []\n        \n        for i in range(lo,hi+1):\n            sol = [i]\n            \n            count = 0\n            \n            while i != 1:\n                if i %2 == 0:\n                    i//=2\n                else: \n                    i = 3*i+1\n                count += 1\n            \n            sol = [count, sol[0]]\n            res.append(sol)\n        \n        result = sorted(res)\n        \n        \n        ff = [x[1] for x in result]\n        return ff[k-1]", "class Solution:\n    def get_power(self, n):\n      res = 0\n      while n != 1:\n        if n % 2 == 0:\n          n //= 2\n        else:\n          n = 3*n+1\n        res += 1\n      return res\n    \n    def getKth(self, lo: int, hi: int, k: int) -> int:\n      array = []\n      for i in range(lo, hi+1):\n        array.append((i, self.get_power(i)))\n      array.sort(key = lambda x:(x[1], x[0]))\n      return array[k-1][0]", "class Solution:\n    @staticmethod\n    def compute_power(x, d={}):\n        if x in d: return d[x]\n        xcopy, steps = x, 0\n        while x != 1 and x not in d:\n            x = 3 * x + 1 if x % 2 else x//2\n            steps += 1 + d[x] if x in d else 1\n        d[xcopy] = steps\n        return steps\n    \n    def getKth(self, lo, hi, k):\n        vals = list(range(lo, hi+1))\n        vals.sort(key=lambda x: self.compute_power(x))\n        return vals[k-1]", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        \n        ans = {}\n        \n        for i in range(lo,hi+1):\n            j = i\n            s=0\n            while(i != 1):\n                if(i % 2 == 0):\n                    i = i // 2\n                else:\n                    i = i * 3 + 1\n                s =s+1\n                \n            ans[j] = s\n        \n        ans = sorted(list(ans.items()), key=lambda x: x[1])\n        \n        return(ans[k-1][0])\n        \n        \n            \n            \n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        \n        def getPower(x):\n            count = 0\n            while x != 1:\n                if x % 2 == 0:\n                    x = x // 2\n                else:\n                    x = 3 * x + 1\n                count += 1\n            return count\n        \n        output = [[getPower(x), x] for x in range(lo, hi + 1)]\n        output.sort(key = lambda x: (x[0], x[1]))\n        return output[k-1][1]", "class Solution:\n    def __init__(self):\n        self.cache = {1: 0,2: 1,3: 7,4: 2}\n\n    def getPower(self, n):\n        after = 0\n        steps = 0\n        if n % 4 == 0:\n            after = n // 4\n            steps = 2\n        elif n % 4 == 1:\n            after = n // 4 * 3 + 1\n            steps = 3\n        elif n % 4 == 2:\n            after = n // 4 * 3 + 2\n            steps = 3\n        else:\n            after = n // 4 * 9 + 8\n            steps = 4 \n        if after in list(self.cache.keys()): \n            return self.cache[after] + steps\n        else:\n            return self.getPower(after) + steps\n\n    def getKth(self, low, high, k):\n        data = [self.getPower(i) for i in range(low, high + 1)]\n        sorted_data = sorted(zip(data, list(range(len(data)))), key= lambda x:x[0])\n        return sorted_data[k - 1][1] + low\n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        heap = []\n        for i in range(lo, hi+1):\n            ret = i\n            steps = 0\n            while ret != 1:\n                if ret % 2 == 0:\n                    ret = ret // 2\n                else:\n                    ret = 3 * ret + 1\n                steps += 1\n\n            heapq.heappush(heap, (-steps, -i))\n            if len(heap) > k:\n                heapq.heappop(heap)\n        return -(heap[0][1])", "class Solution:\n    #calc=[]\n    def findPower(self,ele):\n        #self.calc=[]\n        ctr=0\n        while ele!=1:\n            if ele%2==0:\n                ele=ele//2\n            else:\n                ele=3*ele+1\n            #self.calc.append(ele)\n            ctr +=1\n        return ctr\n            \n            \n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        powmat=[]\n        for i in range(lo,hi+1):\n            ct=self.findPower(i)\n            powmat.append([ct,i])\n        powmat.sort()\n        print(powmat)\n        return powmat[k-1][1]", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        arr = []\n        for i in range(lo, hi + 1):\n            arr.append([self.getPower(i), i])\n        \n        arr.sort(key=lambda x: (x[0], x[1]))\n        return arr[k - 1][1]\n        \n    def getPower(self, number: int) -> int:\n        count = 0\n        \n        while number != 1:\n            if number % 2 == 1:\n                number = 3 * number + 1\n            else:\n                number //= 2\n            count += 1\n        \n        return count", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        def power(x):\n            count = 0\n            while x > 1:\n                if x % 2:\n                    x = 3* x + 1\n                else:\n                    x = x /2\n                count +=1\n            return count\n        return sorted(range(lo,hi+1), key=power)[k-1]", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        \n        res = []\n        \n        for i in range(lo, hi+1):\n            count = 0 \n            j = i\n            while j > 1:\n                if j & 1:\n                    j = 3*j + 1\n                else:\n                    j //= 2\n                count += 1\n            res.append((count, i))\n            \n        res.sort()\n        return res[k-1][1]\n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        arr = []\n        def power(x):\n            count = 0\n            while(x!= 1):\n                if (x%2 == 0):\n                    x = x//2\n                    count += 1\n                elif(x%2 != 0):\n                    x = 3 * x + 1\n                    count += 1\n            return count\n        for i in range(lo, hi+1):\n            p = power(i)\n            arr.append((i, p))\n        arr = [j[0] for j in sorted(arr, key = lambda x: x[1])]\n        #print(arr)\n        return arr[k-1]\n", "class Solution:\n    dp = {}\n    \n    def findPower(self, num):\n        way = [num]\n        ops = 0\n        \n        while num != 1 and num not in self.dp:\n            if num % 2 == 0:\n                num /= 2\n            else:\n                num = (num * 3 + 1)\n            \n            way.append(num)\n            ops += 1\n        \n        if num in self.dp:\n            ops += self.dp[num]\n            \n        for prev in way:\n            self.dp[prev] = ops\n            ops-=1\n    \n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        res = []\n        \n        for i in range(lo, hi+1):\n            self.findPower(i)\n            res.append((i, self.dp[i]))\n        \n        res = sorted(res, key=lambda x: x[1])\n        return res[k-1][0]\n        \n", "from operator import itemgetter\nclass Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        z = []\n        for i in range(lo, hi + 1):\n            count = 0\n            f=i\n            while i != 1:\n                if i % 2 == 0:\n                    i = i / 2\n                    count += 1\n                else:\n                    i = 3 * i + 1\n                    count += 1\n            z.append([f, count])\n        return sorted(z, key=itemgetter(1))[k-1][0]", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        res=[]\n        dict1={}\n        for i in range(lo,hi+1,1):\n            c=0\n            r=[]\n            v=0\n            p=i\n            while(c==0):\n                if(i==1):\n                    c=1\n                elif(i%2==0):\n                    i=i//2\n                    v+=1\n                    while(i%2==0):\n                        i=i//2\n                        v+=1\n                else:\n                    i=i*3+1\n                    v+=1\n            r.append(p)\n            r.append(v)\n            res.append(r)\n        res.sort(key=lambda x:x[1])\n        print(res)\n        return res[k-1][0]", "class Solution:\n\n    def power_value(self, n):\n        count = 0\n        while n != 1:\n            count += 1\n            if n % 2 == 0:\n                n /= 2\n            else:\n                n = n*3 + 1\n        return count\n    \n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        vals = sorted(list(range(lo, hi+1)), key=self.power_value)\n        return vals[k-1]\n\n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        dic={}\n        def determine_power(a):\n            power=0\n            while (a>1):\n                if a%2:\n                    a=3*a+1\n                    power+=1\n                else:\n                    a=a/2\n                    power+=1\n            return power\n\n        for element in range (lo,hi+1):\n            p=determine_power(element)\n            dic.update({element:p})\n        dd=sorted(list(dic.items ()),key =lambda x:x[1])# sort by value \n        return (dd[k-1][0])\n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        \n        ans = {}\n        \n        for num in range(lo, hi + 1):\n            num_copy = num\n            steps = 0\n            while num_copy != 1:\n                if num_copy % 2 == 0:\n                    num_copy = num_copy / 2\n                    steps += 1\n                else:\n                    num_copy = 3 * num_copy + 1\n                    steps += 1\n            ans[num] = steps\n        \n        return(sorted(list(ans.items()), key=lambda item: item[1]))[k-1][0]\n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        def powerx(x):\n            p=0\n            while x !=1 :\n                if x % 2 == 0:\n                    x = x/2\n                else:\n                    x = x*3+1\n                p+=1\n            return p\n        dic = {}\n        for i in range(lo, hi+1):\n            dic[i] = powerx(i)\n        dic_ordered = sorted(list(dic.items()), key=lambda x: x[1])\n        return(dic_ordered[k-1][0])\n                \n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        def getPower(x):\n          count = 0\n          while(x != 1):\n            if (x % 2 == 0):\n              x /= 2\n              count += 1\n            else:\n              x = 3 * x + 1\n              count += 1\n          return count\n        dic = {}\n        for i in range(lo, hi+1):\n          dic[i] = getPower(i)\n        \n        sorted_dic = sorted(list(dic.items()), key = lambda x: x[1], reverse=False)\n        print(sorted_dic)\n        for i in range(len(sorted_dic)):\n          if (i == k-1):\n            return sorted_dic[i][0]\n        \n        \n        \n        \n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        \n        def getPowerValue(num):\n            num_steps = 0\n            while num != 1:\n                if num % 2 == 0:\n                    num = num /2\n                else:\n                    num = 3 * num + 1\n                num_steps +=1\n            return num_steps\n            \n            \n        powervalues = sorted([i for i in range(lo, hi + 1)], key = getPowerValue)\n        #print(powervalues)\n        return powervalues[k - 1]\n", "class Solution:\n    \n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        power_values = defaultdict()\n        \n        for i in range(lo, hi + 1):\n            count = 0\n            x = i\n            while x != 1:\n                if x % 2 == 0:\n                    x /= 2\n                else:\n                    x = 3 * x + 1\n                count += 1\n            power_values[i] = count\n            \n        sorted_d = sorted(power_values.items(), key=lambda x: x[1])\n\n        return sorted_d[k-1][0]", "class Solution:\n    \n    powers = {1:0}\n    \n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        power_range = []\n        for i in range(lo, hi + 1):\n            tup = (i,self.getPower(i))\n            power_range.append(tup)\n        power_range.sort(key = lambda x: x[1])\n        return power_range[k-1][0]\n        \n    def getPower(self, num):\n        if num in self.powers:\n            return self.powers[num]\n        if num % 2 == 1:\n            power = self.getPower((num*3)+1) + 1\n            self.powers[num] = power\n            return power\n        else:\n            power = self.getPower(num/2) + 1\n            self.powers[num] = power\n            return power", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        \n        def getPowerValue(num):\n            num_steps = 0\n            while num != 1:\n                if num % 2 == 0:\n                    num = num /2\n                else:\n                    num = 3 * num + 1\n                num_steps +=1\n            return num_steps\n            \n            \n        powervalues = sorted([(i, getPowerValue(i)) for i in range(lo, hi + 1)], key = lambda x: x[1])\n        #print(powervalues)\n        return powervalues[k - 1][0]\n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        def getPower(num):\n            if num==1:\n                return 1\n            count = 0\n            while num!=1:\n                if num%2==0:\n                    num = num/2\n                    count += 1\n                else:\n                    num = 3*num + 1\n                    count += 1\n            return count\n        dic = {}\n        for i in range(lo, hi+1):\n            dic[i] = getPower(i)\n        dic = {k:v for k,v in sorted(dic.items())}\n        dic = {k:v for k,v in sorted(list(dic.items()), key = lambda item: item[1])}\n        return list(dic.keys())[k-1]\n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        return sorted(map(lambda x: (self.myfunc(x),x), range(lo,hi+1)) )[k-1][1]\n    \n    def myfunc(self,x):\n        transformations = 0\n        while (x!=1):\n            if x%2==0:\n                x=x/2\n            else:\n                x= 3*x+1\n            transformations+=1\n        return transformations", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        indexList = [i for i in range(lo, hi+1, 1)]\n        powerList = [self.getPower(i) for i in indexList]\n        sortedIndex = [x for _,x in sorted(zip(powerList,indexList))]\n        return sortedIndex[k-1]\n    \n    def getPower(self, x: int) -> int:\n        count = 0;\n        while (x != 1):\n            if (x%2 == 0):\n                x = x/2\n            else:\n                x = 3*x +1\n            count+=1\n        return count\n        \n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        low=lo\n        high=hi\n        countlist=[]\n        intgererlist=[]\n        for lo in range(low,high+1):\n            i=lo\n            count=0\n            while lo>1:\n                if lo%2==0:\n                    lo=lo//2\n                else:\n                    lo=(3*lo)+1\n                count+=1\n            countlist.append(count)\n            intgererlist.append(i)\n\n        ziped=zip(countlist,intgererlist)\n        o=0\n        for i,j in sorted(ziped):\n            o+=1\n            if o==k:\n                return (j)", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        powerSteps = []\n        for i in range(lo, hi + 1):\n            powerSteps.append((self.getPowerSteps(i), i))\n        powerSteps.sort()\n        return powerSteps[k - 1][1]\n        \n        \n    def getPowerSteps(self, value):\n        steps = 0\n        while value != 1:\n            if value % 2 == 0:\n                value = value / 2\n            else:\n                value = 3 * value + 1\n            steps += 1\n        return steps", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        d=dict()\n        for i in range(lo,hi+1):\n            res=0\n            x=i\n            while i!=1:\n                if i%2==1:\n                    i=3*i+1\n                else:\n                    i=i/2\n                res+=1\n            d[x]=res\n            \n        di={k:v for k,v in sorted(d.items(), key=lambda item: item[1])}\n        return list(di.keys())[k-1]", "class Solution:\n    def getKth(self, lo, hi, k):\n        def power(x):\n            if x&1:\n                return 0 if x==1 else 1+power( 3*x + 1 )\n            return 1+power(x >> 1)\n        A = [ (power(x),x) for x in range(lo,hi+1) ]\n        return sorted(A)[k-1][1]", "def fun(x):\n    cnt = 0\n    while x != 1:\n        x = x/2 if x%2==0 else 3*x+1\n        cnt += 1\n    return cnt\n\nclass Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        lst = sorted([(x, fun(x)) for x in range(lo, hi+1)], key=lambda x: (x[1], x[0]))\n        print(lst, k)\n        return lst[k-1][0]", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        dic = {}\n        for x in range(lo, hi+1):\n            dic[x] = self.get_power(x, 0)\n        dic_2 = {k: dic[k] for k in sorted(dic, key=dic.get)}\n        return list(dic_2.keys())[k-1]\n    def get_power(self, x:int, p:int) -> int:\n        while x!=1:\n            if x%2==0:\n                x//=2\n            else:\n                x = 3*x+1\n            p+=1\n        return p\n", "@lru_cache(maxsize=1000)\ndef pow(n: int):\n    if n == 1:\n        return 1\n    if n % 2 == 0:\n        return 1 + pow(n//2)\n    else:\n        return 1 + pow(3 * n + 1)\n\nclass Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        l = list(range(lo, hi + 1))\n        l.sort(key = lambda x: (pow(x),x) )\n        return l[k-1]", "class Solution:\n    def getSteps(self, x):\n        res = 0\n        while x != 1:\n            if x % 2 == 1:\n                x = 3 * x + 1\n            else:\n                x = x / 2\n            res += 1\n        return res\n    \n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        res = []\n        for i in range(lo, hi+1, 1):\n            val = self.getSteps(i)\n            res.append([i, val])\n            \n        print(res)\n        res.sort(key = lambda x: (x[1], x[0]))\n        ans= [item[0] for item in res]\n        print(ans)\n        return ans[k-1]", "import functools\n\nclass Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        arr = []\n        \n        for i in range(lo, hi + 1):\n            arr.append([i,getPower(i)])  \n        \n        arr.sort(key=functools.cmp_to_key(compareByK))\n        \n        return arr[k - 1][0]\n        \ndef getPower(n):\n    steps = 0\n    while n != 1:\n        steps +=1\n        if n % 2 == 0:\n            n = n / 2\n        else:\n            n = n * 3 + 1\n\n    return steps\n    \ndef compareByK(x, y):\n    powerX = x[1]\n    powerY = y[1]\n\n    if powerX < powerY:\n        return -1\n    elif powerX > powerY:\n        return 1\n    else:\n        if x[0] < y[0]:\n            return -1\n        elif x[0] > y[0]:\n            return 1\n        else:\n            return 0", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        int_to_steps = {}\n        for x in range(lo, hi + 1):\n            start = x\n            steps = 0\n            while x != 1:\n                steps += 1\n                if x % 2 == 0:\n                    x = x / 2\n                else:\n                    x = x * 3 + 1\n            # if steps not in steps_to_ints:\n            #     steps_to_ints[steps] = []\n            # steps_to_ints[steps].append(steps)\n            int_to_steps[start] = steps\n        \n        return sorted(list(int_to_steps.items()), key=lambda item: item[1])[k - 1][0]\n", "from collections import defaultdict\nclass Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        # adj=defaultdict(set)\n        po = dict()\n        for i in range(lo,hi+1):\n            po[i]=0\n            curr=i\n            while curr!=1:\n                if curr&1:\n                    child=curr*3+1\n                else:\n                    child=curr//2\n                # adj[curr].add(child)\n                curr=child\n                po[i]+=1\n            \n        \n        res=sorted(po.items(),key = lambda x : x[1])\n        return res[k-1][0]", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        \n        nums = list(range(lo, hi + 1))\n        count = 0\n        while True:\n            for i in range(len(nums)):\n                if nums[i] == 0:\n                    continue\n                elif nums[i] == 1:\n                    count += 1\n                    nums[i] = 0\n                    if count == k:\n                        return lo + i\n                    \n                elif nums[i] % 2 == 0:\n                    nums[i] = nums[i] // 2\n                else:\n                    nums[i] = 3 * nums[i] + 1\n                    \n                if nums[i] == 1:\n                    count += 1\n                    nums[i] = 0\n                    \n                    if count == k:\n                        return lo + i\n                    \n        \n                        \n                    \n                    \n            \n        \n        \n        \n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        if lo == hi:\n            return lo\n        \n        ans = []\n        for i in range(lo, hi+1):\n            num = i\n            ctr = 0\n            while num != 1:\n                if num % 2 != 0: #odd\n                    num = (num * 3) + 1\n                else:\n                    num = num/2\n                ctr+=1\n            ans.append((ctr, i))\n            \n        return sorted(ans, key = lambda x: x[0])[k-1][1]\n            \n                \n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        \n        def power(n: int):\n            step = 0;\n            while n != 1:\n                step += 1\n                if n % 2 == 0:\n                    n = n / 2\n                else:\n                    n = n * 3 + 1\n            return step\n        \n        nums = list(range(lo, hi + 1))\n        powers = [power(n) for n in nums]\n        sortedIndex = list(range(0, hi - lo + 1))\n        sortedIndex = sorted(sortedIndex, key = lambda x: (powers[x], nums[x]))\n        return sortedIndex[k - 1] + lo\n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        powers = {}\n        l = []\n        for i in range(lo, hi+1):\n            j = i\n            stack = []\n            stack.append(j)\n            if j not in powers:\n                while j != 1:\n                    if j%2 == 0:\n                        j = j//2\n                        stack.append(j)\n                    else:\n                        j = j*3 + 1\n                        stack.append(j)\n                cnt = 0\n                while stack:\n                    j = stack.pop()\n                    powers[j] = cnt\n                    cnt += 1\n            l.append((i, powers[i]))\n        l = sorted(l, key = lambda x:(x[1],x[0]))\n        #print(l)\n        return l[k-1][0]", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        def power(n: int)-> int:\n            step = 0\n            while n>1:\n                step+=1\n                if n % 2 == 0:\n                    n = n/2\n                else:\n                    n = 3 * n + 1\n            return step\n        interval = [i for i in range(lo,hi+1)]\n        pwr = [[j,power(j)] for j in range(lo,hi+1)]\n        # print(pwr)\n        pwr = sorted(pwr,key=lambda x: x[1])\n               \n        return (pwr[k-1][0])\n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        \n        arr_of_powers = {}\n        \n        def get_int_power(num):\n            \n            pwr = 0\n            temp = num \n            while temp != 1:\n                pwr += 1\n                if temp % 2 == 0:\n                    temp /= 2\n                elif temp % 2 == 1:\n                    temp = 3 * temp + 1\n            return pwr\n        \n        for num in range(lo, hi+1):\n            arr_of_powers[num] = get_int_power(num)\n\n        interval = sorted(arr_of_powers.items(), key=lambda x: x[1])\n            \n        return interval[k-1][0]", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        @lru_cache(None)\n        def power(x):\n            if x == 1: return 0\n            if x % 2 == 0 : return 1 + power(x//2)\n            return 1 + power(3*x+1)\n        return sorted(range(lo,hi+1),key=power)[k-1]", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        def getSteps(lo):\n            steps = 0\n            reduced = lo\n            while reduced != 1:\n                if reduced % 2 == 0:\n                    reduced = reduced / 2\n                else:\n                    reduced = 3*reduced+1\n                steps += 1\n\n            return (steps)\n\n\n        a = {}\n        for i in range(lo, hi+1):\n            steps = getSteps(i)\n            if steps not in a:\n                a[steps] = [i]\n            else:\n                a[steps].append(i)\n\n        r = []\n        for key in sorted(a.keys()):\n            for val in a[key]:\n                r.append(val)\n\n        return r[k-1]", "# \u9012\u5f52\nclass Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        def getF(x):\n            if x == 1:\n                return 0\n            return (getF(3*x+1) + 1) if x % 2 == 1 else (getF(x // 2) + 1)\n        \n        weights = list(range(lo, hi + 1))\n        weights = sorted(weights, key = lambda x : getF(x))\n        return weights[k - 1]\n    \n# \u672c\u5730\u8bb0\u5fc6\n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        powers = []\n        for i in range(lo, hi+1):\n            index = i\n            steps = 0\n            while i != 1: \n                if i % 2 == 0: \n                    i = i / 2\n                    steps += 1\n                else: \n                    i = 3 * i + 1\n                    steps += 1\n            powers.append([steps, index])         \n        sortPowers = sorted(powers)\n        return sortPowers[k-1][1]", "# brute force\nclass Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        def power(num):\n            res = 0\n            while num != 1:\n                if num % 2 == 0:\n                    num = num / 2\n                else:\n                    num = (3 * num) + 1\n                res += 1\n            return res\n        heap = []\n        for i in range(lo, hi + 1):\n            heap.append((power(i), i))\n        heapq.heapify(heap)\n        for i in range(k - 1):\n            heapq.heappop(heap)\n        return heap[0][1]", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        dic = {}\n        for i in range(lo,hi+1):\n            power = self.findPower(i, 0)\n            dic[i] = power\n        sortedValue = sorted(dic.items(), key=lambda x:x[1])\n        return (sortedValue[k-1][0])\n    \n    def findPower(self, num, count):\n        if num == 1:\n            return count\n        elif num % 2 == 0:\n            return self.findPower(num//2, count+1)\n        else:\n            return self.findPower(3*num+1, count+1)", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        \n        def transform(v):\n            times = 0\n            while v != 1:\n                times += 1\n                if v % 2 == 0:\n                    v = v/2\n                else:\n                    v = 3*v + 1\n            return times\n        \n        res = []\n        \n        for x in range(lo,hi+1):\n            power = transform(x)\n            res.append([power,x])\n        \n        res.sort(key = lambda x:(x[0],x[1]))\n        return res[k-1][1]", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        \n        pair = []\n        \n        def transform(val):\n            \n            count = 0\n            \n            while val != 1:\n                \n                val = val/2 if  val % 2 == 0 else 3 * val + 1\n                count += 1\n            \n            return count\n        \n        for i in range(lo, hi + 1):\n            \n            pair.append(( transform(i), i))\n        print(sorted(pair))\n        return sorted(pair)[k-1][1]", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        def power(x):\n            if x == 1:\n                return 0\n            if x % 2 == 0:\n                return 1 + power(x // 2)\n            return 1 + power(3 * x + 1)\n\n        return sorted(range(lo, hi+1), key=power)[k-1]\n    \n        len_powers = [0]*(hi-lo+1)\n        for n in range(lo,hi+1):\n            ls_power= [n] \n            while ls_power[-1]!=1:\n                #print(ls_power)\n                if ls_power[-1]%2==0:\n                    ls_power.append(ls_power[-1]//2)\n                else:\n                    ls_power.append(3*ls_power[-1]+1)\n            len_powers[n-lo] = len(ls_power)-1\n        return sorted(zip(range(lo,hi+1),len_powers),key = lambda x: [x[1],x[0]])[k-1][0] ", "class Solution:\n    def getKth(self, lo, hi, k):\n        #\n        memo = { 1:0 }\n        def power(x):\n            if x in memo:\n                return memo[x]\n            memo[x] = res = 1 + power( (3*x+1) if x&1 else (x >> 1) )\n            return res\n        #\n        A = [ (power(x),x) for x in range(lo,hi+1) ]\n        return sorted(A)[k-1][1]", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        nums = [i for i in range(lo,hi+1)]\n        powers = [0]*len(nums)\n        for i in range(len(nums)):\n            cur = nums[i]\n            while(cur != 1):\n                if cur%2 == 0:\n                    cur = cur/2\n                else:\n                    cur = 3*cur + 1\n                powers[i] += 1\n        result = [x for _,x in sorted(zip(powers,nums))]\n        return result[k-1]", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        def getPower(n):\n            step = 0\n            while n != 1:\n                n = 3 * n + 1 if n % 2 else n / 2\n                step += 1\n            return step\n        powers = sorted([(i, getPower(i)) for i in range(lo, hi + 1)], key=lambda x:(x[1], x[0]))\n        return powers[k - 1][0]", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        def getPow(n):\n            c=0\n            while n!=1:\n                if n%2==0:\n                    n//=2\n                else:\n                    n=3*n+1\n                c+=1\n            return c\n        def func():\n            arr={i:getPow(i) for i in range(lo,hi+1)}\n            v=list(set(arr.values()))\n            v.sort()\n            fin=[]\n            for i in v:\n                t=[]\n                for a,b in arr.items():\n                    if b==i:\n                        t.append(a)\n                t.sort()\n                fin.extend(t)\n            return fin[k-1]\n        return func()", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        heap = []\n        for i in range(lo, hi+1):\n            power = self.computer_power(i)\n            heapq.heappush(heap, (power, i))\n        \n        k_now = 1\n        while heap:\n            new_power, i = heapq.heappop(heap)\n            if k_now == k:\n                return i\n            k_now += 1\n        return result\n    \n    def computer_power(self, val):\n        if val == 1:\n            return 0\n        \n        if val % 2 == 0:\n            return 1 + self.computer_power(val // 2)\n        else:\n            return 1 + self.computer_power(3*val + 1)", "class Solution:\n    def get_power(self, n):\n        if n == 1:\n            return 0\n        elif n % 2 == 0:\n            return 1 + self.get_power(n // 2)\n        else:\n            return 1 + self.get_power(3 * n + 1)\n    \n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        nums = [i for i in range(lo, hi + 1)]\n        \n        lst2 = []\n        for num in nums:\n            lst2.append((num, self.get_power(num)))\n            \n        lst2.sort(key = lambda x : x[1])\n        \n        return lst2[k - 1][0]\n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        def get_power(x:int, p:int) -> int:\n            while x != 1:\n                x = x //2 if x %2 == 0 else (3 * x) + 1\n                p += 1\n            return p\n        \n        dic = { x: get_power(x, 0) for x in range(lo, hi+1) }\n        return sorted(list(dic.items()), key=lambda x: x[1])[k-1][0]\n\n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        res = []\n        \n        def power(num):\n            if num == 2:\n                return 1\n            elif num % 2 == 0:\n                return 1 + power(num//2)\n            else:\n                return 1 + power((3*num)+1)\n            \n        dic = collections.defaultdict(list)\n        \n        for i in range(lo,hi+1):\n            dic[power(i)].append(i)\n            \n        for _,v in sorted(dic.items()):\n            res += v\n            # print(res,len(res),k)\n        \n        return res[k-1]\n", "class Solution:\n    def __init__(self):\n        self.memo = {}\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        power = [0 for i in range(lo, hi + 1)]\n        for i in range(lo, hi + 1):\n            if i in self.memo:\n                power[i - lo] = self.memo[i]\n            else:    \n                power[i - lo] = (self.get_power(i, 0), i)\n                self.memo[i] = power[i - lo]\n        \n        power.sort()\n        return power[k - 1][1]    \n        \n    def get_power(self, i, curr_pow):\n        if i == 1:\n            return curr_pow\n        if i % 2 == 0:\n            return self.get_power(i / 2, curr_pow + 1)\n        else:\n            return self.get_power((i - 1) / 2 * 3 + 2, curr_pow + 2)", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        @lru_cache(None)\n        def power(x):\n            if x == 1:\n                return 0\n            if x % 2 == 0:\n                return 1 + power(x // 2)\n            return 1 + power(3 * x + 1)\n\n        return sorted(list(range(lo, hi+1)), key=power)[k-1]\n            \n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        def power(x):\n            if x==1: return 0\n            if x%2==0:\n                return power(x>>1)+1\n            else:\n                return power(x*3+1)+1\n       \n        x=sorted([i for i in range(lo,hi+1)],key=power)\n        return x[k-1]", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        heap = []\n        for i in range(lo, hi+1):\n            power = self.computer_power(i)\n            heapq.heappush(heap, (power, i))\n        actual_power = -1\n        new_power = -1\n        actual_list = []\n        result = []\n        k_now = 1\n        while heap:\n            new_power, i = heapq.heappop(heap)\n            if k_now == k:\n                return i\n            k_now += 1\n            if new_power != actual_power:\n                actual_list.sort()\n                result = result + actual_list\n                actual_list = [i]\n            else:\n                actual_list.append(i)\n        if actual_list:\n            actual_list.sort()\n            result = result + actual_list\n        return result\n    \n    def computer_power(self, val):\n        if val == 1:\n            return 0\n        \n        if val % 2 == 0:\n            return 1 + self.computer_power(val // 2)\n        else:\n            return 1 + self.computer_power(3*val + 1)", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        dic = {}\n        for i in range(lo,hi+1):\n            power = self.findPower(i, 0)\n            dic[i] = power\n        sortedValue = sorted(list(dic.items()), key=lambda x:x[1])\n        return (sortedValue[k-1][0])\n    \n    def findPower(self, num, count):\n        if num == 1:\n            return count\n        elif num % 2 == 0:\n            return self.findPower(num//2, count+1)\n        else:\n            return self.findPower(3*num+1, count+1)\n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        def helper(num):\n            if(num == 1):\n                return 0\n            # if dp[num] != -1:\n            #     return dp[num]\n            if num%2 == 0:\n                return helper(num//2) + 1\n            else:\n                return helper((num*3)+1) + 1\n            # return dp[num]\n         \n        # dp = [-1 for i in range(1000000)]\n        # dp[1] = 0\n        res = []\n        for i in range(lo, hi+1):\n            res.append((helper(i), i))\n        res.sort()\n        return res[k-1][1]\n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        \n        len_powers = [0]*(hi-lo+1)\n        for n in range(lo,hi+1):\n            ls_power= [n] \n            while ls_power[-1]!=1:\n                #print(ls_power)\n                if ls_power[-1]%2==0:\n                    ls_power.append(ls_power[-1]//2)\n                else:\n                    ls_power.append(3*ls_power[-1]+1)\n            len_powers[n-lo] = len(ls_power)-1\n        return sorted(zip(range(lo,hi+1),len_powers),key = lambda x: [x[1],x[0]])[k-1][0] ", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        return sorted((get_power_value(x), x) for x in range(lo, hi + 1))[k - 1][1]\ndef get_power_value(x):\n    if x == 1:\n        return 0\n    return 1 + get_power_value(x / 2 if x % 2 == 0 else x * 3 + 1)", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        def transform(x):\n            steps = 0\n            while x != 1:\n                if x & 1 == 0:\n                    x //= 2\n                else:\n                    x = (3*x) + 1\n                steps += 1\n            \n            return steps\n        \n        arr = list(range(lo, hi + 1))\n        arr.sort(key = lambda x: (transform(x), x))\n        \n        return arr[k - 1]\n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        cache = [0] * 999999\n\n        for num in range(lo, hi + 1):\n            if cache[num] != 0:  # already visited\n                continue\n\n            path = [num]\n\n            while num != 1 and cache[num] == 0:\n                if num % 2 == 0:\n                    num //= 2\n                    path.append(num)\n                else:\n                    num = num * 3 + 1\n                    path.append(num)\n\n            # print(path)\n\n            for idx, n in enumerate(path):\n                if cache[n] != 0:\n                    break\n                cache[n] = len(path) - 1 - idx + cache[path[-1]]\n\n        res = [(i + lo, steps) for i, steps in enumerate(cache[lo:hi + 1])]\n        # print(res)\n        res = sorted(res, key=lambda _: _[1])\n        # print(res)\n        return res[k - 1][0]\n\n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        def find_power_value(n: int, steps: int) -> int:\n            if n == 2: return steps + 1\n            if n % 2 == 0:\n                return find_power_value(n // 2, steps + 1)\n            return find_power_value(3 * n + 1, steps + 1)\n        result = [ ]\n        for i in range(lo, hi + 1):\n            result.append((find_power_value(i, 0), i))\n        result.sort()\n        return result[k - 1][1]\n", "class Solution:\n    def getKth(self, lo, hi, k):\n        return sorted(range(lo, hi + 1), key='\u5bd2\u5bd2\u5bd3\u5bd9\u5bd4\u5bd7\u5bda\u5be2\u5bd5\u5be5\u5bd8\u5be0\u5bdb\u5bdb\u5be3\u5be3\u5bd6\u5bde\u5be6\u5be6\u5bd9\u5bd9\u5be1\u5be1\u5bdc\u5be9\u5bdc\u5c41\u5be4\u5be4\u5be4\u5c3c\u5bd7\u5bec\u5bdf\u5bdf\u5be7\u5be7\u5be7\u5bf4\u5bda\u5c3f\u5bda\u5bef\u5be2\u5be2\u5be2\u5c3a\u5bdd\u5bea\u5bea\u5bea\u5bdd\u5bdd\u5c42\u5c42\u5be5\u5bf2\u5be5\u5bf2\u5be5\u5be5\u5c3d\u5c3d\u5bd8\u5bed\u5bed\u5bed\u5be0\u5be0\u5be0\u5c38\u5be8\u5c45\u5be8\u5be0\u5be8\u5be8\u5bf5\u5bf5\u5bdb\u5be8\u5c40\u5c40\u5bdb\u5bdb\u5bf0\u5bf0\u5be3\u5bf0\u5be3\u5c2e\u5be3\u5be3\u5c3b\u5c3b\u5bde\u5c48\u5beb\u5beb\u5beb\u5beb\u5beb\u5c29\u5bde\u5bf8\u5bde\u5c36\u5c43\u5c43\u5c43\u5c17\u5be6\u5bde\u5bf3\u5bf3\u5be6\u5be6\u5bf3\u5bf3\u5be6\u5c31\u5be6\u5c00\u5c3e\u5c3e\u5c3e\u5c00\u5bd9\u5c4b\u5bee\u5bee\u5bee\u5bee\u5bee\u5bfb\u5be1\u5c2c\u5be1\u5bfb\u5be1\u5be1\u5c39\u5c39\u5be9\u5c46\u5c46\u5c46\u5be9\u5be9\u5be1\u5be1\u5be9\u5bf6\u5be9\u5c27\u5bf6\u5bf6\u5bf6\u5c08\u5bdc\u5c34\u5be9\u5be9\u5c41\u5c41\u5c41\u5c15\u5bdc\u5c03\u5bdc\u5c4e\u5bf1\u5bf1\u5bf1\u5c22\u5be4\u5bf1\u5bf1\u5bf1\u5be4\u5be4\u5c2f\u5c2f\u5be4\u5bfe\u5be4\u5bfe\u5c3c\u5c3c\u5c3c\u5bfe\u5bdf\u5c49\u5c49\u5c49\u5bec\u5bec\u5bec\u5c49\u5bec\u5be4\u5bec\u5bf9\u5bec\u5bec\u5c2a\u5c2a\u5bdf\u5bf9\u5bf9\u5bf9\u5bdf\u5bdf\u5c37\u5c37\u5c44\u5bec\u5c44\u5c06\u5c44\u5c44\u5c18\u5c18\u5be7\u5c06\u5bdf\u5bdf\u5bf4\u5bf4\u5bf4\u5c51\u5be7\u5c25\u5be7\u5c51\u5bf4\u5bf4\u5bf4\u5c06\u5be7\u5be7\u5c32\u5c32\u5be7\u5be7\u5c01\u5c01\u5c3f\u5c01\u5c3f\u5c13\u5c3f\u5c3f\u5c01\u5c01\u5bda\u5c4c\u5c4c\u5c4c\u5bef\u5bef\u5bef\u5c20\u5bef\u5c4c\u5bef\u5be7\u5bef\u5bef\u5bfc\u5bfc\u5be2\u5bef\u5c2d\u5c2d\u5be2\u5be2\u5bfc\u5bfc\u5be2\u5bfc\u5be2\u5c0e\u5c3a\u5c3a\u5c3a\u5bfc\u5bea\u5bef\u5c47\u5c47\u5c47\u5c47\u5c47\u5c09\u5bea\u5c1b\u5bea\u5c47\u5be2\u5be2\u5be2\u5bfc\u5bea\u5bf7\u5bf7\u5bf7\u5bea\u5bea\u5c28\u5c28\u5bf7\u5c54\u5bf7\u5bf7\u5bf7\u5bf7\u5c09\u5c09\u5bdd\u5bea\u5c35\u5c35\u5bea\u5bea\u5bea\u5c61\u5c42\u5c04\u5c42\u5bea\u5c42\u5c42\u5c16\u5c16\u5bdd\u5c42\u5c04\u5c04\u5bdd\u5bdd\u5c4f\u5c4f\u5bf2\u5c4f\u5bf2\u5c4f\u5bf2\u5bf2\u5c23\u5c23\u5be5\u5c4f\u5bf2\u5bf2\u5bf2\u5bf2\u5bf2\u5c04\u5be5\u5bff\u5be5\u5bff\u5c30\u5c30\u5c30\u5bff\u5be5\u5be5\u5bff\u5bff\u5be5\u5be5\u5bff\u5bff\u5c3d\u5c11\u5c3d\u5c0c\u5c3d\u5c3d\u5bff\u5bff\u5be0\u5bf2\u5c4a\u5c4a\u5c4a\u5c4a\u5c4a\u5c4a\u5bed\u5c0c\u5bed\u5c1e\u5bed\u5bed\u5c4a\u5c4a\u5bed\u5be5\u5be5\u5be5\u5bed\u5bed\u5bfa\u5bfa\u5bed\u5bfa\u5bed\u5c57\u5c2b\u5c2b\u5c2b\u5c57\u5be0\u5c57\u5bfa\u5bfa\u5bfa\u5bfa\u5bfa\u5bf2\u5be0\u5c0c\u5be0\u5c07\u5c38\u5c38\u5c38\u5bfa\u5c45\u5bed\u5bed\u5bed\u5c45\u5c45\u5c07\u5c07\u5c45\u5bed\u5c45\u5c07\u5c19\u5c19\u5c19\u5c33\u5be8\u5c45\u5c07\u5c07\u5be0\u5be0\u5be0\u5bfa\u5bf5\u5c52\u5bf5\u5c52\u5bf5\u5bf5\u5c52\u5c52\u5be8\u5bf5\u5c26\u5c26\u5be8\u5be8\u5c52\u5c52\u5bf5\u5bf5\u5bf5\u5bed\u5bf5\u5bf5\u5c07\u5c07\u5be8\u5c02\u5be8\u5be8\u5c33\u5c33\u5c33\u5c5f\u5be8\u5c02\u5be8\u5c5f\u5c02\u5c02\u5c02\u5c33\u5c40\u5be8\u5c02\u5c02\u5c40\u5c40\u5c14\u5c14\u5c40\u5c0f\u5c40\u5bf5\u5c02\u5c02\u5c02\u5c0f\u5bdb\u5bf5\u5c4d\u5c4d\u5c4d\u5c4d\u5c4d\u5c0f\u5bf0\u5c4d\u5bf0\u5c4d\u5bf0\u5bf0\u5c21\u5c21\u5bf0\u5bf0\u5c4d\u5c4d\u5bf0\u5bf0\u5be8\u5be8\u5bf0\u5be8\u5bf0\u5c02\u5bfd\u5bfd\u5bfd\u5c5a\u5be3\u5bfd\u5bf0\u5bf0\u5c2e\u5c2e\u5c2e\u5bfd\u5be3\u5c5a\u5be3\u5bf0\u5bfd\u5bfd\u5bfd\u5c29\u5be3\u5bfd\u5bfd\u5bfd\u5be3\u5be3\u5c0f\u5c0f\u5c3b\u5c0a\u5c3b\u5bf0\u5c3b\u5c3b\u5bfd\u5bfd\u5beb\u5bf0\u5bf0\u5bf0\u5c48\u5c48\u5c48\u5bf0\u5c48\u5c0a\u5c48\u5c48\u5c48\u5c48\u5c0a\u5c0a\u5beb\u5c1c\u5c1c\u5c1c\u5beb\u5beb\u5c48\u5c48\u5be3\u5c0a\u5be3\u5c17\u5be3\u5be3\u5bfd\u5bfd\u5beb\u5c55\u5bf8\u5bf8\u5bf8\u5bf8\u5bf8\u5c17\u5beb\u5c55\u5beb\u5c55\u5c29\u5c29\u5c29\u5c55\u5bf8\u5beb\u5c55\u5c55\u5bf8\u5bf8\u5bf8\u5bf8\u5bf8\u5bf0\u5bf8\u5bf0\u5c0a\u5c0a\u5c0a\u5c55\u5bde\u5c05\u5beb\u5beb\u5c36\u5c36\u5c36\u5bf8\u5beb\u5c62\u5beb\u5c36\u5beb\u5beb\u5c62\u5c62\u5c43\u5c05\u5c05\u5c05\u5c43\u5c43\u5beb\u5beb\u5c43\u5c05\u5c43\u5c62\u5c17\u5c17\u5c17\u5c31\u5bde\u5c12\u5c43\u5c43\u5c05\u5c05\u5c05\u5c12\u5bde\u5c12\u5bde\u5bf8\u5c50\u5c50\u5c50\u5bf8\u5bf3\u5c50\u5c50\u5c50\u5bf3\u5bf3\u5c50\u5c50\u5bf3\u5c50\u5bf3\u5c12\u5c24\u5c24\u5c24\u5c7c\u5be6\u5bf3\u5c50\u5c50\u5bf3\u5bf3\u5bf3\u5c12\u5bf3\u5beb\u5bf3\u5beb\u5bf3\u5bf3\u5c05\u5c05\u5be6\u5c00\u5c00\u5c00\u5be6\u5be6\u5c00\u5c00\u5c31\u5bf3\u5c31\u5c5d\u5c31\u5c31\u5c00\u5c00\u5be6\u5c5d\u5be6\u5be6\u5c00\u5c00\u5c00\u5c31\u5be6\u5c2c\u5be6\u5c00\u5c00\u5c00\u5c00\u5c5d\u5c3e\u5be6\u5c12\u5c12\u5c3e\u5c3e\u5c0d\u5c0d\u5c3e\u5bf3\u5c3e\u5c6a\u5c00\u5c00\u5c00\u5c0d\u5be1\u5bf3\u5bf3\u5bf3\u5c4b\u5c4b\u5c4b\u5c6a\u5c4b\u5bf3\u5c4b\u5c0d\u5c4b\u5c4b\u5c4b\u5c4b\u5bee\u5c4b\u5c0d\u5c0d\u5bee\u5bee\u5c1f\u5c1f\u5bee\u5c1f\u5bee\u5c39\u5c4b\u5c4b\u5c4b\u5c1a\u5bee\u5c0d\u5be6\u5be6\u5be6\u5be6\u5be6\u5c1a\u5bee\u5c00\u5bee\u5c58\u5bfb\u5bfb\u5bfb\u5c58\u5bee\u5bfb\u5bfb\u5bfb\u5bee\u5bee\u5c58\u5c58\u5c2c\u5c58\u5c2c\u5bfb\u5c2c\u5c2c\u5c58\u5c58\u5be1\u5bee\u5c58\u5c58\u5bfb\u5bfb\u5bfb\u5c27\u5bfb\u5bfb\u5bfb\u5bfb\u5bfb\u5bfb\u5bf3\u5bf3\u5be1\u5c0d\u5c0d\u5c0d\u5be1\u5be1\u5c08\u5c08\u5c39\u5bee\u5c39\u5c65\u5c39\u5c39\u5bfb\u5bfb\u5c46\u5c65\u5bee\u5bee\u5bee\u5bee\u5bee\u5c84\u5c46\u5c65\u5c46\u5bee\u5c08\u5c08\u5c08\u5c65\u5c46\u5c46\u5bee\u5bee\u5c46\u5c46\u5c08\u5c08\u5c1a\u5c65\u5c1a\u5c00\u5c1a\u5c1a\u5c34\u5c34\u5be9\u5c15\u5c46\u5c46\u5c08\u5c08\u5c08\u5c46\u5be1\u5c15\u5be1\u5c08\u5be1\u5be1\u5bfb\u5bfb\u5bf6\u5c53\u5c53\u5c53\u5bf6\u5bf6\u5c53\u5c53\u5bf6\u5c53\u5bf6\u5c15\u5c53\u5c53\u5c53\u5c46\u5be9\u5c53\u5bf6\u5bf6\u5c27\u5c27\u5c27\u5c53\u5be9\u5c7f\u5be9\u5c27\u5c53\u5c53\u5c53\u5bf6\u5bf6\u5bf6\u5bf6\u5bf6\u5bf6\u5bf6\u5bee\u5bee\u5bf6\u5bee\u5bf6\u5bee\u5c08\u5c08\u5c08\u5c53\u5be9\u5c03\u5c03\u5c03\u5be9\u5be9\u5be9\u5c60\u5c34\u5c03\u5c34\u5bf6\u5c34\u5c34\u5c60\u5c60\u5be9\u5c34\u5c03\u5c03\u5be9\u5be9\u5c60\u5c60\u5c03\u5be9\u5c03\u5bf6\u5c03\u5c03\u5c34\u5c34\u5c41\u5c2f\u5be9\u5be9\u5c03\u5c03\u5c03\u5c03\u5c41'.__getitem__)[k - 1]", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        memo = { 1:0 } # Exit Condition Stored in Memory\n        def power(x):\n            if x in memo:\n                return memo[x]\n            n = memo[x] = 1 + power( (3*x+1) if x&1 else (x >> 1) )\n            return n\n        ans = [(x,power(x)) for x in range(lo,hi+1)]\n        sorted_ans = sorted(ans , key = lambda t:t[1])\n        return sorted_ans[k-1][0]\n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        def process(x, nsteps):\n            if x==2:\n                return nsteps\n            elif x%2==0:\n                return process(x//2, nsteps+1)\n            else:\n                return process(x*3+1, nsteps+1)\n            \n        sol = []\n        for i in range(lo, hi+1):\n            sol.append((process(i, 0), i))\n        sol.sort()\n        # print (sol)\n        return sol[k-1][1]\n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        g={}\n        for i in range(lo,hi+1):\n            p=self.power(i,0)\n            g[i]=p\n        s=sorted(list(g.items()),key=lambda x:x[1])\n        return(s[k-1][0])\n    def power(self, num, count):\n        if num == 1:\n            return count\n        elif num % 2 == 0:\n            return self.power(num//2, count+1)\n        else:\n            return self.power(3*num+1, count+1)\n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        x = {}\n        for i in range(lo, hi+1):\n            j = []\n            g = i\n            while i != 1:\n                if i % 2 == 0:\n                    i = i /2\n                    j.append(i)\n                else:\n                    i = 3 * i + 1\n                    j.append(i)\n            x[g] = len(j)\n        x = sorted(x, key = x.get)\n        return x[k-1]", "class Solution:\n    def transform(self, num, count = 0):\n        if num == 1:\n            return count\n        else:\n            if num%2 == 0:\n                return self.transform(num//2, count + 1)\n            else:\n                return self.transform(num * 3 + 1, count + 1)\n\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        p_list = []\n        for i in range(lo, hi + 1):\n            p_list.append((self.transform(i), i))\n        \n        p_list.sort()\n        \n        return p_list[k-1][1]", "class Solution:\n        def getKth(self, lo: int, hi: int, k: int) -> int:\n                def getPower(num: int) -> int:\n                        if num == 1: return 0\n                        if num % 2 == 0: return 1 + getPower(num // 2)\n                        if num % 2 == 1: return 1 + getPower(3 * num + 1)\n                powers = []\n                for cand in range(lo, hi + 1):\n                        powers.append((cand, getPower(cand)))\n                powers = sorted(powers, key=lambda x: x[1])\n                return powers[k - 1][0]", "from collections import defaultdict\nclass Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        adj=defaultdict(set)\n        po = dict()\n        for i in range(lo,hi+1):\n            temp=0\n            curr=i\n            while curr!=1:\n                if curr&1:\n                    child=curr*3+1\n                else:\n                    child=curr//2\n                adj[curr].add(child)\n                curr=child\n                temp+=1\n            po[i]=temp\n        \n        res=sorted(po.items(),key = lambda x : x[1])\n        return res[k-1][0]", "import heapq\nclass Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        def power(num,cou=0):\n            if num==1:\n                return cou\n            if num%2==0:\n                num=num//2\n                return power(num,cou+1)\n            else:\n                num=(3*num)+1\n                return power(num,cou+1)\n        arr=[]\n        while(lo<=hi):\n            j=power(lo)\n            heapq.heappush(arr,(-j,-lo))\n            if len(arr)>k:\n                heapq.heappop(arr)\n            lo+=1\n        return -heapq.heappop(arr)[1]", "class Solution:\n    def getKth(self, lo, hi, k):\n        memo = { 1:0 }\n        def power(x):\n            if x in memo:\n                return memo[x]\n            memo[x] = res = 1 + power( (3*x+1) if x&1 else (x >> 1) )\n            return res\n        A = [ (power(x),x) for x in range(lo,hi+1) ]\n        return sorted(A)[k-1][1]\n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        def key_func(val):\n            def recur(val):\n                if val <= 1:\n                    return 0\n                if val % 2 == 0:\n                    return recur(val / 2) + 1\n                return recur((val * 3) + 1) + 1\n            return recur(val)\n        out = [i for i in range(lo, hi+1)]\n        out.sort(key=key_func)\n        return out[k-1]\n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        output = {}\n        for i in range(lo,hi+1):\n            a = i\n            counter = 0\n            while i > 1:\n                if i%2 == 0:\n                    i  = i/2\n                else:\n                    i = 3*i + 1\n                counter += 1\n            output[a] = counter\n        output = sorted(output.items(), key=lambda x: x[1])\n        return output[k-1][0]", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        d={}\n        def helper(i):\n            if i==1:\n                return 0\n            if i in d:\n                return d[i]\n            if i%2==0:\n                return 1+helper(i//2)\n            else:\n                return 1+helper(3*i+1)\n        ans=[[helper(i),i] for i in range(lo,hi+1)]\n        ans.sort()\n        return ans[k-1][1]", "class Solution:\n        def getKth(self, lo: int, hi: int, k: int) -> int:\n                def getPower(num: int) -> int:\n                        if num == 1: return 0\n                        if num % 2 == 0: return 1 + getPower(num // 2)\n                        if num % 2 == 1: return 1 + getPower(3 * num + 1)\n\n                powers = []\n                for cand in range(lo, hi + 1):\n                        powers.append((cand, getPower(cand)))\n\n                powers = sorted(powers, key=lambda x: x[1])\n                return powers[k - 1][0]", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        \n        st = [0]*(hi+1-lo)\n        std={}\n        \n        for x in range(lo,hi+1):\n            i=x\n            while (x!=1):\n                \n                st[i-lo]+=1\n                \n                if x%2 == 0:\n                    x=x/2\n                else:\n                    x = 3*x+1\n                    \n            #std[st[i-lo]] = [i]\n            if st[i-lo] in list(std.keys()):\n                std[st[i-lo]].append(i) \n            else:\n                std[st[i-lo]] = [i]\n                \n        s_val = sorted(list(std.keys()))\n        ans = std[s_val[0]]    \n        for i in range(1,len(s_val)):\n            ans = ans + std[s_val[i]]\n\n        return ans[k-1]\n                \n            \n            \n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        def find_transform(x):\n            k = [x]\n            while k[-1] != 1:\n                if x%2 == 0:\n                    x = x/2\n                    k.append(x)\n                else:\n                    x = x*3 + 1\n                    k.append(x)\n            return len(k)-1\n        #l = [i for i in range(lo,hi+1)]\n        power = []\n        for i in range(lo,hi+1):\n            power.append([i,find_transform(i)])\n        return sorted(power,key=lambda x : x[1])[k-1][0]", "class Solution:\n    #calc=[]\n    def findPower(self,ele):\n        self.calc=[]\n        ctr=0\n        while ele!=1:\n            if ele%2==0:\n                ele=ele//2\n            else:\n                ele=3*ele+1\n            self.calc.append(ele)\n            ctr +=1\n        return ctr\n            \n            \n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        powmat=[]\n        for i in range(lo,hi+1):\n            ct=self.findPower(i)\n            powmat.append([ct,i])\n        powmat.sort()\n        print(powmat)\n        return powmat[k-1][1]", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        # use DP to cut down on calculation time\n        # 1 = 1\n        # 2 = 2, 1\n        # 3 = 3, 10, 5, 16, 8, 4, 2, 1\n        # 4 = 4, 2, 1\n        # 5 = 5, 16, 8, 4, 2, 1\n        # 6 = 6, 3\n        \n        dp_steps = {}\n        \n        def find_power(n: int) -> int:\n            if n in dp_steps:\n                return dp_steps[n]\n            elif n == 1:\n                return 0\n            else:\n                if n % 2 == 0:\n                    return 1 + find_power(n//2)\n                else:\n                    return 1 + find_power(n * 3 + 1)                \n        \n        results = []\n        for i in range(lo, hi+1):\n            results.append((find_power(i), i))\n        results.sort()\n        return results[k-1][1]", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        degree_cache = {}\n        \n        def find_degree(n, degree=0):\n            if n == 1:\n                return degree\n            # if n in degree_cache:\n            #     return degree_cache[n]\n\n            if n % 2 == 0:\n                degree = find_degree(n//2, degree + 1)\n            else:\n                degree = find_degree(n*3+1, degree + 1)\n            return degree\n        d = {}\n        for i in range(lo, hi+1):\n            d[i] = find_degree(i, 0)\n        sd = sorted(d.items(), key=lambda x: (x[1], x[0]))\n        return sd[k-1][0]", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        def getPower(n):\n            if n == 1: return 0\n            return (getPower(3 * n + 1) if n % 2 else getPower(n / 2)) + 1\n        powers = sorted([(i, getPower(i)) for i in range(lo, hi + 1)], key=lambda x:(x[1], x[0]))            \n        return powers[k - 1][0]", "from collections import defaultdict\n\ndef getPower(i):\n    if i==1:\n        return 0\n    if i%2==0:\n        return getPower(i/2) + 1\n    else:\n        return getPower(i*3+1) + 1\n\nclass Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        d=defaultdict(int)\n        for i in range(lo, hi+1):\n            d[i]=getPower(i)\n        sd={k: v for k, v in sorted(list(d.items()), key=lambda item: item[1])}\n        \n        return list(sd)[k-1]\n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        power_dic = {}\n        powers = []\n        for num in range(lo, hi+1):\n            powers.append([self.powerOf(num, 0, power_dic), num])\n        return sorted(powers, key=lambda x:x[0])[k-1][1]\n            \n    \n    \n    def powerOf(self, x, steps, power_dic):\n        if x==1:\n            return steps\n        if x&1 == 0:\n            return self.powerOf(x//2, steps+1, power_dic)\n        else:\n            return self.powerOf(3*x+1, steps+1, power_dic)\n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        track = []\n        for i in range (lo, hi+1):\n            power = 0\n            x = i\n            while (i != 1):\n                if (i % 2 == 0):\n                    i = i // 2\n                else:\n                    i = 3 * i + 1\n                power += 1\n            track.append([x, power])\n        \n        sorted_tr = sorted(track, key=lambda x: [x[1], x[0]])\n        print(sorted_tr)\n        return sorted_tr[k-1][0]\n        \n        \n        \n    def getPower (self, c, n):\n        if (int(n) == 1):\n            return c\n        elif (n % 2 == 0):\n            self.getPower(c+1, n / 2)\n        else:\n            self.getPower(c+1, 3 * n + 1)", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        d={}\n        for n in range(lo,hi+1):\n            count = 0\n            p=n\n            while(n!=1):\n                if n%2==0:\n                    n=n/2\n                    count=count+1\n                elif n%2==1:\n                    n=3*n+1\n                    count=count+1\n            d[p]=count\n        return sorted(list(d.items()),key = lambda x:x[1])[k-1][0]\n                \n", "class Solution:\n    def getKth(self, lo, hi, k):\n        #\n        memo = { 1:0 }\n        def power(x):\n            if x in memo:\n                return memo[x]\n            n = memo[x] = 1 + power( (3*x+1) if x&1 else (x >> 1) )\n            return n\n        #\n        A = [ (power(x),x) for x in range(lo,hi+1) ]\n        return sorted(A)[k-1][1]\n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        def getPower(n):\n            step = 0\n            while n != 1:\n                if n%2 == 0: n = int(n/2)\n                else: n = n*3+1\n                step += 1\n            return step\n        ans = []\n        for i in range(lo, hi+1):\n            ip = getPower(i)\n            ans.append((ip, i))\n        # print(ans)\n        ans.sort()\n        return ans[k-1][1]\n        \n        \n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        nums = []\n        for i in range(lo, hi + 1):\n            temp, steps = i, 0\n            while temp != 1:\n                if temp % 2 == 0: temp //= 2\n                else: temp = 3 * temp + 1\n                steps += 1\n            nums.append([i, steps])\n        nums = sorted(nums, key=lambda n: n[1])\n        return nums[k - 1][0]", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        \n        d = {}\n        def steps(num, level):\n#             if num in d:\n#                 return d[num] + level\n            \n#             d[num] = level\n            if num==1:\n                return level\n            if num%2==0:\n                return steps(num/2, level+1)\n            else:\n                return steps(3*num+1, level+1)\n            \n        ans = [(steps(x,0), x) for x in range(lo,hi+1)]\n        ans.sort()\n        return ans[k-1][-1]", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        a=[i for i in range(lo,hi+1)]\n        z=[]\n        def cv(s,c):\n            if s%2==0:\n                s=s/2\n            else:\n                s=3*s+1\n            c=c+1\n            if s==1:\n                return c\n            return cv(s,c)\n        for i in a:\n            c=0\n            b=cv(i,c)\n            z.append([b,i])\n        z.sort(key=lambda x:x[0])\n        a=[]\n        for i in z:\n            a.append(i[1])\n        return a[k-1]  \n        \n           \n            \n        \n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:  \n        dict = defaultdict()\n        def weight(x):\n           if(x==1):\n               return 1\n           if(x%2==0):\n               return 1+weight(x//2);\n           else:\n               return 1+ weight(3*x+1)\n        \n        for i in range(lo, hi+1):\n            dict[i] = weight(i)\n           \n        dict = sorted(list(dict.items()),key=lambda x:x[1])\n        return dict[k-1][0]\n    \n        \n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        \n        def collatz(num, moves = 0):\n            if num == 1:\n                return moves\n            if num % 2 == 0:\n                return collatz(num / 2, moves + 1)\n            else:\n                return collatz(num * 3 + 1, moves + 1)\n        \n        arr = [(i, collatz(i)) for i in range(lo, hi + 1)]\n        arr.sort(key=lambda x:x[1])\n        \n        print(arr)\n        \n        return arr[k-1][0]", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        a=[i for i in range(lo,hi+1)]\n        z=[]\n        def cv(s,c):\n            if s%2==0:\n                s=s/2\n            else:\n                s=3*s+1\n            c=c+1\n            if s==1:\n                return c\n            return cv(s,c)\n        for i in a:\n            c=0\n            a=cv(i,c)\n            z.append([a,i])\n        z.sort(key=lambda x:x[0])\n        a=[]\n        for i in z:\n            a.append(i[1])\n        return a[k-1]  \n        \n           \n            \n        \n", "class Solution:\n    def getKth(self, lo, hi, k):\n        #\n        memo = { 1:0 }\n        def power(x):\n            if x in memo:\n                return memo[x]\n            n = memo[x] = 1 + power( 3*x+1 if x&1 else x>>1 )\n            return n\n        #\n        A = [ (power(x),x) for x in range(lo,hi+1) ]\n        return sorted(A)[k-1][1]", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        a=[i for i in range(lo,hi+1)]\n        z=[]\n        def cv(s,c):\n            if s%2==0:\n                s=s/2\n            else:\n                s=3*s+1\n            c=c+1\n            if s==1:\n                return c\n            return cv(s,c)\n        for i in a:\n            c=0\n            a=cv(i,c)\n            z.append([a,i])\n        z.sort(key=lambda x:x[1])\n        z.sort(key=lambda x:x[0])\n        a=[]\n        for i in z:\n            a.append(i[1])\n        return a[k-1]  \n        \n           \n            \n        \n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        #if lo == hi:\n         #   return lo\n        \n        ans = []\n        for i in range(lo, hi+1):\n            num = i\n            ctr = 0\n            while num != 1:\n                if num % 2 != 0: #odd\n                    num = (num * 3) + 1\n                else:\n                    num = num/2\n                ctr+=1\n            ans.append((ctr, i))\n            \n        return sorted(ans, key = lambda x: x[0])[k-1][1]\n            \n                \n", "class Solution:\n    def getKth(self, lo: int, hi: int, z: int) -> int:\n        d={}\n        def dfs(k):\n            if k==1:\n                return\n            elif k%2==0:\n                c[0]+=1\n                dfs(k//2)\n            else:\n                c[0]+=1\n                dfs(3*k+1)\n        for i in range(lo,hi+1):\n            c=[0]\n            dfs(i)\n            d[i]=c[0]\n        \n        d=sorted(list(d.items()),key=lambda g:g[1])\n        \n        return d[z-1][0]\n            \n", "class Solution:\n    \n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        def step(n,i) -> int:\n            s=0\n            while n!=1:\n                if n%2==0: \n                    n=n/2\n                else:\n                    n=n*3+1\n                s+=1\n            return s\n\n        a = 0\n        l = []\n        for i in range(lo,hi+1):\n            a = step(i,0)\n            l.append((i,a))\n            \n        l = sorted(l,key=lambda x:x[1])    \n        return l[k-1][0]", "class PowerValue(tuple):\n    def __lt__(x, y):\n        \n        return x[1] < y[1] if x[1] != y[1] else x[0] < y[0]\n    \n\n        \nclass Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        all_val = [i for i in range(lo, hi+1)]\n        pow_values = []\n        \n        def power(val):\n            if val == 1:\n                return 0\n\n            if val % 2 == 0:\n                val = val // 2\n            else:\n                val = (3 * val + 1)\n        \n            return 1 + power(val)\n        \n        for num in all_val:\n            get_pow = power(num)\n            pow_values.append((get_pow, num))\n        pow_values.sort()\n        \n        return pow_values[k-1][1]\n        \n        \n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        def distance(n):\n            if n == 1:\n                return 0\n            \n            new_n = n // 2 if n % 2 == 0 else n * 3 + 1\n            return 1 + distance(new_n)\n            \n        nums = list(range(lo, hi + 1))\n        nums.sort(key=lambda x: (distance(x), x))\n        return nums[k - 1]", "from functools import cmp_to_key\n\nclass Solution:\n    def getPower(self, number):\n        if number == 1:\n            return 0\n        if number % 2 == 0:\n            return 1 + self.getPower(number / 2)\n        else:\n            return 1 + self.getPower(number * 3 + 1)\n    \n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        a = []\n        for i in range(lo, hi + 1):\n            a.append((i, self.getPower(i)))\n        a = sorted(a, key=cmp_to_key(\n            lambda x, y: x[1] - y[1] if x[1] != y[1] else x[0] - y[0]))\n        print(a)\n        return a[k-1][0]", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        \n        def get_power_of_element(x):\n            if x == 1:\n                return 0\n            elif x % 2 == 0:\n                x = x/2\n                return 1+get_power_of_element(x)\n            elif x % 2 != 0:\n                x = 3*x + 1\n                return 1+get_power_of_element(x)\n        \n        array_of_numbers = [x for x in range(lo, hi+1)]\n        array_of_values = []\n        for i in array_of_numbers:\n            k_value = get_power_of_element(i)\n            array_of_values.append((k_value, i))\n\n        array_of_values.sort(key=lambda x: x[0])\n        \n        return array_of_values[k-1][1]\n        \n", "class Solution:\n    def getKth(self, lo, hi, k):\n        #\n        memo = { 1:0 }\n        def power(x):\n            if x in memo:\n                return memo[x]\n            n = memo[x] = 1 + power( 3*x+1 if x&1 else x >> 1 )\n            return n\n        #\n        A = [ (power(x),x) for x in range(lo,hi+1) ]\n        return sorted(A)[k-1][1]", "from collections import defaultdict\nclass Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        d = defaultdict(list)\n        for integer in range(lo, hi + 1):\n            res = integer\n            cnt = 0\n            while res != 1:\n                if res % 2 == 0:\n                    res /= 2\n                elif res %2 == 1:\n                    res = res * 3 + 1\n                cnt += 1\n            d[cnt].append(integer)\n        keys = sorted(d.keys())\n        ans = []\n        for key in keys:\n            ans += sorted(d[key])\n        return ans[k-1]", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        track = dict()\n        for i in range (lo, hi+1):\n            power = 0\n            x = i\n            while (i != 1):\n                if (i % 2 == 0):\n                    i = i // 2\n                else:\n                    i = 3 * i + 1\n                power += 1\n            track[x] = power\n        \n        sorted_tr = sorted(track.items(), key=lambda x: [x[1], x[0]])\n        print(sorted_tr)\n        return sorted_tr[k-1][0]", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        ans = []\n        for nn in range(lo,hi+1):\n            ans.append([nn,self.powerVal(nn)])\n        ans = sorted(ans,key=lambda x:x[1])\n        return ans[k-1][0]\n        \n    def powerVal(self, num):\n        count = 0 \n        while num>1:\n            if num%2==0:\n                num = num/2\n            else:\n                num = 3*num+1\n            count +=1\n        return count", "class Solution:\n    \n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        def step(n,i) -> int:\n            i = i + 1\n            if n == 1:\n                return i - 1\n\n            if n % 2:\n                i = step(3*n+1,i)\n            else:\n                i = step(n//2,i)\n            return i\n\n        a = 0\n        l = []\n        for i in range(lo,hi+1):\n            a = step(i,0)\n            l.append((i,a))\n            \n        l = sorted(l,key=lambda x:x[1])    \n        return l[k-1][0]", "\nclass Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        #return sorted(map(lambda x: (self.myfunc(x),x), range(lo,hi+1)) )[k-1][1]\n        return sorted([(self.recursive(x,0,{}),x) for x in range(lo,hi+1)] )[k-1][1]\n\n\n    \n    def recursive(self, x, count,memo):\n        if x in memo:\n            return memo[x]\n        elif x==1:\n            memo[x]=count\n            return count\n        elif x%2==0:\n            return self.recursive(x/2, count+1, memo)\n        else:\n            return self.recursive(3*x+1, count+1, memo)\n        \n        \n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        a=[i for i in range(lo,hi+1)]\n        z=[]\n        def cv(s,c):\n            if s==1:\n                c=c+1\n                return c\n            if s%2==0:\n                s=s/2\n            else:\n                s=3*s+1\n            c=c+1\n            if s==1:\n                return c\n            return cv(s,c)\n        for i in a:\n            c=0\n            b=cv(i,c)\n            z.append([b,i])\n        z.sort(key=lambda x:x[0])\n        a=[]\n        for i in z:\n            a.append(i[1])\n        return a[k-1]  \n        \n           \n            \n        \n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        d=dict()\n        for i in range(lo,hi+1):\n            a=i\n            c=0\n            while(a>1):\n                if(a%2==0):\n                    a=a/2\n                    c+=1\n                else:\n                    a=3*a+1\n                    c+=1\n            d[i]=c\n        res=sorted(list(d.items()), key=lambda x:x[::-1])\n        return(res[k-1][0])\n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        res = []\n        for num in range(lo, hi + 1):\n            var = num\n            count = 0\n            while num != 1:\n                if num % 2 == 0:\n                    num = num / 2\n                else:\n                    num = 3 * num + 1\n                count += 1\n            res.append([count, var])\n        res.sort()\n        return res[k-1][1]\n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        # make list from lo to hi\n        input = list(range(lo, hi+1))\n        \n        output = []\n        \n        def getPower(val, currPower):\n            if val == 1:\n                output.append(currPower)\n                return None\n            elif val % 2 == 0:\n                # if even divide by 2, add to power, and recurse\n                val /= 2\n                currPower += 1\n                getPower(val, currPower)\n            else:\n                val = (3 * val) + 1\n                currPower += 1\n                getPower(val, currPower)\n        \n        # match output with input in sorted order\n        outputDict = dict.fromkeys(input, 0)\n        \n        # get the power of each input number\n        for num in input:\n            getPower(num, 0)\n\n        for keys, vals in enumerate(outputDict.keys()):\n            outputDict[vals] = output[keys]\n        \n        outputDict = sorted((value, key) for (key, value) in outputDict.items())\n        \n        # return the kth value from input\n        return outputDict[k-1][1]", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        \n        cache = {1:0}\n        \n        \n        def power(n):\n            \n            if n in cache:\n                return cache[n]\n            \n            if n & 1:\n                cache[n] = 1 + power(3*n+1)\n                return cache[n]\n        \n            else:\n                cache[n] = 1 + power(n//2)\n                return cache[n]\n            \n            \n        out = []\n        for i in range(lo, hi+1):\n            out.append([i, power(i)])\n            \n        out.sort(key= lambda x:x[1])\n        \n        return out[k-1][0]\n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        def BFS(queue):\n            while queue:\n                var , level = queue.popleft()\n                if var == 1:return level\n                if var % 2:queue.append([3*var+1,level+1])\n                else:queue.append([var/2,level+1])\n        ans = []\n        for i in range(lo,hi+1):\n            ans.append((i,BFS(deque([[i,0]]))))\n        ans = sorted(ans,key = lambda l:l[1])\n        return ans[k-1][0]", "def power_value(num: int, counter = 0):\n    if num % 2 ==0:\n        num = num /2\n    else:\n        num = 3*num + 1\n    \n    counter +=1\n    if num == 1:\n        return counter\n    else:\n        return power_value(num, counter=counter)\n\n\nclass Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        \n        to_sort = []\n        for i in range(lo, hi + 1):\n            to_sort.append([i, power_value(i)])\n            \n        \n        to_sort = sorted(to_sort, key=lambda x: x[1])\n        \n        return to_sort[k-1][0]\n            \n", "class Solution:\n    def powerValue(self, n):\n        count = 0\n        while n != 1:\n            if n%2==0:\n                n = n/2\n            else:\n                n = (3*n)+1\n            \n            count+=1\n        return count\n    \n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        minHeap = []\n        \n        for i in range(lo,hi+1):\n            heapq.heappush(minHeap,(self.powerValue(i),i))\n        \n        i = 1\n        \n        while i < k:\n            heapq.heappop(minHeap)\n            i+=1\n        return minHeap[0][1]", "class Solution:\n    def getKth(self, lo: int, hi: int, m: int) -> int:\n        a=[i for i in range(lo,hi+1)]\n        z=[]\n        def cv(s,c,k):\n            if s in k:\n                k[s]=k[s]+1\n            elif s%2==0:\n                s=s/2\n                c=c+1\n            else:\n                s=3*s+1\n                c=c+1\n            if s==1:\n                return list(k.values()),c\n            return cv(s,c,k)\n        for i in a:\n            c=0\n            k={}\n            b,f=cv(i,c,k)\n            z.append([sum(b)+f,i])\n        z.sort(key=lambda x:x[0])\n        a=[]\n        for i in z:\n            a.append(i[1])\n        return a[m-1]  \n        \n           \n            \n        \n", "class Solution:\n    def getKth(self, lo: int, hi: int, m: int) -> int:\n        a=[i for i in range(lo,hi+1)]\n        z=[]\n        def cv(s,c,k):\n            if s in k:\n                k[s]=k[s]+1\n            elif s%2==0:\n                s=s/2\n                c=c+1\n            else:\n                s=3*s+1\n                c=c+1\n            if s==1:\n                return sum(k.values()),c\n            return cv(s,c,k)\n        for i in a:\n            c=0\n            k={}\n            b=cv(i,c,k)\n            z.append([b,i])\n        z.sort(key=lambda x:x[0])\n        a=[]\n        for i in z:\n            a.append(i[1])\n        return a[m-1]  \n        \n           \n            \n        \n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        \n        def get_power_of_element(x):\n            if x == 1:\n                return 0\n            elif x % 2 == 0:\n                x = x/2\n                return 1+get_power_of_element(x)\n            elif x % 2 != 0:\n                x = 3*x + 1\n                return 1+get_power_of_element(x)\n        \n        array_of_numbers = [x for x in range(lo, hi+1)]\n        hash_map = {}\n        for i in array_of_numbers:\n            k_value = get_power_of_element(i)\n            hash_map[i] = k_value\n\n        array_of_values = [(y, x) for x, y in list(hash_map.items())]\n        array_of_values.sort(key=lambda x: x[0])\n        \n        return array_of_values[k-1][1]\n        \n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n     \n        p={}\n        for i in range(lo, hi+1):\n            temp=0\n            copy_i=i\n            if copy_i==1:\n                p[i]=0\n            while (copy_i!=1):\n                if copy_i %2==0:\n                    copy_i /=2\n                    temp+=1\n                    if copy_i==1:\n                        p[i]=temp\n                        break\n                if copy_i %2 !=0:\n                    copy_i= 3*copy_i + 1\n                    temp+=1\n                    if copy_i==1:\n                        p[i]=temp\n                        break\n        print('p is')\n        print(p)\n        p=sorted(list(p.items()), key=lambda x:x[1])\n        track=0\n        for ele in p:\n            track+=1\n            if track==k:\n                return ele[0]\n", "class Solution:\n\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        dic = {}\n        for i in range(lo, hi+1):\n            z = self.getTheP(i)\n            dic[i] = self.getTheP(i)\n        return sorted(list(dic.items()), key=lambda x:(x[1],x[0]))[k-1][0]\n            \n    def getTheP(self, q: int) -> int:\n        Pow = 0\n        while (q!= 1):\n            if(q%2 == 0):\n                q = (q/2)\n                Pow+=1\n            else:\n                q=(3*q+1)\n                Pow+=1\n        return Pow        \n        \n        \n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        \n        \n        ans=[]\n        for x in range(lo,hi+1):\n            count=0\n            num=x\n            while x>1:\n\n                if x%2==0:\n                    x=x/2\n                else:\n                    x=3*x+1\n                count+=1\n            heapq.heappush(ans,[count,num])\n        \n     \n        return (heapq.nsmallest(k,ans)[-1][-1])\n    \n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        def getPower(n):\n            return 0 if n == 1 else (getPower(3 * n + 1) if n % 2 else getPower(n / 2)) + 1\n        return sorted(range(lo, hi + 1), key=getPower)[k - 1]", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        i = 0\n        pow2Dict = {1:0}\n        pow2Now = 1\n        while i < 32:\n            i += 1\n            pow2Now *= 2\n            pow2Dict[pow2Now] = i\n        \n        visited = {}\n        \n        stack = [(0, i, i) for i in range(lo, hi+1)]\n        \n        while stack:\n            stepNow, numNow, numOrigin = heapq.heappop(stack)\n            if numNow in pow2Dict:\n                visited[numOrigin] = stepNow + pow2Dict[numNow]\n            else:\n                if numNow in visited:\n                    visited[numOrigin] = stepNow + visited[numNow]\n                else:\n                    if numNow%2:\n                        heapq.heappush(stack, (stepNow + 1, numNow*3+1, numOrigin))\n                    else:\n                        heapq.heappush(stack, (stepNow + 1, numNow//2, numOrigin))\n        sortedNums = sorted([i for i in range(lo, hi+1)], key = lambda x: (visited[x], x))\n        return sortedNums[k-1]", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        dic = {}\n        for i in range(lo,hi+1):\n            power = self.findPower(i,{})\n            dic[i] = power\n        #print(dic)\n        sortedValue = sorted(list(dic.items()), key=lambda x:x[1])\n        return (sortedValue[k-1][0])\n    \n    def findPower(self,num,memo):\n        if num in memo:\n            return memo[num]\n        if num == 1:\n            return 1\n        memo[num]=self.findPower(num//2,memo)+1 if num % 2 == 0 else self.findPower(3*num+1, memo)+1\n        return memo[num]\n", "class Solution:\n    def core(self, num: int, counter: int) -> int:\n        if num == 1:\n            return counter\n        if num % 2 == 0:\n            return self.core(num//2, counter + 1)\n        return self.core(num * 3 + 1, counter + 1)\n\n    def getPowerValue(self, num: int) -> int:\n        return self.core(num, 0)        \n        \n    def generatePowerValues(self, lo: int, hi: int) -> List[int]:\n        output = [0]\n        if hi == 1:\n            return output\n        for i in range(2, hi + 1):\n            if i % 2 == 0:\n                output.append(1 + output[i//2 - 1])\n            else:\n                output.append(3 + output[(3*i+1)//4 - 1])\n        return output[lo-1:hi]\n            \n        \n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        output = []\n        for i in range(lo, hi + 1):\n            output.append((i, self.getPowerValue(i)))\n        output.sort(key=lambda x: (x[1], x[0]))\n        return output[k-1][0]", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        power_dic = {}\n        power_dic_sub = {}\n        for i in range(lo, hi+1):\n            power_dic_sub[i] = self.getPower(i, 0, [], power_dic)\n        result_tmp = sorted(power_dic_sub.items(), key=lambda kv: kv[1], reverse= False)\n        return result_tmp[k - 1][0]\n\n    def getPower(self, num, power,power_record, power_dic):\n        if num == 1:\n            for i in power_record:\n                if not power_dic[i]:\n                    power_dic[i] = power - power_record.index(i)\n            return power\n        if num in power_dic:\n            return power_dic[num]\n        if num % 2 == 0:\n            num = num / 2\n        else:\n            num = 3 * num +1\n        power += 1\n        return self.getPower(num, power, power_record, power_dic)", "class Solution:\n    def getKth(self, a: int, b: int, k: int) -> int:\n        def fun(x,d):\n            if x==1:\n                return 0\n            if(x%2==0):\n                if x//2 in d:\n                    d[x]=d[x//2]+1\n                else:\n                    d[x]=fun(x//2,d)+1\n            else:\n                if 3*x+1 in d:\n                    d[x]=d[3*x+1]+1\n                else:\n                    d[x]=fun(3*x+1,d)+1\n            return d[x]\n        d={}\n        for i in range(a,b+1):\n            fun(i,d)\n        d[1]=0\n        ans=[]\n        for i in range(a,b+1):\n            ans.append((d[i],i))\n        ans.sort()\n        return ans[k-1][1]", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        d={}\n        def dp(x):\n            if x==1:\n                return 0\n            if x%2:\n                t= 3*x+1\n                if t not in d:\n                    d[t]=dp(t)\n                return 1+d[t]\n            else:\n                t= x//2\n                if t not in d:\n                    d[t]=dp(t)\n                return 1+d[t]\n        d1={}\n        for i in range(lo,hi+1):\n            d1[i]=dp(i)\n        return sorted(d1,key= lambda x:d1[x])[k-1]\n        \n            \n                \n", "class Solution:\n    def getKth(self, lo, hi, k):\n        return sorted(list(range(lo, hi + 1)), key='\u5bd2\u5bd2\u5bd3\u5bd9\u5bd4\u5bd7\u5bda\u5be2\u5bd5\u5be5\u5bd8\u5be0\u5bdb\u5bdb\u5be3\u5be3\u5bd6\u5bde\u5be6\u5be6\u5bd9\u5bd9\u5be1\u5be1\u5bdc\u5be9\u5bdc\u5c41\u5be4\u5be4\u5be4\u5c3c\u5bd7\u5bec\u5bdf\u5bdf\u5be7\u5be7\u5be7\u5bf4\u5bda\u5c3f\u5bda\u5bef\u5be2\u5be2\u5be2\u5c3a\u5bdd\u5bea\u5bea\u5bea\u5bdd\u5bdd\u5c42\u5c42\u5be5\u5bf2\u5be5\u5bf2\u5be5\u5be5\u5c3d\u5c3d\u5bd8\u5bed\u5bed\u5bed\u5be0\u5be0\u5be0\u5c38\u5be8\u5c45\u5be8\u5be0\u5be8\u5be8\u5bf5\u5bf5\u5bdb\u5be8\u5c40\u5c40\u5bdb\u5bdb\u5bf0\u5bf0\u5be3\u5bf0\u5be3\u5c2e\u5be3\u5be3\u5c3b\u5c3b\u5bde\u5c48\u5beb\u5beb\u5beb\u5beb\u5beb\u5c29\u5bde\u5bf8\u5bde\u5c36\u5c43\u5c43\u5c43\u5c17\u5be6\u5bde\u5bf3\u5bf3\u5be6\u5be6\u5bf3\u5bf3\u5be6\u5c31\u5be6\u5c00\u5c3e\u5c3e\u5c3e\u5c00\u5bd9\u5c4b\u5bee\u5bee\u5bee\u5bee\u5bee\u5bfb\u5be1\u5c2c\u5be1\u5bfb\u5be1\u5be1\u5c39\u5c39\u5be9\u5c46\u5c46\u5c46\u5be9\u5be9\u5be1\u5be1\u5be9\u5bf6\u5be9\u5c27\u5bf6\u5bf6\u5bf6\u5c08\u5bdc\u5c34\u5be9\u5be9\u5c41\u5c41\u5c41\u5c15\u5bdc\u5c03\u5bdc\u5c4e\u5bf1\u5bf1\u5bf1\u5c22\u5be4\u5bf1\u5bf1\u5bf1\u5be4\u5be4\u5c2f\u5c2f\u5be4\u5bfe\u5be4\u5bfe\u5c3c\u5c3c\u5c3c\u5bfe\u5bdf\u5c49\u5c49\u5c49\u5bec\u5bec\u5bec\u5c49\u5bec\u5be4\u5bec\u5bf9\u5bec\u5bec\u5c2a\u5c2a\u5bdf\u5bf9\u5bf9\u5bf9\u5bdf\u5bdf\u5c37\u5c37\u5c44\u5bec\u5c44\u5c06\u5c44\u5c44\u5c18\u5c18\u5be7\u5c06\u5bdf\u5bdf\u5bf4\u5bf4\u5bf4\u5c51\u5be7\u5c25\u5be7\u5c51\u5bf4\u5bf4\u5bf4\u5c06\u5be7\u5be7\u5c32\u5c32\u5be7\u5be7\u5c01\u5c01\u5c3f\u5c01\u5c3f\u5c13\u5c3f\u5c3f\u5c01\u5c01\u5bda\u5c4c\u5c4c\u5c4c\u5bef\u5bef\u5bef\u5c20\u5bef\u5c4c\u5bef\u5be7\u5bef\u5bef\u5bfc\u5bfc\u5be2\u5bef\u5c2d\u5c2d\u5be2\u5be2\u5bfc\u5bfc\u5be2\u5bfc\u5be2\u5c0e\u5c3a\u5c3a\u5c3a\u5bfc\u5bea\u5bef\u5c47\u5c47\u5c47\u5c47\u5c47\u5c09\u5bea\u5c1b\u5bea\u5c47\u5be2\u5be2\u5be2\u5bfc\u5bea\u5bf7\u5bf7\u5bf7\u5bea\u5bea\u5c28\u5c28\u5bf7\u5c54\u5bf7\u5bf7\u5bf7\u5bf7\u5c09\u5c09\u5bdd\u5bea\u5c35\u5c35\u5bea\u5bea\u5bea\u5c61\u5c42\u5c04\u5c42\u5bea\u5c42\u5c42\u5c16\u5c16\u5bdd\u5c42\u5c04\u5c04\u5bdd\u5bdd\u5c4f\u5c4f\u5bf2\u5c4f\u5bf2\u5c4f\u5bf2\u5bf2\u5c23\u5c23\u5be5\u5c4f\u5bf2\u5bf2\u5bf2\u5bf2\u5bf2\u5c04\u5be5\u5bff\u5be5\u5bff\u5c30\u5c30\u5c30\u5bff\u5be5\u5be5\u5bff\u5bff\u5be5\u5be5\u5bff\u5bff\u5c3d\u5c11\u5c3d\u5c0c\u5c3d\u5c3d\u5bff\u5bff\u5be0\u5bf2\u5c4a\u5c4a\u5c4a\u5c4a\u5c4a\u5c4a\u5bed\u5c0c\u5bed\u5c1e\u5bed\u5bed\u5c4a\u5c4a\u5bed\u5be5\u5be5\u5be5\u5bed\u5bed\u5bfa\u5bfa\u5bed\u5bfa\u5bed\u5c57\u5c2b\u5c2b\u5c2b\u5c57\u5be0\u5c57\u5bfa\u5bfa\u5bfa\u5bfa\u5bfa\u5bf2\u5be0\u5c0c\u5be0\u5c07\u5c38\u5c38\u5c38\u5bfa\u5c45\u5bed\u5bed\u5bed\u5c45\u5c45\u5c07\u5c07\u5c45\u5bed\u5c45\u5c07\u5c19\u5c19\u5c19\u5c33\u5be8\u5c45\u5c07\u5c07\u5be0\u5be0\u5be0\u5bfa\u5bf5\u5c52\u5bf5\u5c52\u5bf5\u5bf5\u5c52\u5c52\u5be8\u5bf5\u5c26\u5c26\u5be8\u5be8\u5c52\u5c52\u5bf5\u5bf5\u5bf5\u5bed\u5bf5\u5bf5\u5c07\u5c07\u5be8\u5c02\u5be8\u5be8\u5c33\u5c33\u5c33\u5c5f\u5be8\u5c02\u5be8\u5c5f\u5c02\u5c02\u5c02\u5c33\u5c40\u5be8\u5c02\u5c02\u5c40\u5c40\u5c14\u5c14\u5c40\u5c0f\u5c40\u5bf5\u5c02\u5c02\u5c02\u5c0f\u5bdb\u5bf5\u5c4d\u5c4d\u5c4d\u5c4d\u5c4d\u5c0f\u5bf0\u5c4d\u5bf0\u5c4d\u5bf0\u5bf0\u5c21\u5c21\u5bf0\u5bf0\u5c4d\u5c4d\u5bf0\u5bf0\u5be8\u5be8\u5bf0\u5be8\u5bf0\u5c02\u5bfd\u5bfd\u5bfd\u5c5a\u5be3\u5bfd\u5bf0\u5bf0\u5c2e\u5c2e\u5c2e\u5bfd\u5be3\u5c5a\u5be3\u5bf0\u5bfd\u5bfd\u5bfd\u5c29\u5be3\u5bfd\u5bfd\u5bfd\u5be3\u5be3\u5c0f\u5c0f\u5c3b\u5c0a\u5c3b\u5bf0\u5c3b\u5c3b\u5bfd\u5bfd\u5beb\u5bf0\u5bf0\u5bf0\u5c48\u5c48\u5c48\u5bf0\u5c48\u5c0a\u5c48\u5c48\u5c48\u5c48\u5c0a\u5c0a\u5beb\u5c1c\u5c1c\u5c1c\u5beb\u5beb\u5c48\u5c48\u5be3\u5c0a\u5be3\u5c17\u5be3\u5be3\u5bfd\u5bfd\u5beb\u5c55\u5bf8\u5bf8\u5bf8\u5bf8\u5bf8\u5c17\u5beb\u5c55\u5beb\u5c55\u5c29\u5c29\u5c29\u5c55\u5bf8\u5beb\u5c55\u5c55\u5bf8\u5bf8\u5bf8\u5bf8\u5bf8\u5bf0\u5bf8\u5bf0\u5c0a\u5c0a\u5c0a\u5c55\u5bde\u5c05\u5beb\u5beb\u5c36\u5c36\u5c36\u5bf8\u5beb\u5c62\u5beb\u5c36\u5beb\u5beb\u5c62\u5c62\u5c43\u5c05\u5c05\u5c05\u5c43\u5c43\u5beb\u5beb\u5c43\u5c05\u5c43\u5c62\u5c17\u5c17\u5c17\u5c31\u5bde\u5c12\u5c43\u5c43\u5c05\u5c05\u5c05\u5c12\u5bde\u5c12\u5bde\u5bf8\u5c50\u5c50\u5c50\u5bf8\u5bf3\u5c50\u5c50\u5c50\u5bf3\u5bf3\u5c50\u5c50\u5bf3\u5c50\u5bf3\u5c12\u5c24\u5c24\u5c24\u5c7c\u5be6\u5bf3\u5c50\u5c50\u5bf3\u5bf3\u5bf3\u5c12\u5bf3\u5beb\u5bf3\u5beb\u5bf3\u5bf3\u5c05\u5c05\u5be6\u5c00\u5c00\u5c00\u5be6\u5be6\u5c00\u5c00\u5c31\u5bf3\u5c31\u5c5d\u5c31\u5c31\u5c00\u5c00\u5be6\u5c5d\u5be6\u5be6\u5c00\u5c00\u5c00\u5c31\u5be6\u5c2c\u5be6\u5c00\u5c00\u5c00\u5c00\u5c5d\u5c3e\u5be6\u5c12\u5c12\u5c3e\u5c3e\u5c0d\u5c0d\u5c3e\u5bf3\u5c3e\u5c6a\u5c00\u5c00\u5c00\u5c0d\u5be1\u5bf3\u5bf3\u5bf3\u5c4b\u5c4b\u5c4b\u5c6a\u5c4b\u5bf3\u5c4b\u5c0d\u5c4b\u5c4b\u5c4b\u5c4b\u5bee\u5c4b\u5c0d\u5c0d\u5bee\u5bee\u5c1f\u5c1f\u5bee\u5c1f\u5bee\u5c39\u5c4b\u5c4b\u5c4b\u5c1a\u5bee\u5c0d\u5be6\u5be6\u5be6\u5be6\u5be6\u5c1a\u5bee\u5c00\u5bee\u5c58\u5bfb\u5bfb\u5bfb\u5c58\u5bee\u5bfb\u5bfb\u5bfb\u5bee\u5bee\u5c58\u5c58\u5c2c\u5c58\u5c2c\u5bfb\u5c2c\u5c2c\u5c58\u5c58\u5be1\u5bee\u5c58\u5c58\u5bfb\u5bfb\u5bfb\u5c27\u5bfb\u5bfb\u5bfb\u5bfb\u5bfb\u5bfb\u5bf3\u5bf3\u5be1\u5c0d\u5c0d\u5c0d\u5be1\u5be1\u5c08\u5c08\u5c39\u5bee\u5c39\u5c65\u5c39\u5c39\u5bfb\u5bfb\u5c46\u5c65\u5bee\u5bee\u5bee\u5bee\u5bee\u5c84\u5c46\u5c65\u5c46\u5bee\u5c08\u5c08\u5c08\u5c65\u5c46\u5c46\u5bee\u5bee\u5c46\u5c46\u5c08\u5c08\u5c1a\u5c65\u5c1a\u5c00\u5c1a\u5c1a\u5c34\u5c34\u5be9\u5c15\u5c46\u5c46\u5c08\u5c08\u5c08\u5c46\u5be1\u5c15\u5be1\u5c08\u5be1\u5be1\u5bfb\u5bfb\u5bf6\u5c53\u5c53\u5c53\u5bf6\u5bf6\u5c53\u5c53\u5bf6\u5c53\u5bf6\u5c15\u5c53\u5c53\u5c53\u5c46\u5be9\u5c53\u5bf6\u5bf6\u5c27\u5c27\u5c27\u5c53\u5be9\u5c7f\u5be9\u5c27\u5c53\u5c53\u5c53\u5bf6\u5bf6\u5bf6\u5bf6\u5bf6\u5bf6\u5bf6\u5bee\u5bee\u5bf6\u5bee\u5bf6\u5bee\u5c08\u5c08\u5c08\u5c53\u5be9\u5c03\u5c03\u5c03\u5be9\u5be9\u5be9\u5c60\u5c34\u5c03\u5c34\u5bf6\u5c34\u5c34\u5c60\u5c60\u5be9\u5c34\u5c03\u5c03\u5be9\u5be9\u5c60\u5c60\u5c03\u5be9\u5c03\u5bf6\u5c03\u5c03\u5c34\u5c34\u5c41\u5c2f\u5be9\u5be9\u5c03\u5c03\u5c03\u5c03\u5c41'.__getitem__)[k - 1]\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        \n        memo = {}\n        \n        def help(x):\n            if x in memo:\n                return memo[x]\n            \n            if x == 1:\n                return 0\n            \n            if x%2 == 0:\n                memo[x] = 1+help(x//2)\n            else:\n                memo[x] = 1+help(x*3+1)\n            \n            return memo[x]\n            \n        return sorted( list(range(lo, hi+1)), key=lambda x: [help(x), x]  )[k-1]\n        \n        \n#         def help(x):\n#             step = 0\n#             while x != 1:\n#                 step += 1\n#                 if x%2 == 0:\n#                     x=x//2\n#                 else:\n#                     x = 3*x+1\n#             return step\n        \n#         return sorted( list(range(lo, hi+1)), key=lambda x: [help(x), x]  )[k-1]\n", "class Solution:\n    # def __init__(self):\n        # self.memo = {1: 0}\n        \n    def getPowVal(self, x: int) -> int:\n        if x in self.memo:\n            return self.memo[x]\n        \n        newX = x//2 if x%2==0 else 3*x+1\n        \n        self.memo[x] = 1 + self.getPowVal(newX)\n        \n        return self.memo[x]\n#         intermed = []\n#         steps = 0\n#         while x != 1 or x not in self.memo:\n#             intermed.append(x)\n#             steps += 1\n#             x = x//2 if x%2==0 else 3*x+1\n        \n#         if x in self.memo:\n#             steps += self.memo[x]\n        \n#         for idx in range(len(intermed)):\n#             self.memo[intermed[idx]] = steps-idx\n\n        # return self.memo[intermed[0]]\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        self.memo = {1: 0}\n        powVal = [ (x, self.getPowVal(x)) for x in range(lo, hi+1) ]\n        \n        powVal.sort(key=lambda x: x[1])\n        \n\n        return powVal[k-1][0]\n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        dp = dict()\n        dp[0] = dp[2] = 1\n        dp[1] = 0\n        \n        def calc(x):\n            if dp.get(x) is not None:\n                return dp.get(x)\n            if x%2 == 0:\n                dp[x] = calc(x//2)+1\n            else:\n                dp[x] = calc(x*3+1)+1\n            return dp[x]\n                \n        to_sort = []\n        for i in range(lo,hi+1):\n            calc(i)\n            to_sort.append([i, dp.get(i)])\n        sorted_res = sorted(to_sort, key=lambda x: x[1])\n        return sorted_res[k-1][0]", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        memo = {1:0}\n        def getPower(x):\n            if x in memo:\n                return memo[x]\n            elif x%2==0:\n                memo[x] = 1+getPower(x/2)\n            else:\n                memo[x] = 1+getPower(3*x+1)\n            return memo[x]\n        return sorted([(getPower(x),x) for x in range(lo,hi+1)] )[k-1][1]\n    \n    \n\n\n        \n        \n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        res = []\n        self.inc = {1: 0 }\n        while lo <= hi:\n            heapq.heappush(res, (self.find_power(lo), lo))\n            lo += 1\n        for i in range(k):\n            ans = heapq.heappop(res)[1]\n        return ans\n        \n    def find_power(self, var):\n        if var in self.inc: return self.inc[var]\n        if var % 2 == 0: \n            self.inc[var] = self.find_power(var//2) + 1\n        else: \n            self.inc[var] = self.find_power(3*var + 1) + 1\n        return self.inc[var]\n        \n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        memo={1:0}\n        def getPower(x):\n            if x in memo:\n                return memo[x]\n            if x%2==0:\n                memo.update({x:getPower(x//2)+1})\n                return memo[x]\n            else:\n                memo.update({x:getPower(x*3+1)+1})\n                return memo[x]\n        return sorted(map(lambda x: (getPower(x),x), range(lo,hi+1)))[k-1][1]", "class Solution:\n    def getPower(self, n):\n        if n == 1:\n            return 0\n        \n        if n in self.dp:\n            return self.dp[n]\n        else:\n            if n %2 == 0:\n                self.dp[n] = self.getPower(n//2) + 1\n            else:\n                self.dp[n] = self.getPower(3*n + 1) + 1\n        return self.dp[n]\n        \n        \n        \n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        tmp = []\n        self.dp = {}\n        for num in range(lo, hi+1):\n            tmp.append((num, self.getPower(num)))\n        tmp.sort(key = lambda x: (x[1], x[0]))\n        return tmp[k-1][0]", "import functools\n\nclass Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        return sorted((get_power_value(x), x) for x in range(lo, hi + 1))[k - 1][1]\n\n@functools.lru_cache(maxsize=None)\ndef get_power_value(x):\n    if x == 1:\n        return 0\n    return 1 + get_power_value(x / 2 if x % 2 == 0 else x * 3 + 1)", "from collections import defaultdict\n\nclass Solution:\n    def helper(self, x):\n            if x == 2:\n                return 1\n            if x in self.table:\n                return self.table[x]\n            if x % 2:\n                y = int(3*x+1)\n            else:\n                y = int(x/2)\n            ans = 1+self.helper(y)\n            self.table[x] = ans\n            return ans\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        self.table = dict()\n        self.lo = lo\n        self.hi = hi\n        powers = [self.helper(x) for x in range(lo, hi+1)]\n        tosort = list(zip(powers, list(range(lo, hi+1))))\n        return sorted(tosort)[k-1][1]\n        # print(ranks)\n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        dp = dict()\n        dp[0] = dp[2] = 1\n        dp[1] = 0\n        \n        def calc(x, adj):\n            if x%2 == 0:\n                n = x//2\n            else:\n                n = 3*x+1\n            if dp.get(n) is None:\n                adj.append(n)\n                calc(n, adj)\n            else:\n                count = dp.get(n)\n                for a in adj[::-1]:\n                    count += 1\n                    dp[a] = count\n                \n        to_sort = []\n        for i in range(lo,hi+1):\n            calc(i, [i])\n            to_sort.append([i, dp.get(i)])\n        sorted_res = sorted(to_sort, key=lambda x: x[1])\n        return sorted_res[k-1][0]", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        ans = []\n        self.dic = {1:0}\n        for i in range(lo, hi+1):\n            c = self.solvePower(i)\n            ans.append([c, i])\n            \n        ans.sort()\n        # print(ans)\n        return ans[k-1][1]\n    \n    \n    def solvePower(self, num):\n        if self.dic.get(num, None) != None:\n            return self.dic[num]\n        \n        if num%2 == 0:\n            temp = self.solvePower(num//2)\n        else:\n            temp = self.solvePower(num*3 + 1)\n        \n        self.dic[num] = 1 + temp\n        return self.dic[num]\n            \n        \n        \n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        power = {}\n        power[1] = 0\n        current = {}\n        nums = list(range(lo, hi+1))\n        for i in nums:\n            self.get_power_value(power, current, i)\n        value = sorted(list(current.items()), key= lambda x:x[1])\n        arr = list([x[0] for x in value])\n        return arr[k-1]\n    \n    def get_power_value(self, power, current, num):\n        arr = []\n        start = num\n        if num in power:\n            current[num] = power[num]\n        else:\n            arr = []\n            value = num\n            found_power = 0\n            while value != 1:\n                if value % 2 == 0:\n                    value /= 2\n                else:\n                    value = value * 3 + 1\n                arr.append(value)\n                if value in power:\n                    found_power = power[value]\n                    break\n            for i in range(0, len(arr)):\n                power[start] = len(arr) - i + found_power\n                start = arr[i]\n            current[num] = power[num]\n            \n    \n            \n                \n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        @lru_cache(None)\n        def power(x):\n            if x == 1:\n                return 0\n            return 1 + power(x * 3 + 1) if (x & 1) else 1 + power(x >> 1)\n        a = [(power(x), x) for x in range(lo, hi + 1)]\n        a.sort()\n        print(a)\n        return a[k - 1][1]\n", "class Solution:\n    def __init__(self):\n        self.d = {}\n\n    def solve(self,x):\n        if x == 1:\n            return 0\n        if self.d.get(x,0)!=0:\n            return self.d[x]\n        if x%2==0:\n            self.d[x] = 1+self.solve(x//2)\n            return self.d[x]\n        else:\n            self.d[x] = 1+ self.solve(x*3+1)\n            return self.d[x]\n\n    def getKth(self, lo, hi, k):\n        ar = []\n        for i in range(hi,lo-1,-1):\n            ar.append((self.solve(i),i))\n        ar.sort()\n        return ar[k-1][1]", "import heapq\nfrom operator import itemgetter\n\nclass Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        memo = {1: 0, 2: 1}\n        num_to_power = []\n        \n        for num in range(lo, hi + 1):\n\n            if num == 1:\n                num_to_power.append((num, 0))\n                continue\n                \n            i = num\n            steps = 0   \n            while i != 1:\n                if i in memo:\n                    num_to_power.append((num, steps + memo[i]))\n                    memo[num] = steps + memo[i]\n                    i = 1\n                elif  i % 2 == 0:\n                    i = i // 2\n                    steps += 1\n                else:\n                    i = 3 * i + 1\n                    steps += 1\n\n        num_to_power = sorted(num_to_power, key=itemgetter(1,0))\n        return num_to_power[k - 1][0]", "from collections import defaultdict\n# import heapq\nfrom operator import itemgetter \nclass Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        power_dict = defaultdict(int)\n        \n        def cal_power(n):\n            nonlocal power_dict\n            \n            if n in list(power_dict.keys()):\n                return power_dict[n]-1\n            if n==1:\n                return 0\n            if n%2==0:\n                n = n/2\n            elif n%2==1:\n                n = 3*n+1\n                \n            power_dict[n] = cal_power(n)+1\n            return power_dict[n]\n        lst = []\n        for i in range(lo,hi+1):\n            lst.append((cal_power(i),i))\n        \n        lst = sorted(lst,key = itemgetter(0))\n        return lst[k-1][1]\n\n        # print(lst)\n#         heapq.heapify(lst)\n        \n#         for i in range(k):\n#             ans = heapq.heappop(lst)\n        \n#         return ans[1]  \n    \n    \n#         @lru_cache(None)\n#         def power(x):\n#             if x == 1:\n#                 return 0\n#             if x % 2 == 0:\n#                 return 1 + power(x // 2)\n#             return 1 + power(3 * x + 1)\n\n#         return sorted(range(lo, hi+1), key=power)[k-1]\n    \n                \n                \n", "from collections import defaultdict\nclass Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        \n        m = defaultdict(int)\n        \n        def do(n):\n            if(n==1):\n                return 0\n            if m[n]!=0:\n                return m[n]\n            else:\n                if n%2==0:\n                    m[n]=1+do(n/2)\n                else:\n                    m[n]=1+do(3*n+1)\n            return m[n]\n        \n        res=[]\n        for i in range(lo, hi+1):\n            res.append([do(i), i])\n        \n        res.sort()\n        return res[k-1][1]", "\nclass Solution:\n    cache = {}\n    \n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        l = list(range(lo, hi + 1))\n        l.sort(key = lambda x: self.findKth(x))\n        return l[k - 1]\n        \n    # \u725b\u5564\u7684recursion + cache\u4f18\u5316\n    def findKth(self, n: int) -> int:\n        if n in self.cache:\n            return self.cache[n]\n        \n        if n == 1:\n            return 0\n        \n        if n % 2 == 0:\n            res = 1 + self.findKth(int(n / 2))\n        else:\n            res = 1 + self.findKth(3 * n + 1)\n            \n        self.cache[n] = res\n        return res\n\n\nclass Solution_eva:\n\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        def calSteps(x):\n            cnt = 0\n            # O(n)\n            while x != 1:\n                x = x / 2 if x % 2 == 0 else 3*x + 1\n                cnt += 1\n            return cnt\n        # O(nlogn) * O(n)\n        return sorted([ele for ele in range(lo, hi+1)], key=lambda x: calSteps(x))[k-1]\n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        \n        self.visited = {}\n        \n        def recur(n):\n            if n in self.visited:\n                return self.visited[n]\n            if n == 1:\n                return 0\n            else:\n                if n%2 == 0:\n                    moves = 1 + recur(int(n/2))\n                else:\n                    moves = 1 + recur(int(3*n)+1)\n                self.visited[n]=moves\n                return self.visited[n]\n        for i in range(hi,lo-1,-1):\n            if i not in self.visited:\n                self.visited[i]=recur(i)\n            \n        result =  [ (x,self.visited[x]) for x in self.visited if lo <=x and x<=hi]\n        result.sort(key = lambda x : (x[1],x[0]))\n        return result[k-1][0]", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        # 7  -> 16  7, 22, 11, 34, 17, 52, 26, 133, 40, 20, 10, 5, 16, 8, 4, 2, 1 \n        # 8  -> 3   8, 4, 2, 1 \n        # 9  -> 19  9, 28, 14, 7, 22, 11, 34, 17,  \n        # 10 -> 6   10, 5, 16, 8, 4, 2, 1\n        # 11 -> 14  11, 34\n        power_list = []\n        d = {}\n        for i in range(lo, hi+1):\n            a = self.power(i, d)\n            power_list.append(a)\n        print(power_list)\n        list2 = [i for i in range(lo, hi+1)]\n        # [x for _, x in sorted(zip(Y,X), key=lambda pair: pair[0])]\n        list2 = [ x for x, y in sorted(zip(list2, power_list), key = lambda x: x[1])]\n        return list2[k-1]\n        \n    def power(self, x, dict1):\n        if x in dict1:\n            print(('hi', x))\n            return dict1[x]\n        else:\n            orig = x\n            list1 = []\n            count = 0\n            while x != 1 and x not in dict1:\n                if x %2 == 0:\n                    x /= 2\n                else:\n                    x = 3*x + 1\n                x = int(x)\n                count += 1\n                list1.append(x)\n            n = len(list1)\n            if x == 1:\n                dict1[orig] = n\n                for elem in list1:\n                    dict1[elem] = n-1\n                    n -= 1\n                \n            else:\n                print(('hi ', x))\n                dict1[orig] = n+ dict1[x]\n                for elem in list1:\n                    dict1[elem] = n-1 + dict1[x]\n                    n -= 1\n            return dict1[orig]\n            \n                    \n", "class Heap:\n    def __init__(self, initial=None, key=lambda x: x):\n        self.key = key\n        if initial:\n            self._data = [(key(item), item) for item in initial]\n            heapq.heapify(self._data)\n        else:\n            self._data = []\n            \n    def push(self, item):\n        heapq.heappush(self._data, (self.key(item), item))\n        \n    def pop(self):\n        return heapq.heappop(self._data)[1]\n    \n    def peek(self):\n        return self._data[0][1]\n            \n\nclass Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        powers = {}\n        heap = Heap(key=lambda n: -self._get_power(n, powers))\n        for n in range(lo, lo + k):\n            heap.push(n)\n        for n in range(lo + k, hi + 1):\n            heap.push(n)\n            heap.pop()\n        \n        return heap.peek()\n\n        \n    def _get_power(self, n: int, powers: dict) -> int:\n        orig_n = n\n        if n not in powers:\n            power = 0\n            while n != 1:\n                if n % 2:   # n is odd\n                    n = n * 3 + 1\n                else:       # n is even\n                    n //= 2\n                power += 1\n                if n in powers:\n                    power += powers[n]\n                    break\n            powers[orig_n] = power\n        return powers[orig_n] - 1/orig_n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        dp = {}\n        dp[1] = 0\n        def helper(num):\n            if num in dp:\n                return dp[num]\n            if num == 1:\n                return 0\n            if num%2 == 0:\n                dp[num] = helper(num//2) + 1\n            else:\n                dp[num] = helper((num*3)+1) + 1\n            print((dp[num]))\n            return dp[num]\n        res = []\n        for i in range(lo, hi+1):\n            res.append((helper(i), i))\n        res.sort()\n        return res[k-1][1]\n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        steps = defaultdict(lambda: None)\n        steps[1] = 0\n        vals = list(range(lo, hi+1))\n        powers = []\n        for v in vals:\n            s = v\n            num_steps = 0\n            while s != 1:\n                if steps[s] is not None:\n                    num_steps += steps[s]\n                    break\n                if s % 2 == 0:\n                    s //= 2\n                else:\n                    s = 3*s + 1\n                    \n                num_steps += 1\n                \n            steps[v] = num_steps\n            \n            powers.append(num_steps)\n            \n        items = sorted(zip(powers, vals))\n        return items[k-1][1]\n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        memo = {}\n        res = []\n        for n in range(lo,hi+1):\n            power = 0\n            x = n\n            while x >= 1:\n                if x == 1:\n                    memo[n] = power\n                    break\n                elif x in memo:\n                    power += memo[x]\n                    memo[n] = power\n                    break\n                elif x%2==0:\n                    x//=2\n                    power+=1\n                elif x%2!=0:\n                    x = 3*x+1\n                    power+=1\n\n        res = sorted(memo.items(),key = \n                     lambda kv:(kv[1], kv[0]))\n        return res[k-1][0]", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        @lru_cache(maxsize=None)\n        def get_power(n):\n            if n == 1:\n                return 0\n            elif n % 2:\n                return 1 + get_power(3 * n + 1)\n            return 1 + get_power(n // 2)\n        \n        nums = []\n        \n        for i in range(lo, hi + 1):\n            nums.append([get_power(i), i])\n        \n        nums.sort()\n        \n        return nums[k - 1][1]", "class Solution:\n\n    \n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        lst={1:0}\n        num_list=[]\n        for i in range(lo,hi+1):\n            ans=0\n            while i!=1:\n                if i in list(lst.keys()):\n                    ans=lst[i]+ans\n                    break\n                else:\n                    num_list=num_list+[i]\n                    if i%2:\n                        i=i*3+1\n                        ans+=1\n                    else:\n                        i/=2\n                        ans+=1\n            for ind,num in enumerate(num_list):\n                lst[num]=ans-ind\n            num_list=[]\n        power_list=[(i,lst[i]) for i in range(lo,hi+1)]\n        power_list.sort(key=lambda x:x[1])\n\n        return power_list[k-1][0]\n    \n", "from heapq import heapify, heappop\n\ncache = {\n    1: 0\n}\n\n\ndef collatz(y):\n    if y in cache:\n        return cache[y]\n    \n    x = y\n    steps = 1\n    while x > 1:\n        if x % 2 == 1:\n            x = 3 * x + 1\n        else:\n            x //= 2\n            \n        if x in cache:\n            ans = cache[x] + steps\n            break\n\n        steps += 1\n    else:\n        ans = steps\n\n    cache[y] = ans\n    return ans\n\n\nclass Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        powers = [(collatz(x), x) for x in range(lo, hi + 1)]\n        heapify(powers)\n        \n        for _ in range(k):\n            x = heappop(powers)\n\n        return x[1]", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        memo = {}\n        \n        def power(n):\n            if n == 1:\n                return 0\n            \n            if n in memo:\n                return memo[n]\n            \n            if n % 2 == 0:\n                res = 1 + power(n / 2)\n            else:\n                res = 1 + power(3 * n + 1)\n            \n            memo[n] = res\n            \n            return res\n        \n        s = sorted(range(lo, hi + 1), key=power)\n        return s[k - 1]", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        \n        d = collections.defaultdict(int)\n        d[1] = 0\n        d[2] = 1\n        \n        def dfs(num): \n            if num in d:\n                return d[num]\n            \n            count = 0 \n            if num % 2:\n                d[num] = 1 + dfs(num*3 + 1)\n                return  1 + dfs(num*3 + 1)\n\n            if not num % 2:\n                d[num] = 1 + dfs(num // 2)\n                return 1 + dfs(num // 2)\n        \n        res = collections.defaultdict(int)\n        for n in range(lo, hi+1):\n            res[n] = dfs(n)\n            \n        res = sorted(list(res.items()), key = lambda x: x[1])\n        \n        return res[k-1][0]\n\n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        power = {}\n        for x in range(lo, hi+1):\n            power[x] = self._get_power(x, power)\n        return sorted(power, key=power.get)[k-1]\n        \n    def _get_power(self, x, power):\n        if x in power: return power[x]\n        if x == 1: return 0\n        if x % 2 == 0: return self._get_power(x // 2, power) + 1\n        else: return self._get_power(3 * x + 1, power) + 1\n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        a={}\n        def check(n,a):\n            ct=0\n            while n!=1:\n                if n%2==0:\n                    n=n/2\n                else:\n                    n=3*n+1\n                if n in a:\n                    ct += a[n]+1\n                    return ct\n                    break\n                ct +=1\n            return ct\n        for i in range(lo,hi+1):\n            a[i] = check(i,a)\n        b=sorted(a.items(), key=lambda kv:(kv[1],kv[0]))\n        return b[k-1][0]", "import heapq\nclass Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        # solution one just calculate all the power number \n        pv_map = {}\n        def pv(val): \n            v = val\n            cnt = 1\n            while val!= 1:\n                if val in pv_map: \n                    pv_map[v] = cnt + pv_map[val] -1\n                    return pv_map[v]\n                if val % 2 == 0: \n                    val /= 2\n                else: \n                    val = 3 * val + 1\n                cnt += 1\n            pv_map[v] = cnt\n            return cnt\n        # vs = sorted(range(lo, hi+1), key = lambda x: pv(x))[k-1]\n        h = []\n        for v in range(lo, hi+1): \n            p = pv(v)\n            if len(h) < k: \n                heapq.heappush(h, (-p, -v))\n            else: \n                if p < (-h[0][0]):\n                    heapq.heapreplace(h, (-p, -v))\n\n        return -h[0][1]\n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n\n        @lru_cache(None)\n        def p(x):\n            if x == 1:\n                return 0\n            elif x & 1:\n                return p(3 * x + 1) + 1\n            else:\n                return p(x >> 1) + 1\n\n        return sorted(range(lo, hi + 1), key=p)[k - 1]", "from functools import lru_cache\nfrom heapq import heappop, heappush\n\nclass Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        \n        @lru_cache(None)\n        def get_steps(num):\n            if num == 1:\n                return 0\n            elif num % 2:\n                return 1 + get_steps(3 * num + 1)\n            else:\n                return 1 + get_steps(num // 2)\n            \n        pq = []\n        for i in range(lo, hi + 1):\n            heappush(pq, (-get_steps(i), -i))\n            if len(pq) > k:\n                heappop(pq)\n        \n        return -min(pq)[1]", "from collections import defaultdict\n\nclass Solution:\n    def helper(self, x):\n            if x == 2:\n                return 1\n            if x in self.table:\n                return self.table[x]\n            if x % 2:\n                y = int(3*x+1)\n            else:\n                y = int(x/2)\n            ans = 1+self.helper(y)\n            if self.lo <= x <= self.hi:\n                self.table[x] = ans\n            return ans\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        self.table = dict()\n        self.lo = lo\n        self.hi = hi\n        powers = [self.helper(x) for x in range(lo, hi+1)]\n        tosort = list(zip(powers, list(range(lo, hi+1))))\n        return sorted(tosort)[k-1][1]\n        # print(ranks)\n    \n        # doesnt work\n        # todo = set(range(lo, hi+1))\n        # if len(todo) == 1:\n        #     return 1\n        # ranks = []\n        # while todo:\n        #     y = todo.pop()\n        #     stack = [y]\n        #     while y > 1 and y not in table:\n        #         if y % 2:\n        #             y = 3*y+1\n        #         else:\n        #             y = y/2\n        #         if y in todo:\n        #             todo.remove(y)\n        #         stack.append(y)\n        #     if y == 1:\n        #         ranks = ranks + stack\n        #     else:\n        #         for i in range(len(stack)-1):\n        #             ranks.insert(ranks.index(stack[-i])+1, stack[-i-1])\n        # i = 0\n        # nums = set(range(lo, hi+1))\n        # for r in reversed(ranks):\n        #     if r in nums:\n        #         i += 1\n        #         print(r)\n        #     if i == k:\n        #         return int(r)\n", "from heapq import heapify, heappop\n\ncache = {\n    1: 0\n}\n\n\ndef collatz(y):\n    if y in cache:\n        return cache[y]\n    \n    x = y\n    steps = 0\n    while x > 1:\n        if x % 2 == 1:\n            x = 3 * x + 1\n        else:\n            x //= 2\n            \n        steps += 1\n        if x in cache:\n            ans = cache[x] + steps\n            break\n    else:\n        ans = steps\n\n    cache[y] = ans\n    return ans\n\n\nclass Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        \n        powers = [(collatz(x), x) for x in range(lo, hi + 1)]\n        heapify(powers)\n        \n        for _ in range(k):\n            x = heappop(powers)\n\n        return x[1]", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        if lo==hi==k==1:return 1\n        dic={}\n        def fun(n,count):\n            if n==1:return count\n            count+=1\n            if n%2==0:n//=2\n            else:n=n*3+1\n            if n in dic:return count+dic[n]\n            return fun(n,count)\n        ans=[] \n        for i in range(lo,hi+1):\n            dic[i]=fun(i,0)\n        return sorted(list(dic.items()),key=lambda x :x[1])[k-1][0]\n        \n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        if lo == 1 and hi == 1 and k == 1:\n            return 1\n\n        memo = {}\n\n        def count_steps(x, count, memo):\n            if x == 1:\n                return count\n            count += 1\n            if x % 2 == 0:\n                x = x // 2\n            else:\n                x = 3 * x + 1\n\n            if x in memo:\n                return count + memo[x]\n\n            return count_steps(x, count, memo)\n\n        for x in range(lo, hi+1):\n            memo[x] = count_steps(x, 0, memo)\n\n        return sorted(memo.items(), key=lambda x: x[1])[k-1][0]", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        memo = {}\n        def num_steps(num):\n            if num == 1:\n                return 0\n            elif num in memo:\n                return memo[num]\n            \n            if num % 2 == 0:\n                memo[num] = num_steps(num / 2) + 1\n            else:\n                memo[num] = num_steps(num * 3 + 1) + 1\n            \n            return memo[num]\n        \n        vals = []\n        for i in range(lo, hi + 1):\n            vals.append((i,num_steps(i)))\n            \n        vals = sorted(vals, key = lambda x: (x[1], x[0]))\n        print(vals)\n        vals = [i for i,j in vals]\n        return vals[k-1]", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        heap = []\n        self.memo = {}\n        \n        for i in range(lo, hi+1):\n            power = self.computer_power(i)\n            self.memo[i] = power\n            heapq.heappush(heap, (power, i))\n        \n        k_now = 1\n        while heap:\n            new_power, i = heapq.heappop(heap)\n            if k_now == k:\n                return i\n            k_now += 1\n        return result\n    \n    def computer_power(self, val):\n        if val == 1:\n            return 0\n        if val in self.memo:\n            return self.memo[val]\n        \n        if val % 2 == 0:\n            return 1 + self.computer_power(val // 2)\n        else:\n            return 1 + self.computer_power(3*val + 1)", "\nclass Solution:\n    def __recur(self, dp, num):\n        if num in dp:\n            return dp[num]\n        res = 0\n        if num%2 == 0:\n            res = self.__recur(dp, int(num/2)) + 1\n        else:\n            res = self.__recur(dp, int(num*3) + 1) + 1\n        dp[num] = res\n        return res\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        dp = {1:0}\n        for num in range(1,1001):\n            self.__recur(dp, num)\n        power_order = sorted([(dp[key],key) for key in dp if key >= lo and key<=hi])\n        return power_order[k-1][1]\n        \n        \n", "class Solution:\n    def num_count(self, x, count):\n        if x == 1:\n            return count\n        count += 1\n        if x % 2 == 0:\n            x = x // 2\n        else:\n            x = x * 3 + 1\n        if x in self.dp:\n            return count + self.dp[x]\n        return self.num_count(x, count)\n        \n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        self.dp = {}\n        for x in range(lo, hi + 1):\n            self.dp[x] = self.num_count(x, 0)\n        return sorted(self.dp.items(), key = lambda x : x[1])[k - 1][0]", "class Solution:\n    def power(self, memo, num):\n        if num in memo:\n            return memo[num]\n        \n        result = 0\n        if num%2 == 0:\n            result = self.power(memo, int(num/2)) + 1\n        else:\n            result = self.power(memo, int(num*3) + 1) + 1\n            \n        memo[num] = result\n        return result\n    \n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        memo = {1:0}\n        \n        for num in range(1,1001):\n            self.power(memo, num)\n            \n        porder = sorted([(memo[key],key) for key in memo if key >= lo and key<=hi])\n        \n        return porder[k-1][1]\n    \n        \n        \n        \n", "class Solution:\n    def __recur(self, dp, num):\n        if num in dp:\n            return dp[num]\n        res = 0\n        if num%2 == 0:\n            res = self.__recur(dp, int(num/2)) + 1\n        else:\n            res = self.__recur(dp, int(num*3) + 1) + 1\n        dp[num] = res\n        return res\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        dp = {1:0}\n        for i in range(1,1001):\n            self.__recur(dp, i)\n        power_order = sorted([(dp[key],key) for key in dp if key >= lo and key<=hi])\n        return power_order[k-1][1]", "class Solution:\n    def __recur(self, dp, num):\n        if num in dp:\n            return dp[num]\n        if num == 1:\n            return 0\n        res = 0\n        if num%2 == 0:\n            res = self.__recur(dp, int(num/2)) + 1\n        else:\n            res = self.__recur(dp, int(num*3) + 1) + 1\n        dp[num] = res\n        return res\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        dp = {}\n        dp[1] = 0\n        dp[2] = 1\n        for i in range(1,1001):\n            self.__recur(dp, i)\n        temp = [(dp[key],key) for key in dp if key >= lo and key<=hi]\n        temp.sort()\n        return temp[k-1][1]", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        res = []\n        dic = {}\n        for num in range(lo, hi+1):\n            if num in dic:\n                res.append((dic[num], num))\n                continue \n                \n            steps, tmp = 0, num\n            while num > 1:\n                if num in dic:\n                    steps += dic[num]\n                    break\n                if num%2:\n                    num = 3*num + 1\n                else:\n                    num //= 2   \n                steps += 1\n                \n            dic[tmp] = steps\n            res.append((steps, tmp))\n        res.sort()\n        return res[k-1][1]", "dp = {}\n\nclass Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        \n        result = [(num, self.getPowerValue(num)) for num in range(lo, hi+1)]\n        \n        result.sort(key=lambda x: (x[1], x[0]))\n        \n        return result[k-1][0]\n        \n        \n        \n    \n    def getPowerValue(self, num) -> int:\n        if num == 1:\n            return 0\n        \n        if num in dp:\n            return dp[num]\n        \n        if num%2 == 0:\n            dp[num] = 1 + self.getPowerValue(num/2)\n            \n        else:\n            dp[num] = 1 + self.getPowerValue(3*num + 1)\n            \n        \n        return dp[num]", "class Solution:\n    def __init__(self):\n        self.cache = {1: 0,2: 1,3: 7,4: 2, 5: 5, 6: 8, 7: 16, 8: 3}\n\n    def getPower(self, n):\n        steps = 0\n        rem = n % 8\n        if rem == 0:\n            n = n // 8\n            steps = 3\n        elif rem == 1:\n            n = n // 8 * 9 + 2\n            steps = 5\n        elif rem == 2:\n            n = n // 8 * 3 + 1\n            steps = 4\n        elif rem == 3:\n            n = n // 8 * 9 + 4\n            steps = 5\n        elif rem == 4 or rem == 5:\n            n = n // 8 * 3 + 2\n            steps = 4\n        elif rem == 6:\n            n = n // 8 * 9 + 8\n            steps = 5\n        else:\n            n = n // 8 * 27 + 26\n            steps = 6\n        # if n in self.cache.keys(): \n        if n <= 8:\n            return self.cache[n] + steps\n        else:\n            return self.getPower(n) + steps\n\n    def getKth(self, low, high, k):\n        data = [self.getPower(i) for i in range(low, high + 1)]\n        sorted_data = sorted(zip(data, list(range(len(data)))), key= lambda x:x[0])\n        return sorted_data[k - 1][1] + low\n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        dp = defaultdict(int)\n        dp[1] = 0\n        def go(i):\n            #print(i)\n            if i == 1:\n                return 0\n            if dp[i] > 0:\n                return dp[i]\n            if (i % 2) == 0:\n                ans = go(i//2) + 1\n            else:\n                ans = go((3*i)+1) + 1\n            dp[i] = ans\n            return ans\n\n        for i in range(lo, hi+1):\n             dp[i] = go(i)\n        lis = []\n        for i in range(lo,hi+1):\n            lis.append((dp[i],i))\n        lis.sort()\n        ans = lis[k-1]\n        return ans[1]\n", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        res = []\n        dic = {}\n        for num in range(lo, hi+1):\n            steps = 0\n            tmp = num\n            while num > 1:\n                if num in dic:\n                    steps += dic[num]\n                    break\n                if num%2:\n                    num = 3*num + 1\n                else:\n                    num //= 2   \n                steps += 1\n                \n            dic[tmp] = steps\n            res.append((steps, tmp))\n        res.sort()\n        return res[k-1][1]", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        def powerof(num, memo):\n            step = 0\n            n = num\n            while n > 1:\n                if n in memo:\n                    return step + memo[n]\n                if n % 2 == 0:\n                    n = n // 2\n                else:\n                    n = 3*n+1\n                step += 1\n            memo[num] = step\n            return step\n        mheap = []\n        memo = {}\n        for n in range(lo, hi+1):\n            mheap.append([powerof(n, memo), n])\n        heapq.heapify(mheap)\n        return heapq.nsmallest(k, mheap)[-1][1]", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        d = {}\n        def getPowerValue(x):\n            if x in d:\n                return d[x]\n            steps = 0\n            \n            original = x\n            while x != 1:\n                if x%2:\n                    x = 3*x+1\n                else:\n                    x /= 2\n                    \n                steps += 1\n                \n                if x in d:\n                    steps += d[x]\n                    break\n        \n            d[original] = steps\n            return steps\n        \n        return sorted([x for x in range(lo, hi+1)], key=getPowerValue)[k-1]", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        h={}\n        heap=[]\n        for i in range(lo,hi+1):\n            print(i)\n            q=deque()\n            q.append((0,i))\n            while q:\n                x=q.popleft()\n                if x[1]==1 or x[1] in h:\n                    #print(i,x)\n                    xx=x[0]\n                    if x[1] in h:\n                        xx+=h[x[1]]\n                        #print(xx)\n                    if i not in h:\n                        h[i]=xx\n                    if len(heap)<k:\n                        heapq.heappush(heap,(-xx,-i))\n                    else:\n                        if -xx>heap[0][0]:\n                            heapq.heappop(heap)\n                            heapq.heappush(heap,(-xx,-i))\n                    break;\n                if x[1]%2==0:\n                    q.append((x[0]+1,x[1]//2))\n                else:\n                    q.append((x[0]+1,(3*x[1])+1))         \n        #print(heap)   \n        return -heap[0][1]", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        @lru_cache\n        def getPower(x):\n            if x == 1: return 0\n            if x % 2 == 0: return 1+getPower(x // 2)\n            return 1+getPower(3 * x + 1)\n        return sorted([(getPower(x), x) for x in range(lo, hi + 1)])[k - 1][1]", "class Solution:\n    def power(self, memo, num):\n        if num in memo:\n            return memo[num]\n        \n        result = 0\n        if num%2 == 0:\n            result = self.power(memo, num//2)+ 1\n        else:\n            result = self.power(memo, num*3 + 1) + 1\n            \n        memo[num] = result\n        return result\n    \n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        memo = {1:0}\n        \n        for num in range(1,1001):\n            self.power(memo, num)\n            \n        porder = sorted([(memo[key],key) for key in memo if key >= lo and key<=hi])\n        \n        return porder[k-1][1]\n    \n        \n        \n        \n", "from functools import lru_cache\nclass Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        @lru_cache\n        def helper(x):\n            if x==1: return 1\n            if x%2==0:return 1+helper(x//2)\n            return helper(3*x+1)+1\n        \n        lookup={}\n        for x in range(lo,hi+1):\n            lookup[x]=helper(x)\n        return sorted(lookup.items(),key=lambda x:x[1])[k-1][0]", "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        @lru_cache\n        def getPower(x):\n            if x==1:\n                return 0\n            if x%2==0:\n                return 1+getPower(x//2)\n            return 1+getPower(3*x+1)\n        X = [(getPower(x),x) for x in range(lo,hi+1)]\n        X.sort()\n        return X[k-1][1]", "from functools import lru_cache\nclass Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        \n        @lru_cache\n        def getPower(x: int)-> int:            \n            if x == 1:\n                return 1\n            if x % 2 == 0:\n                return getPower(x//2) + 1\n            \n            if x % 2 == 1:\n                return getPower(3*x+1) + 1\n        \n        powers = [0]*(hi-lo+1)\n        if len(powers) == 1:\n            return lo\n        for i in range(len(powers)):\n            \n            if i+lo != 1:\n                powers[i] = getPower(i+lo)-1\n            else:\n                powers[i] = getPower(i+lo)\n        \n        idxs = sorted(range(len(powers)), key = lambda x: powers[x])\n        # print(powers, idxs)\n        return lo+idxs[k-1]", "from functools import lru_cache\n\n\nclass Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n\n        @lru_cache\n        def power(n):\n            if n == 1:\n                return 0\n            if n % 2 == 0:\n                return 1 + power(n // 2)\n            else:\n                return 1 + power(3 * n + 1)\n\n        powers = [(power(n), n) for n in range(lo, hi+1)]\n        powers.sort()\n\n        return powers[k-1][1]\n", "class Solution:\n    def power(self, n):\n        c = 0\n        while n != 1:\n            if n % 2:\n                n = (n * 3) + 1\n            else:\n                n //= 2\n            c += 1\n        return c\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        e = [i for i in range(lo, hi+1)]\n        e.sort(key = self.power)\n        return e[k-1]\n", "import heapq\nclass Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        memo = {}\n        q = []\n        for num in range(lo,hi+1):\n            count = 0\n            tmp = num\n            while num != 1:\n                if num not in memo:  \n                    if num % 2 == 0:\n                        cal = num//2\n                    else:\n                        cal = 3*num +1\n                    memo[num] = cal\n                \n                num = memo[num]\n                count+=1\n            \n            heapq.heappush(q,(count,tmp))\n        \n        while k>0:\n            item = heapq.heappop(q)\n            #print(item)\n            k-=1\n        return item[1]\n            \n                                 \n            \n        \n                    \n                    \n            \n"]