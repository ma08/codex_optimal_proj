["def mem_alloc(banks):\n    seen = set()\n    while tuple(banks) not in seen:\n        seen.add(tuple(banks))\n        number = max(banks)\n        index = banks.index(number)\n        banks[index] = 0\n        while number:\n            index = (index + 1) % 16\n            banks[index] += 1\n            number -= 1\n    return len(seen)", "def mem_alloc(banks):\n    banks, redist = tuple(banks), set()\n    while banks not in redist:\n        redist.add(banks)\n        blocks = max(banks)\n        index, div, mod = banks.index(blocks), *divmod(blocks, 16)\n        banks = tuple((i != index and bank) + div + ((i-index-1)%16 < mod) for i, bank in enumerate(banks))\n    return len(redist)", "def mem_alloc(banks):\n    seen, turn = set(), 0\n    \n    while 1:\n        saw = tuple(banks)\n        if saw in seen: return turn\n        seen.add(saw)\n        \n        im,m = max(enumerate(banks), key=lambda it: (it[1], -it[0]))\n        n,r = divmod(m, len(banks))\n        \n        banks[im] = 0\n        banks = [v+n for i,v in enumerate(banks)]\n        for i in range(1,r+1): banks[(i+im) % len(banks)] += 1\n        turn += 1", "from operator import itemgetter\n\n\ndef mem_alloc(banks):\n    cache = set()\n    count = 0\n    while tuple(banks) not in cache:\n        cache.add(tuple(banks))\n        count += 1\n        ind, val = max(enumerate(banks), key=itemgetter(1))\n        banks[ind] = 0\n        for i in range(val):\n            ind += 1\n            banks[ind % len(banks)] += 1\n    return count", "def mem_alloc(t):\n    visited, l = set(), len(t)\n    while 1:\n        m = max(t)\n        ind = t.index(m)\n        t[ind], put = 0, m//l\n        for i in range(l) : t[i] += put\n        for i in range(ind+1,ind+(m-put*l)+1) : t[i % l] += 1\n        m = tuple(t)\n        if m in visited : return len(visited)+1\n        visited.add(m)", "def mem_alloc(block):\n    common_set = set()\n    new_list = tuple(block)\n    while not(new_list in common_set):\n        common_set.add(new_list)\n        new_list = list(new_list)\n        max_num = max(new_list)\n        len_list = len(new_list)\n        base_num, len_mod_num = divmod(max_num, len_list)\n        len_div_num = len_list - len_mod_num\n        ind = new_list.index(max_num)\n        new_list[ind] = 0\n        \n        pattern_num = [base_num] * len_div_num + [base_num + 1] * len_mod_num\n        pattern_num = pattern_num[ind::-1] + pattern_num[len_list:ind:-1]\n        for i in range(len_list): new_list[i] += pattern_num[i]\n        new_list = tuple(new_list)\n    return len(common_set)", "def mem_alloc(banks):\n    banks=banks[:]\n    d=set()\n    n=0\n    L=len(banks)\n    while tuple(banks) not in d:\n        d|={tuple(banks)}\n        n+=1\n        i,m=0,0\n        for j,v in enumerate(banks):\n            if v>m:m=v;i=j\n        a,b=divmod(m,L)\n        banks[i]=0\n        for _ in range(L):\n            banks[_]+=a\n        for _ in range(b):\n            banks[(i+_+1)%L]+=1\n    return n", "def mem_alloc(banks):\n    seen = set()\n    while tuple(banks) not in seen:\n        seen.add(tuple(banks[:]))\n        num = max(banks)\n        i = banks.index(num)\n        banks[i] = 0\n        while num:\n            i = (i + 1) % len(banks)\n            banks[i] += 1\n            num -= 1\n    return len(seen)\n", "def mem_alloc(banks):\n    banks, memo, size = tuple(banks), set(), len(banks)\n    while banks not in memo:\n        memo.add(banks)\n        i = max(range(size), key=banks.__getitem__)\n        q, r = divmod(banks[i], size)\n        x, y = r+i, r+i-size\n        banks = tuple(q if i==j else banks[j] + q + (i < j <= x or j <= y) for j in range(size))\n    return len(memo)", "#2700ms\ndef mem_alloc(banks):\n    banks, redist = tuple(banks), set()\n    while banks not in redist:\n        redist.add(banks)\n        blocks = max(banks)\n        index = banks.index(blocks)\n        div, mod = divmod(blocks, 16)\n        banks = tuple((i != index and bank) + div + ((i-index-1)%16 < mod) for i, bank in enumerate(banks))\n    return len(redist)\n"]