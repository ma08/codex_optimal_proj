["import math\n\nclass Solution:\n    def __init__(self):\n        self.happy_string = ''\n    \n    def getHappyString(self, n: int, k: int) -> str:\n        # determine starting character\n        poss_per_group = 2 ** (n - 1)\n        group_num = math.ceil(k / poss_per_group) - 1\n        starting_char = ''\n        \n        # check to make sure there are at least k happy strings\n        if k > poss_per_group * 3:\n            return ''\n        \n        if group_num == 0:\n            self.happy_string += 'a'\n        elif group_num == 1:\n            self.happy_string += 'b'\n        else:\n            self.happy_string += 'c'\n            \n        self.findNextChar(group_num, n - 1, group_num * poss_per_group, (group_num + 1) * poss_per_group, k)\n        return self.happy_string\n        \n    def findNextChar(self, char_index: int, n: int, start: int, end: int, k: int) -> None:\n        if n != 0:\n            lower_index = -1\n            upper_index = -1\n            \n            # 0 = 'a', 1 = 'b', 2 = 'c'\n            if char_index == 0:\n                lower_index = 1\n                upper_index = 2\n            elif char_index == 1:\n                lower_index = 0\n                upper_index = 2\n            else:\n                lower_index = 0\n                upper_index = 1\n                \n            midpoint = int((start + end ) / 2)\n            if (k <= midpoint):\n                self.happy_string += self.indexToStr(lower_index)\n                self.findNextChar(lower_index, n - 1, start, midpoint, k)\n            else:\n                self.happy_string += self.indexToStr(upper_index)\n                self.findNextChar(upper_index, n - 1, midpoint, end, k)                \n                \n    def indexToStr(self, index: int) -> str:\n        if index == 0:\n            return 'a'\n        elif index == 1:\n            return 'b'\n        else:\n            return 'c'\n                \n            \n            \n        \n            \n", "class Solution:\n    def getHappyString(self, n: int, k: int) -> str:\n        m_vals = 3 * (2 ** (n - 1))\n        if k > m_vals:\n            return ''\n        k -= 1\n        m_vals //= 3\n        vals = ['a', 'b', 'c']\n        mapping = {0:'a',1:'b',2:'c'}\n        s = mapping[k // m_vals]\n        k %= m_vals\n        m_vals //= 2\n        prev_map = {'a':{0:'b',1:'c'},'b':{0:'a',1:'c'},'c':{0:'a',1:'b'}}\n        while m_vals:\n            mapping = prev_map[s[-1]]\n            s += mapping[k // m_vals]\n            k %= m_vals\n            m_vals //= 2\n        return s", "class Solution:\n    def getHappyString(self, n: int, k: int) -> str:\n        cnt = 0\n        choice = ['a','b','c']\n        ret = []\n        def backTrack(lastCh, idx, l):\n            nonlocal cnt, ret\n            if idx == n:\n                cnt += 1\n                if cnt == k:\n                    ret = l\n                    return True\n                return False\n            for ch in choice:\n                if ch == lastCh:\n                    continue\n                l.append(ch)\n                if backTrack(ch, idx+1, l):\n                    return True\n                l.pop()               \n        backTrack('x', 0, [])\n        return ''.join(ret)\n", "class Solution:\n    def getHappyString(self, n: int, k: int) -> str:\n        nextLetter = {'a':'bc','b':'ac','c':'ab'}\n        q = deque(['a','b','c'])\n        while len(q[0]) != n:\n            u = q.popleft()\n            for v in nextLetter[u[-1]]:\n                q.append(u + v)\n        return q[k - 1] if len(q) >= k else '' ", "class Solution:\n    def getHappyString(self, n: int, k: int) -> str:\n        nextLetter = {'a':'bc','b':'ac','c':'ab'}\n        q = deque(['a','b','c'])\n        while len(q[0]) != n:\n            u = q.popleft()\n            \n            for v in nextLetter[u[-1]]:\n                q.append(u + v)\n        return q[k - 1] if len(q) >= k else ''", "class Solution:\n    def getHappyString(self, n: int, k: int) -> str:\n        nextLetter = {'a': 'bc', 'b': 'ac', 'c': 'ab'} \n        q = collections.deque(['a', 'b', 'c'])\n        while len(q[0]) != n:\n            u = q.popleft()    \n            for v in nextLetter[u[-1]]:\n                q.append(u + v)\n        return q[k - 1] if len(q) >= k else ''   ", "class Solution:\n    def getHappyString(self, n: int, k: int) -> str:\n        nextLetter = {'a': 'bc', 'b': 'ac', 'c': 'ab'} \n        q = collections.deque(['a', 'b', 'c'])\n        while len(q[0]) != n:\n            u = q.popleft()    \n            for v in nextLetter[u[-1]]:\n                q.append(u + v)\n        return q[k - 1] if len(q) >= k else ''     \n", "class Solution:\n    def getHappyString(self, n: int, k: int) -> str:\n        N = 3 << (n - 1)\n        res = ''\n        if k > N:\n            return res\n        k -= 1\n        letters = ('a', 'b', 'c')\n        res += letters[k * 3 // N]\n        N //= 3\n        k %= N\n        for i in range(1, n):\n            prev = res[i - 1]\n            index = k * 2 // N\n            offset = int(prev <= letters[index])\n            res += letters[index + offset]\n            N >>= 1\n            k %= N\n        return res\n", "class Solution:\n    def getHappyString(self, n: int, k: int) -> str:\n        def stringformer(sts,prev):\n            if len(sts) == n:\n                l.append(sts)\n                return \n            for i in ['a','b','c']:\n                if i != prev:\n                    stringformer(sts+i,i)\n        \n        l = []\n        stringformer('','')\n        if len(l) == 0 or (k>len(l)):\n            return ''\n        else:\n            return l[k-1]\n", "class Solution:\n    def getHappyString(self, n: int, k: int) -> str:\n        res= []\n        s='abc'\n        def dfs(n, res, path):\n            if n==0:\n                res.append(path)\n                return\n            for i in s:\n                if not (path and path[-1]==i):\n                    dfs(n-1, res, path+i)\n        dfs(n, res, '')\n        res.sort()\n        return res[k-1] if k<=len(res) else ''\n\n\n        \n        \n\n", "class Solution:\n    def getHappyString(self, n: int, k: int) -> str:\n        res= []\n        s='abc'\n        def dfs(n, res, path):\n            if n==0:\n                res.append(path)\n                return\n            for i in s:\n                if not (path and path[-1]==i):\n                    dfs(n-1, res, path+i)\n        dfs(n, res, '')\n        #res.sort()\n        return res[k-1] if k<=len(res) else ''\n\n\n        \n        \n\n", "class Solution:\n    def getHappyString(self, n: int, k: int) -> str:\n        if k > 3 * 1 << (n - 1):\n            return ''\n        other = [(1, 2), (0, 2), (0, 1)]\n        ans = [(k-1) // (1 << (n - 1))]\n        k2bit = bin((k-1) % (1 << (n - 1)))[2:]\n        k2bit = '0'*(n-1-len(k2bit)) + k2bit\n        \n        for i in range(1, n):\n            ans.append(other[ans[i-1]][int(k2bit[i-1])])\n        letters = 'abc'\n\n        return ''.join([letters[x] for x in ans])\n", "class Solution:\n    def getHappyString(self, n: int, k: int) -> str:\n        \n        def rec(x,n,s):\n            \n            if len(x) == n:\n                r.append(x)\n            else:\n                for i in range(len(s)):\n                    if s[i] == 'a':\n                        rec(x+s[i],n,'bc')\n                    elif s[i] == 'b':\n                        rec(x+s[i],n,'ac')\n                    else:\n                        rec(x+s[i],n,'ab')\n    \n                    \n        r = []\n        rec('',n,'abc')\n        \n        if k<=len(r):\n            return r[k-1]\n        else:\n            return ''", "class Solution:\n    def getHappyString(self, n: int, k: int) -> str:\n        \n        def dfs(ind,nlen,path,res):\n            if ind == nlen:\n                res.append(path)\n                return\n            for i in range(3):\n                if len(path)==0 or (path[-1]!=ls[i]):\n                    dfs(ind+1,nlen,path+ls[i],res)\n        \n        ls = ['a','b','c']\n        vis = [0]*3\n        res = []\n        dfs(0,n,'',res)\n        res.sort()\n        if len(res)<k:\n            return ''\n        return res[k-1]\n", "class Solution:\n    def getHappyString(self, n: int, k: int) -> str:\n        s, res = 'abc', []\n        \n        def dfs(s, length, path, res):\n            if len(path) == length:\n                res.append(path)\n                return\n            for i in range(len(s)):\n                if path and s[i] == path[-1]: continue\n                else: dfs(s, length, path + s[i], res)\n        \n        dfs(s, n, '', res)\n        res.sort()\n        # print(res)\n        return res[k - 1] if k <= len(res) else ''", "class Solution:\n    def getHappyString(self, n: int, k: int) -> str:\n        \n        self.result = ['']\n        self.index = 0\n        def back_track(cur):\n            if len(cur) == n:\n                self.index+=1\n                if self.index == k: \n                    self.result[0] = cur\n                return\n            for i in range(ord('a'), ord('d')):\n                if len(cur)>0 and cur[-1]== chr(i):\n                    continue\n                back_track(cur+chr(i))\n            return \n        back_track('')\n        return self.result[0]\n            \n            \n", "class Solution:\n    def getHappyString(self, n: int, k: int) -> str:\n        res=[]\n        \n        def helper(cur,tmp):\n            if len(cur)==n:\n                res.append(cur)\n                return             \n            for t in tmp:\n                new=[i for i in ['a','b','c'] if i!=t]\n                helper(cur+t,new)\n            \n        helper('',['a','b','c'])\n        return res[k-1] if k-1<len(res) else ''", "from collections import deque\n\nclass Solution:\n    def getHappyString(self, n: int, k: int) -> str:\n        chars = ['a', 'b', 'c']\n        queue = deque()\n        queue.extend(chars)\n\n        last_length = 0\n        length_count = 0\n        while len(queue[0]) <= n:\n            string = queue.popleft()\n            if len(string) != last_length:\n                last_length = len(string)\n                length_count = 1\n            else:\n                length_count += 1\n\n            if n == last_length and k == length_count:\n                return string\n\n            for char in chars:\n                if char != string[-1]:\n                    queue.append(string + char)\n\n        return ''\n", "import math\n\nLETTER_SET = ['a', 'b', 'c']\nLEFT = 0\nRIGHT = 1\n    \n\nclass Solution:\n\n    def getHappyString(self, n: int, k: int) -> str:\n        index = self.getRootIndex(n, k)\n        if index == None: return ''\n        kth_happy = LETTER_SET[index]\n        \n        happy_strings_per_node = self.calculateTotalNumOfHappyForN(n)\n        min_range = happy_strings_per_node * index + 1\n        max_range = happy_strings_per_node * (index + 1)\n        for level in range(n-1):\n            direction = self.findDirection(min_range, max_range, k)\n            kth_happy = self.nextHappyString(kth_happy, direction)\n            min_range, max_range = self.fetchNewRange(min_range, max_range, direction)\n            \n        return kth_happy\n        \n    def findDirection(self, min_range, max_range, k):\n        min_low = min_range\n        min_high = math.floor((min_range + max_range) / 2)\n        max_low = min_high + 1\n        max_high = max_range\n        is_in_min_range = k >= min_low and k <= min_high\n        return LEFT if is_in_min_range else RIGHT\n        \n    def fetchNewRange(self, min_range, max_range, direction):\n        min_low = min_range\n        min_high = math.floor((min_range + max_range) / 2)\n        max_low = min_high + 1\n        max_high = max_range\n\n        return (min_low, min_high) if (LEFT == direction) else (max_low, max_high)             \n    \n    def calculateTotalNumOfHappyForN(self, n):\n        return 2**(n-1)\n    \n    def getRootIndex(self, n, k):\n        happy_strings_total = self.calculateTotalNumOfHappyForN(n) * len(LETTER_SET)\n        happy_strings_per_node = happy_strings_total / len(LETTER_SET)\n        \n        for i in range(len(LETTER_SET)):\n            min_range = happy_strings_per_node * i + 1\n            max_range = happy_strings_per_node * (i + 1)\n            \n            if k >= min_range and k <= max_range:\n                return i\n            \n        return None\n    \n    def nextHappyString(self, string, direction):\n        happyStrings = []\n        for letter in LETTER_SET:\n            if self.isValidHappyString(string, letter):\n                happyStrings.append(string + letter)\n        return happyStrings[direction]\n    \n    def isValidHappyString(self, string, letter):\n        return string[-1] != letter", "class Solution:\n    def getHappyString(self, n: int, k: int) -> str:\n        s=''\n        l=['a','b','c']\n        self.count=0\n        self.res=''\n        def alls(n,s,k):\n            for i in l:\n                if(len(s)!=0):\n                    if(s[-1]==i):\n                        continue\n                if(n==0):\n                    self.count+=1\n                    if(self.count==k):\n                        self.res=s\n                        return self.res\n                    break\n                n-=1\n                s+=i\n                alls(n,s,k)\n                n+=1\n                s=s[:-1]\n            return self.res\n        return alls(n,s,k)", "class Solution:\n    def getHappyString(self, n: int, k: int) -> str:\n        k = k -1\n        \n        def dfs(path, new):\n            \n            if len(path) == n:\n                res.append(path)\n                return\n            \n            \n            if len(path) == 0:\n                for ind, x in enumerate(new):\n                    dfs(path+x, new[:ind] + new[ind+1:])\n            \n            \n            else:\n                last = path[-1]\n                l = []\n                for i in letters:\n                    if i != last:\n                        l.append(i)\n                \n                for ind, x in enumerate(l):\n                    dfs(path+x, l[:ind] + l[ind+1:])\n        \n        \n        \n        \n        \n        letters = ['a', 'b', 'c']\n        res =[]\n        dfs('', letters)\n        \n        if k >= len(res):\n            return ''\n        else:\n            return res[k]", "class Solution:\n    def getHappyString(self, n: int, k: int) -> str:\n        if n==1:\n            if k<4:\n                return ['a','b','c'][k-1]\n            else:\n                return ''\n        ordered=[]\n        def is_valid(s):\n            if s[len(s)-1]==s[len(s)-2]:\n                return False\n            return True\n        queue=['a','b','c']\n        j=0\n        while queue:\n            if len(queue[len(queue)-1])==n+1:\n                break\n            element=queue.pop(0)\n            for char in ['a','b','c']:\n                if is_valid(element+char):\n                    if len(element+char)==n:\n                        ordered.append(element+char)\n                    queue.append(element+char)\n        if k>len(ordered):\n            return ''\n        return ordered[k-1]", "class Solution:\n    def getHappyString(self, n: int, k: int) -> str:\n        results = []\n        letters = 'abc' \n        combos = set()\n        def backtrack(s):\n            nonlocal results \n            if len(results) == k: \n                return \n            if len(s) == n and s not in combos:\n                combos.add(s)\n                results.append(s)\n                return\n            for i in range(0, len(letters)):\n                if s and s[-1] == letters[i]:\n                    continue\n                s += letters[i] \n                backtrack(s)\n                s = s[0:-1]\n                \n        backtrack('')\n        return results[-1] if len(results) == k else ''\n", "class Solution:\n    def getHappyString(self, n: int, k: int) -> str:\n        count = [0]\n        letters = ['a','b','c']\n        def bt(cur_list=[],last_appended = ''):\n            if len(cur_list) == n:\n                count[0]+=1\n                if count[0] == k:\n                    return ''.join(cur_list)\n                else:\n                    return ''\n            for i in letters:\n                if i == last_appended:\n                    continue\n                else:\n                    cur_list.append(i)\n                    output = bt(cur_list,i)\n                    if output !='':\n                        return output\n                    cur_list.pop()\n            return ''\n                    \n            \n        output = bt()\n        return '' if not output else output"]