["def prod2sum(a, b, c, d):\n    e = sorted([abs(a*d-b*c), abs(a*c+b*d)])\n    f = sorted([abs(a*c-b*d), abs(a*d+b*c)])\n    if e == f:\n        return [e]\n    else:\n        return sorted([e, f])\n\n", "def prod2sum(a, b, c, d):\n    r1 = sorted([abs(a*c-b*d),abs(a*d+b*c)])\n    r2 = sorted([abs(a*c+b*d),abs(a*d-b*c)])\n    return sorted([r1,r2]) if r1!=r2 else [r1]", "prod2sum=lambda a,b,c,d:sorted([list(i) for i in {tuple(sorted(map(abs,[(a*d)+(b*c),(a*c)-(b*d)]))),tuple(sorted(map(abs,[(a*c)+(b*d),abs((a*d)-(b*c))])))}])", "def prod2sum(a, b, c, d):\n    num = [a, b, c, d]\n    if sorted([abs(num[0] * num[2] - num[1] * num[3]), abs(num[0] * num[3] + num[1] * num[2])]) == sorted([num[0] * num[3] - num[1] * num[2], num[0] * num[2] + num[1] * num[3]]):\n        return [sorted([abs(num[0] * num[3] + num[1] * num[2]), abs(num[0] * num[2] - num[1] * num[3])])]\n    else:\n        if sorted([abs(num[0] * num[3] - num[1] * num[2]), abs(num[0] * num[2] + num[1] * num[3])])[0] < sorted([abs(num[0] * num[2] - num[1] * num[3]), abs(num[0] * num[3] + num[1] * num[2])])[0]:\n            return [sorted([abs(num[0] * num[3] - num[1] * num[2]), abs(num[0] * num[2] + num[1] * num[3])]), sorted([abs(num[0] * num[2] - num[1] * num[3]), abs(num[0] * num[3] + num[1] * num[2])])]\n        else:\n            return [sorted([abs(num[0] * num[2] - num[1] * num[3]), abs(num[0] * num[3] + num[1] * num[2])]), sorted([abs(num[0] * num[3] - num[1] * num[2]), abs(num[0] * num[2] + num[1] * num[3])])]\n\n\n", "def chsgn(k):\n    r = []\n    for x in k:\n        if (x < 0):\n            r.append(-x)\n        else:\n            r.append(x)\n    return r\n\ndef prod2sum(a, b, c, d):\n    e1 = a * c + b * d\n    f1 = a * d - b * c\n    e2 = a * c - b * d\n    f2 = a * d + b * c  \n    k = chsgn([e1, e2, f1, f2])\n    e1 = k[0]; e2 = k[1]; f1 = k[2]; f2 = k[3]\n    if ((e1 == f2) and (f1 == e2)) or ((e1 == e2) and (f1 == f2)): \n        res = [[min(e1,f1), max(e1,f1)]]\n    else:\n        res = [[min(e1,f1), max(e1,f1)]]\n        res.append([min(e2,f2), max(e2,f2)])\n    res = sorted(res, key=lambda x: x[0])\n    return res\n", "def prod2sum(a, b, c, d):\n    result = map(sorted, [map(abs, [a * d - b * c, a * c + b * d]), map(abs, [b * d - a * c, b * c + a * d])])\n    return sorted(result, key=lambda x: x[0])[:2 - (a == b or b == 0)]", "prod2sum = lambda a, b, c, d: sorted(map(list, {tuple(sorted(map(abs, s))) for s in ((a*c - b*d, a*d + b*c), (a*d - b*c, a*c + b*d))}))", "def prod2sum(a, b, c, d):\n    l1 = sorted([abs(a*c+b*d),abs(a*d-b*c)])\n    l2 = sorted([abs(a*c-b*d),abs(a*d+b*c)])\n    if l1==l2:\n        return [l1]\n    else:\n        return sorted([l1,l2])", "def prod2sum(a,b,c,d):\n    hi = sorted([abs(a*c+b*d), abs(a*d-b*c)])\n    hello = sorted([abs(a*c-b*d), abs(a*d+b*c)])\n    if hi == hello:\n        return [hi]\n    else:\n        return sorted([hi, hello])", "def as_pair(z):\n    pos_int = lambda x: abs(int(x))\n    return sorted( map(pos_int, [z.real, z.imag]) )\n\ndef prod2sum(a, b, c, d):\n    z = complex(a,b)\n    w = complex(c,d)\n    results = list(map(as_pair, [z * w,  z * w.conjugate()]))\n    if results[1]==results[0]:\n        results.pop()\n    return sorted(results)\n"]