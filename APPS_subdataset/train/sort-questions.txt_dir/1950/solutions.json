["# Definition for singly-linked list.\n # class ListNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.next = None\n \n class Solution:\n     def deleteDuplicates(self, head):\n         \"\"\"\n         :type head: ListNode\n         :rtype: ListNode\n         \"\"\"\n         if not head or not head.next:\n             return head\n         fakehead = ListNode(0)\n         fakehead.next = head\n         prev = fakehead\n         slow = head\n         fast = head.next\n         while fast:\n             if fast.val == slow.val:\n                 while fast and fast.val == slow.val:\n                     fast = fast.next\n                 slow = prev\n             else:\n                 prev = slow\n                 slow = slow.next\n                 slow.val = fast.val\n                 fast = fast.next\n         slow.next = None\n         return fakehead.next\n         ", "# Definition for singly-linked list.\n # class ListNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.next = None\n \n class ListNode:\n     def __init__(self, x):\n         self.val = x\n         self.next = None\n \n class Solution(object):\n     def deleteDuplicates(self, head):\n         \"\"\"\n         :type head: ListNode\n         :rtype: ListNode\n         \"\"\"\n         #start from nothing so we don't need to invalidate our position later\n         real_head = ListNode(0)\n         #previous also points to nothing at the start\n         previous, current = real_head, head\n         while current:\n             #validate current.next OTHERWISE IT CRAHES DUMMY\n             if current.next and current.next.val == current.val:\n                 #remove ALL of the value in a tight loop\n                 val_remove = current.val;\n                 while current and current.val == val_remove:\n                     current = current.next\n                 previous.next = current\n             else:\n                 previous.next = current\n                 previous = current\n                 current = current.next\n         return real_head.next\n             \n         ", "# Definition for singly-linked list.\n # class ListNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.next = None\n \n class ListNode:\n     def __init__(self, x):\n         self.val = x\n         self.next = None\n \n class Solution(object):\n     def deleteDuplicates(self, head):\n         \"\"\"\n         :type head: ListNode\n         :rtype: ListNode\n         \"\"\"\n         #start from nothing so we don't need to invalidate our position later\n         real_head = ListNode(0)\n         #previous also points to nothing at the start\n         previous, current = real_head, head\n         while current:\n             #validate current.next OTHERWISE IT CRAHES DUMMY\n             if current.next and current.next.val == current.val:\n                 #remove ALL of the value in a tight loop\n                 val_remove = current.val;\n                 while current and current.val == val_remove:\n                     current = current.next\n                 previous.next = current\n             else:\n                 previous.next = current\n                 previous = current\n                 current = current.next\n         return real_head.next\n             \n         ", "# Definition for singly-linked list.\n # class ListNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.next = None\n \n class Solution:\n     def deleteDuplicates(self, head):\n         if head == None or head.next == None:\n             return head \n        \n         def get_next(node):\n             while node != None and node.next != None and node.val == node.next.val:\n                 cur_val = node.val\n                 node = node.next.next\n                 while node != None and node.val == cur_val:\n                     node = node.next\n             return node\n \n         head = get_next(head)\n         if head == None:\n             return []\n         \n         prev = head\n         cur = prev.next\n         while (cur != None):\n             cur = get_next(cur)\n             prev.next = cur\n             prev = cur\n             if cur != None:\n                 cur = cur.next\n \n         return head\n         ", "# Definition for singly-linked list.\n # class ListNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.next = None\n \n class Solution:\n     def deleteDuplicates(self, head):\n         \"\"\"\n         :type head: ListNode\n         :rtype: ListNode\n         \"\"\"\n         dummy = ListNode(0)\n         new_head = dummy\n         prev = None\n         n = 0\n         while head:\n             if prev is None:\n                 prev = head\n                 n = 1\n             elif head.val != prev.val:\n                 if n < 2:\n                     new_head.next = prev\n                     new_head = prev\n                 prev = head\n                 n = 1\n             else:\n                 n += 1\n \n             head = head.next\n         if n == 1:\n             new_head.next = prev\n             new_head = new_head.next\n         new_head.next = None\n         return dummy.next\n         ", "# Definition for singly-linked list.\n # class ListNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.next = None\n \n \n         #\"\"\"\n         #:type head: ListNode\n         #:rtype: ListNode\n         #\"\"\"\n \n class Solution:  \n     # @param head, a ListNode  \n     # @return a ListNode  \n     def deleteDuplicates(self, head):\n         pre = ListNode(0)\n         dummy = pre\n         dummy.next = head\n         while head and head.next:\n             if head.val == head.next.val:\n                 while head and head.next and head.val == head.next.val:\n                     head = head.next\n                 head = head.next\n                 pre.next = head\n             else:\n                 pre = pre.next\n                 head = head.next\n         return dummy.next", "# Definition for singly-linked list.\n # class ListNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.next = None\n \n class Solution:\n     def deleteDuplicates(self, head):\n         \"\"\"\n         :type head: ListNode\n         :rtype: ListNode\n         \"\"\"\n         t = None\n         c = None\n         while head:\n             if c is None or c != head.val:\n                 t, head.next, head = head, t, head.next\n                 c = t.val\n             else:\n                 while t and t.val == c:\n                     t = t.next\n                 head = head.next\n         res = None\n         while t:\n             res, t.next, t = t, res, t.next\n         return res", "# Definition for singly-linked list.\n # class ListNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.next = None\n \n class Solution:\n     def deleteDuplicates(self, head):\n         \"\"\"\n         :type head: ListNode\n         :rtype: ListNode\n         \"\"\"\n         dummy = ListNode(0)\n         dummy.next = head\n         node = dummy\n         while node.next:\n             next = node.next\n             val = next.val\n             if next.next and next.next.val == val:\n                 next = next.next.next\n                 while next and next.val == val:\n                     next = next.next\n                 node.next = next\n             else:\n                 node = node.next\n         return dummy.next", "# Definition for singly-linked list.\n # class ListNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.next = None\n \n class Solution:\n     def deleteDuplicates(self, head):\n         temp = head\n         res = None\n         resHead = None\n         counter = 0\n \n         while temp != None:\n             counter = counter + 1\n             if temp.next != None and temp.val == (temp.next).val:\n                 duplicateval = temp.val\n                 print(\"Duplicate Val: %d\" % duplicateval)\n \n                 # Iterate through the list till the value of duplicate are ongoing\n                 while temp != None and temp.val == duplicateval:\n                     temp = temp.next\n             else:\n                 if res == None:\n                     res = ListNode(0)\n                     res.val = temp.val\n                     res.next = None\n                     resHead = res\n                 else:\n                     res = resHead\n                     while res.next != None:\n                         res = res.next\n                     \n                     res.next = ListNode(0)\n                     (res.next).val = temp.val\n                     (res.next).next = None\n             \n                 temp = temp.next\n                 #print(\"Next: %d\", temp.val)\n             \n         return resHead", "# Definition for singly-linked list.\n # class ListNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.next = None\n \n class Solution:\n     def deleteDuplicates(self, head):\n         \"\"\"\n         :type head: ListNode\n         :rtype: ListNode\n         \"\"\"\n         if head == None:\n             return None\n         \n         loop = head\n         loop1 = head\n         d = {}\n         \n         while loop:\n             if loop.val in d.keys():\n                 d[loop.val] += 1\n             else:\n                 d[loop.val] = 1\n             loop = loop.next\n         \n         while loop1.next:\n             if d[loop1.next.val] > 1:\n                 loop1.next = loop1.next.next\n             else:\n                 loop1 = loop1.next\n                 \n         if d[head.val] > 1:\n             return head.next\n         else:\n             return head\n                 \n         ", "# Definition for singly-linked list.\n # class ListNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.next = None\n from collections import OrderedDict\n \n class Solution:\n     def deleteDuplicates(self, head):\n         \"\"\"\n         :type head: ListNode\n         :rtype: ListNode\n         \"\"\"\n         lookup = OrderedDict()\n         \n         while head:\n             if head.val in lookup:\n                 lookup[head.val] += 1\n             else:\n                 lookup[head.val] = 1\n             head = head.next\n         \n         previous = None\n         head = None\n         for key in lookup:\n             \n             if (lookup[key] != 1):\n                 continue\n                 \n             node = ListNode(key)\n             if previous:\n                 previous.next = node\n             else:\n                 head = node\n             previous = node\n \n         return(head)\n         \n         ", "# Definition for singly-linked list.\n # class ListNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.next = None\n \n class Solution:\n     def deleteDuplicates(self, head):\n         \"\"\"\n         :type head: ListNode\n         :rtype: ListNode\n         \"\"\"\n         if head == None:\n             return None\n         \n         loop = head\n         loop1 = head\n         d = {}\n         \n         while loop:\n             if loop.val in d.keys():\n                 d[loop.val] += 1\n             else:\n                 d[loop.val] = 1\n             loop = loop.next\n         \n         while loop1.next:\n             if d[loop1.next.val] > 1:\n                 loop1.next = loop1.next.next\n             else:\n                 loop1 = loop1.next\n                 \n         if d[head.val] > 1:\n             return head.next\n         else:\n             return head\n                 \n         ", "# Definition for singly-linked list.\n # class ListNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.next = None\n \n class Solution:\n     def deleteDuplicates(self, head):\n         \"\"\"\n         :type head: ListNode\n         :rtype: ListNode\n         \"\"\"\n         if not head or not head.next:\n             return head\n         \n         res = ListNode(0)\n         p = res        \n         cnt = 0\n         while head:\n             if cnt == 0:\n                 candidate = head.val\n                 cnt += 1\n             elif candidate != head.val:\n                 if cnt == 1:\n                     p.next = ListNode(candidate)\n                     p = p.next\n                 candidate = head.val\n                 cnt = 1\n             else: \n                 cnt += 1\n             head = head.next\n         \n         if cnt == 1:\n             p.next = ListNode(candidate)\n         return res.next\n                 \n             ", "# Definition for singly-linked list.\n # class ListNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.next = None\n \n class Solution:\n     def deleteDuplicates(self, head):\n         \"\"\"\n         :type head: ListNode\n         :rtype: ListNode\n         \"\"\"\n         if head is None or head.next is None:\n             return head\n         dmy = ListNode (head.val - 1)\n         dmy.next = head\n         prev = dmy\n         curr = dmy\n         dul = dmy.val\n         while curr:\n             if curr.val == dul:\n                 curr = curr.next\n                 if curr:\n                     continue\n                 else:\n                     prev.next = None\n             else:\n                 dul = curr.val\n                 prev.next = curr\n                 curr = curr.next\n                 if curr and curr.val != dul:\n                     prev = prev.next\n         return dmy.next\t"]