["def replace_zero(arr):\n    m, im, i, lst = 0, -1, -1, ''.join(map(str,arr)).split('0')\n    for a,b in zip(lst,lst[1:]):\n        i += len(a) + 1 \n        candidate = len(a)+len(b)+1\n        if m <= candidate:\n            im, m = i, candidate\n    return im", "def replace_zero(arr):\n    ret = [0,0]\n    arr = [None] + arr + [None]\n    for i,e in enumerate(arr):\n        if type(arr[i])==int and not e and any((arr[i+1],arr[i-1])):\n            mx = (sm(arr[:i]) + sm(arr[i+1:][::-1]))\n            ret = [ret,[mx, i-1]][mx>=ret[0]]\n    return ret[-1]\n    \ndef sm(arr, c=0):\n    i = len(arr)-1\n    while arr[i]:\n        i -=1\n        c +=1\n    return c", "def replace_zero(lst):\n    z = [-1] + [i for i, n in enumerate(lst) if not n] + [len(lst)]\n    return max((z[i+1]-z[i-1], z[i]) for i in range(1, len(z)-1))[1]\n", "import itertools\n\ndef replace_zero(arr):\n    xs = list(itertools.chain.from_iterable([length if key else 0] * length\n        for key, grp in itertools.groupby(arr)\n        for _, length in [(key, sum(1 for _ in grp))]\n    ))\n    return max(\n        (0, i) if x else (1 + (xs[i-1] if i > 0 else 0) + (xs[i+1] if i < len(xs)-1 else 0), i)\n        for i, x in enumerate(xs)\n    )[1]", "def replace_zero(arr):\n    # (len, index)\n    best_len, best_idx = 0, 0\n    curr_len, curr_idx = 0, None\n\n    for i, e in enumerate(arr):\n        if e == 1:\n            curr_len += 1\n        else:\n            if curr_len >= best_len:\n                best_len, best_idx = curr_len, curr_idx\n\n            if curr_idx is None:\n                curr_len += 1\n            elif i - curr_idx < 2:\n                curr_len = 1\n            else:\n                curr_len = i - curr_idx\n            curr_idx = i\n\n    if curr_len >= best_len:\n        best_len, best_idx = curr_len, curr_idx\n\n    return best_idx", "def replace_zero(arr):\n    labels=[]\n    max=1\n    ans=-1\n    # find all the indices that correspond to zero values\n    for i in range(len(arr)):\n        if arr[i]==0:\n            labels.append(i)\n    # try each index and compute the associated length\n    for j in range(len(labels)):\n        arr[labels[j]]=1\n        count=1\n        end=0\n        # check how long the sequence in on the left side.\n        k=labels[j]\n        while end==0 and k!=0:\n            if arr[k-1]:\n                count=count+1\n                k=k-1\n            else:\n                end=1\n        end=0\n        k=labels[j]\n        # check how long the sequence in on the right side.\n        while end==0 and k!=len(arr)-1:\n            if arr[k+1]:\n              count=count+1\n              k=k+1\n            else:\n                end=1\n        # restore the selected element to zero and check if the new value is a max.\n        arr[labels[j]]=0\n        if(count>=max):\n            ans=labels[j]\n            max=count\n    return(ans)\n\n", "def replace_zero(arr):\n    max_idx, count = None, 0\n    left = idx = right = 0\n    for i, n in enumerate(arr + [0]):\n        if n:\n            right += 1\n        else:\n            if left + right >= count:\n                max_idx, count = idx, left + right\n            left, idx, right = right, i, 0\n    return max_idx", "def replace_zero(a):\n    li1 = []\n    for i, j in enumerate(a):\n        if j == 0:\n            temp = a[:]\n            t,t1,li,temp[i] = i,i+1,[],1\n            while t >= 0 and temp[t] == 1 : li.append(temp[t]) ; t -= 1\n            while t1 <= len(a) - 1 and temp[t1] == 1 : li.append(temp[t1]) ; t1 += 1\n            li1.append([len(li), i])\n    return sorted( li1, key=lambda x: (-x[0], -x[1]) )[0][1]", "import itertools as it\n\ndef iter_len(iterator):\n    return len(list(iterator))\n\ndef window (iterable, length):\n    iterators = [it.islice(iterator, idx, None) for idx,iterator in enumerate(it.tee(iterable, length))]\n    return zip(*iterators)\n    \ndef replace_zero(arr):\n\n    def accumulate_group(total, group):\n        _, prev_length, prev_begin = total \n        key, length, _ = group\n        return key, length, prev_begin+prev_length\n        \n        \n    groups = ((key, iter_len(group), 0) for key, group in it.groupby(arr))\n    empty = [(None, 0, 0)]\n    indexed_groups = it.accumulate(it.chain(empty,groups,empty), accumulate_group)\n    \n    is_zero = lambda group: group[0] == 0\n    is_one = lambda group: group[0] == 1\n    group_len = lambda group: group[1]\n    first_pos = lambda group: group[2]\n    last_pos = lambda group: group[2] + group[1] - 1\n    revelant = lambda triple: is_zero(triple[1])\n        \n    triples = filter(revelant, window(indexed_groups,3))\n    \n    def solutions (triples): \n        for left,this,right in triples:\n            if group_len(this) == 1:\n                yield group_len(left)+1+group_len(right), first_pos(this)\n            else:\n                yield group_len(left)+1, first_pos(this)\n                yield group_len(right)+1, last_pos(this)\n    \n    length, positions = max(solutions(triples))\n    return positions", "def replace_zero(arr):\n    z = [0]+[i for i in range(len(arr)) if not arr[i]] + [len(arr)]\n    sums = sorted([[sum(arr[z[i]:z[i+2]]),z[i+1]] for i in range(len(z)-2)])\n    return sums[-1][1]\n"]