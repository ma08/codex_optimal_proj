["def snail(array):\n    ret = []\n    if array and array[0]:\n        size = len(array)\n        for n in range((size + 1) // 2):\n            for x in range(n, size - n):\n                ret.append(array[n][x])\n            for y in range(1 + n, size - n):\n                ret.append(array[y][-1 - n])\n            for x in range(2 + n, size - n + 1):\n                ret.append(array[-1 - n][-x])\n            for y in range(2 + n, size - n):\n                ret.append(array[-y][n])\n    return ret\n", "import numpy as np\n\ndef snail(array):\n    m = []\n    array = np.array(array)\n    while len(array) > 0:\n        m += array[0].tolist()\n        array = np.rot90(array[1:])\n    return m", "def snail(array):\n    mission = Game(array)\n    path = []\n    while mission.we_are_not_done:\n        path.append(mission.dig_at_location())\n        if mission.it_is_safe_to_slither:\n            mission.slither_onwards_good_soldier()\n        else:\n            mission.turn_away_from_fire()\n            mission.slither_onwards_good_soldier()\n    return path\n\n\nclass Game(object):\n    def __init__(self, array):\n        self.map = array\n        self.moves_left = len(array) * len(array[0])\n        self.coords = {\"x\": 0, \"y\": len(array)-1}  # start in NW area.\n        self.dir = \"E\"  # slitherin' east.\n        self.fire = {\"min_x\": -1, \"min_y\": -1, \"max_x\": len(array),\n                     \"max_y\": len(array)}  # the carpet is lava.\n        self.rules = {\"N\": {\"x\": 0, \"y\": 1, \"turn\": \"E\"},\n                      \"E\": {\"x\": 1, \"y\": 0, \"turn\": \"S\"},\n                      \"S\": {\"x\": 0, \"y\": -1, \"turn\": \"W\"},\n                      \"W\": {\"x\": -1, \"y\": 0, \"turn\": \"N\"}}\n\n    def slither_onwards_good_soldier(self):\n        self.coords[\"x\"] = self.next_x\n        self.coords[\"y\"] = self.next_y\n        self._subtract_move()\n\n    def turn_away_from_fire(self):\n        self._become_aware_that_the_world_is_closing_in()\n        self.dir = self.rules[self.dir][\"turn\"]\n\n    def dig_at_location(self):\n        # have to invert the y location for the purpose of the array.\n        return self.map[len(self.map)-self.coords[\"y\"]-1][self.coords[\"x\"]]\n\n    def report_in(self):\n        print((\"Dear Sir! I'm stationed @ x: %s, y: %s, heading %s.\" %\n              (self.coords[\"x\"], self.coords[\"y\"], self.dir)))\n\n    @property\n    def it_is_safe_to_slither(self):\n        x = self.next_x\n        y = self.next_y\n        if x != self.fire[\"min_x\"] and \\\n           x != self.fire[\"max_x\"] and \\\n           y != self.fire[\"min_y\"] and \\\n           y != self.fire[\"max_y\"]:\n            return True\n\n    @property\n    def we_are_not_done(self):\n        if self.moves_left > 0:\n            return True\n\n    @property\n    def next_x(self):\n        return self.coords[\"x\"] + self.rules[self.dir][\"x\"]\n\n    @property\n    def next_y(self):\n        return self.coords[\"y\"] + self.rules[self.dir][\"y\"]\n\n    def _become_aware_that_the_world_is_closing_in(self):\n        if self.dir == \"N\":\n            self.fire[\"min_x\"] += 1\n        if self.dir == \"E\":\n            self.fire[\"max_y\"] -= 1\n        if self.dir == \"S\":\n            self.fire[\"max_x\"] -= 1\n        if self.dir == \"W\":\n            self.fire[\"min_y\"] += 1\n\n    def _subtract_move(self):\n        self.moves_left -= 1\n", "import numpy as np\n\ndef snail(array):\n    arr = np.array(array)\n    \n    if len(arr) < 2:\n        return arr.flatten().tolist()\n    \n    tp = arr[0, :].tolist()\n    rt = arr[1:, -1].tolist()\n    bm = arr[-1:, :-1].flatten()[::-1].tolist()\n    lt = arr[1:-1, 0] [::-1].tolist()    \n    \n    return tp + rt + bm + lt + snail(arr[1:-1, 1:-1])", "def snail(array):\n    next_dir = {\"right\": \"down\", \"down\":\"left\", \"left\":\"up\", \"up\":\"right\"}\n    dir = \"right\"\n    snail = []\n    while array:\n        if dir == \"right\":\n            snail.extend(array.pop(0))\n        elif dir == \"down\":\n            snail.extend([x.pop(-1) for x in array])\n        elif dir == \"left\":\n            snail.extend(list(reversed(array.pop(-1))))\n        elif dir == \"up\":\n            snail.extend([x.pop(0) for x in reversed(array)])    \n        dir = next_dir[dir]\n    return snail        ", "def snail(array):\n    out = []\n    while len(array):\n        out += array.pop(0)\n        array = list(zip(*array))[::-1] # Rotate\n    return out", "def trans(array):\n    #Do an inverse transpose (i.e. rotate left by 90 degrees\n    return [[row[-i-1] for row in array] for i in range(len(array[0]))] if len(array)>0 else array\n\ndef snail(array):\n    output=[]\n    \n    while len(array)>0:\n\n        #Add the 1st row of the array\n        output+=array[0]\n        #Chop off the 1st row and transpose\n        array=trans(array[1:])\n        \n    return output", "def snail(array):\n    res = []\n    while len(array) > 1:\n        res = res + array.pop(0)\n        res = res + [row.pop(-1) for row in array]\n        res = res + list(reversed(array.pop(-1)))\n        res = res + [row.pop(0) for row in array[::-1]]\n    return res if not array else res + array[0]\n\n", "snail = lambda a: list(a[0]) + snail(list(zip(*a[1:]))[::-1]) if a else []\n"]