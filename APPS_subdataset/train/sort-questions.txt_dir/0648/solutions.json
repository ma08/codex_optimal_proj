["n,q=list(map(int,input().split()))\nfinal=[]\nheight=list(map(int,input().split()))\nfor k in range(0,q):\n b=input().split()\n if int(b[0])==1:\n  step=int(b[1])-1\n  for k in range(0,int(b[2])):\n   temp = 0\n   j=1\n   while j in range(1,101) and temp==0 and step+j<n:\n    if height[step+j]>height[step]:\n     step=step+j\n     temp=1\n    j+=1\n  final.append(step+1)\n elif int(b[0])==2:\n  for k in range(int(b[1])-1,int(b[2])):\n   height[k]=height[k]+int(b[3])\nfor l in range(0,len(final)):\n print(final[l])", "def find_pos(arr, n, p, c):\n i = p\n i1 = p\n while i <= n and c > 0:\n  if arr[i1] < arr[i]:\n   if i - i1 > 100:\n    return i1\n   c, i1 = c - 1, i\n  i += 1\n return i1\n\n\nn, q = list(map(int, input().split()))\narr = [0] + list(map(int, input().split()))\nfor a0 in range(1, q + 1):\n temp = list(map(int, input().split()))\n if temp[0] == 1:\n  p, c = temp[1], temp[2]\n  print(find_pos(arr, n, p, c))\n else:\n  l, r, val = temp[1], temp[2], temp[3]\n  for i in range(l, r + 1):\n   arr[i] += val\n", "n,q = list(map(int,input().split()))\nhill = list(map(int,input().split()))\ndef get_answer_type_1(i,k):\n for ind in range(k):\n  curr_elem = hill[i]\n  for ind_sub in range(i,i+101):\n   try:\n    this_elem = hill[ind_sub]\n   except:\n    break\n   if this_elem>curr_elem:\n    i=ind_sub\n    break\n return i+1\n\ndef get_answer_type_2(l,r,x):\n for ind in range(l,r+1):\n  hill[ind]+=x\n\nfor i in range(q):\n query = input().split()\n if query[0] == '1':\n  i,k = list(map(int,query[1:]))\n  i-=1\n  print(get_answer_type_1(i,k))\n else:\n  l,r,x = list(map(int,query[1:]))\n  l-=1\n  r-=1\n  get_answer_type_2(l,r,x)\n", "def find_final_posi(l1, cp, jumps):\n count = 0\n i = cp\n while i in range(cp, cp + 101):\n  if ((count == jumps) | (i >= len(l1))):\n   return cp\n  elif l1[cp] < l1[i]:\n   cp = i\n   i += 1\n   count += 1\n  else:\n   i += 1\n return cp\n\n[n, q] = [int(x) for x in input().split()]\nhillht=[-1]\nhillht.extend([int(x) for x in input().split()])\nfor j in range(q):\n oper = [int(x) for x in input().split()]\n if oper[0] == 2:\n  for x in range(oper[1], oper[2] + 1):\n   hillht[x] += oper[3]\n else:\n  print(find_final_posi(hillht, oper[1],oper[2]))", "def find_final_posi(l1, cp, jumps):\n count = 0\n i = cp\n while i in range(cp, cp + 101):\n  if ((count == jumps) | (i >= len(l1))):\n   return cp\n  elif l1[cp] < l1[i]:\n   cp = i\n   i += 1\n   count += 1\n  else:\n   i += 1\n return cp\n\n\n[n, q] = [int(x) for x in input().split()]\nhillht=[-1]\nhillht.extend([int(x) for x in input().split()])\nfor j in range(q):\n oper = [int(x) for x in input().split()]\n if oper[0] == 2:\n  for x in range(oper[1], oper[2] + 1):\n   hillht[x] += oper[3]\n else:\n  i = oper[1]\n  k = oper[2]\n  l = i\n  signal = 0\n  print(find_final_posi(hillht, i, k))", "def find_final_posi(l1, cp, jumps):\n count = 0\n i = cp\n while i in range(cp, cp + 101):\n  if ((count == jumps) | (i>=len(l1))):\n   return cp\n  elif l1[cp] < l1[i]:\n   cp = i\n   i += 1\n   count += 1\n  else:\n   i += 1\n return cp\n\n[n,q]=[int(x) for x in input().split()]\ninp=[int(x) for x in input().split()]\nhillht=[-1]\nhillht.extend(inp)\nfor j in range(q):\n oper=[int (x) for x in input().split()]\n if oper[0]==2:\n  for x in range(oper[1],oper[2]+1):\n   hillht[x]+=oper[3]\n else:\n  i = oper[1]\n  k = oper[2]\n  l=i\n  signal=0\n  print(find_final_posi(hillht,i,k))", "n,q=list(map(int,input().split()))\nl=list(map(int,input().split()))\nfor i in range(q):\n s=list(map(int,input().split()))\n if s[0]==1:\n  ind=s[1]-1\n  jump=s[2]\n  j=ind+1\n  val=l[ind]\n  while True:\n   if j>=len(l):\n    break\n   if l[j]>val and j-ind<=100 and jump>0:\n    val=l[j]\n    jump-=1\n    ind=j\n   if j-ind>100:\n    break\n   if jump<=0:\n    break\n   j+=1\n  print(ind+1)\n else:\n  left=s[1]-1\n  r=s[2]\n  x=s[3]\n  for i in range(left,r):\n   l[i]+=x\n", "import sys\nimport numpy as np\nfrom collections import OrderedDict\nf = sys.stdin\n\n#f = open('HILLJUMP.txt')\n#N and Q, the number of hills and number of operations.\nn, q = [int(x) for x in f.readline().split()]\n#A1, A2, ..., AN denoting the initial heights of the hills.\na = [int(x) for x in f.readline().split()]\n#Each of the next Q lines describes an operation.\nL = [0]*(n+1)\nR = [0]*(n+1)\nfor _ in range(0, q):\n op = [int(x) for x in f.readline().split()]\n if op[0] == 1:\n  p = op[1] - 1\n  nj = 0\n  vis = L[p] - R[p]\n  vp = a[p] + vis\n  for i in range(p + 1, n):\n   dist = i - p\n   if dist > 100:\n    break\n   else:\n    #jump, if dist <= 100\n    vis += L[i] - R[i]\n    vi = a[i] + vis\n    if vp < vi:\n     p = i\n     vp = vi\n     nj += 1\n     if nj >= op[2]:\n      break\n  print(p + 1)\n else:\n  l = op[1] - 1\n  r = op[2] - 1\n  L[l] += op[3]\n  R[r + 1] += op[3]\n#f.close()\n", "def query(i, j):\n cnt = 0\n past = arr[i]\n limit = 0\n ind = i\n for idx in range(i+1, n):\n  curr = arr[idx] \n  if curr != past and curr > past:\n   cnt += 1\n   past = curr\n   ind = idx\n   limit = 0\n  if cnt == j:\n   return ind+1 \n  if curr <= past:\n   limit += 1\n  if limit > 100:\n   break \n return ind+1\n\ndef update(l, r, v):\n for idx in range(l, r+1):\n  arr[idx] += v\n \n\n\nn, q = list(map(int, input().split()))\narr = list(map(int, input().split()))\n\nfor _ in range(q):\n a = list(map(int, input().split()))\n if a[0]-1:\n  update(a[1]-1, a[2]-1, a[3]) \n else:\n  print(query(a[1]-1, a[2]))\n\n\n", "N, Q = list(map(int, input().split(\" \")))\nar = list(map(int, input().split(\" \")))\n\ndef find_next(i,k):\n #print ar, i , k \n count = 0 \n last = i \n ind = i+1 \n while ind < N and count < k:\n  #print ind , count \n  if ar[ind] > ar[last] and ind-last <= 100:\n   count +=1 \n   last = ind \n  elif ind - last > 100:\n   return last\n  \n  ind +=1 \n \n if count < k:\n  return last \n \n return ind-1 \n \n\ndef change_height(L,R,K):\n for i in range(L,R+1):\n  ar[i] += K \n\nfor _ in range(Q):\n inp = list(map(int, input().split(\" \")))\n if inp[0] == 1:\n  i, k = inp[1] , inp[2]\n  print(find_next(i-1, k)+1) \n elif inp[0] == 2:\n  L, R , K = inp[1], inp[2] , inp[3]\n  change_height(L-1,R-1,K )\n  \n", "(N,Q)=input().split()\nN=int(N)\nQ=int(Q)\nL=list(input().split())\nL=list(map(int,L))\n#L=[100, 99, 98, 97, 96, 95, 94, 93, 92, 91, 90, 89, 88, 87, 86, 85, 84, 83, 82, \u00a0\u00a0\u00a0\u00a081, 80, 79, 78, 77, 76, 75, 74, 73, 72, 71, 70, 69, 68, 67, 66, 65, 64, 63, \u00a0\u00a0\u00a0\u00a062, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47, 46, 45, 44, \u00a0\u00a0\u00a0\u00a043, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, \u00a0\u00a0\u00a0\u00a024, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4\u00a0\u00a0\u00a0\u00a0, 3, 2,101,100, 99, 98, 97, 96, 95, 94, 93, 92, 91, 90, 89, 88, 87, 86, 85, \u00a0\u00a0\u00a0\u00a084, 83, 82, 81, 80, 79, 78, 77, 76, 75, 74, 73, 72, 71, 70, 69, 68, 67, 66, \u00a0\u00a0\u00a0\u00a065,64, 63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47, \u00a0\u00a0\u00a0\u00a046, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 29, 28, \u00a0\u00a0\u00a0\u00a027, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8\u00a0\u00a0\u00a0\u00a0, 7, 6, 5, 4, 3,2,102]\n#L=[5,1,2,3,4,6,7,9,8]\n#L.append(198)\n#L.append(222)\n#print L\nwhile(Q>0):\n L2=list(input().split())\n L2=list(map(int,L2))\n le=len(L2)\n i=L2[1]-1\n k=L2[2]\n #print i,k\n if le==3:\n  flag=True\n  \n  #print i\n  #print k\n  while(flag==True):\n   jump= next((z for z,n in enumerate(L[i:]) if n > L[i]), len(L)+1)\n   #print jump\n   #print L[jump]\n   if jump>100 or jump==len(L)+1:\n    print(i+1)\n    flag=False\n   elif k>0:\n    i=i+jump\n    k=k-1\n   else:\n    print(i+1)\n    flag=False\n else:\n  c=L2[3]\n  for i in range(i,k):\n   L[i]=L[i]+c\n  #print L        \n Q=Q-1\n", "debug = True\n\nn, q = list(map(int, input().split()))\na = [0] + list(map(int, input().split()))\n\n\ndef small_inputs():\n p = list(map(int, input().split()))\n\n if p[0] == 1:\n  i, k = p[1:]\n\n  c = i\n  for j in range(k):\n   d = 1\n   m = c + 1\n   while m <= n and d <= 100:\n    if a[m] > a[c]:\n     c = m\n     break\n    d += 1\n    m += 1\n   if m == n + 1 or d > 100:\n    break\n  print(c)\n\n else:\n  l, r, x = p[1:]\n  for i in range(l, r + 1):\n   a[i] += x\n\n\ndef large_inputs():\n p = list(map(int, input().split()))\n\n if p[0] == 1:\n  i, k = p[1:]\n  print(-1)\n\n else:\n  l, r, x = p[1:]\n\nfor test in range(q):\n\n if n <= 1000 and q <= 1000:\n  small_inputs()\n else:\n  large_inputs()\n", "import sys\nimport numpy\nfrom collections import OrderedDict\nf = sys.stdin\n\ndef makeJump(op):\n p = op[1] - 1\n nj = 0\n for i in range(p + 1, n):\n  dist = i - p\n  if dist > 100:\n   break\n  else:\n   #jump, if dist <= 100\n   vp = a[p]\n   vi = a[i]\n   for k in [x for x in list(jumps.keys()) if p <= x]:\n    d = jumps[k]\n    for k2 in d:\n     if p >= k2:\n      vp += d[k2]\n   for k in [x for x in list(jumps.keys()) if i <= x]:\n    d = jumps[k]\n    for k2 in d:\n     if i >= k2:\n      vi += d[k2]\n   if vp < vi:\n    p = i\n    nj += 1\n  if nj >= op[2]:\n   break\n print(p + 1)\n return\n\n#f = open('HILLJUMP.txt')\n#N and Q, the number of hills and number of operations.\nn, q = [int(x) for x in f.readline().split()]\n#A1, A2, ..., AN denoting the initial heights of the hills.\na = [int(x) for x in f.readline().split()]\n#Each of the next Q lines describes an operation.\nqueries = []\njumps = {}\nfor _ in range(0, q):\n op = [int(x) for x in f.readline().split()]\n if op[0] == 1:\n  #Type 1, and it will be followed by two integers i and k.\n  makeJump(op)\n else:\n  #three integers L, R and X.\n  l = op[1] - 1\n  r = op[2] - 1\n  x = op[3]\n  if not r in jumps:\n   jumps[r] = {}\n  if not l in jumps[r]:\n   jumps[r][l] = 0\n  jumps[r][l] += x\n#f.close()\n", "n,q = list(map(int,input().split()))\narr = list(map(int,input().split()))\nfor _ in range(q):\n ar = list(map(int,input().split()))\n a = ar[0]\n if(a==1):\n  b,c = ar[1],ar[2]\n  curr = b-1\n  f = 1\n  for i in range(c):\n   for j in range(curr,n):\n    if(arr[j] > arr[curr] and (j-curr<=100)):\n     curr = j\n     break\n  \n\n  print(curr+1)\n   \n\n else:\n  b,c,d = ar[1],ar[2],ar[3]\n  for k in range(b-1,c):\n   arr[k]+=d\n  \n   \n   \n   \n \n \n \n", "import sys\nimport numpy\nfrom collections import OrderedDict\nf = sys.stdin\n\ndef makeJump(op):\n p = op[1] - 1\n nj = 0\n for i in range(p + 1, n):\n  dist = i - p\n  if dist > 100:\n   break\n  else:\n   #jump, if dist <= 100\n   vp = a[p]\n   vi = a[i]\n   for k in [x for x in list(jumps.keys()) if x <= p]:\n    d = jumps[k]\n    for k2 in d:\n     if p <= k2:\n      vp += d[k2]\n   for k in [x for x in list(jumps.keys()) if x <= i]:\n    d = jumps[k]\n    for k2 in d:\n     if i <= k2:\n      vi += d[k2]\n   if vp < vi:\n    p = i\n    nj += 1\n  if nj >= op[2]:\n   break\n print(p + 1)\n return\n\n#f = open('HILLJUMP.txt')\n#N and Q, the number of hills and number of operations.\nn, q = [int(x) for x in f.readline().split()]\n#A1, A2, ..., AN denoting the initial heights of the hills.\na = [int(x) for x in f.readline().split()]\n#Each of the next Q lines describes an operation.\nqueries = []\njumps = {}\nfor _ in range(0, q):\n op = [int(x) for x in f.readline().split()]\n if op[0] == 1:\n  #Type 1, and it will be followed by two integers i and k.\n  makeJump(op)\n else:\n  #three integers L, R and X.\n  l = op[1] - 1\n  r = op[2] - 1\n  x = op[3]\n  if not l in jumps:\n   jumps[l] = {}\n  if not r in jumps[l]:\n   jumps[l][r] = 0\n  jumps[l][r] += x\n#f.close()\n", "import sys\nimport numpy\nf = sys.stdin\n\n#f = open('HILLJUMP.txt')\n#N and Q, the number of hills and number of operations.\nn, q = [int(x) for x in f.readline().split()]\n#A1, A2, ..., AN denoting the initial heights of the hills.\na = [int(x) for x in f.readline().split()]\n#Each of the next Q lines describes an operation.\nt2 = []\nfor _ in range(0, q):\n op = [int(x) for x in f.readline().split()]\n if op[0] == 1:\n  #Type 1, and it will be followed by two integers i and k.\n  p = op[1] - 1\n  jumps = 0\n  for i in range(p + 1, n):\n   dist = i - p\n   if dist > 100:\n    break\n   else:\n    #jump, if dist <= 100\n    vp = a[p]\n    vi = a[i]\n    for arr2 in t2:\n     l = arr2[1] - 1\n     r = arr2[2] - 1\n     if p >= l and p <= r:\n      vp += arr2[3]\n     if i >= l and i <= r:\n      vi += arr2[3]\n    if vp < vi:\n     p = i\n     jumps += 1\n   if jumps >= op[2]:\n    break\n  print(p + 1)\n else:\n  #three integers L, R and X.\n  #a = a[:op[1]-1] + map(lambda x: x+op[3], a[op[1]-1:op[2]]) + a[op[2]:]\n  #a[op[1]-1:op[2]] = map(lambda x: x+op[3], a[op[1]-1:op[2]])\n  t2.append(op)\n#f.close()\n", "\nfrom sys import stdin, stdout\nn,q=list(map(int,stdin.readline().split()))\nhillheight = list(map(int,stdin.readline().split()))\n\nfor i in range(q):\n t =list(map(int,stdin.readline().split()))\n if t[0] == 1:\n  position = t[1]-1\n  numberofjumps = t[2]\n  for k in range(position,n):\n   if k-position>100 or numberofjumps==0:\n    break\n   if hillheight[k] > hillheight[position]:\n    position = k\n    numberofjumps = numberofjumps - 1\n  stdout.write(\"{}\\n\".format(position+1))\n elif t[0] == 2:\n  L = t[1]\n  R = t[2]\n  X = t[3]\n  for w in range(L-1,R):\n   \n   hillheight[w] = hillheight[w] + X\n   \n\n", "\nimport sys\n \nar = list(map(int, input().strip().split(' ')))\nn=ar[0]\nq=ar[1]\ngre=[]\nfor i1 in range(n+2):\n gre.append(0)\nn1= list(map(int, input().strip().split(' ')))\nn1.insert(0,0)\nfor i1 in range(q):\n a = list(map(int, input().strip().split(' ')))\n if a[0]==2:\n  l=a[1]\n  r=a[2]\n  x=a[3]\n  gre[l]+=x\n  gre[r+1]-=x\n elif a[0]==1:\n  i=a[1]\n  k=a[2]\n  g=gre[i]\n  w1=i\n  m1=n1[i]+g\n  for qw in range(i+1,n+1):\n   g+=gre[qw]\n   if qw-w1>100:\n    break\n   if k==0:\n    break\n   if n1[qw]+g > m1:\n    m1=n1[qw]+g\n    w1=qw\n    k=k-1\n  print(w1) ", "n, queries = list(map(int, input().strip().split()))\narr = list(map(int, input().strip().split()))\n\nfor i in range(queries):\n inp = list(map(int, input().strip().split()))\n if inp[0] == 1:\n  curr, maxJumps, out = inp[1] - 1, inp[2], inp[1] - 1\n  while maxJumps > 0:\n   #print 'starting : ', maxJumps, ' at : ', curr\n   i, nextTo = curr + 1, curr\n   while i < n and i < curr + 101:\n    if arr[i] > arr[curr]:\n     nextTo = i\n     break\n    i+=1\n   if nextTo == curr:\n    out = nextTo\n    break\n   out = nextTo\n   curr = nextTo\n   maxJumps -= 1\n   #print 'Left : ', maxJumps, ' at : ', out + 1\n  print(out + 1)\n else:\n  for i in range(inp[1] - 1, inp[2]):\n   arr[i] += inp[3]\n", "inpt=list(map(int,input().split()))\nn=inpt[0]\nq=inpt[1]\n\nh=list(map(int,input().split()))\nfor i in range(0,q):\n #print(h)\n flag=1\n oper=list(map(int,input().split()))\n typ=oper[0]\n #print(oper)\n if(typ==2):\n  for j in range(oper[1]-1,oper[2]):\n   h[j]=h[j]+ oper[3]\n elif(typ==1):\n  start=oper[1]-1\n  pos=start\n  jump=oper[2]\n  count=0\n  jp=0 \n  for l in range(pos+1,n):\n   #print(l)\n   count=count+1\n   if(jp==jump):\n    break\n   if(count>100):\n    break\n   if(h[l]>h[pos]):\n    start=l\n    pos=start\n    jp=jp+1\n    count=0\n    \n  \n  print(start+1)\n \n  \n  \n  \n  \n  \n   \n", "inpt=list(map(int,input().split()))\nn=inpt[0]\nq=inpt[1]\n\nh=list(map(int,input().split()))\nfor i in range(0,q):\n #print(h)\n flag=1\n oper=list(map(int,input().split()))\n typ=oper[0]\n #print(oper)\n if(typ==2):\n  for j in range(oper[1]-1,oper[2]):\n   h[j]=h[j]+ oper[3]\n elif(typ==1):\n  start=oper[1]-1\n  pos=start\n  jump=oper[2]\n  count=0\n  jp=0 \n  for l in range(pos+1,n):\n   #print(l)\n   count=count+1\n   if(jp==jump):\n    break\n   if(count>100):\n    break\n   if(h[l]>h[pos]):\n    start=l\n    pos=start\n    jp=jp+1\n    count=0\n    \n  \n  print(start+1)\n \n  \n  \n  \n  \n  \n   \n", "inpt=list(map(int,input().split()))\nn=inpt[0]\nq=inpt[1]\nflag=1\nh=list(map(int,input().split()))\nfor i in range(0,q):\n #print(h)\n flag=1\n oper=list(map(int,input().split()))\n typ=oper[0]\n #print(oper)\n if(typ==2):\n  for j in range(oper[1]-1,oper[2]):\n   h[j]=h[j]+ oper[3]\n elif(typ==1):\n  start=oper[1]-1\n  pos=start\n  jump=oper[2]\n  count=0\n  for k in range(0,jump):\n   count=0\n   pos=start\n   for l in range(pos+1,n):\n    #print(l)\n    count=count+1\n    if(count>100):\n     flag=0\n     break\n    if(h[l]>h[pos]):\n     start=l\n     break\n   if(flag==0):\n    break\n  print(start+1)\n \n  \n  \n  \n"]