["from itertools import groupby\n\n\ndef group_ints(lst, key=0):\n    return [list(g) for _, g in groupby(lst, lambda a: a < key)]\n\n\n# PEP8: function name should use snake_case\ngroupInts = group_ints", "from itertools import groupby\n\ndef group_ints(lst, key=0):\n    return [list(g) for _, g in groupby(lst, key.__gt__)]", "def group_ints(lst, key=0):\n    from itertools import groupby\n    return [list(group) for _, group in groupby(lst, lambda v: v >= key)]\n", "from itertools import groupby\nfrom operator import itemgetter\n\ndef group_ints(lst, key=0):\n    # I'm keeping the cat!\n    #\n    #               _ |\\_\n    #               \\` ..\\\n    #          __,.-\" =__Y=\n    #        .\"        )\n    #  _    /   ,    \\/\\_\n    # ((____|    )_-\\ \\_-`\n    # `-----'`-----` `--`\n    \n    return list(map(list, map(itemgetter(1), groupby(lst, key.__gt__))))", "def group_ints(lst, key=0):\n    first = []\n    second = []\n    final = []\n    for i in lst:\n        if i < key:\n            if second:\n                final.append(second)\n                second = []\n            first.append(i)\n        else:\n            if first:\n                final.append(first)\n                first = []\n            second.append(i)\n    if first:\n        final.append(first)\n    if second:\n        final.append(second)\n    return final\n", "def group_ints(lst, key=0):\n    if not lst: return []\n    l, index = [[lst[0]]], 0\n    for x in lst[1:]:\n        if l[index][-1] < key and x < key:\n            l[index].append(x)\n        elif l[index][-1] >= key and x >= key:\n            l[index].append(x)\n        else:\n            l.append([x])\n            index += 1\n    return l", "class Nest():\n    \n    def __init__(self, key, list):\n        self.key  = key\n        self.list = list\n        self.chen = 0\n        self.temp_list = []\n        self.new_list  = []\n        \n        self.ACT  = { \n                      1:self.__ap_end__, \n                      0:self.__swich__ \n                      }\n                      \n        self.OPER = { \n                      0:lambda a, b: a < b ,\n                      1:lambda a, b : a >= b \n                      }\n                      \n    def __ap_end__(self, c_list, element ): \n        c_list.append(element)\n        \n    def __swich__(self, c_list, element):\n        if c_list: \n            self.__ap_end__(self.new_list, c_list)\n        self.temp_list = [element]\n        self.chen = not self.chen\n        \n    def do_sort(self ):\n        if not self.list: return []\n        for e in self.list: \n            self.ACT[ self.OPER[self.chen]( e,self.key ) ]( self.temp_list, e )\n        return self.new_list + [self.temp_list]\n\ngroup_ints = lambda lst, key=0 : Nest( key, lst ).do_sort() ", "def group_ints(lst, key=0):\n    if not lst: return lst\n    oper, temp, last, chen = ['<','>='], [], [], 0\n    for e in lst:\n        if eval(f'{e}{oper[chen]}{key}'):\n            temp.append(e)\n        else:\n            if temp:  last.append(temp)\n            temp, chen = [e], not chen\n    return last + [temp]\n", "from itertools import groupby\n\ndef group_ints(lst, key=0):\n    return [list(grp) for k, grp in groupby(lst, key=lambda x: x < key)]", "from itertools import groupby\n\ndef group_ints(lst, key=0):\n    return [list(g) for _, g in groupby(lst, lambda x: x < key)]\n"]