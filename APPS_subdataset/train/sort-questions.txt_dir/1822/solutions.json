["class Solution:\n     def topKFrequent(self, words, k):\n         \"\"\"\n         :type words: List[str]\n         :type k: int\n         :rtype: List[str]\n         \"\"\"\n         from collections import Counter\n         count = Counter(words)\n         common = sorted(list(count.items()), key=lambda item: (-item[1], item[0]))[:k]\n         return [w for w, n in common]\n", "class Solution:\n     def topKFrequent(self, words, k):\n         \"\"\"\n         :type words: List[str]\n         :type k: int\n         :rtype: List[str]\n         \"\"\"\n         d = {}\n         for word in words:\n             d[word] = d.get(word, 0) + 1\n         \n         ret = sorted(d, key=lambda word: (-d[word], word))\n         \n         return ret[:k]\n", "class Solution:\n     def topKFrequent(self, words, k):\n         \"\"\"\n         :type words: List[str]\n         :type k: int\n         :rtype: List[str]\n         \"\"\"\n         from collections import Counter\n         return [item[0] for item in sorted(Counter(words).items(),key = lambda x: (-x[1],x[0])) [:k]] ", "class Solution:\n     def topKFrequent(self, words, k):\n         \"\"\"\n         :type words: List[str]\n         :type k: int\n         :rtype: List[str]\n         \"\"\"\n         cnt = collections.Counter(words)\n         word_freq = list(cnt.items())\n         word_freq.sort(key=lambda item: (-item[1],item[0]))\n         return [k for k, v in word_freq[:k]]", "class Solution:\n     def topKFrequent(self, words, k):\n         \"\"\"\n         :type words: List[str]\n         :type k: int\n         :rtype: List[str]\n         \"\"\"\n         cnt = {i:words.count(i) for i in list(set(words))}   \n         cntRev = {}\n         ans = []\n         for key, val in cnt.items():\n             if val not in cntRev:\n                 cntRev[val]=[key]\n             else:\n                 cntRev[val].append(key)\n         for num in sorted(cntRev,reverse=True):\n             if k <= len(cntRev[num]):\n                 ans+=sorted(cntRev[num])[:k]\n                 break\n             else:\n                 ans+=sorted(cntRev[num])\n                 k -= len(cntRev[num])\n         return ans", "class Solution:\n     def topKFrequent(self, words, k):\n         times_dict = {}\n         for i in words:\n             if i not in times_dict.keys():\n                 times_dict[i] = 1\n             else:\n                 times_dict[i] += 1\n         return_list = []\n         for i in range(k):\n             max = 0\n             max_key = \"\"\n             for j in times_dict.keys():\n                 if times_dict[j] > max:\n                     max = times_dict[j]\n                     max_key = j\n                 elif times_dict[j] == max and j < max_key:\n                     max = times_dict[j]\n                     max_key = j \n             del times_dict[max_key]\n             return_list.append(max_key)\n         return return_list", "import heapq\n import functools\n \n \n @functools.total_ordering\n class Element:\n     def __init__(self, word, count):\n         self.word = word\n         self.count = count\n     \n     def __eq__(self, other):\n         return self.count == other.count and self.word == other.word\n \n     def __gt__(self, other):\n         if self.count == other.count:\n             return self.word < other.word\n         return self.count > other.count\n \n \n class Solution:\n     def topKFrequent(self, words, k):\n         \"\"\"\n         :type words: List[str]\n         :type k: int\n         :rtype: List[str]\n         \"\"\"\n         heap = []\n         for word, count in collections.Counter(words).items():\n             heapq.heappush(heap, Element(word, count))\n             if len(heap) > k:\n                 heapq.heappop(heap)\n         return [i.word for i in sorted(heap, reverse=True)]\n", "import functools\n import collections\n \n class Solution(object):\n     def topKFrequent(self, words, k):\n         \"\"\"\n         :type words: List[str]\n         :type k: int\n         :rtype: List[str]\n         \"\"\"\n         wordCounts = collections.Counter(words)\n         candidates = list(wordCounts.keys())\n         candidates.sort(key = lambda word: (-wordCounts[word], word))\n         return candidates[:k]\n           ", "class Solution:\n     def topKFrequent(self, words, k):\n         \"\"\"\n         :type words: List[str]\n         :type k: int\n         :rtype: List[str]\n         \"\"\"\n         counter = collections.Counter(words)\n         keys = list(counter.keys())\n         # Notice how this answer used a tuple in sorting so that it sorts based\n         # on counter value first and then string alphabetical value the second\n         keys.sort(key=lambda x: (-counter[x], x))\n         return keys[:k]\n         \n", "class Solution:\n     def topKFrequent(self, words, k):\n         counts = collections.Counter(words)\n         items = list(counts.items())\n         items.sort(key=lambda item:(-item[1],item[0]))\n         return [item[0] for item in items[0:k]]", "class Solution:\n     def topKFrequent(self, words, k):\n         \"\"\"\n         :type words: List[str]\n         :type k: int\n         :rtype: List[str]\n         \"\"\"\n         from collections import Counter\n         c = Counter(words)\n         buckets = [[] for _ in range(len(words)+1)]\n         for key in c:\n             buckets[c[key]].append(key)\n         for b in buckets:\n             b.sort()\n         ans = []\n         i = len(buckets) - 1\n         while i >= 0:\n             if len(ans) + len(buckets[i]) < k:\n                 ans += buckets[i]\n             else:\n                 ans += buckets[i][:k - len(ans)]\n                 break\n             i -= 1\n         return ans\n \n \n def __starting_point():\n     s = Solution()\n     print(s.topKFrequent([\"i\", \"love\", \"leetcode\", \"i\", \"love\", \"coding\"], 2))\n__starting_point()", "class Solution:\n     def topKFrequent(self, words, k):\n         \"\"\"\n         :type words: List[str]\n         :type k: int\n         :rtype: List[str]\n         \"\"\"\n         c = collections.Counter(words).most_common()\n         \n         res = []\n         \n         while len(res) < k:\n             temp = []\n             node = c.pop(0)\n             temp.append(node[0])\n             while c and c[0][1] == node[1]:\n                 node = c.pop(0)\n                 temp.append(node[0])\n             \n             res.extend(sorted(temp))\n             # print(res)\n         \n         return res[:k]", "import heapq\n import functools\n @functools.total_ordering\n class Word:\n     def __init__(self, str, c):\n         self.s = str\n         self.c = c\n     def __eq__(self, other):\n         return self.c == other.c and self.s == other.c\n     def __le__(self, other):\n         return self.c < other.c or (self.c == other.c and self.s > other.s)\n     def __repr__(self):\n         return self.s + str(self.c)\n class Solution:\n     def topKFrequent(self, words, k):\n         \"\"\"\n         :type words: List[str]\n         :type k: int\n         :rtype: List[str]\n         \"\"\"\n         h = []\n         d = {}\n         for w in words:\n             c = d.get(w, 0)\n             c += 1\n             d[w] = c\n         for w in d.keys():\n             heapq.heappush(h, Word(w, d[w]))\n             if len(h) > k:\n                 heapq.heappop(h)\n         res = []\n         while len(h) > 0:\n             res.append(heapq.heappop(h))\n         #print(res)\n         return [w.s for w in reversed(res)]", "import collections\n import heapq\n import functools\n \n @functools.total_ordering\n class Element:\n     def __init__(self, count, word):\n         self.count = count\n         self.word = word\n         \n     def __lt__(self, other):\n         if self.count == other.count:\n             return self.word > other.word\n         return self.count < other.count\n     \n     def __eq__(self, other):\n         return self.count == other.count and self.word == other.word\n \n class Solution(object):\n     def topKFrequent(self, words, k):\n         \"\"\"\n         :type words: List[str]\n         :type k: int\n         :rtype: List[str]\n         \"\"\"\n         counts = collections.Counter(words)   \n         \n         heap = []\n         for word, count in counts.items():\n             heapq.heappush(heap, Element(count, word))\n             if len(heap) > k:\n                 heapq.heappop(heap)\n         \n         res = []\n         for _ in range(k):\n             res.append(heapq.heappop(heap).word)\n         return res[::-1]\n     ", "class Solution:\n     def topKFrequent(self, words, k):\n         \"\"\"\n         :type words: List[str]\n         :type k: int\n         :rtype: List[str]\n         \"\"\"\n         wDict=collections.Counter(words)\n         res=[]\n         maxHeap=[]\n         for key,cnt in list(wDict.items()):\n             heapq.heappush(maxHeap,(-cnt,key))\n         for i in range(k):\n             freq,word=heapq.heappop(maxHeap)\n             res.append(word)\n         return res\n", "import collections\n import heapq\n \n \n def lexical_reverse(w):\n     padding = [999] * (20 - len(w))\n     return (w[0], [200 - ord(x) for x in w[1]] + padding)\n \n \n class Solution:\n     def topKFrequent(self, words, k):\n         \"\"\"\n         :type words: List[str]\n         :type k: int\n         :rtype: List[str]\n         \"\"\"\n         freq = collections.defaultdict(int)\n         for w in words:\n             freq[w] += 1\n         word_pairs = []\n         for w in freq.keys():\n             word_pairs.append((freq[w], w))\n \n         heapq.heapify(word_pairs)\n         return [w[1] for w in heapq.nlargest(\n             k, word_pairs, lexical_reverse)]\n"]