["class Solution:\n    def maxProbability(self, n: int, edges: List[List[int]], probs: List[float], s: int, t: int) -> float:\n        # first build the graph\n        graph = {u: {} for u in range(n)}\n        for (u, v), prob in zip(edges, probs):\n            graph[u][v] = prob\n            graph[v][u] = prob\n\n        # run A* search\n        frontier = [(-1, s)]\n        seen = set()\n\n        while len(frontier) != 0:\n            neg_path_prob, u = heapq.heappop(frontier)\n            if u == t:\n                return -neg_path_prob\n\n            seen.add(u)\n            for v, edge_prob in graph[u].items():\n                if v not in seen:\n                    heapq.heappush(frontier, (neg_path_prob * edge_prob, v))\n        return 0", "class Solution:\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\n        graph = collections.defaultdict(dict)\n        for edge, prob in zip(edges, succProb):\n            s, t = edge\n            graph[s][t] = prob\n            graph[t][s] = prob\n        \n        heap = [(-1, start)]\n        prob = [0] * n\n        prob[start] = 1\n        visited = [False] * n\n        \n        while heap:\n            curr_prob, node = heapq.heappop(heap)\n            if visited[node]:\n                continue\n            if node == end:\n                return prob[end]\n            curr_prob *= -1\n            visited[node] = True\n            for neighbor in graph[node]:\n                if visited[neighbor]:\n                    continue\n                p = curr_prob * graph[node][neighbor]\n                if p > prob[neighbor]:\n                    prob[neighbor] = p\n                    heapq.heappush(heap, (-p, neighbor))\n        \n        return prob[end]", "class Solution:\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\n        weights = list(map(lambda x:-math.log2(x), succProb))\n        g = defaultdict(list)\n        for (u, v), w in zip(edges, weights):\n            g[u].append([v, w])\n            g[v].append([u, w])\n        dist = {}\n        q = [(0, start)]\n        while q:\n            w, u = heapq.heappop(q)\n            if u in dist:\n                continue\n            dist[u] = w\n            if u == end:\n                break\n            for v, w in g[u]:\n                if v not in dist or dist[v] > dist[u] + w:\n                    heapq.heappush(q, (dist[u] + w, v))\n        return 2 ** (-dist[end]) if end in dist else 0.0", "class Solution:\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\n        # bfs only when prob is less than cur best add to the queue\n        graph = [[] for _ in range(n)]\n        for edge, p in zip(edges, succProb):\n            a, b = edge\n            graph[a].append((b, p))\n            graph[b].append((a, p))\n        prob = {start: 1}\n        queue = [(start, 1)]\n        while queue:\n            new_queue = []\n            for a, p_a in queue:\n                for b, p_b in graph[a]:\n                    p = p_a*p_b\n                    if b not in prob or p > prob[b]:\n                        prob[b] = p\n                        new_queue.append((b, p))\n            # print(prob)\n            queue = new_queue\n        return prob.get(end, 0)", "class Solution:\n    def maxProbability(self, n: int, edges: List[List[int]], prob: List[float], start: int, end: int) -> float:\n        weights = list(map(lambda x:-math.log2(x), prob))\n        g = defaultdict(list)\n        \n    \n        for (u, v), w in zip(edges, weights):\n            g[u].append([v, w])\n            g[v].append([u, w])\n        dist = {}\n        q = [(0, start)]\n        while q:\n            w, u = heapq.heappop(q)\n            if u in dist:\n                continue\n            dist[u] = w\n            if u == end:\n                break\n            for v, w in g[u]:\n                if v not in dist or dist[v] > dist[u] + w:\n                    heapq.heappush(q, (dist[u] + w, v))\n        return 2 ** (-dist[end]) if end in dist else 0.0", "class Solution:\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\n        graph = defaultdict(list)\n        \n        for (a, b), probability in zip(edges, succProb):\n            graph[a].append([b, probability])\n            graph[b].append([a, probability])\n        \n        if start == end:\n            return 1\n        \n        queue = [[-1, start]]\n        visited = set()\n        distance_map = defaultdict(lambda: float('inf'))\n        \n        while queue:\n            prob, node = heappop(queue)\n            \n            visited.add(node)\n            \n            if node == end:\n                return -prob\n            \n            for neighbour, next_prob in graph[node]:\n                if neighbour in visited:\n                    continue\n                heappush(queue, [prob * next_prob, neighbour])\n        \n        return 0", "class Solution:\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\n        dp = [0.0 for _ in range(start)]+[1.0]+[0.0 for _ in range(start+1,n)]\n        dic = defaultdict(list)\n        for e,p in zip(edges, succProb):\n            dic[e[0]].append((e[1],p))\n            dic[e[1]].append((e[0],p))\n        \n        queue = deque([start])\n        while queue:\n            for _ in range(len(queue)):\n                cur = queue.popleft()\n                for c,p in dic[cur]:\n                    if dp[cur]*p > dp[c]:\n                        dp[c] = dp[cur]*p\n                        queue.append(c)\n        return dp[end]", "class Solution:\n    def maxProbability(self, n: int, edges: List[List[int]], prob: List[float], start: int, end: int) -> float:\n        weights = list([-math.log2(x) for x in prob])\n        g = defaultdict(list)\n        for (u, v), w in zip(edges, weights):\n            g[u].append([v, w])\n            g[v].append([u, w])\n        dist = {}\n        q = [(0, start)]\n        while q:\n            w, u = heapq.heappop(q)\n            if u in dist:\n                continue\n            dist[u] = w\n            if u == end:\n                break\n            for v, w in g[u]:\n                if v not in dist or dist[v] > dist[u] + w:\n                    heapq.heappush(q, (dist[u] + w, v))\n        return 2 ** (-dist[end]) if end in dist else 0.0\n                \n                \n            \n            \n            \n", "from heapq import heappop, heappush\nfrom sys import maxsize as inf\nfrom collections import defaultdict as dic\n\nclass Solution:\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\n        graph = dic(dict)\n\n        for [u, v], w in zip(edges,succProb):\n            graph[u][v] = w\n            graph[v][u] = w\n\n        dist = { i : 0 for i in range(n)}\n        dist[start] = 1\n        visited = set()\n        max_prob = [(-1*1,start)]\n        while len(max_prob):\n            cur_prob, cur_node = heappop(max_prob)\n            if cur_node in visited:\n                continue\n            visited.add(cur_node)\n            for nei in graph[cur_node]:\n                if nei in visited:\n                    continue\n                if dist[nei] < graph[cur_node][nei] * (-1*cur_prob):\n                    dist[nei] = graph[cur_node][nei] * (-1*cur_prob)\n                    heappush(max_prob, ((-1*dist[nei]),nei) )\n                    \n            if cur_node == end:\n                break\n\n        return(dist[end])\n", "from collections import defaultdict as ddict\nfrom collections import deque\nclass Solution:\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\n        maxProb = ddict(float)\n        \n        graph = ddict(dict)\n        \n        for [a,b],sucprob in zip(edges, succProb):\n            graph[a][b] = sucprob if b not in graph[a] else max(sucprob, graph[a][b])\n            graph[b][a] = sucprob if a not in graph[b] else max(sucprob, graph[b][a])\n        \n        print(graph)\n        \n        que = deque()\n        que.append((start, 1))\n        while que:\n            node, prob = que.popleft()\n            maxProb[node] = max(maxProb[node], prob)\n            \n            for child in graph[node]:\n                if prob*graph[node][child] > maxProb[child]:\n                    que.append((child, prob*graph[node][child]))\n        \n        \n        return maxProb[end]\n", "from heapq import heappush, heappop\n\n\nclass Solution:\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\n        stack = [(-1, start)]\n        paths = [0 for i in range(n)]\n        paths[start] = 1\n        \n        graph = [{} for i in range(n)]\n        for (source, dstn), weight in zip(edges, succProb):\n            graph[source][dstn] = graph[dstn][source] = weight\n        while stack:\n            _, current = heappop(stack)\n            for v in graph[current]:\n                temp = paths[current] * graph[current][v]\n                if temp > paths[v]:\n                    heappush(stack, (-temp, v))\n                    paths[v] = max(temp, paths[v])\n        return paths[end] \n", "import heapq\n\nclass Solution:\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\n        \n        adj = {i:[] for i in range(n)}\n        best = [0] * n   \n        \n        for edge, prob in zip(edges, succProb):\n            u, v = edge\n            adj[u].append((v, prob))\n            adj[v].append((u, prob))\n            \n        queue = []\n        heapq.heappush(queue, (-1, start))\n        while queue:\n            prob, v = heapq.heappop(queue)\n            prob = - prob\n            if v == end:\n                return prob\n            if prob < best[v]:\n                continue\n            best[v] = prob\n            for nxt, np in adj[v]:\n                if nxt != v:\n                    tmp = np * prob\n                    if tmp > best[nxt]:\n                        best[nxt] = tmp\n                        heapq.heappush( queue, (-tmp, nxt) )\n        \n        return 0\n                    \n", "import heapq\n\nclass Solution:\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\n        \n        adj = {i:[] for i in range(n)}\n        best = [0] * n   \n        \n        for edge, prob in zip(edges, succProb):\n            u, v = edge\n            adj[u].append((v, prob))\n            adj[v].append((u, prob))\n            \n        queue = []\n        heapq.heappush(queue, (-1, start))\n        best[start] = 1\n        while queue:\n            prob, v = heapq.heappop(queue)\n            prob = - prob\n            if v == end:\n                return prob\n            if prob < best[v]:\n                continue\n            for nxt, np in adj[v]:\n                if nxt != v:\n                    tmp = np * prob\n                    if tmp > best[nxt]:\n                        best[nxt] = tmp\n                        heapq.heappush( queue, (-tmp, nxt) )\n        \n        return 0\n                    \n", "class Solution:\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\n        dp = [0.0 for _ in range(start)] + [1.0] + [0.0 for _ in range(start+1,n)]\n        # dp[i] is the prob of getting node i from node start\n        \n        graph = defaultdict(list)\n        for (u,v),p in zip(edges,succProb):\n            graph[u].append((v,p))\n            graph[v].append((u,p))\n        \n        # dijkstra's algorithm\n        selected = set()\n        heap = [(-1.0, start)]\n        \n        while heap:\n            p, cur = heapq.heappop(heap)\n            selected.add(cur)\n            if cur==end:\n                return -p\n            for child, prob in graph[cur]:\n                if child not in selected and dp[cur]*prob>dp[child]:\n                    dp[child] = dp[cur]*prob\n                    heapq.heappush(heap, (-dp[child],child))\n        return 0", "import heapq\n\nclass Solution:\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\n        \n        adj = {i:[] for i in range(n)}\n        best = [0] * n   \n        \n        for edge, prob in zip(edges, succProb):\n            u, v = edge\n            adj[u].append((v, prob))\n            adj[v].append((u, prob))\n            \n        queue = []\n        heapq.heappush(queue, (-1, start))\n        best[start] = 1\n        while queue:\n            prob, v = heapq.heappop(queue)\n            prob = - prob\n            if v == end:\n                return prob\n            if prob < best[v]:\n                continue\n            best[v] = prob\n            for nxt, np in adj[v]:\n                if nxt != v:\n                    tmp = np * prob\n                    if tmp > best[nxt]:\n                        best[nxt] = tmp\n                        heapq.heappush( queue, (-tmp, nxt) )\n        \n        return 0\n                    \n", "from collections import defaultdict, deque\n\n\nclass Solution:\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\n        stack = deque([start])\n        paths = [0 for i in range(n)]\n        paths[start] = 1\n        \n        graph = [{} for i in range(n)]\n        for (source, dstn), weight in zip(edges, succProb):\n            graph[source][dstn] = graph[dstn][source] = weight\n        # seen = set()\n        while stack:\n            current = stack.popleft()\n            for v in graph[current]:\n                temp = paths[current] * graph[current][v]\n                if temp > paths[v]:\n                    stack.append(v)\n                    paths[v] = max(temp, paths[v])\n        return paths[end] \n", "class Solution:\n    def maxProbability(self, n: int, edges: List[List[int]], prob: List[float], start: int, end: int) -> float:\n        weights = list(map(lambda x:-math.log2(x), prob))\n        g = defaultdict(list)\n        for (u, v), w in zip(edges, weights):\n            g[u].append([v, w])\n            g[v].append([u, w])\n        dist = {}\n        q = [(0, start)]\n        while q:\n            w, u = heapq.heappop(q)\n            if u in dist:\n                continue\n            dist[u] = w\n            if u == end:\n                break\n            for v, w in g[u]:\n                if v not in dist or dist[v] > dist[u] + w:\n                    heapq.heappush(q, (dist[u] + w, v))\n        return 2 ** (-dist[end]) if end in dist else 0.0", "class Solution:\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\n        def method1():\n            graph=collections.defaultdict(set)\n            for i,pair in enumerate(edges):\n                u,v=pair\n                graph[u].add((v,succProb[i]))\n                graph[v].add((u,succProb[i]))\n                \n            seen={0:0}\n            queue=[(start,-1)]\n            ans=float('-inf')\n            while queue:\n                node,p=heapq.heappop(queue)\n                p=-p\n                if node==end:\n                    ans=max(ans,p)\n                for nei,dw in graph[node]:\n                    if (nei not in seen or seen[nei]<p*dw) and p*dw>ans:\n                        seen[nei]=p*dw\n                        heapq.heappush(queue,(nei,-p*dw))\n                        \n            return ans if ans!=float('-inf') else 0\n        \n        #return method1()\n    \n        def method2():\n            AdjList = [set() for _ in range(n)]\n            \n            for (u, v), p in zip(edges, succProb):\n                AdjList[u].add((v, log2(1/p)))\n                AdjList[v].add((u, log2(1/p)))\n            \n            dist = [float('inf') for _ in range(n)]\n            dist[start] = 0\n            h = [(0, start)]\n            while h:\n                d, u = heappop(h)\n                if d == dist[u]:\n                    for (v, p) in AdjList[u]:\n                        if dist[u] + p < dist[v]:\n                            dist[v] = dist[u] + p\n                            heappush(h, (dist[v], v))\n            return 1 / (2 ** dist[end])\n        return method2()", "from collections import defaultdict, deque\nimport bisect\nfrom sortedcontainers import SortedList\n\n\n# class Solution:\n#     def maxProbability(self, n: int, edges, succProb, start: int, end: int) -> float:\n\n#         m = [{} for i in range(n)]\n#         for edge, d in zip(edges, succProb):\n#             s, e = edge\n#             m[s][e] = m[e][s] = d\n\n#         seen = {start: 1}       \n#         sorted_e = SortedList([m[start][k], k] for k in m[start])\n        \n#         while sorted_e:\n            \n#             if end in seen: break        \n#             p, e = sorted_e.pop()\n#             seen[e] = p\n    \n#             for tmp_e, tmp_p in m[e].items():\n#                 if tmp_e in seen: continue\n#                 new_p = tmp_p * p\n#                 sorted_e.add([new_p, tmp_e])\n        \n#         return seen.get(end, 0)\n\nclass Solution:\n    def maxProbability(self, n: int, edges, succProb, start: int, end: int) -> float:\n\n        m = [{} for i in range(n)]\n        for edge, d in zip(edges, succProb):\n            s, e = edge\n            m[s][e] = m[e][s] = d\n\n        queue = deque([start])\n        seen = [0] * n\n        seen[start] = 1\n\n        while queue:\n\n            s = queue.popleft()\n            prob = seen[s]\n\n            for e, p in m[s].items():\n                tmp = prob * p\n                if seen[e] < tmp:\n                    seen[e] = tmp\n                    queue.append(e)\n\n        return seen[end]", "from heapq import heappush, heappop\nfrom math import log2\n\nclass Solution:\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\n        AdjList = [set() for _ in range(n)]\n        for (u, v), p in zip(edges, succProb):\n            AdjList[u].add((v, log2(1/p)))\n            AdjList[v].add((u, log2(1/p)))\n        dist = [float('inf') for _ in range(n)]\n        dist[start] = 0\n        h = [(0, start)]\n        while h:\n            d, u = heappop(h)\n            if True:\n                for (v, p) in AdjList[u]:\n                    if dist[u] + p < dist[v]:\n                        dist[v] = dist[u] + p\n                        heappush(h, (dist[v], v))\n        return 1 / (2 ** dist[end])", "class Solution:\n    def maxProbability(self, n, edges, succProb, start, end) -> float:\n        \n        g    = [[] for _ in range(n)]\n        prob = [0.  for _ in range(n)]\n        \n        prob[start] = 1.\n        \n        for (a,b), p in zip(edges, succProb):\n            g[a].append((p, b))\n            g[b].append((p, a))\n        \n        pq = [(-1., start)]\n        \n        while pq:\n            p, v = heapq.heappop(pq)\n            if prob[v] + p: continue\n            \n            if v == end:\n                return prob[v]\n            \n            for ep, n in g[v]:\n                _p = ep * prob[v]\n                \n                if _p > prob[n]:\n                    prob[n] = _p\n                    heapq.heappush(pq, (-_p, n))\n        \n        return 0\n            \n            \n            \n", "from collections import defaultdict, deque\n\n\nclass Solution:\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\n        stack = deque([start])\n        paths = {i: 0 for i in range(n)}\n        paths[start] = 1\n        \n        graph = {i: {} for i in range(n)}\n        for (source, dstn), weight in zip(edges, succProb):\n            graph[source][dstn] = graph[dstn][source] = weight\n\n        while stack:\n            current = stack.popleft()\n            for v in graph[current]:\n                if paths[current] * graph[current][v] > paths[v]:\n                    stack.append(v)\n                    paths[v] = max(paths[current] * graph[current][v], paths[v])\n        return paths[end] \n", "class Solution:\n    def maxProbability(self, n: int, edges: List[List[int]], probs: List[float], s: int, t: int) -> float:\n        # first build the graph\n        graph = {u: {} for u in range(n)}\n        for (u, v), prob in zip(edges, probs):\n            graph[u][v] = prob\n            graph[v][u] = prob\n\n        # run DFS/BFS search\n        frontier = [s]\n        path_probs = {u: 0 for u in range(n)}\n        path_probs[s] = 1\n\n        while len(frontier) != 0:\n            u = frontier.pop(0)\n            path_prob = path_probs[u]\n\n            for v, edge_prob in graph[u].items():\n                if path_prob * edge_prob > path_probs[v]:\n                    path_probs[v] = path_prob * edge_prob\n                    frontier.append(v)\n        return path_probs[t]", "from collections import defaultdict, deque\n\n\nclass Solution:\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\n        stack = deque([start])\n        paths = {i: 0 for i in range(n)}\n        paths[start] = 1\n        \n        graph = defaultdict(dict)\n        for (source, dstn), weight in zip(edges, succProb):\n            graph[source][dstn] = weight\n            graph[dstn][source] = weight\n\n        while stack:\n            current = stack.popleft()\n            for v in graph[current]:\n                if paths[current] * graph[current][v] > paths[v]:\n                    stack.append(v)\n                    paths[v] = max(paths[current] * graph[current][v], paths[v])\n        return paths[end] \n", "import heapq\n\nclass Solution:\n    def maxProbability(self, n: int, edges: List[List[int]], probs: List[float], s: int, t: int) -> float:\n        # first build the graph\n        graph = {u: {} for u in range(n)}\n        for (u, v), prob in zip(edges, probs):\n            graph[u][v] = prob\n            graph[v][u] = prob\n\n        # run A* search\n        frontier = [(-1, s)]\n        seen = set()\n\n        while len(frontier) != 0:\n            neg_path_prob, u = heapq.heappop(frontier)\n            if u == t:\n                return -neg_path_prob\n\n            seen.add(u)\n            for v, edge_prob in graph[u].items():\n                if v not in seen:\n                    heapq.heappush(frontier, (neg_path_prob * edge_prob, v))\n        return 0", "import heapq \nfrom math import log2\n\nclass Solution:\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\n        AdjList = [set() for _ in range(n)]\n        for (u, v), prob in zip(edges, succProb):\n            AdjList[u].add(( -log2(prob), v ))\n            AdjList[v].add(( -log2(prob), u ))\n        dist = [float('inf')]*n\n        dist[start] = 0\n        heap = [(0, start)]\n        explored = set()\n        while heap:\n            d, curr = heapq.heappop(heap)\n            explored.add(curr)\n            for (val, node) in AdjList[curr]:\n                if node not in explored:\n                    if dist[curr] + val < dist[node]:\n                        dist[node] = dist[curr] + val\n                        heapq.heappush(heap, (dist[node], node))\n        return 2 ** (-dist[end])", "from collections import deque\n\nclass Solution:\n    def maxProbability(self, n: int, edges, succProb, start: int, end: int) -> float:\n\n        m = [{} for i in range(n)]\n        for edge, d in zip(edges, succProb):\n            s, e = edge\n            m[s][e] = m[e][s] = d\n\n        res = [0] * n\n        res[start] = 1\n        q = [[-1, start]]\n\n        while q and res[end] == 0:\n            tmp = heapq.heappop(q)\n            prob, cur = -tmp[0], tmp[1]\n            res[cur] = prob\n            for nxt, np in m[cur].items():\n                if res[nxt] != 0: continue\n                heapq.heappush(q, [-np * prob, nxt])\n        return res[end]", "class Solution:\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\n        graph = collections.defaultdict(list)\n        for (s, e), prob in zip(edges, succProb):\n            graph[s].append((e, prob))\n            graph[e].append((s, prob))\n        \n        visited = [0] * n\n        \n        prio = [(-1, start)]\n        while prio:\n            prob, vertex = heapq.heappop(prio)\n            \n            if prob > visited[vertex]:\n                continue\n            visited[vertex] = prob\n            \n            if vertex == end:\n                return -prob\n            \n            for neighbor, cost in graph[vertex]:\n                if prob * cost < visited[neighbor]:\n                    visited[neighbor] = prob * cost\n                    heapq.heappush(prio, (prob * cost, neighbor))\n        \n        return 0", "class Solution:\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\n        \n        g = defaultdict(list)\n        \n        '''\n        {0: [(0.5, 1), (0.2, 2)], 1: [(0.5, 0), (0.5, 2)], 2: [(0.5, 1), (0.2, 0)]}\n        '''\n        for edge, prob in zip(edges, succProb):\n            x, y = edge\n            g[x].append((prob, y))\n            g[y].append((prob, x))\n            \n        print(g)\n        \n        q, vis = [(-1, start)], set()\n        cand = []\n        while q:\n            prob, node = heapq.heappop(q)\n            \n            # print((prob, node))\n            if node == end:\n                cand.append(-prob)\n            \n            if node not in vis:\n                vis.add(node)\n                \n                for next_prob, nbrs in g[node]:\n                    if nbrs not in vis:\n                        heapq.heappush(q, (prob * next_prob, nbrs))\n                        \n                        \n        print(cand)\n        return max(cand, default=0)\n            \n            \n", "class Solution:\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\n        # undirected graph\n        # weighted positive edges\n        # single start\n        \n        # shortest path <-> longest path\n        \n        # \u6700\u77ed\u8def \u6b63\u8fb9\u6743 \u7a00\u758f\u56fe -\u300b stack dijkstra\n\n        N = 100010\n        dist = [2 for i in range(N)] \n        seen = set()\n        \n        h = [-1 for i in range(N)]\n        e = {}\n        ne = {}\n        w = {}\n        idx = 0\n        \n        # build singly linked list graph\n        def add(a, b, c, idx):\n            e[idx], w[idx] = b, c\n            ne[idx] = h[a] \n            h[a] = idx\n            \n        for edge, prob in zip(edges, succProb):\n            add(edge[0], edge[1], prob, idx)\n            idx += 1\n            add(edge[1], edge[0], prob, idx)\n            idx += 1\n        \n        \n        def heap_dijkstra():\n            dist[start] = 1\n            heap = []\n            heapq.heappush(heap, (-1, start))\n\n            while heap:\n                t = heapq.heappop(heap)\n                vertex, distance = t[1], -t[0]\n                if vertex in seen:\n                    continue\n                    \n                seen.add(vertex)\n                    \n                i = h[vertex] # idx\n                while i != -1:\n                    j = e[i]\n                    if dist[j] == 2 or dist[j] < distance * w[i]:\n                        dist[j] = distance * w[i]\n                        heapq.heappush(heap, (-dist[j], j))\n\n                    i = ne[i]\n            return dist[end]\n        \n        '''\n        graph = [[1e-6 for i in range(N)] for j in range(N)]\n\n        for edge, prob in zip(edges, succProb):\n            graph[edge[0]][edge[1]] = max(prob, graph[edge[0]][edge[1]])   \n            graph[edge[1]][edge[0]] = max(prob, graph[edge[1]][edge[0]])            \n        \n        def dijkstra():\n            dist[start] = 1\n            \n            for i in range(n):\n                t = -1\n                for j in range(n):\n                    if not seen[j] and (t == -1 or dist[t] < dist[j]):\n                        t = j\n                \n                seen[t] = True\n                for j in range(n):\n                    dist[j] = max(dist[j], dist[t] * graph[t][j])\n            \n            return dist[end]\n        \n        '''\n        \n\n        \n        output = heap_dijkstra()\n\n        if output == 2 or output < 1e-5:\n            return 0.0\n        else:\n            return output", "class Solution:\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\n        dp = [0.0 for _ in range(start)] + [1.0] + [0.0 for _ in range(start+1,n)]\n        # dp[i] is the prob of getting node i from node start\n        \n        graph = defaultdict(list)\n        for (u,v),p in zip(edges,succProb):\n            graph[u].append((v,p))\n            graph[v].append((u,p))\n        \n        # dijkstra's algorithm\n        heap = [(-1.0, start)]\n        \n        while heap:\n            p, cur = heapq.heappop(heap)\n            if cur==end:\n                return -p\n            for child, prob in graph[cur]:\n                if dp[cur]*prob>dp[child]:\n                    dp[child] = dp[cur]*prob\n                    heapq.heappush(heap, (-dp[child],child))\n        return 0", "class Solution:\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\n        \n        dist = [-math.inf for _ in range(n)]\n        dist[start] = 1\n        max_heap = [(1, start)]\n        graph = collections.defaultdict(list)\n        \n        for (u, v), w in zip(edges, succProb):\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n            \n        while max_heap:\n            prob, node = heapq.heappop(max_heap)\n            prob = abs(prob) # make it positive to avoid confusion\n            if node == end:\n                return prob\n            for adj, next_prob in graph[node]:\n        # if we are coming from the start node, make sure we don't multiply it by 0\n                next_prob *= prob\n                if dist[adj] < next_prob:\n                    dist[adj] = next_prob\n                    heapq.heappush(max_heap, (-next_prob, adj))\n        return 0.0\n", "from collections import deque\nfrom heapq import heappush, heappop\n\nclass Solution:\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\n        graph = [[] for _ in range(n)]\n        for (u, v), wt in zip(edges, succProb):\n            graph[u].append((v, wt))\n            graph[v].append((u, wt))\n        \n        probabilities = [0 for _ in range(n)]\n        probabilities[start] = 1\n        h = [(-probabilities[start], start)]\n        visited = set()\n        while h:\n            curr_prob, curr_node = heappop(h)\n            curr_prob *= -1\n            visited.add(curr_node)\n            for v, wt in graph[curr_node]:\n                if v not in visited:\n                    if probabilities[curr_node] * wt > probabilities[v]:\n                        probabilities[v] = probabilities[curr_node] * wt\n                        heappush(h, (-probabilities[v], v))\n        return probabilities[end]\n            \n        \n        \n", "class Solution:\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\n        dist = [0.0]*n\n        dist[start] = 1.0\n\n        for i in range(n):\n            flag = False\n            for (a,b), p in zip(edges, succProb):\n                if dist[a]==0.0 and dist[b]==0.0:continue\n                Max = max(dist[a], dist[b])*p\n                if Max > dist[a]:\n                    dist[a] = Max\n                    flag = True\n                if Max > dist[b]:\n                    dist[b] = Max\n                    flag = True\n            if not flag:\n                break\n                \n        return dist[end]", "from collections import defaultdict\nfrom heapq import heappush, heappop\nfrom typing import List\n\n\nclass Solution:\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\n        adjlist = defaultdict(list)\n        for edge, succ in zip(edges, succProb):\n            adjlist[edge[0]].append([edge[1], succ])\n            adjlist[edge[1]].append([edge[0], succ])\n        cost = [float('-inf')] * n\n        hp = [(-1, start)]\n        visited = set()\n        while hp:\n            price, node = heappop(hp)\n            price = -price\n            if node in visited:\n                continue\n            for neigh, neighcost in adjlist[node]:\n                heappush(hp, (-(price * neighcost), neigh))\n            cost[node] = price\n            visited.add(node)\n        print(cost)\n        if cost[end] == float('-inf'):\n            return 0\n        return cost[end]\n", "from heapq import *\nfrom collections import defaultdict\n\nclass Solution:\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\n        # construct graph\n        graph = defaultdict(list)\n        \n        for edge, prob in zip(edges, succProb):\n            src, dst = edge\n            graph[src].append((dst, prob))\n            graph[dst].append((src, prob))\n        \n        # Dijkstra (-ve probabilities for max heap)\n        max_heap = [(-1.0, start, None)]\n        \n        while max_heap:\n            probability, node, parent = heappop(max_heap)\n            probability = -probability\n            # print(f\\\"Node: {node}\\\")\n            \n            if node == end:\n                return probability\n            \n            neighbors = graph[node]\n            \n            for neighbor, weight in neighbors:\n                # don't go back to the parent\n                if neighbor != parent:\n                    heappush(max_heap, (-weight*probability, neighbor, node))\n        \n        return 0\n        \n", "class Solution:\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\n        g = collections.defaultdict(list)\n        for (u, v), p in zip(edges, succProb):\n            g[u].append((v, p))\n            g[v].append((u, p))\n      #  print(g)\n        q = [(-1, start)]\n        seen = set()\n        while q:\n         #   print(q)\n            p, u = heapq.heappop(q)\n            if u in seen:\n                continue\n            seen.add(u)\n            if u == end:\n                return -p\n            for v, pp in g[u]:\n               # print(v, pp, seen)\n                if v not in seen:\n                    heapq.heappush(q, (p * pp, v))\n                    #seen.add(v)\n        return 0\n", "from collections import defaultdict\nfrom heapq import heappop, heappush\nclass Solution:\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\n        adjlist = defaultdict(list)\n        for pair, prob in zip(edges, succProb):\n            p, c = pair\n            adjlist[p].append([c, prob])\n            adjlist[c].append([p, prob])\n        probability = {i: float('-inf') for i in range(n)}\n        hq = [[-1, start]]\n        visited = set()\n        while hq:\n            cost, curr = heappop(hq)\n            cost = -cost\n            if curr in visited:\n                continue\n            for child, price in adjlist[curr]:\n                heappush(hq, [-(price*cost), child])\n            visited.add(curr)\n            if probability[curr] < cost:\n                probability[curr] = cost\n        if probability[end] == float('-inf'):\n            return 0\n        return probability[end]\n", "class Solution:\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\n        G = defaultdict(list)\n        P = {}\n        for (i, j), p in zip(edges, succProb):\n            G[i].append(j)\n            G[j].append(i)\n            P[i, j] = P[j, i] = p\n        hp = [(-1, start)]\n        seen = {start: 1}\n        while hp:\n            prob, node = heapq.heappop(hp)\n            prob *= -1\n            if node == end:\n                return prob\n            for nei in G[node]:\n                tmp = seen[node] * P[node, nei]\n                if nei not in seen or seen[nei] < tmp:\n                    heapq.heappush(hp, (-tmp, nei))\n                    seen[nei] = tmp\n        return 0\n                    \n", "class Solution:\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\n        dp = [0.0 for _ in range(start)] + [1.0] + [0.0 for _ in range(n)]\n        graph = defaultdict(list) # undirected\n        for (u,v),p in zip(edges,succProb):\n            graph[u].append((v,p))\n            graph[v].append((u,p))\n        \n        queue = [(-1.0,start)] # tuple[0] is current point, tuple[1] is prob of getting cur from start\n\n        while queue:\n            for _ in range(len(queue)):\n                p, cur = heapq.heappop(queue)\n                if cur==end:\n                    return -p\n                for child,prob in graph[cur]:\n                    if dp[cur]*prob > dp[child]:\n                        dp[child] = dp[cur]*prob\n                        heapq.heappush(queue,(-dp[child], child))\n                            \n                        \n        return 0", "class Solution:\n    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\n        \n        dist = [-math.inf for _ in range(n)]\n        dist[start] = 1\n        max_heap = [(1, start)]\n        # graph = collections.defaultdict(list)\n        graph = collections.defaultdict(dict)\n        \n        for (u, v), w in zip(edges, succProb):\n            # graph[u].append((v, w))\n            # graph[v].append((u, w))\n            graph[u][v] = w\n            graph[v][u] = w\n            \n        while max_heap:\n            prob, node = heapq.heappop(max_heap)\n            prob = abs(prob) # make it positive to avoid confusion\n            if node == end:\n                return prob\n            for adj in graph[node]:\n        # if we are coming from the start node, make sure we don't multiply it by 0\n                next_prob = graph[node][adj]\n                next_prob *= prob\n                if dist[adj] < next_prob:\n                    dist[adj] = next_prob\n                    heapq.heappush(max_heap, (-next_prob, adj))\n        return 0.0\n"]