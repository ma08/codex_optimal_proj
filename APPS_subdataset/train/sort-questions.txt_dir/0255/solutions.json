["class Solution:\n     def jump(self,nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         if len(nums) == 1:\n             return 0\n         else:\n             step = 0\n             pos = 0\n             while pos != len(nums) - 1:\n                 bestStep = -1\n                 bestValue = -1\n                 for i in range(nums[pos], 0, -1):\n                     if len(nums) - 1 == pos + i:\n                         bestStep = i\n                         break\n                     if (pos + i < len(nums) and nums[pos + i] != 0 and nums[pos + i] + i > bestValue):\n                         bestStep = i\n                         bestValue = nums[pos + i] + i\n                 print(bestStep)\n                 pos += bestStep \n                 step += 1\n \n             return step\n \n \n", "class Solution:\n     def jump(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         res = 0\n         n = len(nums)\n         i, j = 0, 0\n         \n         while j < n - 1:\n             print((i, j))\n             ii, jj = i, j\n             for k in range(ii, jj + 1):\n                 j = max(j, min(n - 1, k + nums[k]))\n             i = jj + 1\n             res += 1\n         return res\n", "class Solution:\n     def jump(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         if not nums: return 0\n         if len(nums) == 1: return 0\n         step, far, maxV = 0, 0, 0\n         \n         for i in range(len(nums)):\n             if i + nums[i] > maxV and i + nums[i] >= len(nums) - 1: return step + 1\n             maxV = max(maxV, i + nums[i])\n             if i == far:\n                 step += 1\n                 far = maxV\n         return step", "class Solution:\n     def jump(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         p = [0]\n         for i in range(len(nums) - 1):\n             while(i + nums[i] >= len(p) and len(p) < len(nums)):\n                 p.append(p[i] + 1)\n         return p[-1]", "class Solution:\n     def jump(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \n         if len(nums)<=1:\n             return 0\n         dist=1\n         explored ={}\n         Q =[]\n         explored[0]=dist\n         Q.append(0)\n         levelup = 0\n         while Q[-1]+1 < len(nums):\n             print(Q)\n             v = Q[0]\n             Q.pop(0)\n             before=len(explored)\n             for i in range(nums[v]):\n                 if not (v+i+1) in explored:\n                     explored[v+i+1] = dist\n                     Q.append(v+i+1)\n             if v== levelup:\n                 dist+=1\n                 levelup=Q[-1]\n             print(Q)\n         return explored[len(nums)-1]\n         \"\"\"\n         cur = 0\n         ans = 0\n         maxstep =0\n         for i in range (0,len(nums)-1):\n             maxstep = max(maxstep,i+nums[i])\n             if i ==cur:\n                 ans +=1\n                 cur = maxstep\n         return ans", "class Solution:\n     def jump(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         if len(nums) == 0 or len(nums) == 1:\n             return 0;\n         s = 0; e = 0; step = 0\n         while (e < len(nums) - 1):\n             fst = e\n             step += 1\n             for i in range(s, e + 1):\n                 if fst < nums[i] + i:\n                     fst = nums[i] + i\n             s = e + 1\n             e = fst\n         return step", "class Solution:\n     def jump(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         current_step = 0\n         last_step = 0\n         i = 0\n         n_jumps = 0\n         while last_step < len(nums)-1:\n             while i <= last_step:\n                 current_step = max(i+nums[i],current_step)\n                 i += 1\n             last_step = current_step\n             n_jumps += 1\n         return n_jumps\n", "class Solution:\n     def jump(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         n, start, end, step = len(nums), 0, 0, 0\n         while end < n - 1:\n             step += 1\n             maxend = end + 1\n             for i in range(start, end + 1):\n                 if i + nums[i] >= n - 1:\n                     return step\n                 maxend = max(maxend, i + nums[i])\n             start, end = end + 1, maxend\n         return step", "class Solution:\n     def jump(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         if nums is None or len(nums) <= 1:\n             return 0\n         \n         start = currEnd = nextEnd = jump = 0\n         while currEnd - start + 1 > 0:\n             jump += 1\n             for i in range(start, currEnd+1):\n                 nextEnd = max(nums[i] + i, nextEnd)\n                 if nextEnd >= len(nums) - 1:\n                     return jump\n             start = currEnd + 1\n             currEnd = nextEnd\n         return jump", "class Solution:\n     def jump(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         if len(nums) <= 2:\n             return len(nums)-1\n         stack = []\n         i = len(nums) - 2\n         while i >= 0:\n #            print(nums,stack)\n             if nums[i] == 1:\n                 stack.append(i)\n             elif nums[i] >= (len(nums)-1-i):\n                 if stack:\n                     stack.clear()    \n                 stack.append(i)\n             else:\n                 j = 0\n                 while stack and j < len(stack): \n                     if nums[i] >= (stack[j]-i):\n                         stack = stack[0:j+1]\n                         stack.append(i)\n                         break\n                     else:\n                         j += 1\n             i -= 1\n #        print(stack)\n         return len(stack)\n                     \n", "class Solution:\n     def jump(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         L = len(nums)\n         lo = 0\n         hi = 0\n         jumps = 0\n         while hi < L-1:\n             jumps += 1\n             nexthi = hi\n             for i in range(lo, hi+1):\n                 nexthi = max(nexthi, i + nums[i])\n                 if nexthi >= L-1:\n                     return jumps\n             lo, hi = hi + 1, nexthi\n         return jumps", "class Solution:\n     def jump(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         if not nums:\n             return 0\n         dic = {}\n         length = len(nums)\n         dic[length - 1] = 0\n         for j in range(length - 1)[::-1]:\n             #print(length - j + 1)\n             if(nums[j] >= nums[j + 1] + 1 and not j + 1 == length - 1):\n                 minstep = dic[j + 1] - 1\n                 for k in range(max(3, nums[j+1] + 2) ,min(length - j , nums[j] + 1)):\n                     #print(j,k)\n                     if dic[j + k] < minstep:\n                         minstep = dic[j + k]\n                 dic[j] = minstep + 1\n                 continue\n             minstep = dic[j + 1]\n             for k in range(2,min(length - j , nums[j] + 1)):\n                 #print(j,k)\n                 if dic[j + k] < minstep:\n                     minstep = dic[j + k]\n             dic[j] = minstep + 1\n         #print(dic)\n         return dic[0]"]