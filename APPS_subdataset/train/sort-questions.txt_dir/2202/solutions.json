["import sys\ninput = sys.stdin.readline\n\nn=int(input())\nA=list(map(int,input().split()))\n\nBIT=[0]*(n+1)\n\ndef update(v,w):\n    while v<=n:\n        BIT[v]+=w\n        v+=(v&(-v))\n\ndef getvalue(v):\n    ANS=0\n    while v!=0:\n        ANS+=BIT[v]\n        v-=(v&(-v))\n    return ANS\n\nfor i in range(1,n+1):\n    update(i,i)\n\nANS=[-1]*n\n\nfor i in range(n-1,-1,-1):\n    MIN=0\n    MAX=n\n    k=A[i]\n\n    while True:\n        x=(MIN+MAX+1)//2\n\n\n        if getvalue(x)>k:\n            if getvalue(x-1)==k:\n                ANS[i]=x\n                break\n            else:\n                MAX=x\n        else:\n            MIN=x\n\n    update(x,-x)\n\n            \nprint(*ANS)\n", "class DualBIT():\n    def __init__(self, n):\n        self.n = n\n        self.bit = [0] * (n + 1)\n\n    def get(self, i):\n        '''i\u756a\u76ee\u306e\u8981\u7d20\u3092\u53d6\u5f97'''\n        i = i + 1\n        s = 0\n        while i <= self.n:\n            s += self.bit[i]\n            i += i & -i\n        return s\n\n    def _add(self, i, x):\n        while i > 0:\n            self.bit[i] += x\n            i -= i & -i\n\n    def add(self, i, j, x):\n        '''[i, j)\u306e\u8981\u7d20\u306bx\u3092\u52a0\u7b97\u3059\u308b'''\n        self._add(j, x)\n        self._add(i, -x)\n\n\nn = int(input())\na = list(map(int, input().split()))\n                        \nbit = DualBIT(n+3)\nfor i in range(1, n+1):\n    bit.add(i+1, n+1, i)\n\nli = []\nflag = False\nwhile True:\n    if not a:\n        break\n    ok = n + 1\n    ng = 0\n    num = a[-1]\n    if num == 0 and not flag:\n        flag = True\n        bit.add(1, n + 2, -1)\n        li.append(1)\n        del a[-1]\n        continue\n    while abs(ok - ng) > 1:\n        mid = (ok + ng) // 2\n        if bit.get(mid) > num:\n            ok = mid\n        else:\n            ng = mid\n    tmp = ok - 1\n    bit.add(ok, n + 2, -tmp)\n    li.append(tmp)\n    del a[-1]\nprint(*li[::-1])\n          \n\n", "NN = 18\nBIT=[0]*(2**NN+1)\n\ndef addbit(i, x):\n    while i <= 2**NN:\n        BIT[i] += x\n        i += i & (-i)\n\ndef getsum(i):\n    ret = 0\n    while i != 0:\n        ret += BIT[i]\n        i -= i&(-i)\n    return ret\n\ndef searchbit(x):\n    l, sl = 0, 0\n    d = 2**(NN-1)\n    while d:\n        m = l + d\n        sm = sl + BIT[m]\n        if sm <= x:\n            l, sl = m, sm\n        d //= 2\n    return l\n    \nN = int(input())\nA = [int(a) for a in input().split()]\nfor i in range(1, N+1):\n    addbit(i, i)\n\nANS = []\nfor s in A[::-1]:\n    a = searchbit(s) + 1\n    addbit(a, -a)\n    ANS.append(a)\n    \nprint(*ANS[::-1])", "from sys import setrecursionlimit as SRL, stdin\n\nSRL(10 ** 7)\nrd = stdin.readline\nrrd = lambda: map(int, rd().strip().split())\n\nn = int(rd())\n\nbit = [0] * 200005\n\n\ndef add(x, val):\n    while x <= n:\n        bit[x] += val\n        x += (x & -x)\n\n\ndef query(x):\n    num = 0\n    for i in range(30, -1, -1):\n        if num+(1 << i) <= n and bit[num + (1 << i)] <= x:\n           \n            x -= bit[num + (1 << i)]\n            num += (1 << i)\n\n    return num + 1\n\n\nfor i in range(1, n + 1):\n    add(i, i)\n\ns = list(rrd())\n\nans = []\n\nfor i in range(len(s) - 1, -1, -1):\n    q = query(s[i])\n    ans.append(q)\n    add(q, -q)\n\nans = ans[::-1]\nprint(*ans)", "from sys import setrecursionlimit as SRL, stdin\n\nSRL(10 ** 7)\nrd = stdin.readline\nrrd = lambda: map(int, rd().strip().split())\n\nn = int(rd())\n\nbit = [0] * 200005\n\n\ndef add(x, val):\n    while x <= n:\n        bit[x] += val\n        x += (x & -x)\n\n\ndef query(x):\n    num = 0\n    for i in range(30, -1, -1):\n        if num+(1 << i) <= n and bit[num + (1 << i)] <= x:\n\n            x -= bit[num + (1 << i)]\n            num += (1 << i)\n\n    return num + 1\n\n\nfor i in range(1, n + 1):\n    add(i, i)\n\ns = list(rrd())\n\nans = []\n\nfor i in range(len(s) - 1, -1, -1):\n    q = query(s[i])\n    ans.append(q)\n    add(q, -q)\n\nans = ans[::-1]\nprint(*ans)", "import sys\ninput = sys.stdin.readline\n\nnn = 18\nbit=[0]*(2**nn+1)\n \ndef addbit(i, x):\n    while i <= 2**nn:\n        bit[i] += x\n        i += i & (-i)\n \ndef getsum(i):\n    ret = 0\n    while i != 0:\n        ret += bit[i]\n        i -= i&(-i)\n    return ret\n \ndef searchbit(x):\n    l, sl = 0, 0\n    d = 2**(nn-1)\n    while d:\n        m = l + d\n        sm = sl + bit[m]\n        if sm <= x:\n            l, sl = m, sm\n        d //= 2\n    return l + 1\n\nn = int(input())\nl = list(map(int, input().split()))\nfor i in range(1, n + 1):\n\taddbit(i, i)\nans = [0 for _ in range(n)]\nfor i in range(n - 1, -1, -1):\n\ta = searchbit(l[i])\n\taddbit(a, -a)\n\tans[i] = a\nprint(*ans)\n\n\n\n\n\n", "n=int(input())\nP=[int(i) for i in input().split()]\nimport math\nimport bisect\n\nn_max=2*10**5\nnn=int(math.log2(n_max))+1\nBIT=[0]*(2**nn+1)\n\ndef bitsum(BIT,i):\n  s=0\n  while i>0:\n    s+=BIT[i]\n    i-=i&(-i)\n  return s\ndef bitadd(BIT,i,x):\n  if i<=0:\n    return True\n  else:\n    while i<=2**nn:\n      BIT[i]+=x\n      i+=i&(-i)\n    return BIT\ndef bitlowerbound(BIT,s):\n  if s<=0:\n    return 0\n  else:\n    ret=0\n    k=2**nn\n    while k>0:\n      if k+ret<=2**nn and BIT[k+ret]<s:\n        s-=BIT[k+ret]\n        ret+=k\n      k//=2\n    return ret+1\nfor i in range(n_max):\n  bitadd(BIT,i+1,i+1)\n\nAns=[]\nfor i in reversed(range(n)):\n  p=P[i]\n  ans=bitlowerbound(BIT,p+1)\n  Ans.append(ans)\n  bitadd(BIT,ans,-ans)\nAns=Ans[::-1]\nprint(*Ans)", "# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\nfrom sys import stdin, stdout\nfrom collections import defaultdict\nfrom collections import deque\nimport math\nimport copy\n \n#T = int(input())\nN = int(input())\n#s1 = input()\n#s2 = input()\n#N,Q = [int(x) for x in stdin.readline().split()]\narr = [int(x) for x in stdin.readline().split()]\n \nbit = [0]*N\n\nseries = [x for x in range(N)]\n\ndef lowbit(x):\n    return x&(-x)\n\ndef update(idx,delta):\n    while idx<N:\n        bit[idx] += delta\n        idx += lowbit(idx)\n\ndef query(x):\n    s = 0\n    while x>0:\n        s += bit[x]\n        x -= lowbit(x)\n    return s\n    \n# init\nfor i in range(N):\n    bit[i] += series[i]\n    y = i + lowbit(i)\n    if y<N:\n        series[y] += series[i]\n        \nvisited = [0]*N\nans = [0]*N\nfor i in range(N-1,-1,-1):\n    # find\n    left = 0\n    right = N-1\n    target = arr[i]\n    while left<=right:\n        mid = (left+right)//2\n        q = query(mid)\n        if q<target:\n            left = mid + 1\n        elif q>target:\n            right = mid - 1\n        else:\n            if visited[mid]==1:\n                left = mid + 1\n            else:\n                visited[mid] = 1\n                ans[i] = mid + 1\n                break\n    # update\n    if mid+1<N:\n        update(mid+1,-mid-1)\n    \n    \nprint(*ans)\n", "# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\nfrom sys import stdin, stdout\nfrom collections import defaultdict\nfrom collections import deque\nimport math\nimport copy\n \n#T = int(input())\nN = int(input())\n#s1 = input()\n#s2 = input()\n#N,Q = [int(x) for x in stdin.readline().split()]\narr = [int(x) for x in stdin.readline().split()]\n \nbit = [0]*(N+1)\n\nseries = [0] + [x for x in range(N)]\n\ndef lowbit(x):\n    return x&(-x)\n\ndef update(idx,delta):\n    while idx<=N:\n        bit[idx] += delta\n        idx += lowbit(idx)\n\ndef query(x):\n    s = 0\n    while x>0:\n        s += bit[x]\n        x -= lowbit(x)\n    return s\n    \n# init\nfor i in range(1,N+1):\n    bit[i] += series[i]\n    y = i + lowbit(i)\n    if y<=N:\n        series[y] += series[i]\n        \nvisited = [0]*(N+1)\nans = [0]*N\nfor i in range(N-1,-1,-1):\n    # find\n    left = 1\n    right = N\n    target = arr[i]\n    while left<=right:\n        mid = (left+right)//2\n        q = query(mid)\n        #print(mid,q)\n        if q<target:\n            left = mid + 1\n        elif q>target:\n            right = mid - 1\n        else:\n            if visited[mid]==1:\n                left = mid + 1\n            else:\n                visited[mid] = 1\n                ans[i] = mid \n                break\n    # update\n    update(mid+1,-mid)\n    \n    \nprint(*ans)\n", "# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\nfrom sys import stdin, stdout\nfrom collections import defaultdict\nfrom collections import deque\nimport math\nimport copy\n \n#T = int(input())\nN = int(input())\n#s1 = input()\n#s2 = input()\n#N,Q = [int(x) for x in stdin.readline().split()]\narr = [int(x) for x in stdin.readline().split()]\n \nbit = [0]*(N+1)\n\nseries = [0] + [x for x in range(N)]\n\ndef lowbit(x):\n    return x&(-x)\n\ndef update(idx,delta):\n    while idx<=N:\n        bit[idx] += delta\n        idx += lowbit(idx)\n\ndef query(x):\n    s = 0\n    while x>0:\n        s += bit[x]\n        x -= lowbit(x)\n    return s\n    \n# init\nfor i in range(1,N+1):\n    bit[i] += series[i]\n    y = i + lowbit(i)\n    if y<=N:\n        series[y] += series[i]\n        \nvisited = [0]*(N+1)\nans = [0]*N\n\nfor i in range(N-1,-1,-1):\n    # find\n    left = 1\n    right = N\n    target = arr[i]\n    \n    \n    while True:\n        L = right - left + 1\n        num = left - 1 + 2**int(math.log(L,2))\n        \n        q = bit[num]\n        #print(num,q,target,left,right)\n        if q<target:\n            target -= q\n            left = num + 1\n        elif q>target:\n            right = num - 1\n        else:\n            if visited[num]==1:\n                target -= q\n                left = num + 1\n            else:\n                visited[num] = 1\n                ans[i] = num\n                break\n            \n    # update\n    update(num+1,-num)\n    \n    \nprint(*ans)\n", "from operator import add\n\nclass Stree:\n    def __init__(self, f, n, default, init_data):\n        self.ln = 2**(n-1).bit_length()\n        self.data = [default] * (self.ln * 2)\n        self.f = f\n        for i, d in init_data.items():\n            self.data[self.ln + i] = d\n        for j in range(self.ln - 1, 0, -1):\n            self.data[j] = f(self.data[j*2], self.data[j*2+1])\n\n    def update(self, i, a):\n        p = self.ln + i\n        self.data[p] = a\n        while p > 1:\n            p = p // 2\n            self.data[p] = self.f(self.data[p*2], self.data[p*2+1])\n\n    def get(self, i, j):\n        def _get(l, r, p):\n            if i <= l and j >= r:\n                return self.data[p]\n            else:\n                m = (l+r)//2\n                if j <= m:\n                    return _get(l, m, p*2)\n                elif i >= m:\n                    return _get(m, r, p*2+1)\n                else:\n                    return self.f(_get(l, m, p*2), _get(m, r, p*2+1))\n        return _get(0, self.ln, 1)\n\n    def find_value(self, v):\n        def _find_value(l, r, p, v):\n            if r == l+1:\n                return l\n            elif self.data[p*2] <= v:\n                return _find_value((l+r)//2, r, p*2+1, v - self.data[p*2])\n            else:\n                return _find_value(l, (l+r)//2, p*2, v)\n        return _find_value(0, self.ln, 1, v)\n\n\ndef main():\n    n = int(input())\n    sums = {i:i for i in range(n+1)}\n    stree = Stree(add, n+1, 0, sums)\n    ss = list(map(int, input().split()))\n    ss.reverse()\n    pp = []\n    for s in ss:\n        sval = stree.find_value(s)\n        pp.append(sval)\n        stree.update(sval,0)\n    print(*(reversed(pp)))\n\ndef __starting_point():\n    main()\n__starting_point()", "def update(x,val):\n    while x<=n:\n        BIT[x]+=val\n        x+=(x&-x)\ndef query(x):\n    s=0\n    while x>0:\n        s=(s+BIT[x])\n        x-=(x&-x)\n    return s\nn=int(input())\nBIT=[0]*(n+1)\nfor i in range(1,n+1):\n    update(i,i)\narr=list(map(int,input().split()))\nanswers=[0]*(n)\n#print(BIT)\nfor i in range(n-1,-1,-1):\n    lol=arr[i]\n    low=0\n    fjf=0\n    high=n\n   # print(lol)\n    while True:\n        \n        mid=(high+low+1)//2\n        j=query(mid)\n      #  print(mid,j)\n      #  print(answers)\n       # break\n        if j>lol:\n            if query(mid-1)==lol:\n                answers[i]=mid\n                update(mid,-mid)\n                break\n            else:\n                high=mid\n        else:\n            low=mid\n    \nprint(*answers)\n        \n", "# 1208D\nclass segTree():\n    def __init__(self, n):\n        self.t = [0] * (n << 2)\n\n    def update(self, node, l, r, index, value):\n        if l == r:\n            self.t[node] = value\n            return\n        mid = (l + r) >> 1\n        if index <= mid:\n            self.update(node*2, l, mid, index, value)\n        else:\n            self.update(node*2 + 1, mid + 1, r, index, value)\n        self.t[node] = self.t[node*2] + self.t[node*2 + 1]\n\n    def query(self, node, l, r, value):\n        if l == r:\n            return self.t[node]\n        mid = (l + r) >> 1\n        if self.t[node*2] >= value:\n            return self.query(node*2, l, mid, value)\n        return self.query(node*2 + 1, mid + 1, r, value - self.t[node*2])\n\ndef do():\n    n = int(input())\n    nums = [int(i) for i in input().split(\" \")]\n    res = [0]*n\n    weightTree = segTree(n)\n    for i in range(1, n+1):\n        weightTree.update(1, 1, n, i, i)\n    # print(weightTree.t)\n    for i in range(n-1, -1, -1):\n        res[i] = weightTree.query(1, 1, n, nums[i] + 1)\n        weightTree.update(1, 1, n, res[i], 0)\n    return \" \".join([str(c) for c in res])\nprint(do())\n", "class FTree:\n\n    def __init__(self, f):\n\n        self.n = len(f)\n\n        self.ft = [0] * (self.n + 1)\n\n\n\n        for i in range(1, self.n + 1):\n\n            self.ft[i] += f[i - 1]\n\n            if i + self.lsone(i) <= self.n:\n\n                self.ft[i + self.lsone(i)] += self.ft[i]\n\n\n\n    def lsone(self, s):\n\n        return s & (-s)\n\n\n\n    def query(self, i, j):\n\n        if i > 1:\n\n            return self.query(1, j) - self.query(1, i - 1)\n\n\n\n        s = 0\n\n        while j > 0:\n\n            s += self.ft[j]\n\n            j -= self.lsone(j)\n\n\n\n        return s\n\n\n\n    def update(self, i, v):\n\n        while i <= self.n:\n\n            self.ft[i] += v\n\n            i += self.lsone(i)\n\n\n\n    def select(self, k):\n\n        lo = 1\n\n        hi = self.n\n\n\n\n        for i in range(19): ########  30\n\n            mid = (lo + hi) // 2\n\n            if self.query(1, mid) < k:\n\n                lo = mid\n\n            else:\n\n                hi = mid\n\n\n\n        return hi\n\n\nn = int(input())\ndata = [int(i) for i in input().split()]\nft = FTree(list(range(1, n+1)))\nans = [\"\"]*n\n\nfor i in range(n-1, -1, -1):\n    val = data[i]\n    ind = ft.select(val+1)\n    ans[i] = str(ind)\n    ft.update(ind, -ind)\n\nprint(\" \".join(ans))", "class FTree:\n    def __init__(self, f):\n        self.n = len(f)\n        self.ft = [0] * (self.n + 1)\n        for i in range(1, self.n + 1):\n            self.ft[i] += f[i - 1]\n            if i + self.lsone(i) <= self.n:\n                self.ft[i + self.lsone(i)] += self.ft[i]\n    def lsone(self, s):\n        return s & (-s)\n    def query(self, i, j):\n        if i > 1:\n            return self.query(1, j) - self.query(1, i - 1)\n        s = 0\n        while j > 0:\n            s += self.ft[j]\n            j -= self.lsone(j)\n        return s\n    def update(self, i, v):\n        while i <= self.n:\n            self.ft[i] += v\n            i += self.lsone(i)\n    def select(self, k):\n        lo = 1\n        hi = self.n\n        for i in range(19): ########  30\n            mid = (lo + hi) // 2\n            if self.query(1, mid) < k:\n                lo = mid\n            else:\n                hi = mid\n        return hi\nn = int(input())\ndata = [int(i) for i in input().split()]\nft = FTree(list(range(1, n+1)))\nans = [\"\"]*n\nfor i in range(n-1, -1, -1):\n    val = data[i]\n    ind = ft.select(val+1)\n    ans[i] = str(ind)\n    ft.update(ind, -ind)\nprint(\" \".join(ans))\n\n", "def sumsegtree(l,seg,st,en,x):\n    if st==en:\n        seg[x]=l[st]\n    else:\n        mid=(st+en)>>1\n        sumsegtree(l,seg,st,mid,2*x)\n        sumsegtree(l,seg,mid+1,en,2*x+1)\n        seg[x]=seg[2*x]+seg[2*x+1]\n\ndef query(seg,st,en,val,x):\n    if st==en:\n        return seg[x]\n    mid=(st+en)>>1\n    if seg[2*x]>=val:\n        return query(seg,st,mid,val,2*x)\n    return query(seg,mid+1,en,val-seg[2*x],2*x+1)\n\ndef upd(seg,st,en,ind,val,x):\n    if st==en:\n        seg[x]=val\n        return\n    mid=(st+en)>>1\n    if mid>=ind:\n        upd(seg,st,mid,ind,val,2*x)\n    else:\n        upd(seg,mid+1,en,ind,val,2*x+1)\n    seg[x]=seg[2*x]+seg[2*x+1]\n\nn=int(input())\nl=list(map(int,range(1,n+1)))\ns=[0]*n\np=list(map(int,input().split()))\n\n\nseg=[\"#\"]*(n<<2)\nsumsegtree(l,seg,0,len(l)-1,1)\n\nfor i in range(n-1,-1,-1):\n    s[i]=query(seg,1,n,p[i]+1,1)\n    upd(seg,1,n,s[i],0,1)\n\nprint (*s)", "def sumsegtree(l,seg,st,en,x):\n    if st==en:\n        seg[x]=l[st]\n    else:\n        mid=(st+en)>>1\n        sumsegtree(l,seg,st,mid,2*x)\n        sumsegtree(l,seg,mid+1,en,2*x+1)\n        seg[x]=seg[2*x]+seg[2*x+1]\n \ndef query(seg,st,en,val,x):\n    if st==en:\n        return seg[x]\n    mid=(st+en)>>1\n    if seg[2*x]>=val:\n        return query(seg,st,mid,val,2*x)\n    return query(seg,mid+1,en,val-seg[2*x],2*x+1)\n \ndef upd(seg,st,en,ind,val,x):\n    if st==en:\n        seg[x]=val\n        return\n    mid=(st+en)>>1\n    if mid>=ind:\n        upd(seg,st,mid,ind,val,2*x)\n    else:\n        upd(seg,mid+1,en,ind,val,2*x+1)\n    seg[x]=seg[2*x]+seg[2*x+1]\n \nn=int(input())\nl=list(map(int,range(1,n+1)))\ns=[0]*n\np=list(map(int,input().split()))\n \n \nseg=[\"#\"]*(n<<2)\nsumsegtree(l,seg,0,len(l)-1,1)\n \nfor i in range(len(p)-1,-1,-1):\n    s[i]=query(seg,1,n,p[i]+1,1)\n    upd(seg,1,n,s[i],0,1)\n \nprint (*s)", "_ = input()\nx = [int(i) for i in input().split()]\n\nres = []\n\nfrom math import log\n\n\nclass SegmentTree(object):\n\n    def __init__(self, nums):\n        self.arr = nums\n        self.l = len(nums)\n        self.tree = [0] * self.l + nums\n        for i in range(self.l - 1, 0, -1):\n            self.tree[i] = self.tree[i << 1] + self.tree[i << 1 | 1]\n\n    def update(self, i, val):\n        n = self.l + i\n        self.tree[n] = val\n        while n > 1:\n            self.tree[n >> 1] = self.tree[n] + self.tree[n ^ 1]\n            n >>= 1\n\n    def query(self, i, j):\n        m = self.l + i\n        n = self.l + j\n        res = 0\n        while m <= n:\n            if m & 1:\n                res += self.tree[m]\n                m += 1\n            m >>= 1\n            if n & 1 == 0:\n                res += self.tree[n]\n                n -= 1\n            n >>= 1\n        return res\n\ntree = SegmentTree(list(range(1, len(x) + 1)))\norg = len(x)\nwhile x:\n    q = x.pop()\n\n    lo = 0\n    hi = org - 1\n\n    while lo < hi:\n        mid = (lo + hi) // 2\n        # print(lo, hi, mid)\n        sm = tree.query(0, mid)\n        # print(sm, mid)\n        if sm > q:\n            hi = mid\n        else:\n            lo = mid + 1\n    # print(tree.arr, lo, hi)\n    idx = tree.arr[lo]\n    # print(idx)\n    tree.update(lo, 0)\n    res.append(idx)\n\nprint(' '.join(str(i) for i in res[::-1]))", "\n\ndef sum_number(n,j):\n    j[0]=0\n    j[1]=0\n    for i in range(2,n+1):\n        j[i]=j[i-1]+(i-1)\n    return(j)\npo=int(input())\nl=[0]*(po+1)\nl1=[int(i) for i in input().split()]\ndef getsum(BITTree,i):\n    s = 0\n    while i > 0:\n        s += BITTree[i]\n        i -= i & (-i) \n    return(s) \ndef updatebit(BITTree , n , i ,v):\n    #print('n',n)\n    while i <= n:\n        #print('i',i)\n        BITTree[i] += v\n        i += i & (-i)\n    #print(BITTree)\nfor i in range(1,po+1):\n    updatebit(l,po,i,i)\noutput=[0]*po\nfor i in range(po-1,-1,-1):\n    min_=0\n    max_=po\n    k=l1[i]\n    while True:\n        x=(min_+max_+1)//2\n        if getsum(l,x)>k:\n            if getsum(l,x-1)==k:\n                output[i]=x\n                break\n            else:\n                #print(x)\n                max_=x\n        else :\n            #print(x)\n            min_=x\n    updatebit(l,po,x,-x)\nprint(*output)\n\n\n\n        \n    \n    \n\n\n\n", "# https://codeforces.com/contest/1208/problem/D\n\nfrom sys import stdin, stdout\ninput = stdin.readline\nprint = stdout.write\n\n# For every i from N to 1, let's say the value of the si is x. \n# So it means there are k smallest unused numbers whose sum is x.\n# We simply put the (k+1)st number in the output permutation at this i, and continue to move left. \n\n# segment tree and binary search\n\n_ = input()\nx = [int(i) for i in input().split()]\n \nres = []\n \nfrom math import log\n \n \nclass SegmentTree(object):\n \n    def __init__(self, nums):\n        self.arr = nums\n        self.l = len(nums)\n        self.tree = [0] * self.l + nums\n        for i in range(self.l - 1, 0, -1):\n            self.tree[i] = self.tree[i << 1] + self.tree[i << 1 | 1]\n \n    def update(self, i, val):\n        n = self.l + i\n        self.tree[n] = val\n        while n > 1:\n            self.tree[n >> 1] = self.tree[n] + self.tree[n ^ 1]\n            n >>= 1\n \n    def query(self, i, j):\n        m = self.l + i\n        n = self.l + j\n        res = 0\n        while m <= n:\n            if m & 1:\n                res += self.tree[m]\n                m += 1\n            m >>= 1\n            if n & 1 == 0:\n                res += self.tree[n]\n                n -= 1\n            n >>= 1\n        return res\n \ntree = SegmentTree(list(range(1, len(x) + 1)))\norg = len(x)\nwhile x:\n    # from back to forth\n    q = x.pop()\n \n    lo = 0\n    hi = org - 1\n \n    while lo < hi:\n        mid = (lo + hi) // 2\n        # print(lo, hi, mid)\n        sm = tree.query(0, mid)\n        # print(sm, mid)\n        if sm > q:\n            hi = mid\n        else:\n            lo = mid + 1\n    # print(tree.arr, lo, hi)\n    idx = tree.arr[lo]\n    # print(idx)\n    tree.update(lo, 0)\n    # also from back to forth\n    res.append(idx)\n \nprint(' '.join(str(i) for i in res[::-1]))", "# https://codeforces.com/contest/1208/problem/D\n\nfrom sys import stdin, stdout\ninput = stdin.readline\n# print = stdout.write\n\n# si is the sum of elements before the i-th element that are smaller than the i-th element.\n\n# For every i from N to 1, let's say the value of the si is x.\n# So it means there are k smallest unused numbers whose sum is x.\n# We simply put the k+1st number in the output permutation at this i, and continue to move left.\n\n# BIT and binary lifting\n# https://codeforces.com/contest/1208/submission/59526098\n\n\nclass BIT:\n    def __init__(self, nums):\n        # we store the sum information in bit 1.\n        # so the indices should be 1 based.\n        # here we assume nums[0] = 0\n        self.nums = [0] * (len(nums))\n        for i, x in enumerate(nums):\n            if i == 0:\n                continue\n            self.update(i, x)\n\n    def low_bit(self, x):\n        return x & (-x)\n\n    def update(self, i, diff):\n        while i < len(self.nums):\n            self.nums[i] += diff\n            i += self.low_bit(i)\n\n    def prefix_sum(self, i):\n        ret = 0\n        while i != 0:\n            ret += self.nums[i]\n            i -= self.low_bit(i)\n        return ret\n\n    def search(self, x):\n        # find the index i such that prefix_sum(i) == x\n        cur_index, cur_sum = 0, 0\n        delta = len(self.nums) - 1\n        while delta - self.low_bit(delta):\n            delta -= self.low_bit(delta)\n\n        while delta:            \n            m = cur_index + delta\n            if m < len(self.nums):\n                sm = cur_sum + self.nums[m]\n                if sm <= x:\n                    cur_index, cur_sum = m, sm\n            delta //= 2\n        return cur_index + 1\n\n\nn = int(input())\nbit = BIT(list(range(n+1)))\n\nans = [0 for _ in range(n)]\nnums = list(map(int, input().split()))\nfor i in range(n - 1, -1, -1):\n    index = bit.search(nums[i])\n    bit.update(index, -index)\n    ans[i] = index\nprint(*ans)\n", "import sys\ninput = sys.stdin.readline\nclass SegTree(object):\n\t\"\"\"docstring for SegTree\"\"\"\n\tdef __init__(self, n, arr):\n\t\tself.n = n\n\t\tself.arr = arr\n\t\tself.tree = [0 for i in range(2*n)]\n\n\tdef construct(self): # Construction\n\t\tfor i in range(self.n):\n\t\t\tself.tree[n+i] = self.arr[i]\n\t\tfor i in range(n-1,0,-1):\n\t\t\tself.tree[i] = self.function(self.tree[2*i],self.tree[2*i+1])\n\n\tdef update(self,index,value):\n\t\tstart = index+self.n\n\t\tself.tree[start] = value\n\t\twhile start>0:\n\t\t\tstart = start//2\n\t\t\tself.tree[start] = self.function(self.tree[2*start],self.tree[2*start+1])\n\n\tdef calc(self,low,high): # 0-indexed\n\t\tlow+=self.n\n\t\thigh+=self.n\n\t\tans = 0 # Needs to initialised\n\t\twhile low<high:\n\t\t\tif low%2:\n\t\t\t\tans = self.function(ans, self.tree[low])\n\t\t\t\tlow += 1\n\t\t\tif high%2:\n\t\t\t\thigh -= 1\n\t\t\t\tans = self.function(ans, self.tree[high])\n\t\t\tlow = low//2\n\t\t\thigh = high//2\n\t\treturn ans\n\t\n\tdef function(self,a,b): # Function used to construct Segment Tree\n\t\treturn a + b\n\n\ndef find(num):\n\tlow = 0\n\thigh = n-1\n\twhile low<high:\n\t\tmid = (low+high)//2\n\t\tif st.calc(0,mid+1)>num:\n\t\t\thigh = mid - 1\n\t\telse:\n\t\t\tlow = mid + 1\n\tif st.calc(0,low+1)>num:\n\t\treturn low\n\telse:\n\t\treturn low + 1\n\n\n\nn = int(input())\na = list(map(int,input().split()))\narr = [i for i in range(1,n+1)]\nst = SegTree(n,arr)\nst.construct()\nans = [-1]*n\nfor i in range(n-1,-1,-1):\n\tind = find(a[i])\n\t# print (a[i],ind,arr)\n\tans[i] = arr[ind]\n\tst.update(ind,0)\nprint(*ans)\n"]