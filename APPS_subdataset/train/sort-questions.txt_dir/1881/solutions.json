["class Solution:\n     def intersectionSizeTwo(self, intervals):\n         \"\"\"\n         :type intervals: List[List[int]]\n         :rtype: int\n         \"\"\"\n         intervals.sort(key=lambda x: x[1])\n         if len(intervals) <= 1:\n             return len(intervals[0])\n         s = set()\n         prev_e = None\n         intersect = False\n         for e in intervals:\n             if not s:\n                 a = e[1] - 1\n                 b = e[1]\n                 s.add(a)\n                 s.add(b)\n                 continue\n             if e[0] <= a :\n                 intersect = True\n                 continue\n                 \n             if e[0] > a and  e[1] > b >= e[0] :\n                 intersect = True\n                 a = b\n                 b = e[-1]\n                 s.add(b)\n                 continue\n             a = e[1] - 1\n             b = e[1]\n             s.add(a)\n             s.add(b)\n         \n         if not intersect:\n             return 0\n         return len(s)\n", "class Solution:\n     def intersectionSizeTwo(self, intervals):\n         \"\"\"\n         :type intervals: List[List[int]]\n         :rtype: int\n         \"\"\"\n         r1=[x[0] for x in intervals]\n         r2=[x[1] for x in intervals]\n         intervals=sorted(intervals,key=lambda x: x[1])\n         s=[intervals[0][1]-1,intervals[0][1]]\n         for interval in intervals:\n             if interval[0]>s[-1]:\n                     s+=[interval[1]-1,interval[1]]\n             elif interval[0]>s[-2]:\n                 s+=[interval[1]]\n         return len(s)\n                 \n", "class Solution:\n     def intersectionSizeTwo(self, intervals):\n         \"\"\"\n         :type intervals: List[List[int]]\n         :rtype: int\n         \"\"\"\n         intervals.sort(key=lambda inter: (inter[1], -inter[0]))\n         res=0\n         left,right=-1,-1 # current second largest, and largest\n         for inter in intervals: # assume each inter[0]<inter[1]\n             if inter[0]<=left: # two overlap, skip this inter, cc for intervals with the same inter[1]\n                 continue # current inter[0] is not greater than previou inter[0], so at least (left,right) are overlap elements\n             if inter[0]>right: # greater than current largest, no overlap, need add new [left, right]\n                 res+=2\n                 right=inter[1] # greedy, use the two largest num in this inter\n                 left=right-1 \n             elif inter[0]<=right: # one overlap with current largest\n                 res+=1\n                 left=right\n                 right=inter[1]\n         return res\n", "class Solution:\n     def intersectionSizeTwo(self, intervals):\n         \"\"\"\n         :type intervals: List[List[int]]\n         :rtype: int\n         \"\"\"\n         intervals.sort(key=lambda x: x[1])\n         if len(intervals) <= 1:\n             return len(intervals[0])\n         s = set()\n         for e in intervals:\n             if not s:\n                 a = e[1] - 1\n                 b = e[1]\n                 s.add(a)\n                 s.add(b)\n                 continue\n             if e[0] <= a :\n                 continue\n                 \n             if e[0] > a and  e[1] > b >= e[0] :\n                 a = b\n                 b = e[-1]\n                 s.add(b)\n                 continue\n             a = e[1] - 1\n             b = e[1]\n             s.add(a)\n             s.add(b)\n         \n         return len(s)\n", "class Solution:\n     def intersectionSizeTwo(self, intervals):\n         res = 0\n         last2 = [-float('inf')] * 2\n         intervals = sorted(intervals, key=lambda x: x[1])\n         for lo, hi in intervals:\n             n = sum(x < lo for x in last2)\n             res += n\n             if n == 2:\n                 last2 = hi - 1, hi\n             elif n == 1:\n                 last2 = last2[1], hi\n         return res\n"]