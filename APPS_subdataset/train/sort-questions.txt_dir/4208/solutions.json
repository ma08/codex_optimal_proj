["import ipaddress as ip\n\ndef ipsubnet2list(subnet):\n    try: return list(map(str,ip.ip_network(subnet).hosts()))\n    except: pass", "def ip_to_int(ip):\n    return sum(int(i[0]) << i[1]*8 for i in zip(ip.split('.'), range(3,-1,-1)))\ndef int_to_ip(num):\n    return '.'.join(str(num >> i*8 & 0xff) for i in range(3,-1,-1))\n\ndef ipsubnet2list(subnet):\n    net, prelen = subnet.split('/')\n    num, mask = ip_to_int(net), 1 << 32 - int(prelen)\n    if net != int_to_ip(num):\n        return None\n    if mask == 2:\n        return [int_to_ip(num), int_to_ip(num+1)]\n    return [int_to_ip(num^i) for i in range(1, mask-1)]", "from ipaddress import ip_network\nfrom typing import List, Union\n\n\ndef ipsubnet2list(subnet: str) -> Union[List[str], None]:\n    try:\n        return list(map(str, ip_network(subnet).hosts()))\n    except ValueError:\n        return\n", "def cidr_to_bits(subnet): \n    subnet_int = int(subnet[-2:]) \n    mask_in_bits = [(1,0)[i > subnet_int] for i in range(1,33)]\n    return mask_in_bits  \n\ndef ip_bits(subnet):\n    ip_bits_str =  list([format(int(x),'#010b')[2:] for x in subnet[:-3].split('.')])\n    ip_bits_int = [ int(i) for x in ip_bits_str for i in x]\n    return ip_bits_int # Address from input in bits\n\ndef f_addr_bits(x):\n    return [ i&j for i,j in zip(ip_bits(x),cidr_to_bits(x))] #  AND opperation on IP in bits and MASK in bits to achive first address in pool\n\ndef l_addr_bits(x):\n    not_on_mask = [(0,1)[ i == 0] for  i in cidr_to_bits(x)] #  OR opperation on IP in bits and MASK in bits to achive last address in pool\n    return  [ i|j for i,j in zip(f_addr_bits(x),not_on_mask)]\n\ndef address_to_int(bits_lst):\n    return [int(''.join(str(bits_lst[y+i]) for i in range(8)),2) for y in range(0,32,8)] # Translate list of 32 bits to 4 octets with ints [192, 168, 0 ,1] \n\ndef list_of_addresses(x):\n    first_address = address_to_int(f_addr_bits(x)) \n    last_address = address_to_int(l_addr_bits(x))\n    octets_ranges = [ [ i for i in range(i,j+1)] if j-i != 0 else [i] for i,j in zip(first_address,last_address)] # compare octets from first and last address if subtraction differs from 0 generate range of numbers \n    addresses = []\n    for first_oct in octets_ranges[0]:\n        for second in octets_ranges[1]:\n                for third in octets_ranges[2]:\n                        for fourth in octets_ranges[3]:\n                            addresses.append(f'{first_oct}.{second}.{third}.{fourth}')\n    return addresses \n\ndef ipsubnet2list(subnet):\n    result = list_of_addresses(subnet)\n    \n    if subnet[:-3] in result:\n        if len(result) == 2: # this condition is only because kata is made kind of retarded, with 192.168.1.0/31 creator of this kata wants list [192.168.1.0, 192.168.1.1] but those are not host IP's like in other inputs\n            return result     \n        return result[1:-1]\n    \n    else:\n        return None\n", "from ipaddress import ip_network\n\ndef ipsubnet2list(subnet):\n    try:\n        return [ip.compressed for ip in ip_network(subnet).hosts()]\n    except ValueError:\n        return", "from ipaddress import IPv4Network, AddressValueError\n\ndef ipsubnet2list(subnet):\n    try: return list(map(str, IPv4Network(subnet).hosts()))\n    except AddressValueError: return None", "from ipaddress import IPv4Network, AddressValueError\n\n\ndef ipsubnet2list(subnet):\n    try:\n        ip_list = [str(ip) for ip in IPv4Network(subnet)]\n        return ip_list[1:-1] if len(ip_list) > 2 else ip_list\n    except AddressValueError:\n        return None", "def ipsubnet2list(subnet):\n    import ipaddress\n    ls=[]\n    try:\n        for i in ipaddress.IPv4Network(subnet):\n            ls.append(str(i))\n    except :\n        return None\n    return ls[1:-1] if len(ls)>2 else ls", "def ipsubnet2list(subnet):\n    netaddr,prefix=subnet.split('/')\n    if not all([0<=int(x)<256 for x in netaddr.split('.')]):\n        return None\n    netaddrbyte=0\n    for x in netaddr.split('.'):\n        netaddrbyte=netaddrbyte*256+int(x)\n    r=[]\n    for i in range(2**(32-int(prefix))):\n        addr=netaddrbyte+i\n        a=[]\n        for _ in range(4):\n            a.append(addr%256)\n            addr//=256\n        r.append('.'.join(map(str,a[::-1])))\n    if int(prefix)<31:\n        r=r[1:-1]\n    return r", "def ipsubnet2list(s):\n    try:return[str(x)for x in list(__import__('ipaddress').ip_network(s).hosts())]\n    except ValueError: return None"]