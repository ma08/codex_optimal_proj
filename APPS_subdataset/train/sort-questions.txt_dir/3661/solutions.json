["def find_part_max_prod(n):\n  if n == 1: return [[1], 1]\n  q, r = divmod(n, 3)\n  if r == 0: return [[3]*q, 3**q]\n  if r == 1: return [[4] + [3]*(q - 1), [3]*(q - 1) + [2, 2], 3**(q - 1) * 2**2]\n  return [[3]*q + [2], 3**q * 2]", "from collections import defaultdict\nfrom functools import reduce\n\ndef find_part_max_prod(n):\n    prods = defaultdict(list)\n    for p in sum_part(n):\n        prods[reduce(int.__mul__, p)].append(p)\n    mx = max(prods.keys())\n    return sorted(prods[mx], key=len) + [mx]\n\ndef sum_part(n, k=2):\n    if n < 5:\n        yield [n]\n    for i in range(k, n//2 + 1):\n        for part in sum_part(n-i, i):\n            yield part + [i]", "from collections import defaultdict\n\ndef partitions(n, I=1):\n    yield (n, [n])\n    for i in range(n//2, I-1, -1):\n        for x,p in partitions(n-i, i):\n            yield (x*i, p+[i])\n\ndef find_part_max_prod(n):\n    result = defaultdict(list)\n    for x,p in partitions(n):\n        result[x].append(p)\n    k, v = max(result.items())\n    return [*v, k]", "def partitions(n, s=float('inf')):\n    if not n: yield []; return\n    for i in range(min(n, s), 0, -1):\n        for p in partitions(n - i, i):\n            yield [i] + p\n\nfrom collections import defaultdict\nfrom functools import reduce\nfrom operator import mul\ndef find_part_max_prod(n):\n    products = defaultdict(list)\n    for p in partitions(n):\n        products[reduce(mul, p)].append(p)\n    m = max(products)\n    return products[m] + [m]", "from functools import reduce\ndef find_part_max_prod(n):\n    partitions = []\n    for k in range(1,n+1):\n        part = [n//k+1]*(n%k)+[n//k]*(k-n%k)\n        partitions.append([reduce(int.__mul__, part), part])\n    m = max(partitions)[0]\n    return [j for i,j in partitions if i==m] + [m]", "def find_part_max_prod(n):\n    if n % 3 == 0:\n        return [[3]*(n/3),3**(n/3)]\n    if n % 3 == 2:\n        return [[3]*(n//3)+[2],3**(n//3)*2]\n    if n == 1:\n        return 1\n    if n % 3 == 1:\n        return [[4]+[3]*(n//3-1),[3]*(n//3-1)+[2,2],3**(n//3-1)*4]", "def find_part_max_prod(n):\n    if(n==2):\n        return [[1, 1], 1]\n    if(n==3):\n        return [[2, 1], 1]\n    if(n%3==0):\n        return [[3]*(n//3), pow(3, n//3)]\n    if(n%3==2):\n        return  [[3]*((n-2)//3) + [2] , 2 * pow(3, (n-2)//3)]\n    if(n%3==1):\n        return [[4] + [3]*((n-4)//3), [3]*((n-4)//3) + [2, 2], 4 * pow(3, (n-4)//3)]", "def find_part_max_prod(n):\n    if n % 3 == 0:\n        Q = n//3\n        return [[3]*Q, 3**Q]\n    elif (n - 1) % 3== 0:\n        Q = (n-1)//3 - 1\n        return [[4]+[3]*Q,[3]*Q+[2,2], 4*3**Q]\n    elif (n - 2) % 3 == 0:\n        Q = (n-2)//3\n        return [[3]*Q+[2], 2*3**Q]"]