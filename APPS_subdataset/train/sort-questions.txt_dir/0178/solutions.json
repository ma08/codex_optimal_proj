["class Solution:\n     def lengthOfLIS(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         if len(nums) == 0:\n             return 0\n         res = [nums[0]]\n         def binarySearch(l,target):\n             left , right = 0 , len(l)-1\n             while left < right:\n                 mid = (left + right)//2\n                 if l[mid] >= target:\n                     right = mid\n                 else:\n                     left = mid + 1\n             return left\n         for i in range(1,len(nums)):\n             if nums[i] > res[-1]:\n                 res.append(nums[i])\n             else:\n                 res[binarySearch(res,nums[i])] = nums[i]\n         return len(res)\n", "class Solution:\n     def lengthOfLIS(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         \n         if not nums:\n             return 0\n         \n         c = [nums[0]]\n         \n         for i in range(1,len(nums)):\n             if nums[i]<=c[0]:\n                 c[0] = nums[i] \n                 continue\n             \n             if nums[i]>c[-1]:\n                 c.append(nums[i]) \n                 continue\n             \n             l = 0\n             h = len(c)-1\n             \n             while l+1!=h:\n                 m = (l+h)>>1\n                 if nums[i]>c[m]:\n                     l = m\n                 else:\n                     h = m\n             c[h] = nums[i]\n             \n   \n         \n         return len(c)", "class Solution:\n     def lengthOfLIS(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         tails = [0] * len(nums)\n         size = 0\n         for num in nums:\n             i, j = 0, size\n             while i != j:\n                 m = i + (j - i) // 2\n                 if tails[m] < num:\n                     i = m + 1\n                 else:\n                     j = m\n             tails[i] = num\n             size = max(i+1, size)\n         return size", "class Solution:\n     def lengthOfLIS(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         tails = [0 for i in range(len(nums))]\n         size = 0\n         for x in nums:\n             i, j = 0, size\n             while i != j:\n                 m = (i+j)//2\n                 if tails[m] < x:\n                     i = m+1\n                 else: \n                     j = m\n             tails[i] = x\n             size = max(i+1, size)\n         return size\n", "class Solution:\n     def lengthOfLIS(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         if not nums:\n             return 0\n         tails = [0]*(len(nums))\n         size=0\n         for num in nums:\n             i=0\n             j=size\n             while i!=j:\n                 mid = (i+j)//2\n                 if tails[mid]<num:\n                     i = mid+1\n                 else:\n                     j = mid\n             tails[j]=num\n             size=max(i+1,size)\n         return size\n                     \n             \n", "class Solution:\n     def lengthOfLIS(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         n = len(nums)\n         dp = [float('inf')] * (n + 1)\n         res = 0\n         \n         for num in nums:\n             # like finding inerstion position             \n             lo, hi = 1, n\n             while lo < hi:\n                 mi = int((lo + hi) / 2)\n                 if dp[mi] < num:\n                     lo = mi + 1\n                 else:\n                     hi = mi\n             dp[lo] = num\n             res = max(res, lo)\n         return res\n", "class Solution:\n     def lengthOfLIS(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         tails = []\n         size = 0\n         def search_tails(tails, n):\n             if len(tails) == 0:\n                 return 0\n             l, r = 0, len(tails)\n             while l < r:\n                 m = (l+r)//2\n                 if tails[m] < n:\n                     l = m + 1\n                 else:\n                     r = m\n             return l\n             \n         for n in nums:\n             i = search_tails(tails, n)\n             if i == len(tails):\n                 tails.append(n)\n             else:\n                 tails[i] = n\n         return len(tails)\n", "class Solution:\n     def lengthOfLIS(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         tails = [0] * len(nums)\n         size = 0\n         for x in nums:\n             i, j = 0, size\n             while i != j:\n                 m = (i + j) // 2\n                 if tails[m] < x:\n                     i = m + 1\n                 else:\n                     j = m\n             tails[i] = x\n             size = max(i + 1, size)\n         return size       ", "class Solution:\n     def lengthOfLIS(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         maxLen = 0\n         dp = []\n         for i in nums:\n             if not dp:\n                 dp.append(i)\n             pos = self.search(i, dp)\n             if pos==len(dp): dp.append(i)\n             else: dp[pos] = i\n             maxLen = max(maxLen, len(dp))\n         return maxLen\n     \n     def search(self, curr, nums):\n         start = 0\n         end = len(nums)-1\n         if curr > nums[-1]: return len(nums)\n         while end >= start:\n             mid = int(start + (end-start)/2)\n             if curr < nums[mid]:\n                 end = mid-1\n             elif curr > nums[mid]:\n                 start = mid+1\n             else:\n                 return mid\n         return start", "class Solution:\n     def lengthOfLIS(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         tails = [0] * len(nums)\n         size = 0\n         \n         for x in nums:\n             i = 0\n             j = size\n             index_to_insert = i\n             while i < j:\n                 mid = i + (j - i) // 2\n                 if tails[mid] < x:\n                     i = mid + 1\n                 else:\n                     j = mid\n             \n             tails[i] = x\n             size = max(size, i + 1)\n         \n         return size\n     \n", "class Solution:\n     def lengthOfLIS(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         n = len(nums)\n         if n <= 1: return n\n         \n         tails = [nums[0]]\n         for i in range(1, n):\n             x = nums[i]\n             l, r = 0, len(tails)-1\n             while(l < r):\n                 mid = (l + r) // 2\n                 if tails[mid] >= x:\n                     r = mid\n                 else:\n                     l = mid + 1\n             if tails[l] < x:\n                 tails.append(x)\n             else:\n                 tails[l] = x\n         return len(tails)", "class Solution:\n     def lengthOfLIS(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         n = len(nums)\n         if n <= 1: return n\n         \n         tails = [nums[0]]\n         for i in range(1, n):\n             l, r = 0, len(tails)-1\n             while(l < r):\n                 mid = (l + r) // 2\n                 if tails[mid] >= nums[i]:\n                     r = mid\n                 else:\n                     l = mid + 1\n             if tails[l] < nums[i]:\n                 tails.append(nums[i])\n             else:\n                 tails[l] = nums[i]\n         return len(tails)", "class Solution:\n     def lengthOfLIS(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         import bisect\n         \n         d = [0] * len(nums)\n         \n         maxLen = 0\n         \n         for n in nums:\n           i = bisect.bisect_left(d, n, 0, maxLen)\n           if i == maxLen:\n             maxLen += 1\n           d[i] = n\n         return maxLen", "class Solution:\n     def lengthOfLIS(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         if nums == []:\n             return 0\n         dp = []\n         for i, num in enumerate(nums):\n             if i == 0 or num > dp[-1]:\n                 dp.append(num)\n             elif num < dp[0]:\n                 dp[0] = num\n             else:\n                 low, high = 0, len(dp) - 1\n                 while(low < high):\n                     mid = (low + high)//2\n                     mid_num = dp[mid]\n                     if num > mid_num:\n                         low = mid + 1\n                     else:\n                         high = mid\n                 dp[low] = num\n         return len(dp)\n", "class Solution:\n     def lengthOfLIS(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         lenLastIdx = [-1]\n         for i in range(len(nums)):\n             currLen = self.findLen(nums, lenLastIdx, nums[i])\n             if len(lenLastIdx) == currLen:\n                 lenLastIdx.append(0)\n             lenLastIdx[currLen] = i\n         return len(lenLastIdx) - 1\n     \n     def findLen(self, nums, lenLastIdx, val):\n         p = 1\n         q = len(lenLastIdx)\n         while p < q:\n             mid = p + (q - p) // 2\n             if nums[lenLastIdx[mid]] >= val:\n                 q = mid\n             else:\n                 p = mid + 1\n         return p\n             \n         \n"]