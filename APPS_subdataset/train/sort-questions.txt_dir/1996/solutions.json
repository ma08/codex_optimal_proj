["class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        \\\"\\\"\\\"\n        Just move along unvisited (-1) nodes and remark them as 0 on the queue while visiting others on the path and finish them as 1. If you meet them again on the queue while visiting (being 0) it means you completed a cycle, in other words it is not safe and return back without adding.\n        \\\"\\\"\\\"\n        visited, result = [-1] * len(graph), []\n        \n        def explore(i):\n            visited[i] = 0\n            for v in graph[i]:\n                if visited[v] == 0 or (visited[v]==-1 and explore(v)): return True\n            visited[i] = 1\n            result.append(i)\n            return False\n        \n        for i in range(len(graph)):\n            if visited[i] == -1: explore(i)\n\n        return sorted(result)\n            ", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        \n        N = len(graph)\n        if N == 0:\n            return []\n        \n        color = [0] * N\n        in_cycle = set()\n        \n        def dfs(i):\n            if color[i] != 0:\n                return color[i] == 2\n            \n            color[i] = 1\n            for j in graph[i]:\n                if color[j] == 2:\n                    continue\n                elif color[j] == 1 or (dfs(j) == False):\n                    return False\n            color[i] = 2\n            return True\n        \n        ret = []\n        for i in range(N):\n            if dfs(i):\n                ret.append(i)\n        return ret\n        \n", "class Solution:\n    def dfs(self, node, v, g):\n        if v[node]==2:\n            return False\n        if v[node]==1:\n            return True\n        if len(g[node])==0:\n            v[node]=2\n            return False\n        v[node]=1\n        for i in g[node]:\n            if self.dfs(i, v, g):\n                return True\n        v[node]=2\n        return False\n    \n    \n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        if len(graph)==0:\n            return []\n        g = {}\n        v = [0]*len(graph)\n        ans = set()\n        \n        for i in range(len(graph)):\n            if not self.dfs(i, v, graph):\n                ans.add(i)\n        ans = list(ans)\n        ans.sort()\n        return ans", "from collections import defaultdict\nclass Solution:\n    def eventualSafeNodes(self, graph):\n        state = defaultdict(lambda: 'unknown')\n        \n        def dfs(node):\n            if state[node] != 'unknown':\n                return state[node] == 'safe'\n            state[node] = 'visiting'\n            for nei in graph[node]:\n                if state[nei] == 'visiting' or not dfs(nei):\n                    return False\n            state[node] = 'safe'\n            return True\n        N = len(graph)\n        return [node for node in range(N) if dfs(node)]", "import collections\nclass Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        Terminal = []\n        dict_raw = dict()\n        dict_idx = collections.defaultdict(list)\n        for i, ele in enumerate(graph):\n            dict_raw[i] = set(ele)\n            if ele==[]: # Terminal\n                Terminal.append(i)\n            else:\n                for idx in ele:\n                    dict_idx[idx].append(i) # dict_idx[idx]: what nodes going into node idx\n        # Then start from Terminal and do backsearch\n        stack = Terminal\n        safe = set(Terminal)\n        \n        while stack:\n            node = stack.pop()\n            for ele_1 in dict_idx[node]:\n                if dict_raw[ele_1].issubset(safe) and ele_1 not in safe: # the 1-step previous node will go to all safe nodes, thus safe\n                    safe.add(ele_1)\n                    stack.append(ele_1)\n        res = list(safe)\n        return sorted(res)\n                \n            \n", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        def cycle(snode):\n            if mem[snode] == -1:\n                return True\n            elif mem[snode] == 1:\n                return False\n\n            mem[snode] = -1\n            for e in graph[snode]:\n                res = cycle(e)\n                if res:\n                    return True\n            mem[snode] = 1\n            return False\n\n        n = len(graph)\n        ret = []\n        mem = [0] * n\n        for i in range(n):\n            if not cycle(i):\n                ret.append(i)\n        return ret\n", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        # first find all the nodes that does not have out degree\n        if not graph: return None\n        n = len(graph)\n        out_degree, rgraph = collections.Counter(), collections.defaultdict(set)\n        for node, neighbors in enumerate(graph): \n            for nei in neighbors: \n                out_degree[node] += 1\n                rgraph[nei].add(node)\n                \n        q = collections.deque([x for x in range(n) if out_degree[x] == 0])\n        ans = []\n        while q: \n            node = q.popleft()\n            ans.append(node)\n            for nei in rgraph[node]: \n                if out_degree[nei] == 0: \n                    continue\n                out_degree[nei] -= 1\n                if out_degree[nei] == 0: \n                    q.append(nei)\n        ans.sort()\n        return ans\n            \n        \n        \n        \n", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        if not graph:\n            return []\n        n = len(graph)\n        adj = collections.defaultdict(set)\n        for i in range(n):\n            for j in graph[i]:\n                adj[j].add(i)\n        res = [i for i in range(n) if not graph[i]]\n        outdegree = [len(graph[i]) for i in range(n)]\n        Q = collections.deque(res)\n        while Q:\n            cur = Q.popleft()\n            for i in adj[cur]:\n                outdegree[i] -= 1\n                if outdegree[i] == 0:\n                    res.append(i)\n                    Q.append(i)\n        return sorted(res)\n        \n", "class Solution:\n  def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n    n = len(graph)\n    state = [-1] * n # -1 = unvisited, 0 = involved in directed cycle, 1 = eventually safe\n    \n    def dfs(node):\n      state[node] = 0 # may be involved in a cycle\n      for adj in graph[node]:\n        if state[adj] == 0 or (state[adj] == -1 and dfs(adj)):\n          return True\n      state[node] = 1\n    \n    for i in range(n):\n      if state[i] == -1:\n        dfs(i)\n    \n    return [i for i in range(n) if state[i] == 1]\n    \n", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        outdegree = collections.defaultdict(int)\n        dic = collections.defaultdict(list)\n        queue = collections.deque()\n        visited, res = set(), []\n        for i in range(len(graph)):\n            outdegree[i] += len(graph[i])\n            if not graph[i]: \n                queue.append(i)\n                visited.add(i)\n            for node in graph[i]:\n                dic[node].append(i)\n        \n        while queue:\n            node = queue.popleft()\n            res.append(node)\n            for nbr in dic[node]:\n                outdegree[nbr] -= 1\n                if nbr not in visited and outdegree[nbr] == 0:\n                    queue.append(nbr)\n                    visited.add(nbr)\n\n        return(sorted(res))\n        \n\n            \n                    \n\n", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n#         g = collections.defaultdict(list)\n#         N = len(graph)\n        \n#         for i, end in enumerate(graph):\n#             for x in end:\n#                 g[i].append(x)\n            \n#         def dfs(node, cycle):\n#             if(not g[node]):\n#                 return True\n            \n#             c = False\n#             for nei in g[node]:\n#                 if(nei not in cycle):\n#                     cycle.add(nei)\n#                     if(not dfs(nei, cycle)):\n#                         c = True\n#                         break\n#                     cycle.remove(nei)\n#                 else:\n#                     c = True\n#                     break\n#             if(not c):\n#                 return True\n#             else:\n#                 return False\n    \n#         res = []\n#         for i in range(N):\n#             cycle = set()\n#             cycle.add(i)\n#             if(dfs(i, cycle)):\n#                 res.append(i)\n#         return res\n\n#         W, G, B = 0, 1, 2\n#         color = collections.defaultdict(int)\n        \n#         def dfs(node):\n#             if(color[node] != W):\n#                 return color[node] == B\n            \n#             color[node] = G\n#             for nei in graph[node]:\n#                 if(color[nei] == B):\n#                     continue\n#                 if(color[nei] == G or not dfs(nei)):\n#                     return False\n#             color[node] = B\n#             return True\n        \n#         res = []\n#         for i in range(len(graph)):\n#             if(dfs(i)):\n#                 res.append(i)\n#         return res\n\n        N = len(graph)\n    \n        # graph = map(set, graph)\n        re = [set() for _ in range(N)]\n        q = collections.deque([])\n        \n        for i, v in enumerate(graph):\n            if(not v):\n                q.append(i)\n            for j in v:\n                re[j].add(i)\n        \n        res = []\n        while(q):\n            temp = q.popleft()\n            res.append(temp)\n            for renei in re[temp]:\n                graph[renei].remove(temp)\n                if(len(graph[renei]) == 0):\n                    q.append(renei)\n        \n        return sorted(res)\n", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        # first find all the nodes that does not have out degree\n        if not graph: return None\n        n = len(graph)\n        out_degree, rgraph = collections.Counter(), collections.defaultdict(set)\n        for node, neighbors in enumerate(graph): \n            for nei in neighbors: \n                out_degree[node] += 1\n                rgraph[nei].add(node)\n                \n        q = collections.deque([x for x in range(n) if out_degree[x] == 0])\n        ans = []\n        while q: \n            node = q.popleft()\n            ans.append(node)\n            for nei in rgraph[node]: \n                if out_degree[nei] != 0: \n                    out_degree[nei] -= 1\n                    if out_degree[nei] == 0: \n                        q.append(nei)\n        ans.sort()\n        return ans\n            \n        \n        \n        \n", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        ans = []\n        if len(graph) == 0:\n            return ans\n        status = [0 for _ in range(len(graph))]\n        for i in range(len(graph)):\n            if status[i] == 0:\n                self.dfs(i, graph, status, ans)\n        ans.sort();\n        return ans\n                \n    \n    def dfs(self, i, graph, status, ans):\n        status[i] = 1\n        for neighbor in graph[i]:\n            if status[neighbor] == 1:\n                return False\n            if status[neighbor] == 0 and not self.dfs(neighbor, graph, status, ans):\n                return False\n        \n        status[i] = 2\n        ans.append(i)\n        return True", "from collections import defaultdict\nclass Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        \n        g = defaultdict(list)\n        for i in range(len(graph)):\n            g[i] = graph[i]\n            \n        array = [False]*len(graph)\n        visited = [False]*len(graph)\n        \n        for i in range(len(graph)):\n            if visited[i]==False:\n                self.dfs(i,graph,visited,array)\n                \n        ans = []\n        for i in range(len(array)):\n            if array[i]==True:\n                ans.append(i)\n        return ans\n        \n        \n    def dfs(self,node,graph,visited,array):\n        \n        visited[node] = True\n        if len(graph[node])==0:\n            array[node]=True\n        \n        else:\n            b = True\n            for ver in graph[node]:\n                if visited[ver] ==False:\n                    self.dfs(ver,graph,visited,array)\n                b = b&array[ver]\n            array[node] = b\n            \n", "from collections import defaultdict\nclass Solution:\n    def eventualSafeNodes(self, graph):\n        state = defaultdict(int)\n        \n        def dfs(node):\n            if state[node]:\n                return state[node] == 2\n            state[node] = 1\n            for nei in graph[node]:\n                if state[nei] == 1 or not dfs(nei):\n                    return False\n            state[node] = 2\n            return True\n        N = len(graph)\n        return [node for node in range(N) if dfs(node)]", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        visited = [False for i in range(len(graph))]\n        recStack = [False for i in range(len(graph))]\n        def dfs(node):\n            visited[node] = True\n            recStack[node] = True\n            for nbor in graph[node]:\n                if not visited[nbor]:\n                    if dfs(nbor): \n                        return True\n                elif recStack[nbor]: \n                    return True\n            \n            recStack[node] = False\n            return False\n        \n        res = []\n        for vert in range(len(graph)):\n            if not dfs(vert):\n                res.append(vert)\n        res.sort()\n        return res", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        n = len(graph)\n        adj = {}\n        for i in range(n):\n            adj[i] = set(graph[i])\n        \n        safe = set() \n        for i in range(n):\n            if not adj[i]:\n                safe.add(i)\n        \n        prev_size = len(safe)\n        while True:\n            for i in range(n):\n                if i in safe:\n                    continue\n                for x in adj[i]:\n                    if x not in safe:\n                        break\n                else:\n                    safe.add(i)\n            if len(safe) == prev_size:\n                break\n            else:\n                prev_size = len(safe)\n              \n        out = []\n        for i in range(n):\n            if i in safe:\n                out.append(i)\n        return out", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        nodes = set()\n        for i in range(len(graph)):\n            if len(graph[i]) == 0:\n                nodes.add(i)\n        \n        stop = False\n        while not stop:\n            tmp = set()\n            for i in range(len(graph)):\n                if i not in nodes:\n                    add = True\n                    for dest in graph[i]:\n                        if dest not in nodes:\n                            add = False\n                            break\n                    if add:\n                        tmp.add(i)\n            if len(tmp) == 0:\n                stop = True\n            nodes = nodes.union(tmp)\n            # print(nodes)\n            \n        return sorted(nodes)\n            \n", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n#         g = collections.defaultdict(list)\n#         N = len(graph)\n        \n#         for i, end in enumerate(graph):\n#             for x in end:\n#                 g[i].append(x)\n            \n#         def dfs(node, cycle):\n#             if(not g[node]):\n#                 return True\n            \n#             c = False\n#             for nei in g[node]:\n#                 if(nei not in cycle):\n#                     cycle.add(nei)\n#                     if(not dfs(nei, cycle)):\n#                         c = True\n#                         break\n#                     cycle.remove(nei)\n#                 else:\n#                     c = True\n#                     break\n#             if(not c):\n#                 return True\n#             else:\n#                 return False\n    \n#         res = []\n#         for i in range(N):\n#             cycle = set()\n#             cycle.add(i)\n#             if(dfs(i, cycle)):\n#                 res.append(i)\n#         return res\n\n        W, G, B = 0, 1, 2\n        color = collections.defaultdict(int)\n        \n        def dfs(node):\n            if(color[node] != W):\n                return color[node] == B\n            \n            color[node] = G\n            for nei in graph[node]:\n                if(color[nei] == B):\n                    continue\n                if(color[nei] == G or not dfs(nei)):\n                    return False\n            color[node] = B\n            return True\n        \n        res = []\n        for i in range(len(graph)):\n            if(dfs(i)):\n                res.append(i)\n        return res", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        # Start at 10:19 PM\n        # Need to do DFS, reduce computation if already visited the node\n        visited = set()\n        \n        states = [None]*len(graph)\n        \n        def verify(i):\n            if states[i] is not None:\n                return states[i]\n            \n            # Cyclical relation detected\n            if i in visited:\n                return False\n            visited.add(i)\n            \n            for j in graph[i]:\n                stable = verify(j)\n                \n                if j in visited:\n                    visited.remove(j)\n                \n                states[j] = stable\n                \n                if not stable:\n                    return False\n            return True\n\n        verified_unstable = set()\n        \n        for i in range(len(graph)):\n            if states[i] is not None:\n                continue\n            states[i] = verify(i)\n        \n        return [i for i, val in enumerate(states) if val == True]\n                \n", "#Cycle detection alg: s f pointers are only for lists and linkedlists. WGB DFS is for graph.\nclass Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        color = [0]*(len(graph)) #0 white, 1 grey, 2 black\n        \n        #True: black or safe    False: grey or unsafe\n        def df(v):\n            if color[v]==2:\n                return True\n            if color[v]==1:\n                return False \n            \n            color[v] = 1 #set it to grey while traversing\n            for v2 in graph[v]:\n                if color[v2]==1 or color[v2]==0 and not df(v2):\n                    return False       \n            color[v] = 2 #set it to black after traversing if safe\n            \n            return True\n        \n        safe = []\n        for v in range(len(graph)):\n            if df(v):\n                safe.append(v)\n        \n        return safe\n        \n", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        g=defaultdict(list)\n        result=[]\n        outDegre=[0]*len(graph)\n        for i in range(len(graph)):\n            outDegre[i]=len(graph[i])\n            if not outDegre[i]:\n                result.append(i)\n            for j in graph[i]:\n             g[j].append(i)\n        print(outDegre)\n        for nodes in result:\n            for nei in g[nodes]:\n                outDegre[nei]=outDegre[nei] -1 \n                if outDegre[nei]==0:\n                    result.append(nei)\n        print(g)\n        print(outDegre)\n        return sorted(result)\n", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        outdegree = collections.defaultdict(int)\n        dic = collections.defaultdict(list)\n        queue = collections.deque()\n        visited, res = set(), []\n        for i in range(len(graph)):\n            outdegree[i] += len(graph[i])\n            if not graph[i]: \n                queue.append(i)\n                visited.add(i)\n            for node in graph[i]:\n                dic[node].append(i)\n                \n        # print(indegree)\n        # print(outdegree)\n        # print(dic)\n        # print(queue)\n        # print('*********')\n        \n        while queue:\n            node = queue.popleft()\n            res.append(node)\n            for nbr in dic[node]:\n                outdegree[nbr] -= 1\n                if nbr not in visited and outdegree[nbr] == 0:\n                    queue.append(nbr)\n                    visited.add(nbr)\n            # print(queue)\n        return(sorted(res))\n        \n\n            \n                    \n\n", "class Solution(object):\n    def eventualSafeNodes(self, graph):\n        WHITE, GRAY, BLACK = 0, 1, 2\n        color = collections.defaultdict(int)\n\n        def dfs(node):\n            if color[node] != WHITE:\n                return color[node] == BLACK\n\n            color[node] = GRAY\n            for nei in graph[node]:\n                if color[nei] == BLACK:\n                    continue\n                if color[nei] == GRAY or not dfs(nei):\n                    return False\n            color[node] = BLACK\n            return True\n\n        return filter(dfs, range(len(graph)))", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        \n        def dfs(graph, node):\n            if not graph[node]:\n                return True\n            if node not in self.dp:\n                self.dp[node] = -1\n                res = True\n                for nex in graph[node]:\n                    res = res and dfs(graph, nex)\n                self.dp[node] = res\n            else:\n                if self.dp[node] == -1:\n                    return False\n            return self.dp[node]\n        \n        self.dp = {}\n        res = []\n        for i in range(len(graph)):\n            if dfs(graph, i):\n                res.append(i)\n        return res\n", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        visited = {}\n        departures = [-1] * len(graph)\n        res = []\n        def _dfs(node):\n            visited[node] = 1\n            neighbors = graph[node]\n        \n            for neighbor in neighbors:\n                if neighbor not in visited:\n                    if _dfs(neighbor):\n                        return True \n                else:\n                    if departures[neighbor] == -1:\n                        return True\n                    \n            departures[node] = 1\n            return False\n        \n        \n        for i in range(0, len(graph)):\n            if not _dfs(i):\n                res.append(i)\n        return res", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        n = len(graph)\n        adj = {}\n        for i in range(n):\n            adj[i] = set(graph[i])\n        \n        safe = set() \n        for i in range(n):\n            if not adj[i]:\n                safe.add(i)\n        \n        prev_size = len(safe)\n        while True:\n            for i in range(n):\n                if i in safe:\n                    continue\n                for x in adj[i]:\n                    if x not in safe:\n                        break\n                else:\n                    safe.add(i)\n            if len(safe) == prev_size:\n                break\n            else:\n                prev_size = len(safe)\n              \n        \n        out = list(safe)\n        out.sort()\n        return out\n        \n", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        res = set()\n        for i in range(len(graph)):\n            visited = set([i])\n            self.dfs(graph, i, visited, res)\n        \n        return sorted(list(res))\n    \n    # dfs is to check if there's a cycle starting from this point\n    def dfs(self, graph, i, visited, res):\n        for j in graph[i]:\n            if j in visited:\n                return False\n            # This step is not necessary for the correctness of the result, but saves time\n            if j in res:\n                continue\n            visited.add(j)\n            # Now we go on to the next step and see if there's a cycle\n            if not self.dfs(graph, j, visited, res):\n                return False\n            visited.remove(j)\n        \n        res.add(i)\n        return True\n            \n", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        res = set()\n        for i in range(len(graph)):\n            visited = set([i])\n            self.dfs(graph, i, visited, res)\n        \n        return sorted(list(res))\n    \n    # dfs is to check if there's a cycle starting from this point\n    def dfs(self, graph, i, visited, res):\n        for j in graph[i]:\n            if j in visited:\n                return False\n            if j in res:\n                continue\n            visited.add(j)\n            # Now we go on to the next step and see if there's a cycle\n            if not self.dfs(graph, j, visited, res):\n                return False\n            visited.remove(j)\n        \n        res.add(i)\n        return True\n            \n", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        res = set()\n        for i in range(len(graph)):\n            visited = set()\n            self.dfs(graph, i, visited, res)\n        \n        return sorted(list(res))\n    \n    # dfs is to check if there's a cycle starting from this point\n    def dfs(self, graph, i, visited, res):\n        visited.add(i)\n        for j in graph[i]:\n            if j in visited:\n                return False\n            if j in res:\n                continue\n            if not self.dfs(graph, j, visited, res):\n                return False\n        visited.remove(i)\n        res.add(i)\n        return True\n\n            \n", "from typing import Dict, List, Set\n\n\nclass Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        result = []\n        graph_map: Dict[int, Set[int]] = {}\n        reverse_graph_map: Dict[int, Set[int]] = {}\n        for i, edges in enumerate(graph):\n            graph_map[i] = set(edges)\n            for n in edges:\n                reverse_graph_map.setdefault(n, set())\n                reverse_graph_map[n].add(i)\n\n        while True:\n            to_remove = set()\n            for i, edges in list(graph_map.items()):\n                if len(edges) == 0:\n                    to_remove.add(i)\n            if len(to_remove) == 0:\n                break\n\n            result.extend(to_remove)\n\n            for i in to_remove:\n                del graph_map[i]\n                for n in reverse_graph_map.get(i, set()):\n                    graph_map[n].remove(i)\n\n        return sorted(result)\n", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        flags = [0] * len(graph)\n        \n        def dfs(node, visited):\n            visited.add(node)\n            for neighbor in graph[node]:\n                if flags[neighbor] == 1:\n                    continue\n                if flags[neighbor] == -1:\n                    return False\n                if neighbor in visited or not dfs(neighbor, visited.copy()):\n                    flags[neighbor] = -1\n                    return False\n            flags[node] = 1\n            return True\n        \n        visited = set()\n        for i in range(len(graph)):\n            if not flags[i]:\n                dfs(i, visited)\n        return [i for i, flag in enumerate(flags) if flag==1]", "class Solution:\n    \n    def isCycle(self, src, graph: List[List[int]], visited):\n        \n        \n        \n        WHITE, GRAY, BLACK = 0, 1, 2\n        \n        if visited[src] != WHITE:\n            return visited[src] == GRAY \n        \n        stack = []\n    \n        stack.append((src,1))\n        stack.append((src,0))\n        \n        while stack:\n            # print(stack)\n            # print(visitedNodes)\n            current = stack.pop()\n            if current[1] == 1:\n                visited[current[0]] = BLACK\n                continue\n            current = current[0]\n            visited[current] = GRAY\n            \n            \n            for e in graph[current]:\n                \n                # if not visited[e]:\n                if visited[e] == GRAY:\n                    # print('here', e)\n                    return True\n                    \n                if visited[e] == WHITE:\n                    stack.append((e, 1))  \n                    stack.append((e, 0))  \n            \n        return False\n    \n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        eventualSafe = []\n        visited = [0] * len(graph)\n        for i in range(len(graph)):\n            # print('Node :', i)\n            if not self.isCycle(i, graph, visited):\n                # print('Found you')\n                eventualSafe.append(i)\n        \n        \n        return eventualSafe\n    \n    \n            \n            \n        \n        \n", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        # no out/ all out are safe state\n        degree = [len(row) for row in graph]\n        children = collections.defaultdict(list)\n        \n        for i,row in enumerate(graph):\n            for j in row:\n                children[j].append(i)\n                \n                \n        seen = set()\n        bfs = [i for i in range(len(degree)) if degree[i]==0]\n        for val in bfs:\n            if val in seen:\n                continue\n            seen.add(val)\n            for child in children[val]:\n                degree[child]-=1\n                if not degree[child]:\n                    bfs.append(child)\n        return sorted(list(seen))", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        def explore(i):\n            visited[i] = 0\n            for v in graph[i]:\n                if visited[v] == 0 or (visited[v] == -1 and explore(v)): return True\n            visited[i] = 1\n            res.append(i)\n            return False\n        visited, res = [-1] * len(graph), []\n        for i in range(len(graph)):\n            if visited[i] == -1: explore(i)\n        return sorted(res)\n        \n", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        safe_nodes = set()\n        \n        for i, node in enumerate(graph):\n            if len(node) == 0:\n                safe_nodes.add(i)\n        \n        while True:\n            starting_len = len(safe_nodes)\n            for i, node in enumerate(graph):\n                all_safe = True\n                for j in node:\n                    if j not in safe_nodes:\n                        all_safe = False\n                        break\n                if all_safe:\n                    safe_nodes.add(i)\n            if starting_len == len(safe_nodes):\n                break\n        \n        return sorted(list(safe_nodes))", "class Solution:\n    \n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        \n        out_degree = collections.defaultdict(int)\n        inward_nodes = collections.defaultdict(list)   # recording the nodes going into the 'key' node\n        \n        for src in range(len(graph)):\n            for child in graph[src]:\n                inward_nodes[child].append(src)\n                out_degree[src] += 1\n        \n        q = collections.deque()\n        for i in range(len(graph)):\n            if not i in out_degree:\n                q.append(i)\n        \n        result = []\n        while q:\n            top = q.popleft()\n            result.append(top)\n            for parent in inward_nodes[top]:\n                out_degree[parent] -= 1\n                if out_degree[parent] == 0:\n                    q.append(parent)\n        return sorted(result)", "#Cycle detection alg: s f pointers are only for lists and linkedlists. WGB DFS is for graph.\nclass Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        color = [0]*(len(graph)) #0 white, 1 grey, 2 black\n        \n        def df(v):\n            if color[v]==2:\n                return True\n            \n            color[v] = 1 #set it to grey while traversing\n            for v2 in graph[v]:\n                if color[v2]==1 or color[v2]==0 and not df(v2):\n                    return False       \n            color[v] = 2 #set it to black after traversing if safe\n            \n            return True\n        \n        safe = []\n        for v in range(len(graph)):\n            if df(v):\n                safe.append(v)\n        \n        return safe\n        \n", "#Cycle detection alg: s f pointers are only for lists and linkedlists. WGB DFS is for graph.\nclass Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        color = [0]*(len(graph)) #0 white, 1 grey, 2 black\n        \n        def df(v):\n            if color[v]==2:\n                return True\n            if color[v]==1: #Grey nodes will stay grey if cycle found. THis is for when doing WGB DFS for every node.\n                return False \n            \n            color[v] = 1 #set it to grey while traversing\n            for v2 in graph[v]:\n                if color[v2]==1 or color[v2]==0 and not df(v2):\n                    return False       \n            color[v] = 2 #set it to black after traversing if safe\n            \n            return True\n        \n        safe = []\n        for v in range(len(graph)):\n            if df(v):\n                safe.append(v)\n        \n        return safe\n        \n", "class Solution:\\r\n    def eventualSafeNodes(self, graph):\\r\n        def dfs(i):\\r\n            # return false if cyclic\\r\n            colors[i] = 1  # checking, set color to \\\"gray\\\"\\r\n            # scan all the neighbor\\r\n            for v in graph[i]:\\r\n                if colors[v] == 1:\\r\n                    # cycle detected\\r\n                    return False\\r\n                if colors[v] == 0 and dfs(v) == False:\\r\n                    return False\\r\n            res.append(i)\\r\n            colors[i] = 2\\r\n            return True\\r\n\\r\n        colors = [0] * len(graph)\\r\n        res = []\\r\n\\r\n        for i, neighbors in enumerate(graph):\\r\n            if not colors[i]:\\r\n                dfs(i)\\r\n\\r\n        return sorted(res)\\r\n\\r\n", "class Solution:\n    data = {}\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        result = []\n        # print(result, self.data)\n        self.data = {}\n        for i in range(len(graph)):\n            if i in self.data:\n                if self.data[i]:\n                    result.append(i)\n            else:\n                res = self.check(graph, i, [])\n                if res == True:\n                    result.append(i)\n                    self.data[i] = True\n                    \n        return result\n        \n    def check(self, graph, curr, path):\n        if curr in path:\n            self.data[curr] = False\n            for p in path:\n                self.data[p] = False\n            return False\n\n        if len(graph[curr]) == 0:\n            self.data[curr] = True\n            return True\n        \n        result = True\n        for n in graph[curr]:\n            if n == curr:\n                self.data[n] = False\n                return False\n            \n            if n in self.data:\n                result = result and self.data[n]\n            else:\n                res = self.check(graph, n, path + [curr])\n                result = result and res\n            if result == False:\n                return False\n\n        if result == True:\n            self.data[curr] = True\n\n        return True\n", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        # list of node out degrees\n        n = len(graph)\n        out_degrees = [0] * n\n        # list of nodes that point to this node\n        node_lsts = collections.defaultdict(list)\n        queue = []\n        # instantiate empty lists of nodes to point, outdegrees\n        for i in range(len(graph)):\n            out_degrees[i] = len(graph[i])\n            if out_degrees[i] == 0: queue.append(i)\n            for j in graph[i]: node_lsts[j].append(i)\n        # loop through deleting stuff from queue\n        for term_node in queue:\n            for n in node_lsts[term_node]:\n                out_degrees[n] -= 1\n                if out_degrees[n] == 0:\n                    queue.append(n)\n        return sorted(queue)", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        n = len(graph)\n        state = ['UNPROCESSED'] * n\n        def isAcyclic(node):\n            if state[node] == 'PROCESSING':\n                return False\n            elif state[node] == 'PROCESSED':\n                return True\n            else:\n                state[node] = 'PROCESSING'\n                if any(not isAcyclic(nei) for nei in graph[node]):\n                    return False\n                state[node] = 'PROCESSED'\n                return True\n        return list(filter(isAcyclic, list(range(n))))", "\\\"\\\"\\\"\n0 - unvisited\n1 - currently visiting in the current DFS traversal\n2 - already visited\n\\\"\\\"\\\"\nWHITE = 0\nGRAY = 1\nBLACK = 2\n\nfrom collections import defaultdict\nclass Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        \n        if not g:\n            return []\n        \n        res = []\n        g = defaultdict(list)\n        n = len(graph)\n        currRecurStack = [WHITE] * n\n        visited = set()\n        cycleExists = False\n        \n        for i in range(n):\n            for vertex in graph[i]:\n                g[i].append(vertex)\n        \n        \n        for i in range(n):\n            if i not in visited:\n                cycleExists = dfsDetectCycle(g, visited, currRecurStack, i)\n                if not cycleExists:\n                    res.append(i)\n        \n        return res\n                \n            \n    \n\ndef dfsDetectCycle(g, visited, currRecurStack, i):\n    visited.add(i)\n    currRecurStack[i] = GRAY\n    \n    neighbors = g[i]\n    for nh in neighbors:\n        if (nh not in visited and dfs(g, visited, currRecurStack, nh)): return True\n        if (currRecurStack[nh] == GRAY): return True\n    \n    currRecurStack[i] = BLACK\n    return False\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfrom collections import defaultdict\nclass Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        # visited = set()\n        n = len(graph)\n        # recur = [False] * n\n        color = [0] * n\n        g = defaultdict(list)\n        ans = []\n        \n        for i in range(n):\n            for nh in graph[i]:\n                g[i].append(nh)\n        \n        for i in range(n):\n            if not dfsCycle(g, i, color):\n                ans.append(i)\n        \n        return ans\n\n# alternate version with same logic\n\\\"\\\"\\\"    \ndef dfsCycle2(g, node, recur, visited):\n    visited.add(node)\n    recur[node] = True\n    \n    for nh in g[node]:\n        if (nh not in visited and dfsCycle2(g, nh, recur, visited)): return True\n        if (recur[nh]): return True\n    \n    recur[node] = False\n    return False\n\\\"\\\"\\\"\n\ndef dfsCycle(g, node, color):\n    color[node] = 1\n    neighbours = g[node]\n    \n    for nh in neighbours:\n        if (color[nh] == 0 and dfsCycle(g, nh, color)): return True\n        if (color[nh] == 1): return True\n    \n    color[node] = 2\n    return False", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        \n        WHITE, GRAY, BLACK = 0, 1, 2    #GRAY is part of a cycle, BLACK is safe\n        color = {}\n        for i in range(len(graph)):\n            color[i] = WHITE\n         \n        # Return whether it is safe\n        def dfs(node):\n            if color[node] != WHITE:\n                return color[node] == BLACK\n            \n            color[node] = GRAY\n            for nei in graph[node]:\n                if color[nei] == BLACK:\n                    continue\n                elif color[nei] == GRAY:\n                    return False\n                elif not dfs(nei):\n                    return False\n            color[node] = BLACK\n            return True\n        \n        safe = []\n        for i in range(len(graph)):\n            if dfs(i):\n                safe.append(i)\n                \n        return safe\n            \n            \n            \n            \n        \n        \n        \n", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        \n        \n        def cycle(index):\n            if visited[index] == 1:\n                return True\n            if visited[index] == 2:\n                return False\n            \n            visited[index] = 1\n            for node in graph[index]:\n                if cycle(node):\n                    return True\n                \n            visited[index] = 2\n            return False\n        \n        \n        visited = [0] * len(graph)\n        \n        for i in range(len(graph)):\n            cycle(i)\n                    \n        safe = []\n        for i in range(len(graph)):\n            if visited[i] == 2:\n                safe.append(i)\n        return safe", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        \n        def dfs(node):\n            # if\n            # print(\\\"node\\\",node)\n            if(node in terminalnodes):\n                return True\n            if(node in visited):\n                return False\n            visited[node] = 1\n            a = True\n            for newnodes in graph[node]:\n                a = a and dfs(newnodes)\n                \n            if(a==True):\n                terminalnodes.add(node)\n                return True\n            else:\n                return False\n        \n        \n        \n        \n        nodes = len(graph)\n        \n        m = []\n        # print(len(m))\n        \n        nonlocal terminalnodes\n        terminalnodes = {i for i in range(nodes) if len(graph[i])==0}\n        print(terminalnodes)\n        nonlocal visited\n        visited = {}\n        for i in range(len(graph)):\n            visited = {}\n            a = dfs(i)\n            if(a==True):\n                terminalnodes.add(i)\n        if(len(terminalnodes)==0):\n            return []\n        \n        t = list(terminalnodes)\n        t.sort()\n        return t   \n", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        notSafe = set()\n        safe = set()\n        def isSafe(node,visited):\n            if node in notSafe: return False\n            if not graph[node]: return True\n            if node in safe: return True\n            #print(node)\n            visited.add(node)\n            for child in graph[node]:\n                if child in visited: \n                    notSafe.add(child)\n                    notSafe.add(node)\n                    return False\n                if not isSafe(child,set(visited)): \n                    notSafe.add(child)\n                    notSafe.add(node)\n                    return False\n            safe.add(node) \n            return True\n        out = []\n        for i in range(len(graph)):\n            if  isSafe(i,set()): out+=i,\n        return out        ", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        # table = collections.defaultdict(list)\n        # for i in range(len(graph)):\n        #     table[i] = graph[i]\n        \n        #\u5bfb\u627e\u4ece\u4e00\u4e2a\u70b9\u51fa\u53d1\uff0c\u662f\u5426\u6709\u73af\n        def dfs(i):\n            if color[i] == 1:\n                return False\n            elif color[i] == 2:\n                #\u4e0b\u9762\u4e0d\u9700\u8981ans.append(i),\u56e0\u4e3a\u5728color\u4ece1\u52302\u7684\u65f6\u5019\u5c31\u5df2\u7ecf\u88ab\u52a0\u8fdb\u4e86ans\uff01\uff01\n                # ans.append(i)\n                return True\n            elif color[i] == 0:\n                color[i] = 1\n                for j in graph[i]:\n                    #\u4e0d\u80fd\u76f4\u63a5dfs(j),\u56e0\u4e3a\u8fd9\u6837dfs(j)\u6709\u53ef\u80fd\u662ffalse\uff0c\u4f46\u662f\u5374\u6ca1\u6709\u9000\u51fa\uff0c\u5bfc\u81f4\u540e\u9762\u8fd8\u4f1a\u6267\u884c\n                    # color[i] = 2 ans.append(i) return True\n                    # dfs(j)\n                    #\u4e0b\u9762\u662f\u8981\u5bf9false\u5224\u65ad\uff0c\u5982\u679c\u662ffalse\u76f4\u63a5\u9000\u51fa\n                    if not dfs(j):\n                        return False\n                color[i] = 2\n                ans.append(i)\n                return True\n                \n                \n        ans = []\n        color = [0] * len(graph)\n        for i in range(len(graph)):\n            if color[i] == 0:\n                dfs(i)\n        return sorted(ans)\n            \n        \n", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        def cycle(snode):\n            if mem[snode] == -1:\n                return True\n            elif mem[snode] == 1:\n                return False\n\n            seen_path.add(snode)\n            for e in graph[snode]:\n                if e in seen_path:\n                    for n in seen_path:\n                        mem[n] = -1\n                    return True\n                if e not in seen:\n                    seen.add(e)\n                    res = cycle(e)\n                    if res:\n                        return res\n            mem[snode] = 1\n            seen_path.discard(snode)\n            return False\n\n        ret = []\n        seen = set()\n        seen_path = set()\n        mem = [0] * len(graph)\n        for i in range(len(graph)):\n            seen_path.clear()\n            seen.clear()\n            if not cycle(i):\n                ret.append(i)\n        return ret\n\n", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        \n        terminal = []\n        n = len(graph)\n        visited = [-1]*n\n        \n                \n        def dfs(i):\n            visited[i] = 0 # i is visiting\n            for t in graph[i]:\n                if visited[t] == 0 or (visited[t]==-1 and not dfs(t)):\n                    return False\n            visited[i] = 1 # i visited already\n            terminal.append(i)\n            return True\n                \n        for i in range(n):\n            if visited[i] == -1:\n                dfs(i)\n                \n        return sorted(terminal)", "class Solution:\n    def eventualSafeNodes(self, graph):\n        \\\"\\\"\\\"\n        :type graph: List[List[int]]\n        :rtype: List[int]\n        \\\"\\\"\\\"\n        n = len(graph)\n        res = set([i for i in range(n) if graph[i] == []])\n        left = set(range(n)) - res\n        while True:\n            new_res = set(res)\n            new_left = set(left)\n            for i in left:\n                if set(graph[i]).issubset(res):\n                    new_res.add(i)\n                    new_left.remove(i)\n            if new_res == res:\n                return sorted(list(res))\n            else:\n                res = new_res\n                left = new_left", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        graph = list(map(set, graph))\n        rgraph = defaultdict(set)\n        q = deque()\n        \n        for i, nn in enumerate(graph):\n            if not nn:\n                q.append(i)\n            for j in nn:\n                rgraph[j].add(i)\n        res = []\n        while q:\n            j = q.popleft()\n            res.append(j)\n            for i in rgraph[j]:\n                graph[i].remove(j)\n                if not graph[i]:\n                    q.append(i)\n        res.sort()\n        return res\n    \n#     def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n#         self.nope = set()\n#         res = []\n#         for i in range(len(graph)):\n#             if i in self.nope:\n#                 continue\n#             if not self.has_cycle(graph, i, i, set()):\n#                 res.append(i)\n#         return res\n        \n        \n#     def has_cycle(self, graph, i, root, seen):\n#         # print('here', i, root, seen)\n#         if i == root and root in seen:\n#             self.nope.add(i)\n#             return True\n#         if i in seen:\n#             self.nope.add(i)\n#             return True\n        \n#         res = False\n#         seen.add(i)\n#         for nei in graph[i]:\n#             res |= self.has_cycle(graph, nei, root, seen)\n#         seen.remove(i)\n#         return res\n", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        def check_safe(graph, st, seen, cur):\n            if st[cur] != 0:\n                return st[cur]\n            if len(graph[cur]) == 0:\n                return 1\n            if cur in seen:\n                return -1\n            seen.add(cur)\n            for ne in graph[cur]:\n                rtv = check_safe(graph, st, seen, ne)\n                if rtv == -1:\n                    st[cur] = -1\n                    return -1\n            seen.discard(cur)\n            st[cur] = 1\n            return 1\n        \n        N = len(graph)\n        st= [0] * N #   -1\u4e0d\u5b89\u5168\u30010\u4e0d\u786e\u5b9a\u30011\u5b89\u5168\n\n        for i in range(N):\n            if st[i] != 0:\n                continue\n            seen = set()\n            st[i] = check_safe(graph, st, seen, i)\n        # print(st)\n        rtv = []\n        for i,s in enumerate(st):\n            if s == 1:\n                rtv.append(i)\n        return rtv\n", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        n = len(graph)\n        out_degree = [0] * n\n        in_nodes = collections.defaultdict(list) \n        queue = []\n        for i in range(n):\n            out_degree[i] = len(graph[i])\n            if out_degree[i] == 0: queue.append(i)\n            for j in graph[i]: in_nodes[j].append(i)  \n        for term_node in queue:\n            for in_node in in_nodes[term_node]:\n                out_degree[in_node] -= 1\n                if out_degree[in_node] == 0: queue.append(in_node)\n        return sorted(queue)", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        \n        WHITE, GRAY, BLACK = 0, 1, 2    #GRAY is part of a cycle, BLACK is safe\n        color = {}\n        for i in range(len(graph)):\n            color[i] = WHITE\n         \n        # Return whether it is safe\n        def dfs(node):\n            if color[node] != WHITE:\n                return color[node] == BLACK\n            \n            color[node] = GRAY\n            for nei in graph[node]:\n                if color[nei] == GRAY:\n                    return False\n                elif not dfs(nei):\n                    return False\n            color[node] = BLACK\n            return True\n                \n        return list(filter(dfs, list(range(len(graph)))))\n            \n            \n            \n            \n        \n        \n        \n", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        n = len(graph)\n        \n        res = []\n        degree = [0]*n\n        reverseGraph = collections.defaultdict(list)\n        q = collections.deque()\n           \n        for i in range(n):\n            if len(graph[i])==0:\n                q.append(i)\n            for nextNode in graph[i]:\n                reverseGraph[nextNode].append(i)\n                degree[i]+=1\n        \n        while q:\n            index = q.popleft()\n            res.append(index)\n            for nextNode in reverseGraph[index]:\n                degree[nextNode]-=1\n                if degree[nextNode]==0:\n                    q.append(nextNode)\n        \n        return sorted(res)\n            \n                \n                \n", "#[] Graph(Reversed-Topology, outdegree)\n#1) node A has no child nodes => A must be stable\n#2) All childs of node A are stable => A must be stable\n#Solution: Traverse all nodes in reversed topological order (remove nodes with out-degree==0 first)\nfrom collections import defaultdict, deque\nclass Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        revadj, outdegree = defaultdict(list), dict()\n        for src, dsts in enumerate(graph):\n            for dst in dsts:\n                revadj[dst].append(src)\n            outdegree[src] = len(dsts)\n        q, res = deque([i for i, d in outdegree.items() if d == 0]), []\n        while q:\n            dst = q.popleft()\n            res.append(dst)\n            for src in revadj[dst]:\n                outdegree[src] -= 1\n                if outdegree[src] == 0:\n                    q.append(src)\n        return sorted(res)", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        n = len(graph)\n        v = [0] * n \n        def circle(i):\n            if v[i] == 2: return False\n            if v[i] == 1: return True \n            v[i] = 1 \n            for nei in graph[i]:\n                if circle(nei): return True \n            v[i] = 2\n            return False \n        \n        res = []\n        for i in range(n):\n            if circle(i): continue\n            res.append(i)\n        return res\n", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        n = len(graph)\n        safe = [False for _ in range(n)]\n        \n        rgraph = [set([]) for _ in range(n)]\n        \n        queue = collections.deque([])\n        \n        for i in range(n):\n            if not graph[i]:\n                queue.append(i)\n            else:\n                for j in graph[i]:\n                    rgraph[j].add(i)\n        \n        while queue:\n            curr_node = queue.popleft()\n            \n            safe[curr_node] = True\n            \n            for prev in rgraph[curr_node]:\n                graph[prev].remove(curr_node)\n                \n                if len(graph[prev]) == 0:\n                    queue.append(prev)\n        return [i for i, s in enumerate(safe) if s]\n                \n                \n                \n                \n                \n", "#dfs, with status: UNKNOWN, VISITING, VISITED\nclass Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        UNKNOWN, VISITING, VISITED = 0, 1, 2\n        status = [UNKNOWN] * len(graph)\n        def dfs(node):\n            if status[node] == UNKNOWN:\n                status[node] = VISITING\n                if all([dfs(n) for n in graph[node]]):\n                    status[node] = VISITED\n                    return True\n                else:\n                    return False\n            elif status[node] == VISITED:\n                return True\n            elif status[node] == VISITING:\n                return False\n        for n in range(len(graph)):\n            if status[n] == UNKNOWN:\n                dfs(n)\n        return sorted([x for x, stat in enumerate(status) if stat == VISITED])", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        \n        dic = collections.defaultdict(list)\n        \n        for i, e in enumerate(graph):\n            for j in e:\n                dic[i].append(j)\n        \n        memo = {}\n        def dfs(node):\n            if not dic[node]:\n                return True\n            \n            if node in memo:\n                return memo[node]\n            \n            memo[node] = False\n            if all(dfs(nxt) for nxt in dic[node]):\n                memo[node] = True\n            \n            return memo[node]\n        \n        res = []\n        for i in range(len(graph)):\n            if dfs(i):\n                res.append(i)\n        return res\n        \n        # for k, v in sorted(memo.items(), key = lambda x: x[1]):\n        #     if v:\n        #         res.append(v)\n", "'''\nGraph DFS brute force search\n'''\nclass Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        # cycle detection\n        # initial state 0, processing 1, eventual state 2\n        n = len(graph)\n        \n        states = [0 for i in range(n)]\n        \n        def dfs(i):\n            if states[i] != 0:\n                return states[i]\n            \n            if not graph[i]:\n                states[i] = 2\n                return states[i]\n            \n            states[i] = 1\n            eventual_state = 2\n            for j in graph[i]:\n                if states[j] == 0:\n                    state_j = dfs(j)\n                else:\n                    state_j = states[j]\n                eventual_state = min(state_j, eventual_state)\n            \n            states[i] = eventual_state\n            return states[i]\n        \n        \n        output = []\n        for i in range(n):\n            s = dfs(i)\n            if s == 2:\n                output.append(i)\n        \n        return sorted(output)", "#topology, indegree + bfs\n#if the node doesn't point to other node, which means it will not get to the loop, so it is stable.\n#so we could count the degree of each node, degree[i] = how many node can i get to from node_i.\n#build a adj, adj[i] = who can get to node_i\nclass Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        adj = defaultdict(list)\n        degree = dict()\n        for i, node in enumerate(graph):\n            degree[i] = len(node)\n            for n in node:\n                adj[n].append(i)\n        bfs = deque([x for x, count in degree.items() if count == 0])\n        result = []\n        while bfs:\n            current = bfs.popleft()\n            result.append(current)\n            for n in adj[current]:\n                degree[n] -= 1\n                if degree[n] == 0:\n                    bfs.append(n)\n        return sorted(result)", "from collections import defaultdict\n\nclass Solution:\n    def dfs(self, node, graph, eventuallySafe, visited):\n        if node in eventuallySafe:\n            return True\n        if node in visited:\n            return False\n        \n        # never seen before\n        visited.add(node)\n        adjNodes = graph[node]\n        if len(adjNodes) != 0:\n            isEventuallySafe = True\n            for neighbour in adjNodes:\n                isEventuallySafe = self.dfs(neighbour, graph, eventuallySafe, visited) and isEventuallySafe\n            \n            if not isEventuallySafe:\n                return False\n\n        # eventually safe, or safe\n        eventuallySafe.add(node)\n        return True\n\n        \n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        # isSafe(n) <==> n.edges = {}\n        # isEventuallySafe(n) <=> for_all e IN n.edges, isEventuallySafe(n) || isSafe(n)\n        \n        eventuallySafe = set()\n        visited = set()\n        for n in range(len(graph)):\n            self.dfs(n, graph, eventuallySafe, visited)\n            \n        return sorted(list(eventuallySafe))\n            \n", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        adj_list = defaultdict(list)\n        vertices_with_no_incoming_edges = []\n        stack = deque()\n        indegree_graph = defaultdict(int) \n        vertices_part_of_cycle = []\n        no_of_vertices = len(graph)\n\n        for i in range(no_of_vertices):\n            indegree_graph[i] = 0\n\n        for source in range(no_of_vertices):\n            for dest in graph[source]:\n                adj_list[dest].append(source) \n                indegree_graph[source] += 1\n\n        for key, val in indegree_graph.items():\n            if indegree_graph[key] == 0:\n                stack.append(key)\n                vertices_with_no_incoming_edges.append(key)\n\n        while stack:\n            vert = stack.pop()\n\n            if vert in adj_list:\n                for v in adj_list[vert]:\n                    indegree_graph[v] -= 1\n                \n                    if indegree_graph[v] == 0:\n                        vertices_with_no_incoming_edges.append(v)\n                        stack.append(v)\n\n        return sorted(vertices_with_no_incoming_edges) ", "# DFS / Topological Method\nclass Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        WHITE, GREY, BLACK = 0,1,2\n        result=[]\n        \n        # 1) assign colors for all nodes\n        color=defaultdict()\n        for i in range(len(graph)):\n            color[i]=WHITE\n        \n        # 2) dfs the nodes\n        def dfs(node):\n            if color[node] != WHITE:          # this node was visited, could be grey or black\n                return color[node] == BLACK       # shortcut return \n            \n            color[node]=GREY                    # visiting node so color it grey\n            for neigh in graph[node]:           # visit all neighbors of current node\n                if not dfs(neigh):\n                    return False\n                \n            color[node]=BLACK                   # Done visiting this node so mark it Black\n            return True\n\n        # 3) check all nodes in graph\n        for i in range(len(graph)):             # check each node in graph\n            if not graph[i]:             # if node has no outgoing edges it must be a terminal node\n                result.append(i)\n            elif dfs(i):                        \n                result.append(i)\n        \n        return result\n\n    # Complexity: O(N+E)   N-nodes, for each node, have to explore all its edges.\n", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        graph_reverse = collections.defaultdict(list)\n        indegree = collections.defaultdict(int)\n        for i in range(len(graph)):\n            if not graph[i]:\n                indegree[i]\n            for nei in graph[i]:\n                graph_reverse[nei].append(i)\n                indegree[nei]\n                indegree[i] += 1\n        q = collections.deque([node for node in indegree if indegree[node] == 0])\n        res = []\n        while q:\n            node = q.popleft()\n            res.append(node)\n            for nei in graph_reverse[node]:\n                indegree[nei] -= 1\n                if indegree[nei] == 0:\n                    q.append(nei)\n        return sorted(res)\n", "#[Runtime: 736 ms, faster than 57.43%] DFS\n#O(V + E)\nfrom collections import defaultdict\nUNKNOWN, VISITING, VISITED = 0, -1, 1\nclass Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        visited = defaultdict(int)\n        def dfs(cur: int) -> bool:\n            \\\"\\\"\\\"return True if there is cycle\\\"\\\"\\\"\n            if visited[cur] == VISITED:\n                return False\n            elif visited[cur] == VISITING:\n                return True\n            visited[cur] = VISITING\n            if any(dfs(nxt) for nxt in graph[cur]):\n                return True\n            visited[cur] = VISITED\n            return False\n        return [i for i in range(len(graph)) if not dfs(i)]", "#[] DFS\n#O(V + E)\nfrom collections import defaultdict\nUNKNOWN, VISITING, VISITED = 0, 1, 2\nclass Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        adj, visited = defaultdict(list), defaultdict(int)\n        #build graph\n        for src, dsts in enumerate(graph):\n            for dst in dsts:\n                adj[src].append(dst)\n        def dfs(cur: int) -> bool:\n            \\\"\\\"\\\"return True if there is cycle\\\"\\\"\\\"\n            if visited[cur] == VISITED:\n                return False\n            elif visited[cur] == VISITING:\n                return True\n            visited[cur] = VISITING\n            res = any(dfs(nxt) for nxt in adj[cur])\n            if not res:\n                visited[cur] = VISITED\n            return res\n        return [i for i in range(len(graph)) if not dfs(i)]", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        nodes = reduce(lambda node, e: node[e[0]].extend(e[1]) or node, enumerate(graph), defaultdict(list))\n        \n        visited = set() \n        s = set()\n        def dfs(i):\n            if i in s:\n                return False\n            if i in visited:\n                return True\n            \n            s.add(i)\n            if not all(map(dfs, nodes[i])):\n                return False\n            s.remove(i)\n            visited.add(i)\n            return True \n        \n        return [i for i in range(len(graph)) if dfs(i)]", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        n = len(graph)\n        deg = {}\n        grev = {}\n        terminals = []\n        for i in range(n):\n            deg[i] = len(graph[i])\n            if deg[i] == 0:\n                terminals.append(i)\n            for j in graph[i]:\n                if j not in grev:\n                    grev[j] = []\n                grev[j].append(i)\n        for t in terminals:\n            if t not in grev:\n                continue\n            for j in grev[t]:\n                deg[j] -= 1\n                if deg[j] == 0:\n                    terminals.append(j)\n        return sorted(terminals)", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        graph_reverse = collections.defaultdict(list)\n        indegree = collections.defaultdict(int)\n        for i in range(len(graph)):\n            if not graph[i]:\n                indegree[i]\n            for nei in graph[i]:\n                graph_reverse[nei].append(i)\n                indegree[nei]\n                indegree[i] += 1\n        q = collections.deque([node for node in indegree if indegree[node] == 0])\n        res = [False for _ in range(len(graph))]\n        while q:\n            node = q.popleft()\n            res[node] = True\n            for nei in graph_reverse[node]:\n                indegree[nei] -= 1\n                if indegree[nei] == 0:\n                    q.append(nei)\n        return [i for i in range(len(res)) if res[i] == True]\n", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        n = len(graph)\n        safe = set()\n        revg = defaultdict(set)\n        q = deque()\n        \n        graph = list(map(set,graph))\n        \n        for u,nodes in enumerate(graph):\n            if not nodes:\n                q.append(u)\n            for v in nodes:\n                revg[v].add(u)\n                \n        while q:\n            temp = q.popleft()\n            safe.add(temp)\n            for v in revg[temp]:\n                graph[v].remove(temp)\n                if not graph[v]:\n                    q.append(v)\n                    \n        return sorted(safe)", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        n = len(graph)\n        out_degree = collections.defaultdict(int)\n        in_nodes = collections.defaultdict(list) \n        queue = []\n        ret = []\n        for i in range(n):\n            out_degree[i] = len(graph[i])\n            if out_degree[i]==0:\n                queue.append(i)\n            for j in graph[i]:\n                in_nodes[j].append(i)  \n        while queue:\n            term_node = queue.pop(0)\n            ret.append(term_node)\n            for in_node in in_nodes[term_node]:\n                out_degree[in_node] -= 1\n                if out_degree[in_node]==0:\n                    queue.append(in_node)\n        return sorted(ret)", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        n = len(graph)\n        ans = []\n        \n        def dfs(node):\n            #print(i, \\\" \\\", arr)\n            if arr[node] != -1:\n                return arr[node] == 1\n            arr[node] = 0\n            for j in graph[node]:\n                #print(j)\n                if arr[j] == 1:\n                    continue\n                elif arr[j] == 0 or not dfs(j):\n                    return False\n            arr[node] = 1\n            return True\n        \n        arr = [-1]*n\n        for i in range(n):\n            if len(graph[i]) == 0:\n                ans.append(i)\n                continue\n            if dfs(i):\n                ans.append(i)\n        return ans    ", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        def cycle(snode):\n            if mem[snode] < 0:\n                return True\n            elif mem[snode] > 0:\n                return False\n\n            mem[snode] = -1\n            for e in graph[snode]:\n                if cycle(e):\n                    return True\n            mem[snode] = 1\n            return False\n\n        n = len(graph)\n        ret = []\n        mem = [0] * n\n        for i in range(n):\n            if not cycle(i):\n                ret.append(i)\n        return ret\n", "class Solution:\n    def eventualSafeNodes(self, graph):\n        degrees = {}\n        safe, unsafe = set(), set()\n        adj = {}\n        for node in range(len(graph)):\n            nodes = graph[node]\n            degrees[node] = len(nodes)\n            graph[node] = set(nodes)\n            if node not in adj:\n                adj[node] = set()\n            for another in nodes:\n                if another not in adj:\n                    adj[another] = set()\n                adj[another].add(node)\n        queue = []\n        for node in degrees:\n            if degrees[node] == 0:\n                queue.append(node)\n        while True:\n            if len(queue) == 0:\n                break\n            node = queue.pop()\n            if degrees[node] == 0:\n                safe.add(node)\n                for another in adj[node]:\n                    degrees[another] -= 1 \n                    if degrees[another] == 0 and another not in safe:\n                        queue.append(another)\n            else:\n                break\n        safe = list(safe)\n        safe.sort()\n        return safe\n                \n                \n                \n                \n        \n\n                \n            \n                \n", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        def cycle(snode):\n            if mem[snode] == -1:\n                return True\n            elif mem[snode] == 1:\n                return False\n\n            mem[snode] = -1\n            for e in graph[snode]:\n                if cycle(e):\n                    return True\n            mem[snode] = 1\n            return False\n\n        n = len(graph)\n        ret = []\n        mem = [0] * n\n        for i in range(n):\n            if not cycle(i):\n                ret.append(i)\n        return ret\n", "#[Runtime: 736 ms, faster than 57.43%] DFS\n#O(V + E)\nfrom collections import defaultdict\nUNKNOWN, VISITING, VISITED = 0, 1, 2\nclass Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        adj, visited = defaultdict(list), defaultdict(int)\n        #build graph\n        for src, dsts in enumerate(graph):\n            for dst in dsts:\n                adj[src].append(dst)\n        def dfs(cur: int) -> bool:\n            \\\"\\\"\\\"return True if there is cycle\\\"\\\"\\\"\n            if visited[cur] == VISITED:\n                return False\n            elif visited[cur] == VISITING:\n                return True\n            visited[cur] = VISITING\n            if any(dfs(nxt) for nxt in adj[cur]):\n                return True\n            visited[cur] = VISITED\n            return False\n        return [i for i in range(len(graph)) if not dfs(i)]", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        ans = []\n        N = len(graph)\n        out = collections.defaultdict(set)\n        in_cnt = [0 for _ in range(N)]\n        ready = set(range(N))\n        for end in range(N):\n            for start in graph[end]:\n                out[start].add(end)\n                in_cnt[end] += 1\n                if end in ready:\n                    ready.remove(end)\n        \n        while len(ready) > 0:\n            rm = ready.pop()\n            ans.append(rm)\n            for nei in out[rm]:\n                in_cnt[nei] -= 1\n                if in_cnt[nei] == 0:\n                    ready.add(nei)\n        return sorted(ans)\n\n        \n", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        cycle = set()\n        used = set()\n        \n        def do(cur, path=set()):\n            if cur in used:\n                return True\n            if cur in cycle or cur in path:\n                return False\n            for nxt in graph[cur]:                \n                if not do(nxt, path | {cur}):\n                    cycle.update({cur, nxt})\n                    return False\n            used.add(cur)\n            return True\n        \n        return list(filter(do, range(len(graph))))", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        new_g = {i: [] for i in range(len(graph))}\n        for i, n in enumerate(graph):\n            new_g[i].append(n)\n        \n        def dfs(n):\n            if status[n] == -1:\n                return False\n            if status[n] == 1:\n                return True\n            status[n] = -1\n            for adj in graph[n]:\n                if not dfs(adj):\n                    return False\n            status[n] = 1\n            return True\n        status = [0 for _ in range(len(graph))]\n        return filter(dfs, range(len(graph)))", "# visiting, safe, unsafe\nfrom collections import defaultdict\nclass Solution:\n    def eventualSafeNodes(self, graph):\n        state = defaultdict(int)\n        def dfs(node):\n            if state[node] == 1:\n                state[node] = 3\n                return 3\n            if state[node]:\n                return state[node]\n            state[node] = 1\n            for nei in graph[node]:\n                if dfs(nei) == 3:\n                    state[node] = 3\n                    return 3\n            state[node] = 2\n            return 2\n        N = len(graph)\n        return [node for node in range(N) if dfs(node) == 2]", "from collections import defaultdict, deque\nclass Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        degree = [len(graph[i]) for i in range(len(graph))]\n        edges = defaultdict(list)\n        for i in range(len(graph)):\n            for j in graph[i]:\n                edges[j].append(i)\n        \n        q = deque()\n        for i in range(len(graph)):\n            if degree[i] == 0:\n                q.append(i)\n        \n        res = []\n        while q:\n            node = q.popleft()\n            res.append(node)\n            for n in edges[node]:\n                degree[n] -= 1\n                if degree[n] == 0:\n                    q.append(n)\n        return sorted(res)", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        perm = {i for i, e in enumerate(graph) if not e}\n\n        rev = [[] for i in range(len(graph))]\n\n        for i, e in enumerate(graph):\n            for j in e:\n                rev[j].append(i)\n\n        last = perm.copy()\n        while last:\n            tmp = set()\n            for n in last:\n                for nei in rev[n]:\n                    if nei not in perm and all(cat in perm for cat in graph[nei]):\n                        tmp.add(nei)\n            perm = perm.union(tmp)\n            last = tmp\n\n        return sorted(perm)", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        unsafe_nodes = set()\n        \n        safe_nodes = set()\n        \n        def dfs(node, visited):\n            if node in visited:\n                return False\n            \n            visited.add(node)\n            for neighbor in graph[node]:\n                if neighbor in unsafe_nodes:\n                    unsafe_nodes.add(node)\n                    return False\n                if neighbor in safe_nodes:\n                    continue\n                if not dfs(neighbor, visited):\n                    unsafe_nodes.add(node)\n                    return False\n     \n            safe_nodes.add(node)\n            return True\n        \n        safe = []\n        for i in range(len(graph)):\n            if dfs(i,set()):\n                safe.append(i)\n                \n        return safe", "class Solution:\n    \n    # Check each vertex to see if its part of a cycle\n    # If it is, it is not a safe vertex.\n    \n    # All nodes in that cycle are not considered to be safe vertices\n    \n    # Nodes that have no directed edges are also considered to be safe.\n    \n    # A node is considered safe it all its edges are to nodes that will eventually\n    # become safe. So it one edge points to a safe node, but the other edge points to a \n    # cycle, that node is stil considered unsafe.\n    \n    # Even union find fails algo? Yes. You can group up safe nodes with cycles\n    # Union find helps you prevent cycles, but not this application.\n    \n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        \n        # If parent node i has no incoming edges (i,j) where parent (k) of \n        # node j is also a child of i, then it is not a cycle.\n        \n        # Let's say parent of i is safe\n        # remove (i,j) from graphDict for child node j\n        \n        # Do so for all child of i, so that graphDict[i] has no more result \n        # (no more outgoing edges)\n        \n        #  Need to check all incoming edges though?\n        \n        # Just because its children are safe doesn't mean parent is safe.\n        # The reverse is not true. If even one of its children is not safe, the \n        # parent is not safe. -> So if all children are safe, parent is safe.\n        \n        # Node j (child) is safe and in queue\n        # i in reverseGraphDict[j], so remove (i,j) from graphDict\n        # Loop. If all (i,j) is removed from graphDict, so \n        # graphDict[i] contains empty set(), then parent is also successfully safe.\n        \n        #    0     1    2   3   4   5  6      all parents\n        # [[1,2],[2,3],[5],[0],[5],[],[]]    all children     \n        \n        N = len(graph)\n        safe = [False] * N\n\n        graph = list(map(set, graph))\n        rgraph = [set() for _ in range(N)]\n        q = collections.deque()\n\n        for i, js in enumerate(graph):\n            if not js:\n                q.append(i)\n            for j in js:\n                rgraph[j].add(i)\n\n        while q:\n            j = q.pop()\n            safe[j] = True\n            for i in rgraph[j]:\n                graph[i].remove(j)\n                if len(graph[i]) == 0:\n                    q.append(i)\n\n        return [i for i, v in enumerate(safe) if v]\n        \n        \n        \n        \\\"\\\"\\\"\n        \n        N = len(graph)\n        safe = [False] * N\n        \n        graph = map(set,graph)\n        for elem in graph:\n            print(elem)\n        reverseGraphDict = [set() for _ in range(N)]\n\n        safeQueue = collections.deque()\n        \n        for parent, children in enumerate(graph):\n            # If there is no children (empty[]), terminal node\n            if not children:\n                safeQueue.append(parent)\n                \n            for child in children:\n                # Don't do dfs here\n                reverseGraphDict[child].add(parent) # a child can have multiple parents\\\"\\\"\\\"\n                \n                \n                \n        while safeQueue:\n            child = safeQueue.popleft()\n            safe[child] = True\n            for parent in reverseGraphDict[child]:\n                graph[parent].remove(child)\n                \n                # Parent is safe too, so push it into queue\n                if len(graph[parent]) == 0:\n                    #safe[parent] = True # Wil be taken care at top of loop\n                    safeQueue.append(parent)\n                \n        return [idx for idx, boolean in enumerate(safe) if boolean == True]\n            \n        \\\"\\\"\\\"\n        # Try DFS. Use a set to keep track of nodes already seen\n        seenSet = set()\n        safeList = []\n        \n        # Add parent to seenSet\n        # Iterate over all connections to children from parent\n        # dfs for each of those connections\n        \n        def dfs(parent):\n            nonlocal graph\n            nonlocal seenSet\n            \n            if parent in seenSet: # Already discovered before\n            \n            seenSet.add(parent)\n            \n            for edge in graph:\n                if edge[0] == parent:\n                    dfs(edge[1])\n            \n        \n        \n        \n        \\\"\\\"\\\"\n        '''\n        # Loop over all nodes in graph, make them their own group\n        for edge in graph:\n            parent = edge[0]\n            \n            # group.newGroup(parent)\n        \n        \n        for edge in graph:\n            parent = edge[0]\n            child = edge[1]'''\n            \n            # group parent and child together\n            \n            # if child is already grouped with parent (cycle),\n            # Those nodes in the group cannot be part of the answer.\n            \n            # But if the parent/child has only one connection to all \n            # the nodes within the group that has the cycle, that node\n            # (though connect) is technically safe.\n            \n            ", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        def cycle(snode):\n            if mem[snode] == 1:\n                return True\n            elif mem[snode] == 2:\n                return False\n\n            mem[snode] = 1\n            for e in graph[snode]:\n                if cycle(e):\n                    return True\n            mem[snode] = 2\n            return False\n\n        n = len(graph)\n        ret = []\n        mem = [0] * n\n        for i in range(n):\n            if not cycle(i):\n                ret.append(i)\n        return ret\n", "class Solution:\n    def __init__(self):\n        self.safe_nodes = set()\n        self.unsafe_nodes = set()\n        \n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        \n        def is_safe(node, stack=[]):\n            if (not graph[node]) or (node in self.safe_nodes):\n                self.safe_nodes.add(node)\n                return True\n            elif node in self.unsafe_nodes:\n                return False\n            else:\n                if node in stack:\n                    self.unsafe_nodes |= set(stack)\n                    return False\n                stack.append(node)\n                if all([is_safe(child) for child in graph[node]]):\n                    self.safe_nodes.add(node)\n                    stack.pop()\n                    return True\n                else:\n                    self.unsafe_nodes.add(node)\n                    stack.pop()\n                    return False\n        \n        for node in range(len(graph)):\n            is_safe(node)\n        \n        return sorted(list(self.safe_nodes))", "from collections import defaultdict, deque\nclass Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        n = len(graph)\n        q = deque()\n        ans = [False] * n\n        \n        graph_map = dict()\n        r_graph_map = defaultdict(set)\n        for i in range(n):\n            graph_map[i] = set(graph[i])\n            \n            if not graph[i]:\n                q.append(i)            \n            for out in graph[i]:\n                r_graph_map[out].add(i)\n        \n        while q:\n            safe_i = q.popleft()\n            ans[safe_i] = True\n            for in_id in r_graph_map[safe_i]:\n                graph_map[in_id].remove(safe_i)\n                if len(graph_map[in_id]) == 0:\n                    q.append(in_id)\n        return [i for i, safe in enumerate(ans) if safe]\n", "import queue\n\nclass Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        \\\"\\\"\\\"\n        Obs:\n        1. Clearly, each note that belongs to the cycle is wrong\n        If node is a leaf (terminal node), then it's eventually safe.\n        If we remove this node, some other nodes might become leaves, if so, they are eventuall safe as well\n        \\\"\\\"\\\"\n        \n        # We need transposition of the graph (directed graph with reversed edges), to be able to decrease out_deg for out predecessors\n        graph_t = [[] for _ in range(len(graph))]\n        for origin, adj_list in enumerate(graph):\n            for dest in adj_list:\n                graph_t[dest].append(origin)\n        \n        deg_out = [0 for _ in range(len(graph))]\n        deg_out = [len(adj_list) for adj_list in graph]\n        \n        terminal_nodes = queue.Queue()\n        for terminal_node in [node for node, d_out in enumerate(deg_out) if d_out == 0]:\n            terminal_nodes.put(terminal_node)\n        res = []\n        while not terminal_nodes.empty():\n            node = terminal_nodes.get()\n            for dest in graph_t[node]:\n                deg_out[dest] -= 1\n                if deg_out[dest] == 0:\n                    terminal_nodes.put(dest)\n            \n            res.append(node)\n        \n        return sorted(res)\n        ", "from collections import deque\n\nclass Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        N = len(graph)\n        \n        graph = list(map(set,graph)) # fr -> tos\n        rgraph=[set() for _ in range(N)] # to -> frs\n        safe = [False]*N\n        \n        # this will contain safe nodes (that are not pointed to)\n        q=deque()\n        \n        for fr,tos in enumerate(graph):\n            if not tos:\n                # safe\n                q.append(fr)\n            for to in tos:\n                rgraph[to].add(fr)\n            \n        while q:\n            to = q.popleft()\n            safe[to] = True\n            for fr in rgraph[to]:\n                graph[fr].remove(to)\n                if not graph[fr]:\n                    # safe after removal of a to that is safe\n                    q.append(fr)\n                    \n        return [i for i,v in enumerate(safe) if v]", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        SAFE, VISITED, UNSAFE = 1, 0, -1\n        is_safe = [None] * len(graph)\n\n        def explore(node):\n            if not graph[node]:\n                is_safe[node] = SAFE\n                return\n\n            if is_safe[node] == VISITED:\n                is_safe[node] = UNSAFE  # detected cycle\n                return\n\n            if is_safe[node] == None:\n                is_safe[node] = VISITED\n                for child in graph[node]:\n                    if is_safe[child] in [None, VISITED]:\n                        explore(child)\n                    if is_safe[child] == UNSAFE:\n                        is_safe[node] = UNSAFE\n                        return\n                else:\n                    is_safe[node] = SAFE\n                    return\n        \n        for node in range(len(graph)):\n            if is_safe[node] == None:\n                explore(node)\n        return [node for node in range(len(graph)) if is_safe[node] == SAFE]\n", "import queue\n\nclass Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        \\\"\\\"\\\"\n        Obs:\n        1. Clearly, each note that belongs to the cycle is wrong\n        If node is a leaf (terminal node), then it's eventually safe.\n        If we remove this node, some other nodes might become leaves, if so, they are eventuall safe as well\n        \\\"\\\"\\\"\n        \n        # We need transposition of the graph (directed graph with reversed edges), to be able to decrease out_deg for out predecessors\n        graph_t = [[] for _ in range(len(graph))]\n        for origin, adj_list in enumerate(graph):\n            for dest in adj_list:\n                graph_t[dest].append(origin)\n        \n        deg_out = [0 for _ in range(len(graph))]\n        deg_out = [len(adj_list) for adj_list in graph]\n        \n        terminal_nodes = queue.Queue()\n        for terminal_node in [node for node, d_out in enumerate(deg_out) if d_out == 0]:\n            terminal_nodes.put(terminal_node)\n        eventually_safe = [False for _ in range(len(graph))]\n        while not terminal_nodes.empty():\n            node = terminal_nodes.get()\n            for dest in graph_t[node]:\n                deg_out[dest] -= 1\n                if deg_out[dest] == 0:\n                    terminal_nodes.put(dest)\n            \n            eventually_safe[node] = True\n        \n        return [idx for idx in range(len(graph)) if eventually_safe[idx]]\n        ", "class Solution:\n  def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n    cycle_nodes = set()\n    safe_nodes = set()\n    visited = set()\n    \n    def helper(node: int, visited: set) -> bool:\n      if node in cycle_nodes:\n        return False\n      if node in safe_nodes:\n        return True\n      \n      if node in visited:\n        cycle_nodes.add(node)\n        return False\n      \n      visited.add(node)\n      \n      for child in graph[node]:\n        if helper(child, visited) is False:\n          cycle_nodes.add(node)\n          return False\n      \n      safe_nodes.add(node)\n      return True\n    \n    ans = []\n    for node in range(len(graph)):\n      if helper(node, visited):\n        ans.append(node)\n    \n    return ans\n    \n        \n        \n    \n    \n    # (0), (1, 2)\n    # (0, 1), (2, 2, 3)\n    # (0, 1, 2), (2, 3, 5)\n    # ()\n", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        WHITE, GRAY, BLACK = 0, 1, 2\n        color = collections.defaultdict(int)\n        \n        def dfs(node):\n            if color[node] != WHITE:\n                return color[node] == BLACK\n            \n            color[node] = GRAY\n            for next_node in graph[node]:\n                if color[next_node] == BLACK:\n                    continue\n                if color[next_node] == GRAY or not dfs(next_node):\n                    return False\n            color[node] = BLACK\n            return True\n        \n        return filter(dfs, range(len(graph)))", "class Solution:\n     def eventualSafeNodes(self, graph):\n        def explore(i):\n            visited[i] = 0\n            for v in graph[i]:\n                if visited[v] == 0 or (visited[v] == -1 and explore(v)): return True\n            visited[i] = 1\n            res.append(i)\n            return False\n        visited, res = [-1] * len(graph), []\n        for i in range(len(graph)):\n            if visited[i] == -1: explore(i)\n        return sorted(res)\n        \n", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        \n        ev_safe = collections.deque()  # indicate eventually safe\n        \n        sgraph = defaultdict(set)  # The original graph, set version\n        rgraph = defaultdict(set)  # So that we can removed it\n        safe = [False]*len(graph)\n        \n        for i, nei in enumerate(graph):\n            if not nei:\n                ev_safe.append(i)\n            for out in nei:\n                rgraph[out].add(i)\n                sgraph[i].add(out)\n        \n        # Start updating\n        while ev_safe:\n            node_point2safe = ev_safe.popleft()\n            safe[node_point2safe] = True\n            for node in rgraph[node_point2safe]:\n                graph[node].remove(node_point2safe)\n                if len(graph[node]) == 0:\n                    ev_safe.append(node)\n        \n        return [i for i, v in enumerate(safe) if v]\n            \n", "def f(x,y,ci,v):\n    a=True\n    for i in x[ci]:\n        if i in v:\n            if y[i]!=1:a=False\n            continue\n        v.add(i)\n        y[i]=f(x,y,i,v)\n        a=y[i] and a\n    return a\nclass Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        l=len(graph)\n        y=[-1 for i in range(l)]\n        v=set()\n        for i in range(l):\n            if y[i]==-1:\n                v.add(i)\n                y[i]=f(graph,y,i,v)\n        return [i for i in range(l) if y[i]]", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        SAFE, VISITED, UNSAFE = 1, 0, -1\n        is_safe = [None] * len(graph)\n\n        def explore(node):\n            if not graph[node]:\n                is_safe[node] = SAFE\n                return\n\n            if is_safe[node] == VISITED:\n                is_safe[node] = UNSAFE  # detected cycle\n                return\n\n            if is_safe[node] == None:\n                is_safe[node] = VISITED\n                for child in graph[node]:\n                    explore(child)\n                    if is_safe[child] == UNSAFE:\n                        is_safe[node] = UNSAFE\n                        return\n                else:\n                    is_safe[node] = SAFE\n                    return\n        \n        for node in range(len(graph)):\n            if is_safe[node] == None:\n                explore(node)\n        # print(is_safe)\n        return [node for node in range(len(graph)) if is_safe[node] == SAFE]\n", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        \n        def dfs(node, graph):\n            nodes[node] = 1  ## mark as visiting \n            for child in graph[node]:\n                if nodes[child] == 1: \n                    return False \n                if not nodes[child] and not dfs(child, graph):\n                    return False \n            nodes[node] = 2 \n            return True \n        \n        nodes = [0 for _ in range(len(graph))]\n        ans = [] \n        ## check if there is a cycle at each node in the graph \n        ## if there is a cycle then don't add to final list \n        ## to check if there is a cycle in directed graph, use \n        ## 3-coloring DFS \n        \n        for node in range(len(graph)):\n            if dfs(node, graph):\n                ans.append(node)\n                \n\n        return ans\n                \n                    \n            \n", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        # to see start with the node, whether there is a cycle\n        v = [0 for _ in range(len(graph))]\n        ans = []\n        \n        def dfs(cur):\n            if v[cur] == 1:\n                return True\n            if v[cur] == 2:\n                return False\n            v[cur] = 1\n            for j in graph[cur]:\n                if dfs(j):\n                    return True\n            v[cur] = 2\n            return False\n        \n        for i in range(len(graph)):\n            if dfs(i):\n                continue\n            else:\n                ans.append(i)\n        \n        return ans        \n    \n        \n", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        # table = collections.defaultdict(list)\n        # for i in range(len(graph)):\n        #     table[i] = graph[i]\n        \n        #\u5bfb\u627e\u4ece\u4e00\u4e2a\u70b9\u51fa\u53d1\uff0c\u662f\u5426\u6709\u73af\n        def dfs(i):\n            if color[i] == 1:\n                return False\n            elif color[i] == 2:\n                # ans.append(i)\n                return True\n            elif color[i] == 0:\n                color[i] = 1\n                if graph[i]:\n                    for j in graph[i]:\n                        # dfs(j)\n                        if not dfs(j):\n                            return False\n                color[i] = 2\n                ans.append(i)\n                return True\n                \n                \n        ans = []\n        color = [0] * len(graph)\n        for i in range(len(graph)):\n            if color[i] == 0:\n                dfs(i)\n        return sorted(ans)\n            \n        \n", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        \n        n = len(graph)\n        \n        out_degree = [0] * n\n        \n        in_nodes = collections.defaultdict(list) \n        term_nodes = []\n        \n        for i in range(n):\n            \n            out_degree[i] = len(graph[i])\n            \n            if out_degree[i] == 0: \n                term_nodes.append(i)\n                \n            for j in graph[i]: \n                in_nodes[j].append(i) \n                \n        #print(f'out_degree:{out_degree}') #out_degree:[2, 2, 1, 1, 1, 0, 0]\n        #print(f'in_nodes:{in_nodes}')  \n        #in_nodes:defaultdict(<class 'list'>, {1: [0], 2: [0, 1], 3: [1], 5: [2, 4], 0: [3]})\n        #print(f'term_nodes:{term_nodes}')   #term_nodes:[5, 6]\n\n                      \n        for term_node in term_nodes:\n            for in_node in in_nodes[term_node]:\n                \n                out_degree[in_node] -= 1\n                \n                if out_degree[in_node] == 0: \n                    term_nodes.append(in_node)\n                    \n        return sorted(term_nodes)\n", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        \n        n = len(graph)\n        out_degree = collections.defaultdict(int)\n        in_nodes = collections.defaultdict(list) \n        queue = []\n        ret = []\n        for i in range(n):\n            out_degree[i] = len(graph[i])\n            if out_degree[i]==0:\n                queue.append(i)\n            for j in graph[i]:\n                in_nodes[j].append(i)  \n        while queue:\n            term_node = queue.pop(0)\n            ret.append(term_node)\n            for in_node in in_nodes[term_node]:\n                out_degree[in_node] -= 1\n                if out_degree[in_node]==0:\n                    queue.append(in_node)\n        return sorted(ret)\n", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:    \n        WHITE, GREY, BLACK = 0, 1, 2\n        color = collections.defaultdict(int)\n        \n        def dfs(u):\n            if color[u] != WHITE:\n                return color[u] != GREY\n            \n            color[u] = GREY\n            for v in graph[u]:\n                if color[v] == BLACK:\n                    continue\n                if color[v] == GREY or not dfs(v):\n                    return False\n                \n            color[u] = BLACK\n            \n            return True\n        \n        return list(filter(dfs, range(len(graph))))", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        n = len(graph)\n        colour = [-1]*n\n        \n        def dfs(u):\n            if colour[u]!=-1:\n                colour[u]=1\n            \n            colour[u]=0\n            for nei in graph[u]:\n                if colour[nei]==1:\n                    continue\n                if colour[nei]==0 or not dfs(nei):\n                    return False\n            colour[u]=1\n            return True\n        \n        return list(filter(dfs, list(range(n))))\n                \n            \n        \n        \n", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        n = len(graph)\n        result = []\n        indegree = [len(edge) for edge in graph]\n        neighbors = collections.defaultdict(list)\n        for i, edge in enumerate(graph):\n            for j in edge:\n                neighbors[j].append(i)\n        queue = []\n        for i in range(n):\n            if indegree[i] == 0:\n                queue.append(i)\n        while queue:\n            i = queue.pop(0)\n            result.append(i)\n            for neighbor in neighbors[i]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n        return sorted(result)", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        ans = []\n        if len(graph) == 0:\n            return ans\n        status = [0 for _ in range(len(graph))]\n        for i in range(len(graph)):\n            if status[i] == 0:\n                self.dfs(i, graph, status, ans)\n        for i in range(len(graph)):\n            if status[i] == 2:\n                ans.append(i)\n        return ans\n                \n    \n    def dfs(self, i, graph, status, ans):\n        status[i] = 1\n        for neighbor in graph[i]:\n            if status[neighbor] == 1:\n                return False\n            if status[neighbor] == 0 and not self.dfs(neighbor, graph, status, ans):\n                return False\n        \n        status[i] = 2\n        return True", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        n = len(graph)\n        color = [0] * n\n        def dfs(node):\n            if color[node]:\n                return color[node] == 2\n            color[node] = 1\n            for nbor in graph[node]:\n                if not dfs(nbor):\n                    return False\n            color[node] = 2\n            return True\n        return [node for node in range(n) if dfs(node)]", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        def explore(i):\n            visited[i] = 0\n            for v in graph[i]:\n                if visited[v] == 0 or (visited[v] == -1 and explore(v)): return True\n            visited[i] = 1\n            res.append(i)\n            return False\n        \n        visited, res = [-1] * len(graph), []\n        \n        for i in range(len(graph)):\n            if visited[i] == -1: explore(i)\n        return sorted(res)", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:  \n        # 0 = not processed     1 = processing     2 = processed\n        \n        def cycle(ind):\n            if color[ind] == 1:\n                return True   # true means that there is a cycle\n            if color[ind] == 2:\n                return False   # no cycle is present\n            \n            color[ind] = 1\n            \n            for node in graph[ind]:\n                if cycle(node):\n                    return True            \n            color[ind] = 2\n            return False\n  \n        \n        n = len(graph)\n        color = [0]*n  \n        \n        for i in range(len(graph)):\n            cycle(i)     \n        \n        return [i for i in range(n) if color[i] == 2]\n    \n#     def helper(self, graph, index, visited, cache) -> bool:\n#         if visited[index]:\n#             return False\n        \n#         if len(graph[index]) == 0:\n#             return True\n        \n#         if index in cache:\n#             return cache[index]\n        \n#         visited[index] = True\n#         safe = True\n#         for v in graph[index]:\n#             safe = safe and self.helper(graph, v, visited, cache)\n#         visited[index] = False\n        \n#         cache[index] = safe\n#         return safe\n        \n#     def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n#         result = []\n#         cache = {}\n#         for i in range(len(graph)):\n#             visited = [False for node in graph]\n#             if self.helper(graph, i, visited, cache):\n#                 result.append(i)\n#         return result\n", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        def dfs(i):\n            if color[i] != 0: return color[i]\n            color[i] = 1\n            if any(dfs(j)==1 for j in graph[i]):\n                return color[i]\n            color[i] = 2\n            return color[i]\n            \n        color = collections.defaultdict(int)\n            \n        ans = []\n        n = len(graph)\n        for i in range(n):\n            if dfs(i) == 2:\n                ans.append(i)\n                \n        return ans\n                \n", "# 0: unknown, 1: visiting, 2: safe\nfrom collections import defaultdict\nclass Solution:\n    def eventualSafeNodes(self, graph):\n        state = defaultdict(int)\n        N = len(graph)\n        def dfs(node):\n            if state[node] != 0:\n                return state[node] == 2\n            state[node] = 1\n            for nei in graph[node]:\n                if state[nei] == 1 or not dfs(nei):\n                    return False\n            state[node] = 2\n            return True\n        return [node for node in range(N) if dfs(node)]\n", "#\n# @lc app=leetcode id=802 lang=python3\n#\n# [802] Find Eventual Safe States\n#\nclass Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        size = len(graph)\n        AVAILABLE = 0\n        VISITING = 1\n        VISITED = 2\n        status = [AVAILABLE] * size\n        def isSafe(source, res):\n            if status[source] != AVAILABLE: \n                return status[source] == VISITED\n            status[source] = VISITING\n            for neighbour in graph[source]:\n                if not isSafe(neighbour, res):\n                    return False\n            status[source] = VISITED\n            res.append(source)\n            return True\n        res = []\n        for node in range(size):\n            isSafe(node, res)\n        return sorted(res)\n\n", "from collections import defaultdict\n\nclass Solution:\n    def eventualSafeNodes(self, edges: List[List[int]]) -> List[int]:\n        graph = defaultdict(set)\n        inv = defaultdict(set)\n        N = len(edges)\n        ret = set()\n        \n        for s, es in enumerate(edges):\n            for e in es:\n                graph[s].add(e)\n                inv[e].add(s)\n        \n        for n in range(N):\n            if len(graph[n]) == 0: ret.add(n)\n        \n        todo = set(ret)\n        \n        while todo:\n            pending = set()\n            for n in todo:\n                for s in inv[n]:\n                    if graph[s].issubset(ret):\n                        ret.add(s)\n                        pending.add(s)\n            todo = pending\n        \n        return sorted(ret)", "from typing import List, Dict, Set\nfrom collections import defaultdict\n\ndef find_safe_nodes(graph: Dict, rev_graph: Dict):\n    outcount_nodes = defaultdict(set)\n    for node, list_innodes in list(graph.items()):\n        count_outedges = len(list_innodes)\n        outcount_nodes[count_outedges].add(node)\n\n    safe_nodes = set()\n    while len(outcount_nodes[0]) > 0:\n        safe_node = outcount_nodes[0].pop()\n        safer_nodes = rev_graph[safe_node]\n        for safer_node in safer_nodes:\n            prev_outcount = len(graph[safer_node])\n            graph[safer_node].remove(safe_node)\n            outcount_nodes[prev_outcount].remove(safer_node)\n            outcount_nodes[prev_outcount - 1].add(safer_node)\n        safe_nodes.add(safe_node)\n    return safe_nodes\n\nclass Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        list_graph = graph\n        graph = defaultdict(set)\n        rev_graph = defaultdict(set)\n\n        for node1, list_node2 in enumerate(list_graph):\n            for node2 in list_node2:\n                graph[node1].add(node2)\n                rev_graph[node2].add(node1)\n\n        for i in range(len(list_graph)):\n            if i not in graph:\n                graph[i] = set()\n            if i not in rev_graph:\n                rev_graph[i] = set()\n\n        safe_nodes = find_safe_nodes(graph, rev_graph)\n        return sorted(safe_nodes)\n\ns = Solution()\n\nprint((s.eventualSafeNodes(graph = [[1,2],[2,3],[5],[0],[5],[],[]])))\nprint((s.eventualSafeNodes(graph = [[1,2],[2,3],[5],[0],[5],[],[]]) == [2,4,5,6]))\n\nprint((s.eventualSafeNodes([[],[0,2,3,4],[3],[4],[]])))\nprint((s.eventualSafeNodes([[],[0,2,3,4],[3],[4],[]]) == [0, 1, 2, 3, 4]))\n\n\n", "import collections\\r\nclass Solution:\\r\n    def eventualSafeNodes(self, graph):\\r\n        q = collections.deque()\\r\n        outdegree = [0]*len(graph)\\r\n        income_node = collections.defaultdict(list)\\r\n        result = []\\r\n        for i in range(len(graph)):\\r\n            outdegree[i] = len(graph[i])\\r\n            if outdegree[i] == 0:\\r\n                q.append(i)\\r\n                continue\\r\n            for next_node in graph[i]:\\r\n                income_node[next_node].append(i)\\r\n        \\r\n        while q:\\r\n            node = q.popleft()\\r\n            result.append(node)\\r\n            for pre_node in income_node[node]:\\r\n                outdegree[pre_node] -= 1\\r\n                if outdegree[pre_node] == 0:\\r\n                    q.append(pre_node)\\r\n        \\r\n        return sorted(result)\\r\n\\r\ndef __starting_point():\\r\n    sol = Solution()\\r\n    graph = [[1,2],[2,3],[5],[0],[5],[],[]]\\r\n    sol.eventualSafeNodes(graph)\\r\n\\r\n\\r\n\\r\n        \\r\n\\r\n                \\r\n\\r\n\\r\n        \n__starting_point()", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        #Alternate solution to white gray black\n        \n        # white - not visited\n        # grey - currently visiting\n        # black - completely visited (so that we don't repeat it)\n        \n        unsafe_nodes = set()\n        \n        safe_nodes = set()\n        \n        def dfs(node, visited):\n            if node in visited:\n                return False\n            \n            visited.add(node)\n            for neighbor in graph[node]:\n                if neighbor in unsafe_nodes:\n                    unsafe_nodes.add(node)\n                    return False\n                if neighbor in safe_nodes:\n                    continue\n                if not dfs(neighbor, visited):\n                    unsafe_nodes.add(node)\n                    return False\n     \n            safe_nodes.add(node)\n            return True\n        \n        for i in range(len(graph)):\n            dfs(i,set())\n                \n        return list(sorted(safe_nodes))", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        parent_g=collections.defaultdict(list)\n        visited=set()\n        queue=[]\n        for i in range(len(graph)):\n            if len(graph[i])==0:\n                queue.append(i)\n            for c in graph[i]:\n                parent_g[c].append(i)\n        while(queue):\n            current=queue.pop(0)\n            flag=True\n            for c in graph[current]:\n                if not c in visited:\n                    flag=False\n                    break\n            if flag:\n                visited.add(current)\n                for p in parent_g[current]:\n                    if not p in visited:\n                        queue.append(p)\n        return sorted(list(visited))\n                \n", "class Solution:\n    # if cycle then not safe else safe\n        # we can tell if there's a cycle by keeping track of visited for all paths eminating from node\n    # DP: keep track of set of nodes that are not safe so that if we see it again we know not safe automatically\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        ans, dp, visited = [], {}, set()\n        \n        def dfs_visit(i):\n            if i in visited: return False\n            if i in dp: return dp[i]\n            visited.add(i)\n            valid = True\n            if graph[i]:\n                valid = all([ dfs_visit(j) for j in graph[i] ])\n            visited.remove(i)\n            dp[i] = valid\n            return valid\n        \n        \n        for i in range(len(graph)):\n            if dfs_visit(i):\n                ans.append(i)\n        return ans\n    \n    \n    \n    \n    \n        \n", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        w,g,b = 0,1,2\n        color = collections.defaultdict(int)\n        def dfs(node):\n            if color[node] != w:\n                return color[node] == b\n            color[node] = g\n            for child in graph[node]:\n                if color[child] == b:\n                    continue\n                elif color[child] == g or not dfs(child):\n                    return False\n            color[node] = b\n            return True\n        ans = []\n        for i in range(len(graph)):\n            if dfs(i) == True:\n                ans.append(i)\n        return ans", "class Solution:\n  def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n    n = len(graph)\n    state = [-1] * n # -1 = unvisited, 0 = involved in directed cycle, 1 = eventually safe\n    result = []\n    \n    def dfs(node):\n      state[node] = 0 # may be involved in a cycle\n      for adj in graph[node]:\n        if state[adj] == 0 or (state[adj] == -1 and dfs(adj)):\n          return True\n      state[node] = 1\n      result.append(node)\n    \n    for i in range(n):\n      if state[i] == -1:\n        dfs(i)\n    \n    return sorted(result)\n    \n", "import collections \n\nclass Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        WHITE, GRAY, BLACK = 0, 1,2\n        color_of_nodes = collections.defaultdict(int)\n        def dfs(node):\n            if color_of_nodes[node] != WHITE:\n                return color_of_nodes[node] == BLACK \n            \n            color_of_nodes[node] = GRAY\n            for nei in graph[node]:\n                if color_of_nodes[nei] == GRAY or not dfs(nei):\n                    return False \n            color_of_nodes[node] = BLACK\n            return True\n        \n        res = []\n        for i, node in enumerate(graph):\n            if dfs(i):\n                res.append(i)\n        return res \n                    \n                \n        \n    \n", "class Solution(object):\n    def eventualSafeNodes(self, graph):\n        N = len(graph)\n        T = set([n for n in range(N) if not graph[n]])\n        V = set()\n        def dfs(node,visited):\n            if node in T:\n                return True\n            if node in V or node in visited:\n                return False\n            visited.append(node)\n            for n in graph[node]:\n                if not dfs(n,visited):\n                    V.add(node)\n                    V.add(n)\n                    return False\n                else:\n                    T.add(n)\n            T.add(node)\n            return True\n        res = [n for n in range(N) if dfs(n,[])]\n        return res", "class Solution:\n    def __init__(self):\n        self.d = {}\n        self.safe_nodes = {}\n    \n    def safe_finder(self, cur_node):\n        if len(self.d[cur_node]) == 0:\n            self.safe_nodes[cur_node] = True\n            return True\n        \n        for n in self.d[cur_node]:\n            print(cur_node,n)\n            if n == cur_node:\n                self.safe_nodes[cur_node] = False\n                return False\n            \n            if n in self.safe_nodes.keys():\n                if self.safe_nodes[n] == False:\n                    self.safe_nodes[cur_node] = False\n                    return False\n            else:\n                self.safe_nodes[n] = False\n                tmp = Solution.safe_finder(self, n)\n                if tmp == False:\n                    self.safe_nodes[cur_node] = False\n                    return False\n        \n        self.safe_nodes[cur_node] = True\n        return True\n                \n            \n        \n    \n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        \n        for i in range(len(graph)):\n            node = graph[i]\n            self.d[i] = []\n            for edge in node:\n                self.d[i].append(edge)\n        \n        # print(self.d)\n        for k in self.d.keys():\n            Solution.safe_finder(self,k)\n        \n        answer = []\n        for k,v in self.safe_nodes.items():\n            if v == True:\n                answer.append(k)\n        \n        return sorted(answer)", "from collections import deque, defaultdict\nclass Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        N = len(graph)\n        safe_states = [False] * N\n        \n        another_graph = defaultdict(set)\n        q = collections.deque()\n        \n        for i, js in enumerate(graph):\n            if not js:\n                q.append(i)\n            \n            for j in js:\n                another_graph[j].add(i)\n        \n        print((graph, another_graph))\n        \n        while q:\n            u = q.popleft()\n            safe_states[u] = True\n            \n            for v in another_graph[u]:\n                graph[v].remove(u)\n                \n                if len(graph[v]) == 0:\n                    q.append(v)\n        \n        return [u for u, v in enumerate(safe_states) if v]\n        \n", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        def cycle(ind):\n            if color[ind] == 1:\n                return True   # true means that there is a cycle\n            if color[ind] == 2:\n                return False   # no cycle is present\n            \n            color[ind] = 1\n            \n            for node in graph[ind]:\n                if cycle(node):\n                    return True            \n            color[ind] = 2\n            return False\n  \n        \n        n = len(graph)\n        color = [0]*n  \n        \n        for i in range(len(graph)):\n            cycle(i)     \n        \n        return [i for i in range(n) if color[i] == 2]", "from collections import deque\nclass Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        def explore(i):   ##checks for cycle (true)\n            colors[i] = 1\n            for j in graph[i]:\n                if ((colors[j]==0 and explore(j)) or colors[j] == 1):\n                    return True\n            colors[i] = 2\n            res.append(i)\n            return False\n        colors = [0 for i in range(len(graph))]\n        #0 - white, 1 - gray, 2 - black\n        #0 - unvisited, 1 - under processing, 2 - visited\n        res = []\n        for i in range(len(graph)):\n            if colors[i] == 0:\n                explore(i)\n        return sorted(res)", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        g = dict(enumerate(graph))\n        \n        safe = [-1] * len(g)\n        \n        def dfs(v):\n            if safe[v] >= 0:\n                return safe[v]\n            \n            if v not in g:\n                safe[v] = 0\n                return 0\n            \n            children = g.pop(v)\n            \n            if all(map(dfs, children)):\n                safe[v] = 1\n                return 1\n            \n            safe[v] = 0\n            return 0\n        \n        for i in range(len(g)):\n            dfs(i)\n        \n        return [i for i, s in enumerate(safe) if s > 0]\n                \n            \n            # if (1) all of my children are safe\n            # if (2) \n            \n            \n            \n        \n        \n", "class Solution:\n    \n    # Check each vertex to see if its part of a cycle\n    # If it is, it is not a safe vertex.\n    \n    # All nodes in that cycle are not considered to be safe vertices\n    \n    # Nodes that have no directed edges are also considered to be safe.\n    \n    # A node is considered safe it all its edges are to nodes that will eventually\n    # become safe. So it one edge points to a safe node, but the other edge points to a \n    # cycle, that node is stil considered unsafe.\n    \n    # Even union find fails algo? Yes. You can group up safe nodes with cycles\n    # Union find helps you prevent cycles, but not this application.\n    \n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        \n        # If parent node i has no incoming edges (i,j) where parent (k) of \n        # node j is also a child of i, then it is not a cycle.\n        \n        # Let's say parent of i is safe\n        # remove (i,j) from graphDict for child node j\n        \n        # Do so for all child of i, so that graphDict[i] has no more result \n        # (no more outgoing edges)\n        \n        #  Need to check all incoming edges though?\n        \n        # Just because its children are safe doesn't mean parent is safe.\n        # The reverse is not true. If even one of its children is not safe, the \n        # parent is not safe. -> So if all children are safe, parent is safe.\n        \n        # Node j (child) is safe and in queue\n        # i in reverseGraphDict[j], so remove (i,j) from graphDict\n        # Loop. If all (i,j) is removed from graphDict, so \n        # graphDict[i] contains empty set(), then parent is also successfully safe.\n        \n        #    0     1    2   3   4   5  6      all parents\n        # [[1,2],[2,3],[5],[0],[5],[],[]]    all children     \n        \\\"\\\"\\\"\n        N = len(graph)\n        safe = [False] * N\n\n        graph = list(map(set, graph))\n        rgraph = [set() for _ in range(N)]\n        q = collections.deque()\n\n        for i, js in enumerate(graph):\n            if not js:\n                q.append(i)\n            for j in js:\n                rgraph[j].add(i)\n\n        while q:\n            j = q.pop()\n            safe[j] = True\n            for i in rgraph[j]:\n                graph[i].remove(j)\n                if len(graph[i]) == 0:\n                    q.append(i)\n\n        return [i for i, v in enumerate(safe) if v]\\\"\\\"\\\"\n        \n        \n        \n        \n        \n        N = len(graph)\n        safe = [False] * N\n        \n        graph = list(map(set,graph))\n        print(graph)\n        for elem in graph:\n            print(elem)\n        reverseGraphDict = [set() for _ in range(N)]\n\n        safeQueue = collections.deque()\n        \n        for parent, children in enumerate(graph):\n            # If there is no children (empty[]), terminal node\n            if not children:\n                safeQueue.append(parent)\n                \n            for child in children:\n                # Don't do dfs here\n                reverseGraphDict[child].add(parent) # a child can have multiple parents\n                \n                \n                \n        while safeQueue:\n            child = safeQueue.popleft()\n            safe[child] = True\n            for parent in reverseGraphDict[child]:\n                graph[parent].remove(child)\n                \n                # Parent is safe too, so push it into queue\n                if len(graph[parent]) == 0:\n                    #safe[parent] = True # Wil be taken care at top of loop\n                    safeQueue.append(parent)\n                \n        return [idx for idx, boolean in enumerate(safe) if boolean == True]\n            \n        \\\"\\\"\\\"\n        # Try DFS. Use a set to keep track of nodes already seen\n        seenSet = set()\n        safeList = []\n        \n        # Add parent to seenSet\n        # Iterate over all connections to children from parent\n        # dfs for each of those connections\n        \n        def dfs(parent):\n            nonlocal graph\n            nonlocal seenSet\n            \n            if parent in seenSet: # Already discovered before\n            \n            seenSet.add(parent)\n            \n            for edge in graph:\n                if edge[0] == parent:\n                    dfs(edge[1])\n            \n        \n        \n        \n        \\\"\\\"\\\"\n        '''\n        # Loop over all nodes in graph, make them their own group\n        for edge in graph:\n            parent = edge[0]\n            \n            # group.newGroup(parent)\n        \n        \n        for edge in graph:\n            parent = edge[0]\n            child = edge[1]'''\n            \n            # group parent and child together\n            \n            # if child is already grouped with parent (cycle),\n            # Those nodes in the group cannot be part of the answer.\n            \n            # But if the parent/child has only one connection to all \n            # the nodes within the group that has the cycle, that node\n            # (though connect) is technically safe.\n            \n            ", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        m = len(graph)\n        color = [0] * m\n        def dfs(i):\n            if color[i]:\n                return color[i] == 1\n            color[i] = 2\n            for n in graph[i]:\n                if not dfs(n):\n                    return False\n            color[i] = 1\n            return True\n        output = []\n        for i in range(m):\n            if dfs(i):\n                output.append(i)\n        return output", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        colour = [0] * len(graph)\n        def dfs(i):\n            if colour[i] != 0:\n                return colour[i] == 2\n\n            colour[i] = 1\n            for c in graph[i]:\n                if not dfs(c):\n                    return False\n            colour[i] = 2\n            return True\n\n        for node in range(len(graph)):\n            dfs(node)\n        return [i for i in range(len(graph)) if colour[i] == 2]\n", "import collections\nclass Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        res = []\n        visited = collections.defaultdict(int)\n        N = len(graph)\n        for i in range(N):\n            if self.dfs(graph, i, visited):\n                res.append(i)\n        return res\n    \n    def dfs(self, graph, node, visited):\n        if visited[node] == 1:\n            return False\n        if visited[node] == 2:\n            return True\n        visited[node] = 1\n        for n in graph[node]:\n            if not self.dfs(graph, n, visited):\n                return False\n        visited[node] = 2\n        return True", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        n = len(graph)\n        color = [0 for _ in range(n)] # 0 white, 1 gray, 2 black\n        res = []\n        for node_index in range(n):\n            if self.dfs(graph, index=node_index, color=color):\n                res.append(node_index)\n        return res\n            \n    \n    def dfs(self, graph, index, color):\n        if color[index] > 0:\n            return color[index] == 2\n        \n        color[index] = 1\n        \n        for j in graph[index]:\n            if color[j] == 2:\n                continue\n            elif color[j] == 1 or not self.dfs(graph, j, color):\n                return False\n        \n        color[index] = 2\n        return True\n", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        # BFS\n        safe = [False] * len(graph)\n        rev = [set() for _ in range(len(graph))]\n        queue = collections.deque()\n        \n        for i, nodes in enumerate(graph):\n            if not nodes:\n                queue.append(i)\n            else:\n                for node in nodes:\n                    rev[node].add(i)\n        \n        while queue:\n            curr = queue.popleft()\n            safe[curr] = True\n            for j in rev[curr]:\n                graph[j].remove(curr)\n                if len(graph[j]) == 0:\n                    queue.append(j)\n        return [i for i, val in enumerate(safe) if val]\n        \n        \n        # DFS\n#         W, G, B = 0, 1, 2     # gray: entry; black: exit\n#         color = collections.defaultdict(int)\n        \n#         def dfs(node):\n#             if color[node] == G:\n#                 return False\n#             if color[node] == B:\n#                 return True\n            \n#             color[node] = G\n#             for nei in graph[node]:\n#                 if color[nei] == B:\n#                     continue\n#                 if color[nei] == G or not dfs(nei):\n#                     return False\n                \n#             color[node] = B\n#             return True\n            \n        \n#         res = []\n#         for i in range(len(graph)):\n#             if dfs(i): res.append(i)\n#         return res\n", "class Solution:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        seen, safe = set(), set()\n        def dfs(u):\n            if u in seen: return u in safe\n            seen.add(u)\n            if all(dfs(v) for v in graph[u]): safe.add(u); return True\n        return list(filter(lambda u: dfs(u), range(len(graph))))", "class Solution:\n    \n    # Check each vertex to see if its part of a cycle\n    # If it is, it is not a safe vertex.\n    \n    # All nodes in that cycle are not considered to be safe vertices\n    \n    # Nodes that have no directed edges are also considered to be safe.\n    \n    # A node is considered safe it all its edges are to nodes that will eventually\n    # become safe. So it one edge points to a safe node, but the other edge points to a \n    # cycle, that node is stil considered unsafe.\n    \n    # Even union find fails algo? Yes. You can group up safe nodes with cycles\n    # Union find helps you prevent cycles, but not this application.\n    \n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        \n        # If parent node i has no incoming edges (i,j) where parent (k) of \n        # node j is also a child of i, then it is not a cycle.\n        \n        # Let's say parent of i is safe\n        # remove (i,j) from graphDict for child node j\n        \n        # Do so for all child of i, so that graphDict[i] has no more result \n        # (no more outgoing edges)\n        \n        #  Need to check all incoming edges though?\n        \n        # Just because its children are safe doesn't mean parent is safe.\n        # The reverse is not true. If even one of its children is not safe, the \n        # parent is not safe. -> So if all children are safe, parent is safe.\n        \n        # Node j (child) is safe and in queue\n        # i in reverseGraphDict[j], so remove (i,j) from graphDict\n        # Loop. If all (i,j) is removed from graphDict, so \n        # graphDict[i] contains empty set(), then parent is also successfully safe.\n        \n        #    0     1    2   3   4   5  6      all parents\n        # [[1,2],[2,3],[5],[0],[5],[],[]]    all children     \n        \\\"\\\"\\\"\n        N = len(graph)\n        safe = [False] * N\n\n        graph = list(map(set, graph))\n        rgraph = [set() for _ in range(N)]\n        q = collections.deque()\n\n        for i, js in enumerate(graph):\n            if not js:\n                q.append(i)\n            for j in js:\n                rgraph[j].add(i)\n\n        while q:\n            j = q.pop()\n            safe[j] = True\n            for i in rgraph[j]:\n                graph[i].remove(j)\n                if len(graph[i]) == 0:\n                    q.append(i)\n\n        return [i for i, v in enumerate(safe) if v]\\\"\\\"\\\"\n        \n        \n        \n        \n        \n        N = len(graph)\n        safe = [False] * N\n        \n        graph = list(map(set,graph))\n        print(graph)\n        for elem in graph:\n            print(elem)\n        reverseGraphDict = [set() for _ in range(N)]\n\n        safeQueue = collections.deque()\n        \n        for parent, children in enumerate(graph):\n            # If there is no children (empty[]), terminal node\n            if not children:\n                safeQueue.append(parent)\n                \n            for child in children:\n                # Don't do dfs here\n                reverseGraphDict[child].add(parent) # a child can have multiple parents\n                \n                \n                \n        while safeQueue:\n            child = safeQueue.pop()\n            safe[child] = True\n            for parent in reverseGraphDict[child]:\n                graph[parent].remove(child)\n                \n                # Parent is safe too, so push it into queue\n                if len(graph[parent]) == 0:\n                    #safe[parent] = True # Wil be taken care at top of loop\n                    safeQueue.append(parent)\n                \n        return [idx for idx, boolean in enumerate(safe) if boolean == True]\n            \n        \\\"\\\"\\\"\n        # Try DFS. Use a set to keep track of nodes already seen\n        seenSet = set()\n        safeList = []\n        \n        # Add parent to seenSet\n        # Iterate over all connections to children from parent\n        # dfs for each of those connections\n        \n        def dfs(parent):\n            nonlocal graph\n            nonlocal seenSet\n            \n            if parent in seenSet: # Already discovered before\n            \n            seenSet.add(parent)\n            \n            for edge in graph:\n                if edge[0] == parent:\n                    dfs(edge[1])\n            \n        \n        \n        \n        \\\"\\\"\\\"\n        '''\n        # Loop over all nodes in graph, make them their own group\n        for edge in graph:\n            parent = edge[0]\n            \n            # group.newGroup(parent)\n        \n        \n        for edge in graph:\n            parent = edge[0]\n            child = edge[1]'''\n            \n            # group parent and child together\n            \n            # if child is already grouped with parent (cycle),\n            # Those nodes in the group cannot be part of the answer.\n            \n            # But if the parent/child has only one connection to all \n            # the nodes within the group that has the cycle, that node\n            # (though connect) is technically safe.\n            \n            "]