["import sys\nsys.setrecursionlimit(10000000)\ndef mergeSortInversions(arr):\n  if len(arr) == 1:\n    return arr, 0\n  larr=len(arr)\n  a = arr[:larr//2]\n  b = arr[larr//2:]\n  a, ai = mergeSortInversions(a)\n  b, bi = mergeSortInversions(b)\n  c = []\n  i = 0\n  j = 0\n  inversions = 0 + ai + bi\n  la=len(a)\n  while i < la and j < len(b):\n    if a[i] <= b[j]:\n      c.append(a[i])\n      i += 1\n    else:\n      c.append(b[j])\n      j += 1\n      inversions += (la-i)\n  c += a[i:]\n  c += b[j:]\n  return c, inversions \nfor _ in range(int(input())):\n  n,d=list(map(int,input().split()))\n  p=[int(o) for o in input().split()]\n  array=[[] for i in range(d)]\n  flag=0\n  for i in range(n):\n    array[i%d].append(p[i])\n    if p[i]%((i%d)+1)!=0:\n      flag=1\n  \n \n  ans=0\n  dumarr=[0]*n\n  for i in range(d):\n    array[i],v=mergeSortInversions(array[i])\n    for j in range(len(array[i])):\n      dumarr[i+j*d]=array[i][j]\n    ans+=v\n  p=sorted(p)\n  # print(dumarr)\n  if dumarr==p:\n    print(ans)\n  else:\n    print(-1)\n", "import sys\nsys.setrecursionlimit(10000000)\ndef mergeSortInversions(arr):\n  if len(arr) == 1:\n    return arr, 0\n  larr=len(arr)\n  a = arr[:larr//2]\n  b = arr[larr//2:]\n  a, ai = mergeSortInversions(a)\n  b, bi = mergeSortInversions(b)\n  c = []\n  i = 0\n  j = 0\n  inversions = 0 + ai + bi\n  la=len(a)\n  while i < la and j < len(b):\n    if a[i] <= b[j]:\n      c.append(a[i])\n      i += 1\n    else:\n      c.append(b[j])\n      j += 1\n      inversions += (la-i)\n  c += a[i:]\n  c += b[j:]\n  return c, inversions \nfor _ in range(int(input())):\n  n,d=list(map(int,input().split()))\n  p=[int(o) for o in input().split()]\n  array=[[] for i in range(d)]\n  flag=0\n  for i in range(n):\n    array[i%d].append(p[i])\n    if p[i]%((i%d)+1)!=0:\n      flag=1\n  \n \n  ans=0\n  dumarr=[0]*n\n  for i in range(d):\n    array[i],v=mergeSortInversions(array[i])\n    for j in range(len(array[i])):\n      dumarr[i+j*d]=array[i][j]\n    ans+=v\n  p=sorted(p)\n  # print(dumarr)\n  if dumarr==p:\n    print(ans)\n  else:\n    print(-1)\n", "# cook your dish here\ndef mergeSort(arr, n):\n temp_arr = [0] * n\n return _mergeSort(arr, temp_arr, 0, n - 1)\n\n\ndef _mergeSort(arr, temp_arr, left, right):\n inv_count = 0\n\n if left < right:\n  mid = (left + right) // 2\n\n  inv_count += _mergeSort(arr, temp_arr, left, mid)\n\n  inv_count += _mergeSort(arr, temp_arr, mid + 1, right)\n\n  inv_count += merge(arr, temp_arr, left, mid, right)\n return inv_count\n\n\ndef merge(arr, temp_arr, left, mid, right):\n i = left\n j = mid + 1\n k = left\n inv_count = 0\n\n while i <= mid and j <= right:\n\n  if arr[i] <= arr[j]:\n   temp_arr[k] = arr[i]\n   k += 1\n   i += 1\n  else:\n\n   temp_arr[k] = arr[j]\n   inv_count += (mid - i + 1)\n   k += 1\n   j += 1\n\n while i <= mid:\n  temp_arr[k] = arr[i]\n  k += 1\n  i += 1\n\n while j <= right:\n  temp_arr[k] = arr[j]\n  k += 1\n  j += 1\n\n for loop_var in range(left, right + 1):\n  arr[loop_var] = temp_arr[loop_var]\n\n return inv_count\n\n\nt=int(input())\nfor _ in range(0,t):\n n,D=list([int(x) for x in input().split()])\n p=list([int(x) for x in input().split()])\n q=[0]*len(p)\n for i in range(n):\n  q[p[i]-1]=i\n sublists=[]\n \n for i in range(0,D):\n  sublist=[]\n  for j in range(i,len(p),D):\n   sublist.append(q[j])\n  sublists.append(sublist)\n \n \n flag=0\n \n for i in range(0,D):\n  temp_sublist=sorted(sublists[i])\n  for j in range(0,len(sublists[i])):\n   if i+j*D!=temp_sublist[j]:\n    print(-1)\n    flag=1\n    break\n  if flag==1:\n   break\n if flag==0:\n  total=sum([mergeSort(sublist,len(sublist)) for sublist in sublists ])\n  print(total)\n", "import sys\nsys.setrecursionlimit(10000000)\ndef mergeSortInversions(arr):\n  if len(arr) == 1:\n    return arr, 0\n  larr=len(arr)\n  a = arr[:larr//2]\n  b = arr[larr//2:]\n  a, ai = mergeSortInversions(a)\n  b, bi = mergeSortInversions(b)\n  c = []\n  i = 0\n  j = 0\n  inversions = 0 + ai + bi\n  la=len(a)\n  while i < la and j < len(b):\n    if a[i] <= b[j]:\n      c.append(a[i])\n      i += 1\n    else:\n      c.append(b[j])\n      j += 1\n      inversions += (la-i)\n  c += a[i:]\n  c += b[j:]\n  return c, inversions \nfor _ in range(int(input())):\n  n,d=list(map(int,input().split()))\n  p=[int(o) for o in input().split()]\n  array=[[] for i in range(d)]\n  flag=0\n  for i in range(n):\n    array[i%d].append(p[i])\n    if p[i]%((i%d)+1)!=0:\n      flag=1\n  ans=0\n  dumarr=[0]*n\n  for i in range(d):\n    array[i],v=mergeSortInversions(array[i])\n    for j in range(len(array[i])):\n      dumarr[i+j*d]=array[i][j]\n    ans+=v\n  p=sorted(p)\n  if dumarr==p:\n    print(ans)\n  else:\n    print(-1)\n", "import sys\nsys.setrecursionlimit(10000000)\ndef mergeSortInversions(arr):\n  if len(arr) == 1:return arr, 0\n  larr=len(arr)\n  a,b = arr[:larr//2],arr[larr//2:] \n  a, ai = mergeSortInversions(a)\n  b, bi = mergeSortInversions(b)\n  c,i,j = [],0,0\n  inversions = 0 + ai + bi\n  la=len(a)\n  while i < la and j < len(b):\n    if a[i] <= b[j]:\n      c.append(a[i])\n      i += 1\n    else:\n      c.append(b[j])\n      j ,inversions = j+1,inversions + (la-i)\n  c += (a[i:]+b[j:])\n  return c, inversions \nfor _ in range(int(input())):\n  n,d=map(int,input().split())\n  p=[int(o) for o in input().split()]\n  array,flag,ans,dumarr = [[] for i in range(d)],0,0,[0]*n\n  for i in range(n):\n    array[i%d].append(p[i])\n    if p[i]%((i%d)+1)!=0:flag=1\n  for i in range(d):\n    array[i],v=mergeSortInversions(array[i])\n    for j in range(len(array[i])):dumarr[i+j*d]=array[i][j]\n    ans+=v\n  print(ans) if dumarr==sorted(p) else print(-1)", "\ndef getSum( BITree, index): \n sum = 0 \n while (index > 0): \n  sum += BITree[index] \n  index -= index & (-index) \n return sum\ndef updateBIT(BITree, n, index, val): \n while (index <= n): \n  BITree[index] += val \n  index += index & (-index) \ndef getInvCount(arr, n): \n invcount = 0 \n maxElement = max(arr) \n BIT = [0] * (maxElement + 1) \n for i in range(1, maxElement + 1): \n  BIT[i] = 0\n for i in range(n - 1, -1, -1): \n  invcount += getSum(BIT, arr[i] - 1) \n  updateBIT(BIT, maxElement, arr[i], 1) \n return invcount \nimport sys\ninput=sys.stdin.readline \nfor _ in range(int(input())):\n n,k=map(int,input().split())\n l=[int(i) for i in input().split()]\n f=1 \n sm=0\n for x in range(k):\n  mat=[]\n  li=[]\n  le=0 \n  c={}\n  for y in range(x,n,k):\n   mat.append(l[y])\n   li.append(y+1)\n   le+=1 \n   c[l[y]]=1 \n  for y in range(x,n,k):\n   if c.get(y+1,-1)==-1:\n    f=0 \n    break \n  else:\n   sm+=getInvCount(mat,le)\n if f==0:\n  print(-1)\n else: \n  print(sm)", "# Python3 program to count inversions using \n# Binary Indexed Tree \n\n# Returns sum of arr[0..index]. This function \n# assumes that the array is preprocessed and \n# partial sums of array elements are stored \n# in BITree[]. \ndef getSum( BITree, index): \n sum = 0 # Initialize result \n \n # Traverse ancestors of BITree[index] \n while (index > 0): \n\n  # Add current element of BITree to sum \n  sum += BITree[index] \n\n  # Move index to parent node in getSum View \n  index -= index & (-index) \n\n return sum\n\n# Updates a node in Binary Index Tree (BITree) \n# at given index in BITree. The given value \n# 'val' is added to BITree[i] and all of its \n# ancestors in tree. \ndef updateBIT(BITree, n, index, val): \n\n # Traverse all ancestors and add 'val' \n while (index <= n): \n\n  # Add 'val' to current node of BI Tree \n  BITree[index] += val \n\n  # Update index to that of parent \n  # in update View \n  index += index & (-index) \n\n# Returns count of inversions of size three \ndef getInvCount(arr, n): \n\n invcount = 0 # Initialize result \n\n # Find maximum element in arrays \n maxElement = max(arr) \n\n # Create a BIT with size equal to \n # maxElement+1 (Extra one is used \n # so that elements can be directly \n # be used as index) \n BIT = [0] * (maxElement + 1) \n for i in range(1, maxElement + 1): \n  BIT[i] = 0\n for i in range(n - 1, -1, -1): \n\n  invcount += getSum(BIT, arr[i] - 1) \n  updateBIT(BIT, maxElement, arr[i], 1) \n return invcount \n \n\n \n# This code is contributed by \n# Shubham Singh(SHUBHAMSINGH10) \n\nfor _ in range(int(input())):\n n,k=map(int,input().split())\n l=[int(i) for i in input().split()]\n if k==1:\n  print(getInvCount(l,n))\n  continue \n mat=l[:]\n f=1 \n sm=0\n from collections import Counter\n for x in range(k):\n  mat=[]\n  li=[]\n  le=0 \n  for y in range(x,n,k):\n   mat.append(l[y])\n   li.append(y+1)\n   le+=1 \n  # print(mat,li)\n  if Counter(mat)!=Counter(li):\n   f=0\n   break \n  else:\n   sm+=getInvCount(mat,len(mat))\n    \n if f==0:\n  print(-1)\n else: \n  print(sm)", "# Python3 program to count inversions using \n# Binary Indexed Tree \n\n# Returns sum of arr[0..index]. This function \n# assumes that the array is preprocessed and \n# partial sums of array elements are stored \n# in BITree[]. \ndef getSum( BITree, index): \n sum = 0 # Initialize result \n \n # Traverse ancestors of BITree[index] \n while (index > 0): \n\n  # Add current element of BITree to sum \n  sum += BITree[index] \n\n  # Move index to parent node in getSum View \n  index -= index & (-index) \n\n return sum\n\n# Updates a node in Binary Index Tree (BITree) \n# at given index in BITree. The given value \n# 'val' is added to BITree[i] and all of its \n# ancestors in tree. \ndef updateBIT(BITree, n, index, val): \n\n # Traverse all ancestors and add 'val' \n while (index <= n): \n\n  # Add 'val' to current node of BI Tree \n  BITree[index] += val \n\n  # Update index to that of parent \n  # in update View \n  index += index & (-index) \n\n# Returns count of inversions of size three \ndef getInvCount(arr, n): \n\n invcount = 0 # Initialize result \n\n # Find maximum element in arrays \n maxElement = max(arr) \n\n # Create a BIT with size equal to \n # maxElement+1 (Extra one is used \n # so that elements can be directly \n # be used as index) \n BIT = [0] * (maxElement + 1) \n for i in range(1, maxElement + 1): \n  BIT[i] = 0\n for i in range(n - 1, -1, -1): \n\n  invcount += getSum(BIT, arr[i] - 1) \n  updateBIT(BIT, maxElement, arr[i], 1) \n return invcount \n \n\n \n# This code is contributed by \n# Shubham Singh(SHUBHAMSINGH10) \n\nfor _ in range(int(input())):\n n,k=map(int,input().split())\n l=[int(i) for i in input().split()]\n if k==1:\n  print(getInvCount(l,n))\n  continue \n mat=l[:]\n f=1 \n sm=0\n from collections import Counter\n for x in range(k):\n  mat=[]\n  li=[]\n  le=0 \n  for y in range(x,n,k):\n   mat.append(l[y])\n   li.append(y+1)\n   le+=1 \n  # print(mat,li)\n  if Counter(mat)!=Counter(li):\n   f=0\n   break \n  else:\n   li=[]\n   le=len(mat)\n   for i in range(le):\n    curr=[mat[i],i]\n    li.append(curr)\n   li.sort() \n   vis=[0]*le \n   for i in range(le):\n    if vis[i] or li[i][1]==i:\n     continue \n    c=0 \n    j=i \n    while not vis[j]:\n     vis[j]=1 \n     j=li[j][1]\n     c+=1 \n    if c:\n     sm+=(c-1)\n    \n if f==0:\n  print(-1)\n else: \n  print(sm)", "import sys\nsys.setrecursionlimit(10000000)\ndef mergeSortInversions(arr):\n  if len(arr) == 1:\n    return arr, 0\n  larr=len(arr)\n  a = arr[:larr//2]\n  b = arr[larr//2:]\n  a, ai = mergeSortInversions(a)\n  b, bi = mergeSortInversions(b)\n  c = []\n  i = 0\n  j = 0\n  inversions = 0 + ai + bi\n  la=len(a)\n  while i < la and j < len(b):\n    if a[i] <= b[j]:\n      c.append(a[i])\n      i += 1\n    else:\n      c.append(b[j])\n      j += 1\n      inversions += (la-i)\n  c += a[i:]\n  c += b[j:]\n  return c, inversions \nfor _ in range(int(input())):\n  n,d=list(map(int,input().split()))\n  p=[int(o) for o in input().split()]\n  array=[[] for i in range(d)]\n  flag=0\n  for i in range(n):\n    array[i%d].append(p[i])\n    if p[i]%((i%d)+1)!=0:\n      flag=1\n  \n \n  ans=0\n  dumarr=[0]*n\n  for i in range(d):\n    array[i],v=mergeSortInversions(array[i])\n    for j in range(len(array[i])):\n      dumarr[i+j*d]=array[i][j]\n    ans+=v\n  p=sorted(p)\n  # print(dumarr)\n  if dumarr==p:\n    print(ans)\n  else:\n    print(-1)\n", "import sys\nsys.setrecursionlimit(10000000)\ndef mergeSortInversions(arr):\n  if len(arr) == 1:\n    return arr, 0\n  larr=len(arr)\n  a = arr[:larr//2]\n  b = arr[larr//2:]\n  a, ai = mergeSortInversions(a)\n  b, bi = mergeSortInversions(b)\n  c = []\n  i = 0\n  j = 0\n  inversions = 0 + ai + bi\n  la=len(a)\n  while i < la and j < len(b):\n    if a[i] <= b[j]:\n      c.append(a[i])\n      i += 1\n    else:\n      c.append(b[j])\n      j += 1\n      inversions += (la-i)\n  c += a[i:]\n  c += b[j:]\n  return c, inversions \nfor _ in range(int(input())):\n  n,d=list(map(int,input().split()))\n  p=[int(o) for o in input().split()]\n  array=[[] for i in range(d)]\n  flag=0\n  for i in range(n):\n    array[i%d].append(p[i])\n    if p[i]%((i%d)+1)!=0:\n      flag=1\n  # print(array)\n  if flag==1:\n    print(\"-1\")\n  else:\n    ans=0\n    for i in range(d):\n      #  print(array[i])\n      g,v=mergeSortInversions(array[i])\n      #  print(array[i],v)\n      ans+=v\n    print(ans)\n", "def merge(arr,start,mid,end):\n p=start\n q=mid+1\n k=0\n inv = 0\n temp=[0]*len(arr)\n for i in range(start,end+1):\n  if p>mid :\n   temp[k]=arr[q]\n   k+=1\n   q+=1\n  elif q>end:\n   temp[k]=arr[p]\n   k+=1\n   p+=1\n  elif arr[p]<=arr[q]:\n   temp[k]=arr[p]\n   p+=1\n   k+=1\n  else:\n   temp[k]=arr[q]\n   q+=1\n   k+=1\n   inv += (mid-p+1)\n for i in range(k):\n  arr[start]=temp[i]\n  start+=1\n \n return inv\n\ndef mergesort(arr,start,end):\n inv_count=0 \n if start<end:\n  mid=(start+end)//2\n  inv_count += mergesort(arr,start,mid)\n  inv_count += mergesort(arr,mid+1,end)\n  inv_count += merge(arr,start,mid,end)\n return inv_count\n\n\ndef solve():\n n,d = map(int, input().split())\n p = list(map(int, input().split()))\n \n inv_count = 0\n m=[0]*n\n sb = True #sortable\n for i in range(d):\n  k=0\n  for j in range(i,n,d):\n   m[k]=p[j]\n   k+=1\n  inv_count += mergesort(m,0,k-1)\n  \n  k=0\n  for j in range(i,n,d):\n   if not(m[k] == (j+1)):\n    sb=False\n    break\n   k+=1\n  \n if sb:\n  print(inv_count)\n else:\n  print(-1)\n\ndef main():\n for _ in range(int(input())):\n  solve()\n\nmain()", "# cook your dish here\n# Python 3 program to count inversions in an array \n# Function to Use Inversion Count \ndef mergeSort(arr, n): \n # A temp_arr is created to store \n # sorted array in merge function \n temp_arr = [0]*n \n return _mergeSort(arr, temp_arr, 0, n-1) \n\n# This Function will use MergeSort to count inversions \n\ndef _mergeSort(arr, temp_arr, left, right): \n\n # A variable inv_count is used to store \n # inversion counts in each recursive call \n\n inv_count = 0\n\n # We will make a recursive call if and only if \n # we have more than one elements \n\n if left < right: \n\n  # mid is calculated to divide the array into two subarrays \n  # Floor division is must in case of python \n\n  mid = (left + right)//2\n\n  # It will calculate inversion counts in the left subarray \n\n  inv_count = _mergeSort(arr, temp_arr, left, mid) \n\n  # It will calculate inversion counts in right subarray \n\n  inv_count += _mergeSort(arr, temp_arr, mid + 1, right) \n\n  # It will merge two subarrays in a sorted subarray \n\n  inv_count += merge(arr, temp_arr, left, mid, right) \n return inv_count \n\n# This function will merge two subarrays in a single sorted subarray \ndef merge(arr, temp_arr, left, mid, right): \n i = left # Starting index of left subarray \n j = mid + 1 # Starting index of right subarray \n k = left # Starting index of to be sorted subarray \n inv_count = 0\n\n # Conditions are checked to make sure that i and j don't exceed their \n # subarray limits. \n\n while i <= mid and j <= right: \n\n  # There will be no inversion if arr[i] <= arr[j] \n\n  if arr[i] <= arr[j]: \n   temp_arr[k] = arr[i] \n   k += 1\n   i += 1\n  else: \n   # Inversion will occur. \n   temp_arr[k] = arr[j] \n   inv_count += (mid-i + 1) \n   k += 1\n   j += 1\n\n # Copy the remaining elements of left subarray into temporary array \n while i <= mid: \n  temp_arr[k] = arr[i] \n  k += 1\n  i += 1\n\n # Copy the remaining elements of right subarray into temporary array \n while j <= right: \n  temp_arr[k] = arr[j] \n  k += 1\n  j += 1\n\n # Copy the sorted subarray into Original array \n for loop_var in range(left, right + 1): \n  arr[loop_var] = temp_arr[loop_var] \n  \n return inv_count \n\n'''\ndef merge(arr,start,mid,end):\n    p=start\n    q=mid+1\n    k=0\n    inv = 0\n    temp=[0]*len(arr)\n    for i in range(start,end+1):\n     if p>mid :\n      temp[k]=arr[q]\n      k+=1\n      q+=1\n     elif q>end:\n      temp[k]=arr[p]\n      k+=1\n      p+=1\n     elif arr[p]<=arr[q]:\n      temp[k]=arr[p]\n      p+=1\n      k+=1\n     else:\n      temp[k]=arr[q]\n      q+=1\n      k+=1\n      inv += (mid-p+1)\n    for i in range(k):\n     arr[start]=temp[i]\n     start+=1\n \n    return inv\n\ndef mergesort(arr,start,end):\n    inv_count=0 \n    if start<end:\n     mid=(start+end)//2\n     inv_count += mergesort(arr,start,mid)\n     inv_count += mergesort(arr,mid+1,end)\n     inv_count += merge(arr,start,mid,end)\n    return inv_count\n\n'''\ndef solve():\n n,d = map(int, input().split())\n p = list(map(int, input().split()))\n \n inv_count = 0\n m={}\n sb = True #sortable\n for i in range(d):\n  k=0\n  for j in range(i,n,d):\n   m[k]=p[j]\n   k+=1\n  inv_count += mergeSort(m,k)\n  \n  k=0\n  for j in range(i,n,d):\n   if not(m[k] == (j+1)):\n    sb=False\n    break\n   k+=1\n  \n if sb:\n  print(inv_count)\n else:\n  print(-1)\n\ndef main():\n for _ in range(int(input())):\n  solve()\n\nmain()", "# cook your dish here\n# Python 3 program to count inversions in an array \n# Function to Use Inversion Count \ndef mergeSort(arr, n): \n # A temp_arr is created to store \n # sorted array in merge function \n temp_arr = [0]*n \n return _mergeSort(arr, temp_arr, 0, n-1) \n\n# This Function will use MergeSort to count inversions \n\ndef _mergeSort(arr, temp_arr, left, right): \n\n # A variable inv_count is used to store \n # inversion counts in each recursive call \n\n inv_count = 0\n\n # We will make a recursive call if and only if \n # we have more than one elements \n\n if left < right: \n\n  # mid is calculated to divide the array into two subarrays \n  # Floor division is must in case of python \n\n  mid = (left + right)//2\n\n  # It will calculate inversion counts in the left subarray \n\n  inv_count = _mergeSort(arr, temp_arr, left, mid) \n\n  # It will calculate inversion counts in right subarray \n\n  inv_count += _mergeSort(arr, temp_arr, mid + 1, right) \n\n  # It will merge two subarrays in a sorted subarray \n\n  inv_count += merge(arr, temp_arr, left, mid, right) \n return inv_count \n\n# This function will merge two subarrays in a single sorted subarray \ndef merge(arr, temp_arr, left, mid, right): \n i = left # Starting index of left subarray \n j = mid + 1 # Starting index of right subarray \n k = left # Starting index of to be sorted subarray \n inv_count = 0\n\n # Conditions are checked to make sure that i and j don't exceed their \n # subarray limits. \n\n while i <= mid and j <= right: \n\n  # There will be no inversion if arr[i] <= arr[j] \n\n  if arr[i] <= arr[j]: \n   temp_arr[k] = arr[i] \n   k += 1\n   i += 1\n  else: \n   # Inversion will occur. \n   temp_arr[k] = arr[j] \n   inv_count += (mid-i + 1) \n   k += 1\n   j += 1\n\n # Copy the remaining elements of left subarray into temporary array \n while i <= mid: \n  temp_arr[k] = arr[i] \n  k += 1\n  i += 1\n\n # Copy the remaining elements of right subarray into temporary array \n while j <= right: \n  temp_arr[k] = arr[j] \n  k += 1\n  j += 1\n\n # Copy the sorted subarray into Original array \n for loop_var in range(left, right + 1): \n  arr[loop_var] = temp_arr[loop_var] \n  \n return inv_count \n\n'''\ndef merge(arr,start,mid,end):\n    p=start\n    q=mid+1\n    k=0\n    inv = 0\n    temp=[0]*len(arr)\n    for i in range(start,end+1):\n     if p>mid :\n      temp[k]=arr[q]\n      k+=1\n      q+=1\n     elif q>end:\n      temp[k]=arr[p]\n      k+=1\n      p+=1\n     elif arr[p]<=arr[q]:\n      temp[k]=arr[p]\n      p+=1\n      k+=1\n     else:\n      temp[k]=arr[q]\n      q+=1\n      k+=1\n      inv += (mid-p+1)\n    for i in range(k):\n     arr[start]=temp[i]\n     start+=1\n \n    return inv\n\ndef mergesort(arr,start,end):\n    inv_count=0 \n    if start<end:\n     mid=(start+end)//2\n     inv_count += mergesort(arr,start,mid)\n     inv_count += mergesort(arr,mid+1,end)\n     inv_count += merge(arr,start,mid,end)\n    return inv_count\n\n'''\nfor _ in range(int(input())):\n n,d = list(map(int, input().split()))\n p = list(map(int, input().split()))\n \n inv_count = 0\n m={}\n sb = True #sortable\n for i in range(d):\n  k=0\n  for j in range(i,n,d):\n   m[k]=p[j]\n   k+=1\n  inv_count += mergeSort(m,k)\n  \n  k=0\n  for j in range(i,n,d):\n   if not(m[k] == (j+1)):\n    sb=False\n    break\n   k+=1\n  \n if sb:\n  print(inv_count)\n else:\n  print(-1)\n", "def merge(arr,start,mid,end):\n p=start\n q=mid+1\n k=0\n inv = 0\n temp=[0]*len(arr)\n for i in range(start,end+1):\n  if p>mid :\n   temp[k]=arr[q]\n   k+=1\n   q+=1\n  elif q>end:\n   temp[k]=arr[p]\n   k+=1\n   p+=1\n  elif arr[p]<=arr[q]:\n   temp[k]=arr[p]\n   p+=1\n   k+=1\n  else:\n   temp[k]=arr[q]\n   q+=1\n   k+=1\n   inv += (mid-p+1)\n for i in range(k):\n  arr[start]=temp[i]\n  start+=1\n \n return inv\n\ndef mergesort(arr,start,end):\n inv_count=0 \n if start<end:\n  mid=(start+end)//2\n  inv_count += mergesort(arr,start,mid)\n  inv_count += mergesort(arr,mid+1,end)\n  inv_count += merge(arr,start,mid,end)\n return inv_count\n\n\nfor _ in range(int(input())):\n n,d = list(map(int, input().split()))\n p = list(map(int, input().split()))\n \n inv_count = 0\n m={}\n sb = True #sortable\n for i in range(d):\n  k=0\n  for j in range(i,n,d):\n   m[k]=p[j]\n   k+=1\n  inv_count += mergesort(m,0,k-1)\n  \n  k=0\n  for j in range(i,n,d):\n   if not(m[k] == (j+1)):\n    sb=False\n    break\n   k+=1\n  \n if sb:\n  print(inv_count)\n else:\n  print(-1)\n", "def merge(arr,start,mid,end):\n p=start\n q=mid+1\n k=0\n inv = 0\n temp=[0]*len(arr)\n for i in range(start,end+1):\n  if p>mid :\n   temp[k]=arr[q]\n   k+=1\n   q+=1\n  elif q>end:\n   temp[k]=arr[p]\n   k+=1\n   p+=1\n  elif arr[p]<=arr[q]:\n   temp[k]=arr[p]\n   p+=1\n   k+=1\n  else:\n   temp[k]=arr[q]\n   q+=1\n   k+=1\n   inv += (mid-p+1)\n for i in range(k):\n  arr[start]=temp[i]\n  start+=1\n \n return inv\n\ndef mergesort(arr,start,end):\n inv_count=0 \n if start<end:\n  mid=(start+end)//2\n  inv_count += mergesort(arr,start,mid)\n  inv_count += mergesort(arr,mid+1,end)\n  inv_count += merge(arr,start,mid,end)\n return inv_count\n\n\nfor _ in range(int(input())):\n n,d = list(map(int, input().split()))\n p = list(map(int, input().split()))\n \n inv_count = 0\n m=[0]*n\n sb = True #sortable\n for i in range(d):\n  k=0\n  for j in range(i,n,d):\n   m[k]=p[j]\n   k+=1\n  inv_count += mergesort(m,0,k-1)\n  \n  k=0\n  for j in range(i,n,d):\n   if not(m[k] == (j+1)):\n    sb=False\n    break\n   k+=1\n  \n if sb:\n  print(inv_count)\n else:\n  print(-1)\n", "def merge(arr,start,mid,end):\n p=start\n q=mid+1\n k=0\n inv = 0\n temp=[0]*len(arr)\n for i in range(start,end+1):\n  if p>mid :\n   temp[k]=arr[q]\n   k+=1\n   q+=1\n  elif q>end:\n   temp[k]=arr[p]\n   k+=1\n   p+=1\n  elif arr[p]<=arr[q]:\n   temp[k]=arr[p]\n   p+=1\n   k+=1\n  else:\n   temp[k]=arr[q]\n   q+=1\n   k+=1\n   inv += (mid-p+1)\n for i in range(k):\n  arr[start]=temp[i]\n  start+=1\n \n return inv\n\ndef mergesort(arr,start,end):\n inv_count=0 \n if start<end:\n  mid=(start+end)//2\n  inv_count += mergesort(arr,start,mid)\n  inv_count += mergesort(arr,mid+1,end)\n  inv_count += merge(arr,start,mid,end)\n return inv_count\n\n\nfor _ in range(int(input())):\n n,d = list(map(int, input().split()))\n p = list(map(int, input().split()))\n \n inv_count = 0\n m=[0]*n\n sb = True #sortable\n for i in range(d):\n  k=0\n  for j in range(i,n,d):\n   m[k]=p[j]\n   k+=1\n  b = m[0:k]\n  inv_count += mergesort(b,0,k-1)\n  \n  k=0\n  for j in range(i,n,d):\n   if not(b[k] == (j+1)):\n    sb=False\n    break\n   k+=1\n  \n if sb:\n  print(inv_count)\n else:\n  print(-1)\n", "def merge(arr,start,mid,end):\n p=start\n q=mid+1\n k=0\n inv = 0\n temp=[0]*len(arr)\n for i in range(start,end+1):\n  if p>mid :\n   temp[k]=arr[q]\n   k+=1\n   q+=1\n  elif q>end:\n   temp[k]=arr[p]\n   k+=1\n   p+=1\n  elif arr[p]<=arr[q]:\n   temp[k]=arr[p]\n   p+=1\n   k+=1\n  else:\n   temp[k]=arr[q]\n   q+=1\n   k+=1\n   inv += (mid-p+1)\n for i in range(k):\n  arr[start]=temp[i]\n  start+=1\n \n return inv\n\ndef mergesort(arr,start,end):\n inv_count=0 \n if start<end:\n  mid=(start+end)//2\n  inv_count += mergesort(arr,start,mid)\n  inv_count += mergesort(arr,mid+1,end)\n  inv_count += merge(arr,start,mid,end)\n return inv_count\n\n\nfor _ in range(int(input())):\n n,d = list(map(int, input().split()))\n p = list(map(int, input().split()))\n a = [0]*n\n \n #transformation\n for i in range(n):\n  a[p[i]-1] = i\n  \n m=[0]*d\n inv_count=0\n for i in range(d):\n  t = (n-1-i)//d+1\n  h=[0]*t\n  for j in range(t):\n   h[j]=a[i+j*(d)]\n   #print(h)\n  inv_count += mergesort(h,0,len(h)-1)\n  m[i]=h\n #print(m)\n s=[0]*n\n for i in range(d):\n  t = (n-1-i)//d+1\n  for j in range(t):\n   s[i+j*(d)]=m[i][j]\n mb=True\n #print('s',s)\n for i in range(n):\n  if(s[i] == i):\n   continue\n  else:\n   mb=False\n   break\n if mb:\n  print(inv_count)\n else:\n  print(-1)\n", "def merge(arr,start,mid,end):\n p=start\n q=mid+1\n k=0\n inv = 0\n temp=[0]*len(arr)\n for i in range(start,end+1):\n  if p>mid :\n   temp[k]=arr[q]\n   k+=1\n   q+=1\n  elif q>end:\n   temp[k]=arr[p]\n   k+=1\n   p+=1\n  elif arr[p]<=arr[q]:\n   temp[k]=arr[p]\n   p+=1\n   k+=1\n  else:\n   temp[k]=arr[q]\n   q+=1\n   k+=1\n   inv += (mid-p+1)\n for i in range(k):\n  arr[start]=temp[i]\n  start+=1\n \n return inv\n\ndef mergesort(arr,start,end):\n inv_count=0 \n if start<end:\n  mid=(start+end)//2\n  inv_count += mergesort(arr,start,mid)\n  inv_count += mergesort(arr,mid+1,end)\n  inv_count += merge(arr,start,mid,end)\n return inv_count\n\n\nfor _ in range(int(input())):\n n,d = list(map(int, input().split()))\n p = list(map(int, input().split()))\n a = [0]*len(p)\n \n #transformation\n for i in range(len(p)):\n  a[p[i]-1] = i\n  \n m=[]\n k=[i for i in range(n)]\n inv_count=0\n for i in range(d):\n  h=[]\n  for j in range(n):\n   if (i+j*(d))>=n:\n    break\n   h.append(a[i+j*(d)])\n   #print(h)\n  m.append(h)\n  inv_count += mergesort(m[-1],0,len(m[-1])-1)\n #print(m)\n s=[0]*n\n for i in range(d):\n  for j in range(n):\n   if (i+j*(d))>=n:\n    break\n   s[i+j*(d)]=m[i][j]\n mb=True\n #print('s',s)\n for i in range(n):\n  if(s[i] == k[i]):\n   continue\n  else:\n   mb=False\n   break\n if mb:\n  print(inv_count)\n else:\n  print(-1)\n", "t=int(input())\ndef solve(arr):\n if len(arr)==1:\n  return [0,arr]\n ans=0\n left=arr[:len(arr)//2]\n right=arr[len(arr)//2:]\n val1,lis1=solve(left)\n val2,lis2=solve(right)\n val,lis=merge(lis1,lis2)\n return [val+val1+val2,lis]\n\ndef merge(left,right):\n ans=[]\n final=0\n i,j=0,0\n n=len(left)\n while i<len(left) and j<len(right):\n  if left[i]<right[j]:\n   ans+=[left[i]]\n   i+=1\n  else:\n   ans+=[right[j]]\n   final+=n-i\n   j+=1\n ans+=left[i:]+right[j:]\n return [final,ans]\n  \n  \nfor _ in range(t):\n n,d=list(map(int,input().split()))\n arr=list(map(int,input().split()))\n ans=0\n dic={i:[] for i in range(d)}\n found=False\n for i in range(n):\n  if (arr[i]-i-1)%d!=0:\n   found=True\n   break\n  else:\n   if arr[i]%d==0:\n    dic[0]+=[arr[i]//d-1]\n   else:\n    dic[arr[i]%d]+=[(arr[i]-(arr[i]%d))//d]\n if found:\n  print(-1)\n else:\n  ans=0\n  for perm in list(dic.values()):\n   ans+=solve(perm)[0]\n  print(ans)\n", "t=int(input())\ndef solve(arr):\n if len(arr)==1:\n  return [0,arr]\n ans=0\n left=arr[:len(arr)//2]\n right=arr[len(arr)//2:]\n val1,lis1=solve(left)\n val2,lis2=solve(right)\n val,lis=merge(lis1,lis2)\n return [val+val1+val2,lis]\n\ndef merge(left,right):\n ans=[]\n final=0\n i,j=0,0\n n=len(left)\n while i<len(left) and j<len(right):\n  if left[i]<right[j]:\n   ans+=[left[i]]\n   i+=1\n  else:\n   ans+=[right[j]]\n   final+=n-i\n   j+=1\n ans+=left[i:]+right[j:]\n return [final,ans]\n  \n  \nfor _ in range(t):\n n,d=list(map(int,input().split()))\n arr=list(map(int,input().split()))\n ans=0\n dic={i:[] for i in range(d)}\n found=False\n for i in range(n):\n  if (arr[i]-i-1)%d!=0:\n   found=True\n   break\n  else:\n   if arr[i]%d==0:\n    dic[0]+=[arr[i]//d-1]\n   else:\n    dic[arr[i]%d]+=[(arr[i]-(arr[i]%d))//d]\n if found:\n  print(-1)\n else:\n  ans=0\n  for perm in list(dic.values()):\n   ans+=solve(perm)[0]\n  print(ans)\n   \n  \n  \n", "def valid(hash_t,n,d):\n flag = 0\n for i in range(d):\n  for j in range(i+1,n,d):\n   if (hash_t[j] - hash_t[i+1]) % d != 0:\n    flag = 1\n    return False\n\n return True\n\n\ndef num_inversion(hash_t,n,d):\n count = 0\n for i in range(d):\n  for j in range(i+1,n,d):\n   for k in range(j,n,d):\n    if hash_t[j] > hash_t[k]:\n     count += 1\n return count\n\n\ntc = int(input())\nwhile tc:\n n, d = input().split()\n n = int(n)\n d = int(d)\n a = [int(x) for x in input().split(\" \")]\n if d == 1:\n  count = 0\n  for i in range(n):\n   for j in range(i+1,n):\n    if a[i] > a[j]:\n     count += 1\n  print(count)\n else :\n  hash_t = [0]*(n+1)\n  for i in range(n):\n   hash_t[a[i]] = i+1\n\n  if not valid(hash_t,n+1,d):\n   print(-1)\n  else :\n   #print(\"Valid\")\n   count = num_inversion(hash_t,n+1,d)\n   print(count)\n tc -= 1"]