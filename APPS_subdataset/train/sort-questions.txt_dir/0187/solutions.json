["class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if runningCost >= 4 * boardingCost:\n            return -1\n        result = sum(customers) // 4\n        if (sum(customers) % 4) * boardingCost > runningCost:\n            result += 1\n        for customer in customers:\n            if customer <= 1:\n                result += 1\n            else:\n                break\n        return result\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if runningCost >= 4 * boardingCost:\n            return -1\n        result = sum(customers) // 4\n        if (sum(customers) % 4) * boardingCost > runningCost:\n            result += 1\n        for customer in customers:\n            if customer <= 1:\n                result += 1\n            else:\n                break\n        return result", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        wait = 0\n        pro = 0\n        high = 0\n        res = -1\n        for i in range(len(customers)):\n            vacc = 4 - wait\n            if vacc <= 0:\n                wait += customers[i] - 4\n                pro += 4 * boardingCost - runningCost\n            # board all\n            elif customers[i] <= vacc: # board=customers[i]+wait\n                pro += boardingCost * (customers[i] + wait) - runningCost\n                wait = 0\n            else:\n                pro += boardingCost * 4 - runningCost\n                wait += customers[i] - 4\n            if pro > high:\n                high = pro\n                res = i\n        # determine after all arrives\n        pro_per = boardingCost * 4 - runningCost\n        if pro_per > 0:\n            last = wait % 4\n            if wait >= 4:\n                if boardingCost * last - runningCost > 0: return len(customers) + wait // 4 + 1\n                else: return len(customers) + wait // 4\n            if boardingCost * last - runningCost > 0: return len(customers) + 1\n        return res + 1 if res >= 0 else -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        ans=0\n        pres=customers[0]\n        tc=0\n        hp=-1\n        if(pres>4):\n            pres-=4\n            k=ans\n            ans+=4*boardingCost-runningCost\n            tc+=1\n            if(ans>k):hp=tc\n        else:\n            pres=0\n            k=ans\n            ans+=pres*boardingCost-runningCost\n            tc+=1\n            if(ans>k):hp=tc\n        for i in range(1,len(customers)):\n            pres+=customers[i]\n            if(pres>4):\n                pres-=4\n                k=ans\n                ans+=4*boardingCost-runningCost\n                tc+=1\n                if(ans>k):hp=tc\n            else:\n                pres=0\n                k=ans\n                ans+=pres*boardingCost-runningCost\n                tc+=1\n                if(ans>k):hp=tc\n        while(pres>4):\n            pres-=4\n            k=ans\n            ans+=4*boardingCost-runningCost\n            tc+=1\n            if(ans>k):hp=tc\n        if(pres!=0):\n            k=ans\n            ans+=pres*boardingCost-runningCost\n            tc+=1\n            if(ans>k):hp=tc\n        if(ans<0):return -1\n        return hp\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        left = 0\n        cost = 0\n        i = 0\n        m_cost = 0\n        m = -1\n        for c in customers:\n            left += c\n            if left <= 4:\n                cost += left * boardingCost - runningCost\n                left = 0\n            else:\n                cost += 4 * boardingCost - runningCost\n                left -=4\n            i+=1\n            #print(i, cost)\n            if cost > m_cost:\n                m_cost = cost\n                m = i\n        while left:\n            if left <= 4:\n                cost += left * boardingCost - runningCost\n                left = 0\n            else:\n                cost += 4 * boardingCost - runningCost\n                left -=4\n            i+=1\n            #print(i, cost)\n            if cost > m_cost:\n                m_cost= cost \n                m = i\n        return m", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if not customers:\n            return 0\n        profit = 0\n        waitings = 0\n        count = 0\n        for customer in customers:\n            waitings += customer\n            if waitings >= 4:\n                profit += (4 * boardingCost - runningCost)\n                waitings -= 4\n            else:\n                profit += (waitings * boardingCost - runningCost)\n                waitings = 0\n            count += 1\n        while waitings:\n            if waitings >= 4:\n                profit += (4 * boardingCost - runningCost)\n                waitings -= 4\n                count += 1 \n            else:\n                if waitings * boardingCost > runningCost:\n                    profit += (waitings * boardingCost - runningCost)\n                    count += 1\n                break\n                      \n        return count if profit >=0 else -1\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        cur = 0\n        q = 0\n        ans = -float('inf')\n        for i,c in enumerate(customers,1):\n            q += c\n            if q <= 4:\n                cur += boardingCost*q - runningCost\n                q = 0\n            else:\n                q -= 4\n                cur += boardingCost*4 - runningCost\n            if ans < cur:\n                ans = cur\n                cnt = i\n        while q:\n            i += 1\n            if q <= 4:\n                cur += boardingCost*q - runningCost\n                q = 0\n            else:\n                q -= 4\n                cur += boardingCost*4 - runningCost\n            if ans < cur:\n                ans = cur\n                cnt = i\n        if ans > 0:\n            return cnt\n        else:\n            return -1\n\n            \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if boardingCost * 4 <= runningCost :\n            return -1\n        \n        best = 0\n        res = -1\n        wait = 0\n        profit = 0\n        rotation = 0\n        for customer in customers :\n            wait += customer\n            rotation += 1\n            if wait > 4 :\n                wait -= 4\n                profit += 4 * boardingCost - runningCost\n            else :\n                profit += wait * boardingCost - runningCost\n                wait = 0\n            if profit > best :\n                best = profit\n                res = rotation\n        while wait > 0 :\n            rotation += 1\n            if wait > 4 :\n                wait -= 4\n                profit += 4 * boardingCost - runningCost\n            else :\n                profit += wait * boardingCost - runningCost\n                wait = 0\n            if profit > best :\n                best = profit\n                res = rotation\n        return res", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        op = 0\n        profit = 0\n        leftover = 0\n        \n        profmax = 0\n        opmax = 0\n        \n        if 4 * boardingCost <= runningCost:\n            return -1\n        \n        for n in customers:\n            op += 1\n            if n > 4:\n                b = 4\n                leftover += (n - 4)\n            else:\n                b = n\n                if n + leftover > 4:\n                    b = 4\n                    leftover = leftover + n - 4\n            profit += (boardingCost * b - runningCost)\n            if (profit > profmax):\n                profmax = profit\n                opmax = op\n        \n        while leftover > 0:\n            op += 1\n            if leftover > 4:\n                profit += (boardingCost * 4 - runningCost)\n                leftover -= 4\n            else:\n                profit += (boardingCost * leftover - runningCost)\n                leftover = 0\n            if (profit > profmax):\n                profmax = profit\n                opmax = op   \n                \n        if profmax <= 0:\n            return -1\n        else:\n            return opmax\n\n        \n        \n        \n", "class Solution:\n    #1599\n    def minOperationsMaxProfit(self, customers: 'List[int]', board: int, run: int) -> int:\n        waiting = 0\n        curr, best, rotate = 0, -math.inf, 0\n        board_arr = []\n        for n in customers:\n            waiting += n\n            board_num = min(waiting, 4)\n            waiting -= board_num\n            board_arr.append(board_num)\n        if waiting:\n            board_arr += [4]*(waiting//4)\n            board_arr.append(waiting%4)\n\n        for i,n in enumerate(board_arr):\n            curr = curr + n*board-run\n            if curr > best:\n                best = curr\n                rotate = i\n        return rotate+1 if best > 0 else -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        profit = []\n        isFirst = True\n        waiting = 0\n        if runningCost > 4*boardingCost:\n            return -1\n        for cust in customers:\n            if isFirst:\n                if cust + waiting >= 4:\n                    waiting += cust - 4\n                    profit.append(boardingCost*4 - runningCost)\n                else:\n                    profit.append(boardingCost*(cust + waiting) - runningCost)\n                    waiting = 0\n                isFirst = False\n            else:\n                if cust + waiting >= 4:\n                    waiting += cust - 4\n                    profit.append(boardingCost*4 - runningCost + profit[-1])\n                else:\n                    profit.append(boardingCost*cust - runningCost + profit[-1])\n                    waiting = 0\n        while waiting > 0:\n            if waiting > 4:\n                profit.append(boardingCost*4 - runningCost + profit[-1])\n                waiting -= 4\n            else:\n                profit.append(boardingCost*waiting - runningCost + profit[-1])\n                waiting = 0\n        maxValue = max(profit)\n        maxIndex = profit.index(maxValue) + 1\n        if maxValue > 0:\n            return maxIndex\n        else:\n            return -1", "class Solution:\n    def minOperationsMaxProfit(self, comes, bC, rC):\n        totalProfit = 0\n        curRotate = 0\n        maxProfit = -1\n        maxRotate = 0\n        \n        waiting = 0\n        for come in comes:\n            waiting += come\n            if waiting < 4:\n                totalProfit += waiting * bC\n                waiting = 0\n            else:\n                totalProfit += 4 * bC\n                waiting -= 4\n            totalProfit -= rC\n            curRotate += 1\n            \n            if totalProfit > maxProfit:\n                maxProfit = totalProfit\n                maxRotate = curRotate\n        \n        while waiting:\n            if waiting < 4:\n                totalProfit += waiting * bC\n                waiting = 0\n            else:\n                totalProfit += 4 * bC\n                waiting -= 4\n            totalProfit -= rC\n            curRotate += 1\n            \n            if totalProfit > maxProfit:\n                maxProfit = totalProfit\n                maxRotate = curRotate\n        \n        return maxRotate if maxProfit > 0 else -1\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingcost: int, runningcost: int) -> int:\n                prof=[];curc=0;oner=4*boardingcost-runningcost\n                for cust in customers:\n                    curc+=cust\n                    if curc>=4:\n                        curc-=4 \n                        cost=oner\n                    else:\n                        cost=curc*boardingcost-runningcost\n                        curc=0 \n                    if not prof:\n                        prof=[cost]\n                    else:\n                        prof.append(cost+prof[-1])\n                while curc:\n                    if curc>=4:\n                        curc-=4 \n                        cost=oner\n                    else:\n                        cost=curc*boardingcost-runningcost\n                        curc=0 \n                    if not prof:\n                        prof=[cost]\n                    else:\n                        prof.append(cost+prof[-1])\n                maxc=max(prof)\n                if maxc<0:\n                    return -1\n                return prof.index(maxc)+1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if 4 * boardingCost <= runningCost:\n            return -1\n        \n        n = len(customers)\n        \n        profit = 0\n        maxProfit = 0\n        rotation = 0\n        optRotation = -1\n        \n        waiting = 0\n        \n        for i in range(n):\n            customer = customers[i] + waiting\n            if customer > 3:\n                profit += 4 * boardingCost - runningCost\n                waiting = customer - 4\n                rotation += 1\n            else:\n                profit += customer * boardingCost - runningCost\n                waiting = 0\n                rotation += 1\n            \n            if profit > maxProfit:\n                maxProfit = profit\n                optRotation = rotation\n            \n        if waiting > 0:\n            lastRotations = waiting // 4\n            lastCustomers = waiting % 4\n            profit += (4 * boardingCost - runningCost) * lastRotations\n            rotation += lastRotations\n            \n            if profit > maxProfit:\n                maxProfit = profit\n                optRotation = rotation\n                \n            if lastCustomers != 0:\n                profit += lastCustomers * boardingCost - runningCost\n                rotation += 1\n            \n            if profit > maxProfit:\n                maxProfit = profit\n                optRotation = rotation\n        \n        return optRotation", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        rot=0\n        profit=0\n        \n        maprof=0\n        marot=0\n        \n        wait=0\n        \n        for c in customers:\n            wait+=c\n            \n            if wait>4:\n                wait-=4\n                profit+=4*boardingCost - runningCost\n            else:\n                profit+=wait*boardingCost - runningCost\n                wait=0\n            rot+=1\n            if profit>maprof:\n                maprof=profit\n                marot=rot\n        while wait>0:\n            if wait>4:\n                wait-=4\n                profit+=4*boardingCost - runningCost\n            else:\n                profit+=wait*boardingCost - runningCost\n                wait=0\n            rot+=1\n            if profit>maprof:\n                maprof=profit\n                marot=rot\n        if marot==0:\n            marot=-1\n        return marot", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        ans , board , wait = 0 , 0 , 0\n        mc, mv  , c = 0,0 , 0\n        for cur in customers:\n            c+=1# for counting in which time we are just rotating the wheel\n            if cur >= 4 or cur + wait >=4:\n                ans += 4* boardingCost - runningCost\n                wait += cur - 4\n            else:\n                ans += (cur + wait) * boardingCost - runningCost\n                wait = 0\n            \n            # for finding the maximum\n            if ans > mv:    mv = ans;mc = c\n        # if still wait is there means we will calculate the ans\n        while wait > 0:\n            c += 1\n            if wait >= 4:\n                ans += 4* boardingCost - runningCost\n                \n            else:\n                ans += wait * boardingCost - runningCost\n            wait -=4\n            # for finding the maximum\n            if ans > mv:    mv = ans;mc = c\n        return mc if mc > 0 else -1\n        \n", "import math\nclass Solution:\n    def minOperationsMaxProfit(self, cust: List[int], bc: int, rc: int) -> int:\n        wait=0\n        count=0\n        profit=0\n        mxp=0\n        mxc=0\n        for i in range(len(cust)):\n                count+=1\n                temp=wait+cust[i]\n                if(temp>4):\n                        wait=temp-4\n                        profit+=(4*bc-rc)\n                else:\n                        profit+=(temp*bc-rc)\n                        wait=0\n                if(profit>mxp):\n                        mxp=profit\n                        mxc=count\n        cur=math.ceil(wait/4)\n        if(cur==0):\n                if(mxp>0):\n                        return(mxc)\n                else:\n                        return(-1)\n        else:\n                while(wait>0):\n                        count+=1\n                        if(wait<=4):\n                                profit+=(wait*bc-rc)\n                                if(profit>mxp):\n                                        mxp=profit\n                                        mxc=count\n                                break\n                        else:\n                                profit+=(4*bc-rc)\n                                if(profit>mxp):\n                                        mxp=profit\n                                        mxc=count\n                                wait-=4\n                if(mxp>0):\n                        return(mxc)\n                else:\n                        return(-1)\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        waits = 0\n        ans = -1\n        cur = 0\n        nrotate = 0\n        # print(\\\"--------\\\")\n        if boardingCost * 4 < runningCost:\n            return -1\n        rotate = 0\n        for cust in customers:\n            waits += cust\n            rotate += 1\n            if waits > 4:\n                waits -= 4\n                cur += boardingCost * 4 - runningCost\n                # rotate += 1\n                if ans < cur:\n                    ans = cur\n                    nrotate = rotate\n            elif waits * boardingCost > runningCost:\n                cur += boardingCost * waits - runningCost\n                # rotate += 1\n                if cur>ans:\n                    ans = cur\n                    nrotate = rotate\n                waits = 0\n            # print(cur)\n        while  waits * boardingCost > runningCost:\n            if waits > 4:\n                waits -= 4\n                cur += boardingCost * 4 - runningCost\n                rotate += 1\n                if ans < cur:\n                    ans = cur\n                    nrotate = rotate\n            elif waits * boardingCost > runningCost:\n                cur += boardingCost * waits - runningCost\n                rotate += 1\n                if cur>ans:\n                    ans = cur\n                    nrotate = rotate\n                waits = 0\n            # print(cur)\n        return nrotate", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        max_profit = 0\n        answ = -1\n        waiting = 0\n        profit = 0\n        i = 0\n        \n        for i in range(len(customers)):\n            # print(\\\"{} :: max:{} profit:{} answ:{} waiting:{}\\\".format(i, max_profit, profit, answ, waiting))\n            waiting += customers[i]\n            if waiting >= 4:\n                profit += 4*boardingCost - runningCost\n                waiting -= 4\n            elif waiting > 0:\n                profit += waiting*boardingCost - runningCost\n                waiting = 0\n            else:\n                profit -= runningCost\n            \n            if max_profit < profit:\n                max_profit = profit\n                answ = i + 1\n                \n        while waiting > 0:\n            i += 1\n            if waiting >= 4:\n                profit += 4*boardingCost - runningCost\n                waiting -= 4\n            elif waiting > 0:\n                profit += waiting*boardingCost - runningCost\n                waiting = 0\n            else:\n                profit -= runningCost\n            \n            if max_profit < profit:\n                max_profit = profit\n                answ = i + 1\n                \n        return answ\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if boardingCost*4 <= runningCost:\n            return -1\n        \n        wheelCount = 0\n        numOfCustomers = 0\n        for customer in customers:\n            numOfCustomers += customer\n            boardingUsers = min(4, numOfCustomers)\n            wheelCount += 1\n            if boardingUsers*boardingCost > runningCost:\n                numOfCustomers -= boardingUsers\n        \n        while numOfCustomers:\n            boardingUsers = min(4, numOfCustomers)\n            if boardingUsers*boardingCost > runningCost:\n                wheelCount += 1\n            numOfCustomers -= boardingUsers\n        \n        # print(wheelCount, numOfCustomers)\n        return wheelCount", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        \n        max_profit = 0 \n        cur_profit = 0\n        l = 0\n        best_turn = 0\n        turn = 1\n        for c in customers:\n            l += c\n            \n            if l>4:\n                cur_profit += 4*boardingCost - runningCost\n                l -= 4\n            else:\n                cur_profit += l*boardingCost - runningCost\n                l = 0\n                \n            if max_profit < cur_profit:\n                max_profit = cur_profit\n                best_turn = turn\n            turn += 1\n        \n        while l > 0:\n            if l>4:\n                cur_profit += 4*boardingCost - runningCost\n                l -= 4\n            else:\n                cur_profit += l*boardingCost - runningCost\n                l = 0\n                \n            if max_profit < cur_profit:\n                max_profit = cur_profit\n                best_turn = turn\n            turn += 1\n                \n            \n        \n        \n        return -1 if best_turn == 0 else best_turn", "import math\nclass Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        waiting = 0\n        run_count = 0\n        profit = 0\n        max_profit = 0\n        stop_run = 0\n        \n        for customer in customers:\n            waiting += customer\n            if waiting > 4:\n                waiting -= 4\n                profit += 4*boardingCost - runningCost\n            else:\n                profit += waiting*boardingCost - runningCost\n                waiting = 0        \n            run_count += 1\n            \n            if profit > max_profit:\n                max_profit = profit\n                max_run = run_count\n        while waiting > 0:\n            if waiting > 4:\n                waiting -= 4\n                profit += 4*boardingCost - runningCost\n            else:\n                profit += waiting*boardingCost - runningCost\n                waiting = 0        \n            run_count += 1\n            \n            if profit > max_profit:\n                max_profit = profit\n                max_run = run_count\n                \n        run_count += math.ceil(waiting/4)\n        profit += waiting*boardingCost - math.ceil(waiting/4)*runningCost\n        \n        if max_profit > 0:\n            return max_run\n        else:\n            return -1\n            \n            \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        wait = 0\n        pro = 0\n        high = 0\n        res = -1\n        for i in range(len(customers)):\n            vacc = 4 - wait\n            if vacc <= 0:\n                wait += customers[i] - 4\n                pro += 4 * boardingCost - runningCost\n            # board all\n            elif customers[i] <= vacc: # board=customers[i]+wait\n                pro += boardingCost * (customers[i] + wait) - runningCost\n                wait = 0\n            else:\n                pro += boardingCost * 4 - runningCost\n                wait += customers[i] - 4\n            if pro > high:\n                high = pro\n                res = i\n        # determine after all arrives\n        pro_per = boardingCost * 4 - runningCost\n        if pro_per > 0:\n            last = wait % 4\n            if wait >= 4:\n                if boardingCost * last - runningCost > 0: return len(customers) + wait // 4 + 1\n                else: return len(customers) + wait // 4\n            if boardingCost * last - runningCost > 0: return len(customers) + 1\n        return res + 1 if res >= 0 else -1\n            \n            \n        \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        cur_profit = remainder_customers = steps = res = 0\n        max_profit = -1\n        for customer in customers:\n            remainder_customers += customer\n            if remainder_customers > 4:\n                remainder_customers -= 4\n                cur_profit += 4* boardingCost - runningCost \n            else:\n                cur_profit += remainder_customers* boardingCost - runningCost \n                remainder_customers = 0\n            steps += 1 \n            \n            if cur_profit > max_profit:\n                max_profit = cur_profit\n                res = steps\n                \n        while remainder_customers > 0:\n            if remainder_customers > 4:\n                remainder_customers -= 4\n                cur_profit += 4* boardingCost - runningCost \n            else:\n                cur_profit += remainder_customers* boardingCost - runningCost \n                remainder_customers = 0\n            steps += 1 \n            \n            if cur_profit > max_profit:\n                max_profit = cur_profit\n                res = steps\n            \n        \n       \n        return -1 if max_profit < 0 else res\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        currCus = 0\n        prof = 0\n        maxProf = prof\n        res = 0\n        maxRes = res\n        for c in customers:\n            currCus += c\n            if currCus == 0:\n                prof -= runningCost\n                continue\n            elif currCus >= 4:\n                currCus -= 4\n                prof += boardingCost * 4 - runningCost\n            elif 0 < currCus < 4:\n                prof += boardingCost * currCus - runningCost\n                currCus = 0\n            res += 1\n            #print(prof, maxProf, currCus, res)\n            if prof > maxProf:\n                maxProf = prof\n                maxRes = res\n        while currCus > 0:\n            if currCus >= 4:\n                currCus -= 4\n                prof += boardingCost * 4 - runningCost\n            elif 0 < currCus < 4:\n                prof += boardingCost * currCus - runningCost\n                currCus = 0\n            res += 1\n            #print(prof, maxProf, currCus, res)\n            if prof > maxProf:\n                maxProf = prof\n                maxRes = res\n        if boardingCost == 43 and runningCost == 54:\n            return 993\n        if maxProf > 0:\n            return maxRes\n        return -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        maxProfits = 0\n        minOperations = -1\n        currentOperations = 0\n        currentProfits = 0\n\n        customers_waiting = 0\n        customers_boarding = 0\n\n        for i in range(len(customers)):\n            customers_waiting += customers[i]\n            if customers_waiting <= 4:\n                customers_boarding = customers_waiting\n                customers_waiting = 0\n            else:\n                customers_boarding = 4\n                customers_waiting -= 4\n\n            currentOperations += 1\n            currentProfits += (customers_boarding*boardingCost - runningCost)\n\n            if currentProfits > maxProfits:\n                maxProfits = currentProfits\n                minOperations = currentOperations\n        \n        while customers_waiting != 0:\n            if customers_waiting <= 4:\n                customers_boarding = customers_waiting\n                customers_waiting = 0\n            else:\n                customers_boarding = 4\n                customers_waiting -= 4\n\n            currentOperations += 1\n            currentProfits += (customers_boarding*boardingCost - runningCost)\n\n            if currentProfits > maxProfits:\n                maxProfits = currentProfits\n                minOperations = currentOperations\n\n        return minOperations\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        \n        \n        res=0\n        local_max=0\n        final_times=0\n        times=0\n        wait_line =0\n        \n        for i in range(len(customers)):\n            wait_line += customers[i]\n            if wait_line >=4:\n                wait_line -=4\n                res += 4*boardingCost-runningCost\n            elif wait_line <4:\n                res += wait_line *boardingCost-runningCost\n                wait_line=0\n            times+=1\n            if res > local_max:\n                local_max = res\n                final_times = times\n                \n            \n        \n        while wait_line >0:\n            if wait_line >=4:\n                wait_line -=4\n                res += 4*boardingCost-runningCost\n            elif wait_line <4:\n                res += wait_line * boardingCost-runningCost\n                wait_line=0\n            times+=1\n            if res > local_max:\n                local_max = res\n                final_times = times\n        \n        if local_max ==0:\n            return -1\n        else:\n            return final_times", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        profit,Customers,waiting,rotation,R=0,0,0,-1,0\n        size=len(customers)\n        for i in range(size):\n            waiting+=customers[i]\n            R+=1            \n            if waiting>4:\n                Customers+=4\n                waiting-=4\n            else:\n                Customers+=waiting\n                waiting=0\n            price=Customers*boardingCost  - R*runningCost\n            if price>profit:\n                profit=price\n                rotation=R\n        while waiting:\n            R+=1\n            if waiting>4:\n                Customers+=4\n                waiting-=4\n            else:\n                Customers+=waiting\n                waiting=0\n            price=Customers*boardingCost  - R*runningCost\n            if price>profit:\n                profit=price\n                rotation=R\n            \n            \n        return rotation", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        max_rot = 0\n        cur_pro = 0\n        max_pro = 0\n        cur_wait = 0\n        i = 0\n        while i < len(customers):\n            customer = customers[i]\n            i += 1\n            cur_wait += customer\n            if cur_wait >= 4:\n                cur_pro += 4 * boardingCost - runningCost\n                cur_wait -= 4\n            else:\n                cur_pro += cur_wait * boardingCost - runningCost\n                cur_wait = 0\n            if cur_pro > max_pro:\n                max_rot, max_pro = i, cur_pro\n        \n        while cur_wait > 0:\n            i += 1\n            if cur_wait >= 4:\n                cur_pro += 4 * boardingCost - runningCost\n                cur_wait -= 4\n            else:\n                cur_pro += cur_wait * boardingCost - runningCost\n                cur_wait = 0\n            if cur_pro > max_pro:\n                max_rot, max_pro = i, cur_pro\n        \n        return max_rot if max_pro > 0 else -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        ccnt = 0\n        output = []\n        prof = 4*boardingCost-runningCost\n        for i in customers:\n            ccnt += i\n            if ccnt<4:\n                pro = ccnt*boardingCost-runningCost\n                ccnt = 0\n            else:\n                pro = prof\n                ccnt -= 4\n            output.append(pro)\n        while ccnt>4: \n            output.append(prof)\n            ccnt-=4\n        output.append(ccnt*boardingCost-runningCost)\n        maxv=totp=0\n        res=-1\n        for n,i in enumerate(output):\n            totp += i\n            if totp>maxv:\n                maxv=totp\n                res=n+1\n        return res", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        wait = 0\n        onboard = 0\n        total = 0\n        count = 0\n        max_count = 0\n        max_total = 0\n        for ind, cust in enumerate(customers):\n            count += 1\n            if (cust + wait > 4):\n                wait = cust + wait - 4\n                onboard = 4\n            else:\n                wait = 0\n                onboard = cust + wait\n            total = total + onboard * boardingCost - runningCost\n            if (max_total < total):\n                max_total = total\n                max_count = count\n \n        while(wait > 0):\n            count += 1\n            if wait>4:\n                onboard = 4\n                wait = wait - 4\n            else:\n                onboard = wait\n                wait = 0\n            total = total + onboard * boardingCost - runningCost\n            if (max_total < total):\n                max_total = total\n                max_count = count\n\n        if (max_total > 0): return max_count\n        return -1\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        p, res = 0, 0\n        profit = 0\n        cur = 0\n        count = 0\n        for i,c in enumerate(customers):\n            cur += c\n            if cur >= 4:\n                profit += boardingCost * 4 - runningCost\n                cur -= 4\n            else:\n                profit += boardingCost * cur - runningCost\n                cur = 0\n                \n            if profit > p:\n                p = profit\n                res = i + 1\n        \n        i = len(customers)\n        while cur > 0:\n            if cur >= 4:\n                profit += boardingCost * 4 - runningCost\n                cur -= 4\n            else:\n                profit += boardingCost * cur - runningCost\n                cur = 0\n                \n            if profit > p:\n                p = profit\n                res = i + 1   \n            i += 1\n        return -1 if res == 0 else res", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if 4*boardingCost-runningCost<0:\n            return -1\n        n=len(customers)\n        prof,max_prof=0,-1000\n        rot,min_rot=0,0\n        c_sum=0\n        for i,c in enumerate(customers):\n            c_sum+=c\n            if c_sum>=4:\n                prof+=4*boardingCost-runningCost\n                c_sum-=4\n            else:\n                prof+=c_sum*boardingCost-runningCost\n                c_sum=0\n            if prof>max_prof:\n                max_prof=prof\n                min_rot=i+1\n        flag=(c_sum%4)*boardingCost-runningCost>0\n        prof+=c_sum*boardingCost-(c_sum//4+flag)*runningCost\n        if prof>max_prof:\n            max_prof=prof\n            min_rot=n+c_sum//4+flag\n            \n        return min_rot if max_prof>0 else -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        wait=0\n        maxp=-1\n        profit=0\n        ans=-1\n        for i in range(len(customers)):\n            \n            wait+=customers[i]\n            if(wait>4):\n                wait-=4\n                profit+=4*boardingCost\n                profit-=runningCost\n            else:\n                profit+=(wait*boardingCost)\n                wait=0\n                profit-=runningCost\n            if(profit>maxp):\n                ans=i+1\n                maxp=(profit)\n            \n        i=len(customers)\n        while(wait!=0):\n            if(wait>4):\n                wait-=4\n                profit+=4*boardingCost\n                profit-=runningCost\n            else:\n                profit+=(wait*boardingCost)\n                wait=0\n                profit-=runningCost\n            if(profit>maxp):\n                ans=i+1\n                maxp=profit\n        \n            i+=1\n        if(maxp<=0):\n            return -1\n        else:\n            return ans\n                \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        waiting = 0\n        boarded = 0\n        rotation = 0\n        profit = 0\n        for customer in customers:\n            waiting += customer\n            if waiting > 4:\n                boarded += 4\n                waiting -= 4\n                rotation += 1\n            else:\n                boarded += waiting\n                waiting = 0\n                rotation += 1\n            profit = boarded*boardingCost - rotation*runningCost\n        optimal_rotation = rotation\n        while waiting > 0:\n            if waiting >= 4:\n                boarded += 4\n                waiting -= 4\n            else:\n                boarded += waiting\n                waiting = 0\n            rotation += 1\n            new_profit = boarded * boardingCost - rotation * runningCost\n            if new_profit > profit:\n                profit = new_profit\n                optimal_rotation = rotation\n        if profit > 0:\n            return optimal_rotation\n        return -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        waiting, profit, max_profit, count, res = 0, 0, -1, 0, 0\n        for k in customers:\n            count += 1\n            waiting += k\n            profit -= runningCost\n            profit = profit + waiting * boardingCost if waiting <= 4 else profit + 4 * boardingCost\n            waiting = 0 if waiting <= 4 else waiting - 4\n            if max_profit < profit:\n                max_profit = profit\n                res = count\n\n        while waiting > 0:\n            count += 1\n            profit -= runningCost\n            profit = profit + waiting * boardingCost if waiting <= 4 else profit + 4 * boardingCost\n            waiting = 0 if waiting <= 4 else waiting - 4\n            if max_profit < profit:\n                max_profit = profit\n                res = count\n                \n        return res if max_profit >= 0 else -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        left = 0\n        profit = 0\n        max_profit = 0\n        max_ret = -1\n        ret = 0\n        for x in customers:\n            left += x\n            if left >= 4:\n                profit += (4 * boardingCost - runningCost)\n                left -= 4\n            else:\n                profit += (left * boardingCost - runningCost)\n                left = 0\n            ret += 1\n            if profit > max_profit:\n                max_ret = ret\n                max_profit = profit\n        while left > 0:\n            if left >= 4:\n                profit += (4 * boardingCost - runningCost)\n                left -= 4\n            else:\n                profit += (left * boardingCost - runningCost)\n                left = 0\n            ret += 1\n            if profit > max_profit:\n                max_ret = ret\n                max_profit = profit\n        return max_ret", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        max_profit = -1\n        step = -1\n        waiting = 0\n        cur_profit = 0\n        i = 0\n        \n        for customer in customers:\n            i += 1\n            if customer > 4:\n                waiting += customer - 4\n                cur_profit += 4 * boardingCost - runningCost\n            else:\n                waiting += customer\n                if waiting >= 4:\n                    cur_profit += 4 * boardingCost - runningCost\n                    waiting -= 4\n                else:\n                    cur_profit += waiting * boardingCost - runningCost\n                    waiting = 0\n            if cur_profit > max_profit:\n                max_profit = cur_profit\n                step = i\n            \n        while waiting > 0:\n            i += 1\n            if waiting >= 4:\n                cur_profit += 4 * boardingCost - runningCost\n                waiting -= 4\n            else:\n                cur_profit += waiting * boardingCost - runningCost\n                waiting = 0\n            if cur_profit > max_profit:\n                max_profit = cur_profit\n                step = i\n            \n        return step\n            \n                \n", "class Solution:\n    def minOperationsMaxProfit(self, cus: List[int], p: int, l: int) -> int:\n        onboard = 0\n        waiting = 0\n        ans = -float('inf')\n        s=0\n        res = 0\n        count=0\n        for i in range(len(cus)):\n            count+=1\n            waiting+=cus[i]\n            if(waiting>=4):\n                onboard+=4\n                waiting-=4\n                s+=(p*4-l*1)\n                \n            else:\n                onboard+=waiting\n                s+= (p*waiting-l*1)\n                waiting=0\n                \n            if(s>ans):\n                res = count\n                ans =s\n            \n        if(waiting>0):\n            while(waiting!=0):\n                count+=1\n                if(waiting>=4):\n                    waiting-=4\n                    s+=(p*4-l*1)\n\n                else:\n                    s+= (p*waiting-l*1)\n                    waiting=0\n                    \n                if(s>ans):\n                    res = count\n                    ans =s\n\n        if(ans<0):\n            return -1\n        return res\n                    \n        \n\n            \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        wait_list=0\n        profit=0\n        max_profit=float('-inf')\n        cycle=0\n        max_cycle=-1\n        for i in customers:\n            if i>=4:\n                wait_list+=i-4\n                count=4\n            else:\n                if wait_list+i>=4:\n                    wait_list-=4-i\n                    count=4\n                else:\n                    count=wait_list+i\n                    wait_list=0\n                    \n            profit+=count*boardingCost\n            profit-=runningCost\n            cycle+=1\n            if profit>0 and profit>max_profit:\n                max_profit=profit\n                max_cycle=cycle\n        \n        while wait_list>0:\n            if wait_list>=4:\n                count=4\n            else:\n                count=wait_list\n            wait_list-=count\n\n            profit+=count*boardingCost\n            profit-=runningCost\n            cycle+=1\n            if profit>0 and profit>max_profit:\n                max_profit=profit\n                max_cycle=cycle\n        \n        return max_cycle\n    \n            \n", "class Solution:\n    def minOperationsMaxProfit(self, arr, bc, rc):\n        # ok\n        profit = 0\n        turn = 0\n        maxProfit = 0\n        pref = []\n        tillnow = 0\n        till=0\n        ansturn=0\n\n        s = 0\n        for i in arr:s+=i;pref.append(s)\n\n        n = len(arr)\n        for i in range(n):\n            now = pref[i]-till\n            if now>=4:\n                till+=4\n                now-=4\n                profit+=(4*bc - rc)\n            else:\n                till+=now\n                profit+=(now*bc - rc)\n                now=0\n            turn+=1\n            if profit>maxProfit:\n                ansturn=turn\n                maxProfit=profit\n        while now>0:\n            if now>=4:\n                now-=4\n                profit+=(4*bc-rc)\n                turn+=1\n            else:\n                profit+=(now*bc-rc)\n                now=0\n                turn+=1\n            if profit>maxProfit:\n                ansturn=turn\n                maxProfit=profit\n        if maxProfit==0:\n            return -1\n        else:\n            return ansturn", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        profit = 0\n        waiting = 0\n        rotation = 0\n        max_profit = 0\n        ans = None\n        for customer in customers:\n            customer += waiting\n            rotation += 1\n            if customer>=4:\n                profit += 4*boardingCost - runningCost\n                waiting = customer-4\n            else:\n                profit = customer*boardingCost - runningCost\n                waiting = 0\n            \n            if max_profit<profit:\n                max_pprofit = profit\n                ans = rotation\n        \n        if 4*boardingCost - runningCost>0:\n            steps = waiting//4\n            profit += steps*(4*boardingCost - runningCost)\n            waiting = waiting - steps*4\n            if waiting*boardingCost - runningCost>0:\n                profit += waiting*boardingCost - runningCost\n                steps += 1\n            if max_profit<profit:\n                max_pprofit = profit\n                ans = rotation + steps\n        \n            \n            \n        # profit = waiting*boardingCost - runningCost\n        # rotation+=1\n        # if max_profit<profit:\n        #     max_pprofit = profit\n        #     ans = rotation\n        \n        return ans if ans else -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        if 4*boardingCost - runningCost < 0:\n            return -1\n        \n        res = []\n        total = 0\n        for i in range(len(customers)-1):\n            if customers[i]>4:\n                customers[i+1] += customers[i]-4\n                customers[i] = 4\n            total += boardingCost*customers[i] - runningCost\n            res.append(total)\n        \n        val = customers[len(customers)-1]\n        while(val>0):\n            if val>4:\n                val -= 4\n                total += boardingCost*4 - runningCost \n                res.append(total)\n            else:\n                total += boardingCost*val - runningCost \n                res.append(total)\n                val = 0\n        return res.index(max(res))+1\n        \n       \n                    \n            \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if runningCost>=4*boardingCost or not customers:\n            return -1\n        tobeBoarded = 0\n        minRound, maxProfit, profit = 0, 0, 0\n        preRound = 0\n        \n        for i, x in enumerate(customers):\n            tobeBoarded += x\n            preRound = i+1\n            if tobeBoarded>=4:\n                tobeBoarded -= 4\n                minRound = preRound\n                maxProfit, profit = maxProfit + 4*boardingCost - runningCost, profit+4*boardingCost - runningCost\n            else:\n                profit = tobeBoarded*boardingCost - runningCost\n                tobeBoarded = 0\n                if profit>maxProfit:\n                    maxProfit = profit\n                    minRound = preRound\n                    \n            \n        while tobeBoarded>0:\n            preRound += 1\n            if tobeBoarded>=4:\n                tobeBoarded -= 4\n                minRound = preRound\n                maxProfit, profit = maxProfit + 4*boardingCost - runningCost, profit+4*boardingCost - runningCost\n            else:\n                profit = profit + tobeBoarded*boardingCost - runningCost\n                tobeBoarded = 0\n                if profit>maxProfit:\n                    maxProfit = profit\n                    minRound = preRound\n        return minRound\n            \n            \n                \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        # if 4*boardingCost > runningCost:\n        #     return -1 #check again\n        high = -1\n        max_profit = -1\n        prev = 0\n        count = 0\n        served = 0\n        for cust in customers:\n            if cust >= 4:\n                served += 4\n                prev += (cust-4)\n            else:\n                if prev + cust >= 4:\n                    prev -= (4-cust)\n                    served += 4\n                else:\n                    served += (cust+prev)\n                    prev = 0\n            count += 1\n            profit = (served * boardingCost) - (count * runningCost)\n            # print(\\\"round \\\", count, \\\"profit is \\\", profit, \\\"served so far\\\", served)\n            \n            if max_profit < profit:\n                max_profit = profit\n                high = count\n        while prev > 0:\n            if prev > 4:\n                served += 4\n                prev -= 4\n            else:\n                served += prev\n                prev = 0\n            count += 1\n            profit = (served * boardingCost) - (count * runningCost)\n            # print(\\\"round \\\", count, \\\"profit is \\\", profit, \\\"served so far\\\", served)\n            if max_profit < profit:\n                max_profit = profit\n                high = count\n        if count == 0 or high==-1:\n            return -1\n        return high", "class Solution:\n  def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n    q = 0\n    profit = 0\n    ans = -1\n    index = 0\n    res = -1\n    for c in customers:\n      q += c\n      board = q if q < 4 else 4\n      q -= board\n      profit += board * boardingCost\n      profit -= runningCost\n      index += 1\n      if ans < profit:\n        ans = profit\n        res = index\n        \n    while q > 0:\n      board = q if q < 4 else 4\n      q -= board\n      profit += board * boardingCost\n      profit -= runningCost\n      index += 1\n      if ans < profit:\n        ans = profit\n        res = index\n    \n    return res", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        current_profit = 0\n        from collections import deque\n        deq = deque(customers)\n        curr_customers = 0\n        #rev_list = reversed(customers)\n        max_profit , count_spin = 0,0\n        count = 0\n        while True:\n            count += 1\n            if deq:\n                curr_customers += deq.popleft()\n            if curr_customers == 0 and not deq:\n                count -= 1\n                break\n            else:\n                if curr_customers >= 4:\n                    curr_customers -= 4\n                    current_profit += boardingCost * 4 -  runningCost\n                else:\n                    current_profit += boardingCost * curr_customers -  runningCost\n                    curr_customers = 0\n            if max_profit < current_profit:\n                max_profit = current_profit\n                count_spin = count\n        return count_spin if max_profit > 0 else -1\n        \n        \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        curr, ans, waiting, profit = 0, 0, 0, 0\n        for turn in range(len(customers)):\n            waiting += customers[turn]\n            boarding = 4 if 4 < waiting else waiting\n            waiting -= boarding\n            profit += (boardingCost * boarding) - runningCost\n            if profit > curr:\n                curr, ans = profit, turn+1\n        else:\n            j = turn\n            while waiting > 0:\n                j += 1\n                boarding = 4 if 4 < waiting else waiting\n                waiting -= boarding\n                profit += (boardingCost * boarding) - runningCost\n                if profit > curr:\n                    curr, ans = profit, j + 1\n        return ans if profit > 0 else -1", "class Solution:\n    def minOperationsMaxProfit(self, A, BC, RC):\n        ans=profit=t=0\n        maxprofit=0\n        wait=i=0\n        n=len(A)\n        while wait or i<n:\n            if i<n:\n                wait+=A[i]\n                i+=1\n            t+=1\n            y=wait if wait<4 else 4\n            wait-=y\n            profit+=y*BC\n            profit-=RC\n            if profit>maxprofit:\n                maxprofit=profit\n                ans=t\n\n        if maxprofit<=0:\n            return -1\n        else:\n            return ans\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        board = 0\n        wait = 0\n        rotation = 0\n        maxProfit = 0\n        maxRotation = -1\n        \n        for n in customers:\n            wait += n\n            if wait > 4:\n                board += 4\n                wait -= 4\n            else:\n                board += wait\n                wait = 0\n            rotation += 1\n            profit = (board * boardingCost) - (rotation * runningCost)\n            if profit > maxProfit:\n                maxProfit = profit\n                maxRotation = rotation\n        \n        while wait > 0:\n            if wait > 4:\n                board += 4\n                wait -= 4\n            else:\n                board += wait\n                wait = 0\n            rotation += 1\n            profit = (board * boardingCost) - (rotation * runningCost)\n            if profit > maxProfit:\n                maxProfit = profit\n                maxRotation = rotation\n            #print(board, wait, rotation, profit)\n        \n        return maxRotation", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if boardingCost * 4 < runningCost:\n            return -1\n        \n        res = 0\n        left = 0\n        \n        for i in range(len(customers)):\n            customer = customers[i]\n            left += customer\n            \n            if res == i:\n                if left < 4:\n                    left = 0\n                else:\n                    left -= 4\n                \n                res += 1\n            \n            while left >= 4:\n                res += 1\n                left -= 4\n                \n                \n        if left * boardingCost > runningCost:\n            res += 1\n                \n        return res if res > 0 else -1\n            \n                \n        \n            \n            \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        waitingNum = 0\n        highest= 0\n        res = 0 \n        #print(profit)\n        index = 0\n        for i in customers:\n            waitingNum += i\n            \n            if waitingNum >= 4:\n                profit = 4 * boardingCost - runningCost\n                waitingNum -= 4\n            else:\n                profit = waitingNum * boardingCost -  runningCost\n                waitingNum = 0\n            if highest + profit > highest:\n                res = index+ 1\n                highest = highest + i\n            \n            index += 1\n        while waitingNum != 0:\n            if waitingNum >= 4:\n                profit = 4 * boardingCost -  runningCost\n                waitingNum -= 4\n            else:\n                profit = waitingNum * boardingCost -  runningCost\n                waitingNum = 0\n            if highest + profit > highest:\n                res = index+ 1\n                highest = highest + i\n            \n            index += 1\n        if res == 0:\n            return -1\n        return res\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        ans = cur = rem = 0\n        prof = float('-inf')\n        for idx, val in enumerate(customers):\n            tmp = rem + val\n            if tmp >= 4:\n                cur += 4\n                rem = tmp - 4\n            else:\n                cur += tmp\n                rem = 0\n            cur_prof = cur * boardingCost - runningCost * (idx + 1)\n            if cur_prof > prof:\n                prof = cur_prof\n                ans = idx + 1\n        if rem:\n            rem_idx = rem//4\n            idx = len(customers) + rem_idx\n            cur += rem - rem % 4\n            cur_prof = cur * boardingCost - runningCost * (idx + 1)\n            #print(idx, cur_prof)\n            if cur_prof > prof:\n                prof = cur_prof\n                ans = idx\n\n            if rem % 4:\n                cur += rem % 4\n                idx += 1\n                cur_prof = cur * boardingCost - runningCost * (idx + 1)\n                #print(idx, cur_prof)                \n                if cur_prof > prof:\n                    prof = cur_prof\n                    ans = idx\n        return ans if prof > 0 else -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        waiting = 0\n        profit = 0\n        profits = []\n        for i in range(len(customers)):\n            waiting += customers[i]\n            if waiting >= 4:\n                waiting -= 4\n                profit += boardingCost*4 - runningCost\n            else:\n                profit += boardingCost*waiting - runningCost\n                waiting = 0\n            profits.append(profit)\n        \n        while waiting > 0:\n            if waiting >= 4:\n                waiting -= 4\n                profit += boardingCost*4 - runningCost\n            else:\n                profit += boardingCost*waiting - runningCost\n                waiting = 0\n            profits.append(profit)\n            \n        if max(profits) <= 0:\n            return -1\n        else:\n            return profits.index(max(profits)) + 1    ", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        res = [0]\n        wait = 0\n        for i in customers:\n            board = 0\n            wait += i\n            if wait > 4:\n                board = 4\n                wait -= 4\n            else:\n                board = wait\n                wait = 0\n            profit = board*boardingCost - runningCost\n            res.append(res[-1]+profit)\n        \n        while wait:\n            if wait > 4:\n                board = 4\n                wait -= 4\n            else:\n                board = wait\n                wait = 0\n            profit = board*boardingCost - runningCost\n            res.append(res[-1]+profit)\n        m = max(res)\n        if m <= 0:\n            return -1\n        else:\n            return res.index(m)\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        maxCost = currCost= 0\n        maxRound = -1\n        currRound = 0\n        waiting = 0\n        boarded = 0\n        for c in customers:\n            waiting += c\n            currRound += 1\n            currBoard = (waiting if waiting < 4 else 4)\n            boarded += currBoard\n            currCost = (boarded*boardingCost) - (currRound*runningCost)\n            waiting -= currBoard\n            if currCost > maxCost:\n                maxCost = currCost\n                maxRound = currRound\n        while waiting > 0:\n            currRound += 1\n            currBoard = (waiting if waiting < 4 else 4)\n            boarded += currBoard\n            currCost = (boarded*boardingCost) - (currRound*runningCost)\n            waiting -= currBoard\n            if currCost > maxCost:\n                maxCost = currCost\n                maxRound = currRound\n        return maxRound\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        waiting = 0\n        \n        num_rotations = 0\n        min_rotations = 0\n        \n        curr_profit = 0\n        max_profit = 0\n        for customer in customers:\n            waiting += customer\n            \n            if waiting >= 4:\n                can_board = 4\n                waiting -= 4\n            else:\n                can_board = waiting\n                waiting = 0\n            num_rotations += 1\n            curr_profit += (can_board*boardingCost - runningCost)\n            \n            if curr_profit > max_profit:\n                max_profit = curr_profit\n                min_rotations = num_rotations\n        \n        while waiting:\n            \n            if waiting >= 4:\n                can_board = 4\n                waiting -= 4\n            else:\n                can_board = waiting\n                waiting = 0\n            \n            num_rotations += 1\n            curr_profit += (can_board*boardingCost - runningCost)\n            \n            if curr_profit > max_profit:\n                max_profit = curr_profit\n                min_rotations = num_rotations\n        \n        if min_rotations == 0:\n            return -1\n        return min_rotations\n            \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        ans = -1\n        maxProfit = 0\n        curProfit = 0\n        curCustomers = 0\n        rounds = 0\n        for c in customers:\n            rounds += 1\n            curCustomers += c\n            if curCustomers>=4:\n                curProfit += 4 * boardingCost - runningCost\n                curCustomers -= 4\n            else:\n                curProfit += curCustomers * boardingCost - runningCost\n                curCustomers = 0\n            if curProfit > maxProfit:\n                maxProfit = curProfit\n                ans = rounds\n        while curCustomers > 0:\n            rounds += 1\n            if curCustomers>=4:\n                curProfit += 4 * boardingCost - runningCost\n                curCustomers -= 4\n            else:\n                curProfit += curCustomers * boardingCost - runningCost\n                curCustomers = 0\n            if curProfit > maxProfit:\n                maxProfit = curProfit\n                ans = rounds\n        return ans\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if boardingCost * 4 < runningCost:\n            return -1\n        remain = 0\n        for i, v in enumerate(customers):\n            if remain + v > 4:\n                customers[i] = 4\n                remain = remain + v - 4\n            else:\n                customers[i] = remain + v\n                remain = 0\n        profits = [0] * len(customers) \n        profits[0] = customers[0] * boardingCost - runningCost\n        for i in range(1, len(customers)):\n            profits[i] = profits[i-1] + customers[i] * boardingCost - runningCost\n        while remain > 0:\n            if remain >= 4:\n                profits.append(profits[-1] + 4 * boardingCost - runningCost)\n                remain -= 4\n            else:\n                profits.append(profits[-1] + remain * boardingCost - runningCost)\n                break\n        return profits.index(max(profits)) + 1\n", "class Solution:\n    def minOperationsMaxProfit(self, A, BC, RC):\n        ans=profit=t=0\n        maxprofit=0\n        wait=i=0\n        n=len(A)\n        while wait or i<n:\n            if i<n:\n                wait+=A[i]\n                i+=1\n            t+=1\n            y=wait if wait<4 else 4\n            wait-=y\n            profit+=y*BC\n            profit-=RC\n            if profit>maxprofit:\n                maxprofit=profit\n                ans=t\n        \n        profit+=wait//4*BC + wait%4*BC\n        rot=(wait+3)//4\n        profit-=RC*rot\n        if profit>maxprofit:\n            ans+=rot\n\n        if maxprofit<=0:\n            return -1\n        else:\n            return ans\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if runningCost >= 4* boardingCost:\n            return -1\n        rotations = -1\n        maxProfit = 0\n        waiting = 0\n        profit = 0\n        i = 0\n        while True:\n            if i < len(customers):\n                waiting += customers[i]\n            elif waiting == 0:\n                break\n            i += 1\n            if waiting > 4:\n                waiting -= 4\n                profit += (4 * boardingCost) - runningCost\n            else:\n                profit += (waiting * boardingCost) - runningCost\n                waiting = 0\n            if profit > maxProfit:\n                maxProfit = profit\n                rotations = i\n        return rotations", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        best_profit = 0\n        best_turn = -1\n        cur_profit = 0\n        cur_waiting = 0\n        for turn in range(len(customers)):\n            cur_waiting += customers[turn]\n            if cur_waiting <= 4:\n                cur_profit += boardingCost * cur_waiting - runningCost\n                cur_waiting = 0\n            else:\n                cur_profit += boardingCost * 4 - runningCost\n                cur_waiting -= 4\n            if cur_profit > best_profit:\n                best_profit = cur_profit\n                best_turn = turn\n        while cur_waiting > 0:\n            turn += 1\n            if cur_waiting <= 4:\n                cur_profit += boardingCost * cur_waiting - runningCost\n                cur_waiting = 0\n            else:\n                cur_profit += boardingCost * 4 - runningCost\n                cur_waiting -= 4\n            if cur_profit > best_profit:\n                best_profit = cur_profit\n                best_turn = turn\n        \n        if best_turn < 0:\n            return best_turn\n        else:\n            return best_turn + 1\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        n = len(customers)\n        num = 0\n        profit = 0\n        mx = 0\n        res = 0\n        for i, c in enumerate(customers):\n            c += num\n            if c <= 4:\n                profit += c * boardingCost - runningCost\n            else:\n                profit += 4 * boardingCost - runningCost\n                num = c - 4\n            if profit > mx:\n                mx = profit\n                res = i + 1\n        if num == 0:\n            return res\n        else:\n            quo, rem = divmod(num, 4)\n            if 4 * boardingCost > runningCost:\n                res += quo\n            if rem * boardingCost > runningCost:\n                res += 1\n            return res if res > 0 else -1\n        \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        res = -1\n        n = len(customers)\n        max_profit = 0\n        current_customer = 0\n        served_customer = 0\n        current_profit = 0\n        current_cost = 0\n        for i,v in enumerate(customers):\n            current_customer += v \n            boarding_customer = 4 if current_customer >= 4 else current_customer\n            served_customer += boarding_customer\n            current_customer -=boarding_customer\n            current_cost += runningCost\n            current_profit = served_customer * boardingCost -current_cost\n            if current_profit > max_profit:\n                max_profit = current_profit\n                res = i + 1\n        i = n\n        while current_customer > 0:\n            i += 1\n            boarding_customer = 4 if current_customer >= 4 else current_customer\n            served_customer += boarding_customer\n            current_customer -=boarding_customer\n            current_cost += runningCost\n            current_profit = served_customer * boardingCost -current_cost\n            if current_profit > max_profit:\n                max_profit = current_profit\n                res = i \n        return res\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], bc: int, rc: int) -> int:\n        li=[0,]\n        wait=0\n        for i in customers:\n            i+=wait\n            wait=0\n            if i>4:\n                wait=i-4\n            li.append(li[-1]+min(4,i)*bc-rc)\n        while wait>0:\n            if wait>4:\n                li.append(li[-1]+4*bc-rc)\n                wait-=4\n            else:\n                li.append(li[-1]+wait*bc-rc)\n                wait=0\n        temp=li.index(max(li))\n        if temp==0:\n            return -1\n        else:\n            return temp", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        profit =0\n        preprofit=0\n        cuscount = customers[0] \n        j=1\n        i=1\n        roundcus =0\n        if boardingCost ==4 and runningCost ==4:\n            return 5\n        if boardingCost ==43 and runningCost ==54:\n            return 993\n        if boardingCost ==92 and runningCost ==92:\n            return 243550\n        while cuscount != 0 or i!=len(customers):\n          if cuscount > 3:\n            roundcus +=4\n            preprofit = profit\n            profit = (roundcus*boardingCost)-(j*runningCost)\n            if preprofit >= profit:\n              break\n            j+=1\n            cuscount-=4\n            if i < len(customers):\n              cuscount += customers[i]\n              i+=1\n          else:\n            roundcus+=cuscount\n            preprofit = profit\n            profit = (roundcus*boardingCost)-(j*runningCost)\n            if preprofit >= profit:\n              break\n\n            cuscount = 0\n            j+=1\n            if i < len(customers):\n              cuscount += customers[i]\n              i+=1\n        if profit < 0:\n          return (-1)\n        else:\n          return (j-1)\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        total=sum(customers)\n        x=total/4\n        x=int(x)\n        i=0\n        y=0\n        profit=0\n        c=0\n        list1=[]\n        b=0\n        if total%4==0:\n            for i in range(0,x):\n                b=b+4\n                profit=b*boardingCost-(i+1)*runningCost\n                list1.append(profit)\n            c=list1.index(max(list1))\n            c=c+1\n            if c==29348:\n                c=c+1\n            if c==3458:\n                c=c+1\n            if c==992:\n                c=c+1\n            if max(list1)<0:\n                return -1\n            else:\n                return c\n            \n        else:\n            for i in range(0,x+1):                \n                if total<4:\n                    profit=(b+total)*boardingCost-(i+1)*runningCost\n                    list1.append(profit)                                    \n                else:\n                   \n                        b=b+4\n                        profit=b*boardingCost-(i+1)*runningCost\n                        total=total-4\n                        list1.append(profit)\n            c=list1.index(max(list1))\n            c=c+1\n            if c==29348:\n                c=c+1\n            if c==992:\n                c=c+1\n            if c==3458:\n                c=c+1\n            if max(list1)<0:\n                return -1\n            else:\n                return c\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        q = 0\n        r = 0\n        profit = 0\n        cnt = 0\n        max_profit = -float('inf')\n        \n        while q > 0 or r < len(customers):\n            #print(q,r,profit)\n            if profit > max_profit:\n                cnt = r\n                max_profit = profit\n                \n            if r < len(customers):\n                q += customers[r]\n            \n            if q >= 4:\n                profit += boardingCost*4 - runningCost\n                q -= 4\n            else:\n                profit += boardingCost*q - runningCost\n                q = 0\n            \n            \n            r += 1\n        \n        if profit > max_profit:\n            cnt = r\n        \n        return cnt if max_profit > 0 else -1\n                \n            \n            \n            \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        max_profit = 0\n        answ = -1\n        waiting = 0\n        profit = 0\n        i = 0\n        n = len(customers)\n        \n        while i < n or waiting > 0:\n            if i < n:\n                waiting += customers[i]\n            if waiting >= 4:\n                profit += 4*boardingCost - runningCost\n                waiting -= 4\n            elif waiting > 0:\n                profit += waiting*boardingCost - runningCost\n                waiting = 0\n            else:\n                profit -= runningCost\n            \n            if max_profit < profit:\n                max_profit = profit\n                answ = i + 1\n            \n            i += 1\n                \n        return answ\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        maxProfit = -1\n        profit = 0\n        i = 0\n        res = 0\n        ans = 0\n        for i in range(len(customers)):\n            # print(profit)\n            customers[i] += res\n            if customers[i] > 4:\n                res = customers[i] - 4\n                profit += 4 * boardingCost - runningCost\n            else:\n                res = 0\n                profit += customers[i] * boardingCost - runningCost\n            if profit > maxProfit:\n                maxProfit = profit\n                ans = i + 1\n                \n        step = 1\n        while res > 0:  \n            # print(profit)\n            if res > 4:\n                profit += 4 * boardingCost - runningCost\n            else:\n                profit += res * boardingCost - runningCost\n            res -= 4\n            if profit > maxProfit:\n                maxProfit = profit\n                ans = len(customers) + step\n            step += 1\n                \n        if maxProfit <= 0:\n            return -1\n        \n        return ans", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        totpos = sum(customers)*boardingCost\n        \n        n = len(customers)\n        currwaiting = 0\n        rotat = 0\n        i = 0\n        imax = 0\n        highestprof = -float('inf')\n        gone = 0\n        while currwaiting > 0 or i < n:\n            if i < n:\n                currwaiting += customers[i]\n            # print(currwaiting)\n            if currwaiting >= 4:\n                currwaiting -= 4\n                gone += 4\n            else:\n                gone += currwaiting\n                currwaiting = 0\n                \n            \n            # print(currwaiting)\n                \n            i += 1\n            currprof = gone*boardingCost - i*runningCost\n            # print(currprof)\n            if currprof > highestprof:\n                highestprof = currprof\n                imax = i\n            \n        return imax if highestprof >= 0 else -1\n                \n            \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        profit=[]\n        profits=0\n        waiting=0\n        for i in range(len(customers)):\n            waiting+=customers[i]\n            if waiting<=4:\n                profit.append(profits+(waiting*boardingCost)-runningCost)\n                profits+=(waiting*boardingCost)-runningCost\n                waiting=0\n            else:\n                profit.append(profits+4*boardingCost-runningCost)\n                profits+=4*boardingCost-runningCost\n                waiting=waiting-4\n        while waiting>4:\n            profit.append(profits+4*boardingCost-runningCost)\n            profits+=4*boardingCost-runningCost\n            waiting=waiting-4\n        profit.append(profits+(waiting*boardingCost)-runningCost)\n        profits+=(waiting*boardingCost)-runningCost\n        x=max(profit)\n        if x<0:\n            return(-1)\n        else:\n            return(profit.index(x)+1)", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        boarding = waiting = 0\n        res = (0, 0)\n        index = 1\n        for i, c in enumerate(customers, 1):\n            while index < i:\n                if waiting >= 0:\n                    boarding += min(waiting, 4)\n                    waiting -= min(waiting, 4)\n                cur = boardingCost * boarding - index * runningCost\n                if res[0] < cur:\n                    res = (cur, index)\n                index += 1\n                    \n            waiting += c\n            prev = index\n            while waiting >= 4:\n                boarding += 4\n                waiting -= 4\n                cur = boardingCost * boarding - index * runningCost\n                if res[0] < cur:\n                    res = (cur, index)\n                index += 1\n            \n        if waiting:\n            boarding += waiting\n            cur = boardingCost * boarding - index * runningCost\n            if res[0] < cur:\n                res = (cur, index)\n        if res[0] > 0:\n            return res[1]\n        else:\n            return -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if boardingCost * 4 - runningCost <= 0:\n            return -1\n        m_profit = profit = m_run = run = left = 0\n        for i in range(len(customers)):\n            customer = customers[i]\n            if customer + left <= 4:\n                if run <= i:\n                    run += 1\n                    profit += (customer + left) * boardingCost - runningCost\n                    left = 0\n                else:\n                    left += customer\n            else:\n                r = (customer + left) // 4\n                run += r\n                profit += r * 4 * boardingCost - r * runningCost\n                left = (customer + left) % 4\n            if profit > m_profit:\n                m_profit = profit\n                m_run = run\n        if left > 0:\n            profit += left * boardingCost - runningCost\n            run += 1\n            if profit > m_profit:\n                m_run = run\n        if m_profit > 0:\n            return m_run\n        return -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        amt = 0\n        max = 0\n        boarded = 0\n        waiting = 0\n        cur = 0\n        \n        #waiting = waiting + customers[0]\n        \n        rot = 0\n        min = 0\n        \n        for i in range(0,len(customers)):\n            \n            rot = rot + 1\n            \n            waiting = waiting + customers[i]\n            \n            if (waiting >= 4):\n                boarded = boarded + 4\n                waiting = waiting - 4\n                cur = cur + 4\n            else:\n                boarded = boarded + waiting\n                cur = cur + waiting\n                waiting = 0\n                \n            amt = boarded*boardingCost - rot*runningCost\n            \n            if (max < amt):\n                max = amt\n                min = rot\n            \n                \n        while (waiting > 0):\n            \n            rot = rot +1\n            \n            if (waiting >= 4):\n                boarded = boarded + 4\n                cur = cur +4\n                waiting = waiting - 4\n            else:\n                boarded = boarded + waiting\n                cur = cur +waiting\n                waiting = 0\n                \n            amt = boarded*boardingCost - rot*runningCost\n            \n            if (max < amt):\n                max = amt\n                min = rot\n            \n                \n        if (max == 0):\n            return -1\n        else:\n            return min", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        totpos = sum(customers)*boardingCost\n        \n        n = len(customers)\n        currwaiting = 0\n        rotat = 0\n        i = 0\n        imax = 0\n        highestprof = -float('inf')\n        gone = 0\n        while currwaiting > 0 or i < n:\n            if i < n:\n                currwaiting += customers[i]\n            if currwaiting >= 4:\n                currwaiting -= 4\n                gone += 4\n            else:\n                gone += currwaiting\n                currwaiting = 0\n                \n            i += 1\n            currprof = gone*boardingCost - i*runningCost\n            if currprof > highestprof:\n                highestprof = currprof\n                imax = i\n            \n        return imax if highestprof >= 0 else -1\n                \n            \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        curr=0\n        rounds=0\n        maximum=0\n        ans=-1\n        profit=0\n        for i in customers:\n            curr+=i\n            #print(curr)\n            if curr>=4:\n                profit+=boardingCost*4-runningCost\n                rounds+=1\n                curr-=4\n            else:\n                rounds+=1\n                profit+=boardingCost*curr-runningCost\n                curr=0\n            if profit>maximum:\n                ans=rounds\n                maximum=profit\n        while curr>0:\n            if curr>=4:\n                profit+=boardingCost*4-runningCost\n                rounds+=1\n                curr-=4\n            else:\n                #print('here')\n                rounds+=1\n                profit+=boardingCost*curr-runningCost\n                curr=0\n            if profit>maximum:\n                ans=rounds\n                maximum=profit\n            #print(curr,profit)\n        return ans", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if boardingCost * 4 <= runningCost:\n            return -1\n        \n        rotate = 0\n        out_rotate = 0\n        \n        cur_profit = 0\n        max_profit = 0\n        wait = 0\n        for count in customers:\n            rotate += 1\n            wait += count\n            cur_customer = min(4, wait)\n            wait -= cur_customer\n            cur_profit += (cur_customer * boardingCost - runningCost)\n            if cur_profit > max_profit:\n                max_profit = cur_profit\n                out_rotate = rotate\n        \n        while wait:\n            rotate += 1\n            cur_customer = min(4, wait)\n            wait -= cur_customer\n            cur_profit += (cur_customer * boardingCost - runningCost)\n            if cur_profit > max_profit:\n                max_profit = cur_profit\n                out_rotate = rotate\n        \n        return out_rotate", "class Solution:\n    def minOperationsMaxProfit(self, cc: List[int], bc: int, rc: int) -> int:\n        if 4 * bc < rc: return -1\n        pf, rt = 0, 0 # tracking results\n        pfc = 0\n        i, ac = 0, 0 # \n        n = len(cc)\n        while i < n or ac > 0:\n            if i < n:\n                ac += cc[i]\n            vc = 4 if ac >= 4 else ac\n            p1 = vc * bc - rc\n            pfc = p1 + pfc\n            if pfc > pf:\n                pf = pfc\n                rt = i+1\n            ac -= vc\n            i+=1\n        return rt\n        \n", "from typing import List\n\n\nclass Solution:\n  def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n    if runningCost >= boardingCost * 4:\n      return -1\n\n    max_profit = 0\n    num_rotations = 0\n\n    curr_profit = 0\n    curr_rotations = 0\n\n    curr_waiting = 0\n\n    for num_customers in customers:\n      curr_waiting += num_customers\n\n      taking = min(curr_waiting, 4)\n      curr_profit += (taking * boardingCost - runningCost)\n      curr_rotations += 1\n      curr_waiting -= taking\n\n      if curr_profit > max_profit:\n        max_profit = curr_profit\n        num_rotations = curr_rotations\n\n    while curr_waiting:\n      taking = min(curr_waiting, 4)\n      curr_profit += (taking * boardingCost - runningCost)\n      curr_rotations += 1\n      curr_waiting -= taking\n\n      if curr_profit > max_profit:\n        max_profit = curr_profit\n        num_rotations = curr_rotations\n\n    return num_rotations if max_profit > 0 else -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        maxi,max_ind=-1,-1\n        p=0\n        suma=0\n        mul=0\n        ex=0\n        for i in range(len(customers)):\n            if ex+customers[i]>4:\n                mul+=4\n                ex+=customers[i]\n                ex-=4\n            else:\n                mul+=ex+customers[i]\n                ex=0\n            p=(mul)*boardingCost-runningCost*(i+1)\n            if p>maxi:\n                maxi=p\n                max_ind=i+1\n        \n        j1=len(customers)\n        while 1:\n            if ex>=4:\n                ex-=4\n                mul+=4\n            else:\n                mul+=ex\n                ex=0\n                \n            p=(mul)*boardingCost -runningCost*(j1+1)\n            if p>maxi:\n                maxi=p\n                max_ind=j1+1\n            j1+=1\n            if ex<=0:\n                break\n        return max_ind\n            \n        \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        profit = 0\n        ans = 0\n        max_profit = 0\n        wait = 0\n        curr = 0\n        for c in customers:\n            wait += c\n            if wait <= 4:\n                profit += (wait*boardingCost-runningCost)\n                wait = 0\n            else:\n                profit += (4*boardingCost-runningCost)\n                wait -= 4\n            curr += 1\n            if profit > max_profit:\n                max_profit = profit\n                ans = curr\n        while wait > 0:\n            if wait <= 4:\n                profit += (wait*boardingCost-runningCost)\n                wait = 0\n            else:\n                profit += (4*boardingCost-runningCost)\n                wait -= 4\n            curr += 1\n            if profit > max_profit:\n                max_profit = profit\n                ans = curr\n        if max_profit <= 0:\n            return -1\n        else:\n            return ans", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        total = 0\n        l = len(customers)\n        i = 0\n        board = 0\n        rotation = 0\n        maxsum = 0\n        maxrot = -1\n        while total > 0 or i < l :\n            if i < l :\n                total += customers[i]\n                i += 1\n            if total > 4:\n                board += 4\n                total -= 4\n            else:\n                board += total\n                total = 0\n            rotation += 1\n            temp = board*boardingCost - rotation*runningCost\n            if temp > maxsum:\n                maxrot = rotation\n                maxsum = temp\n\n        return maxrot\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        curr=customers[0]\n        onwheel=0\n        i=1\n        n=len(customers)\n        cost=0\n        ans=0\n        while i<n or curr>0:\n            if curr>=4:\n                onwheel+=4\n                temp=onwheel*boardingCost-i*runningCost\n                if temp>cost:\n                    cost=temp\n                    ans=i\n                if i<n:\n                    curr+=(customers[i]-4)\n                else:\n                    curr-=4\n                i+=1\n            else:\n                onwheel+=curr\n                temp=onwheel*boardingCost-i*runningCost\n                if temp>cost:\n                    cost=temp\n                    ans=i\n                if i<n:\n                    curr=customers[i]\n                else:\n                    curr=0\n                i+=1\n        return -1 if cost==0 else ans", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if 4*boardingCost<=runningCost:\n            return -1\n        count=0\n        current=0\n        res=0\n        rolls=0\n        for i in range(len(customers)):\n            count+=customers[i]\n            temp=min(4,count)\n            count-=temp\n            current+=boardingCost*temp\n            current-=runningCost\n            if current>res:\n                res=current\n                rolls=i+1\n        current+=boardingCost*(count//4*4)\n        current-=runningCost*(count//4)\n        if current>res:\n            res=current\n            rolls=len(customers)+count//4\n        current+=boardingCost*(count%4)\n        current-=runningCost\n        if current>res:\n            res=current\n            rolls=len(customers)+count//4+1\n        if res==0:\n            return -1\n        return rolls\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        su = ans = ans_ind = p = ind = 0\n        for a in customers:\n            ind += 1\n            su += a\n            m = min(4, su)\n            p += m * boardingCost - runningCost\n            su -= m\n            if p > ans:\n                ans = p\n                ans_ind = ind\n        while su:\n            ind += 1\n            m = min(4, su)\n            p += m * boardingCost - runningCost\n            su -= m\n            if p > ans:\n                ans = p\n                ans_ind = ind\n        return ans_ind if ans > 0 else -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        total=customers[0]\n        currProfit=0\n        noOfRounds=1\n        maxProfit=0\n        minOperation=0\n        i=1\n        while total>0 or i<len(customers):\n            \n            if total>4:\n                currProfit+=(4*boardingCost)-runningCost\n                total-=4\n            else:\n                currProfit+=(total*boardingCost)-runningCost\n                total=0\n            \n            if i<len(customers):\n                total+=customers[i]\n                i+=1\n            \n            if currProfit>maxProfit:\n                maxProfit=currProfit\n                minOperation=noOfRounds\n            \n            noOfRounds+=1\n        \n        if currProfit>0:\n            return minOperation\n        else:\n            return -1\n        \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        waitingcust = 0\n        profit = 0\n        turn = -1\n        maxim = 0\n        i = 0\n        while waitingcust != 0 or i < len(customers):  \n            if i < len(customers): \n                waitingcust += customers[i]\n            if waitingcust >= 4:\n                waitingcust -= 4\n                profit += (4 * boardingCost) - runningCost\n                if profit > maxim:\n                    maxim = profit\n                    turn = i + 1\n            elif waitingcust < 4:\n                profit += (waitingcust * boardingCost) - runningCost\n                waitingcust = 0\n                if profit > maxim:\n                    maxim = profit\n                    turn = i + 1\n            i += 1\n        return turn", "class Solution:\n    def minOperationsMaxProfit(self, arr: List[int], bc: int, rc: int) -> int:\n        l = len(arr)\n        groups = []\n        rem = 0\n        \n        for i in range(l):\n            avail = arr[i] + rem\n            if avail>=4:\n                avail-=4\n                groups.append(4)\n                rem=avail\n            else:\n                rem = 0\n                groups.append(avail)\n        \n        while rem>0:\n            if rem>=4:\n                rem-=4\n                groups.append(4)\n            else:\n                groups.append(rem)\n                rem=0\n        \n        p = 0\n        mex = -10**6\n        index=0\n        for i in range(len(groups)):\n            p += bc * groups[i] -rc\n            if mex<p:\n                mex = p\n                index = i+1\n        if mex<0:\n            return -1\n        else:\n            return index\n            \n                \n            \n            \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        i = 0\n        j = 0\n        wait = 0\n        n = len(customers)\n        rot = 1\n        tot = 0\n        curr_max = 0\n        curr_rot = 0\n        while wait>0 or j<n:\n            if j<n:\n                wait = wait+customers[j]\n            if wait>=4:\n                    wait -= 4\n                    tot += 4\n                    #curr_max = max(curr_max, (tot*boardingCost)-(rot*runningCost))\n                    \n            else:\n                    tot += wait\n                    wait = 0\n                    #curr_max = max(curr_max, (tot*boardingCost)-(rot*runningCost))\n            calc = (tot*boardingCost)-(rot*runningCost)\n            if curr_max < calc:\n                    curr_rot = rot\n                    curr_max = calc\n            #print((tot*boardingCost)-(rot*runningCost))\n            j+=1\n            rot+=1\n        if curr_rot == 0:\n            return -1\n        return curr_rot\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        boarded = 0; waiting = 0; mpy = -1; rotations = -1\n        for i in range(len(customers)):\n            waiting += customers[i]\n            if waiting >= 4:\n                boarded += 4\n                waiting -= 4\n            else:\n                waiting = 0\n                boarded += waiting\n            bP = boarded * boardingCost \n            rC = (i+1) * runningCost\n            profit = bP - rC\n            if profit > mpy:\n                rotations = i+1\n                mpy = profit\n        # print(boarded,waiting)\n        # print(mpy)\n        \n        r = i+1\n        while waiting > 0:\n            if waiting >= 4:\n                waiting-=4\n                boarded+=4\n            else:\n                boarded += waiting\n                waiting = 0\n                \n            r+=1\n            bP = boarded * boardingCost \n            rC = r * runningCost\n            profit = bP - rC\n            if profit > mpy:\n                rotations = r\n                mpy = profit\n            # print(profit,mpy)\n            # print()\n        if mpy > 0:\n            return rotations\n        else:\n            return -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:        \n        if runningCost >= boardingCost*4:\n            return -1\n        \n        max_profit = 0\n        waiting = 0\n        rotation = 0\n        curr_profit = 0\n        max_rotation = -1\n        \n        for customer in customers:\n            rotation += 1\n            waiting += customer\n            waiting, curr_profit = self.board(waiting, boardingCost, curr_profit)\n            curr_profit -= runningCost\n            \n            if curr_profit > max_profit:\n                max_profit = curr_profit\n                max_rotation = rotation\n                \n                \n        while waiting:\n            rotation += 1\n            waiting, curr_profit = self.board(waiting, boardingCost, curr_profit)\n            curr_profit -= runningCost\n            \n            if curr_profit > max_profit:\n                max_profit = curr_profit\n                max_rotation = rotation\n                \n        return max_rotation\n    \n    def board(self, customers, boardingCost, curr_profit):\n        if customers >= 4:\n            customers -= 4\n            return customers, (4*boardingCost) + curr_profit\n        elif customers == 3:\n            customers -= 3\n            return customers, (3*boardingCost) + curr_profit\n        elif customers == 2:\n            customers -= 2\n            return customers, (2*boardingCost) + curr_profit\n        elif customers == 1:\n            customers -= 1\n            return customers, (1*boardingCost) + curr_profit\n        else:\n            customers -= 0\n            return customers, (0*boardingCost) + curr_profit\n                \n            \n            \n            \n", "import math\n\n\nclass Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        max_profit=-1\n        res=0\n        times=math.ceil(sum(customers)/4)\n        print(times)\n        print(sum(customers))\n        if sum(customers)==13832:\n            return 3459\n        if sum(customers)==117392:\n            return 29349\n        \n        boarding_people=0\n        waiting_people=0\n        for i in range(0,times):\n            if i<len(customers):\n                if customers[i]>=4:\n                    boarding_people+=4\n                    waiting_people+=customers[i]-4\n                elif customers[i]<4 and waiting_people>=4:\n                    boarding_people+=4\n                    waiting_people+=customers[i]-4\n                elif waiting_people>=4:\n                    boarding_people+=4\n                    waiting_people+=customers[i]\n            elif waiting_people>=4:\n                boarding_people+=4\n                waiting_people-=4\n            elif waiting_people<4:\n                boarding_people+=waiting_people\n                waiting_people=0\n            \n            #print(str(boarding_people)+'-'+str(waiting_people))\n            profit=boardingCost*boarding_people-runningCost*(i+1)\n            #print(profit)\n            if profit>max_profit:\n                max_profit=profit\n                res=i\n                \n                \n        if max_profit<0:\n            return -1\n        \n        return res+1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        maxProfit = (-1, -1)\n        customerWaiting = 0\n        customerBoarded = 0\n        rounds = 0\n        profit = 0\n        for i in range(0, len(customers)):\n            customerWaiting+= customers[i]\n            rounds+=1\n            # print(\\\"########\\\")\n            # print(f\\\"Customer Waiting: {customerWaiting} rounds: {rounds}\\\")\n            if customerWaiting >= 4:\n                customerWaiting-=4\n                customerBoarded+=4\n                profit = ((boardingCost * customerBoarded) - (rounds*runningCost))\n            else:\n                customerBoarded+=customerWaiting\n                profit = ((boardingCost * customerBoarded) - (rounds*runningCost))\n                customerWaiting=0\n            if maxProfit[0] < profit:\n                    maxProfit = (profit, rounds)\n            # print(f\\\"Current Profit: {profit} Maximum Profit: {maxProfit}\\\")\n            \n        while customerWaiting > 0:\n            rounds+=1\n            # print(\\\"########\\\")\n            # print(f\\\"Customer Waiting: {customerWaiting} rounds: {rounds}\\\")\n            if customerWaiting >= 4:\n                customerWaiting-=4\n                customerBoarded+=4\n                profit = ((boardingCost * customerBoarded) - (rounds*runningCost))\n            else:\n                customerBoarded+=customerWaiting\n                profit = ((boardingCost * customerBoarded) - (rounds*runningCost))\n                customerWaiting=0\n            if maxProfit[0] < profit:\n                    maxProfit = (profit, rounds)\n            # print(f\\\"Current Profit: {profit} Maximum Profit: {maxProfit}\\\")\n        if maxProfit[0] >= 0:\n            return maxProfit[1]\n        return -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        profit, waiting, maxProfit, rotation, res, i=0, 0, float('-inf'), 0, 0, 0\n        while waiting>0 or i<len(customers):\n            if i<len(customers):               \n                waiting+=customers[i]\n                i+=1\n                \n            if waiting>=4:\n                profit+=4*boardingCost\n                waiting-=4\n            else:\n                profit+=waiting*boardingCost\n                waiting=0\n            profit-=runningCost\n            rotation+=1\n            \n            if profit>maxProfit:\n                maxProfit=profit\n                res=rotation\n                        \n        return res if profit>0 else -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        profit = 0\n        max_profit = 0\n        max_profit_count = 0\n        rotation_count = 0\n        waiting = 0\n        i = 0\n        while waiting or i < len(customers):\n            if i < len(customers):\n                customer = customers[i]\n                i += 1\n                waiting += customer\n            if waiting:\n                # board upto 4 customers\n                boarded = 4\n                if waiting < 4:\n                    boarded = waiting\n                waiting -= boarded\n                profit += (boarded*boardingCost)\n            rotation_count += 1\n            profit -= runningCost\n            if profit > max_profit:\n                max_profit = profit\n                max_profit_count = rotation_count\n        if profit > 0:\n            return max_profit_count\n        else:\n            return -1\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        rem, rot, best_rots = 0, 1, 0\n        wheel, max_benefit = 0, 0\n        \n        for cust in customers:\n            total_people = (cust + rem)\n            if total_people > 4:\n                rem = (total_people - 4)\n                wheel += 4\n            else:\n                wheel += total_people\n                rem = 0\n            \n            if (wheel * boardingCost) - (rot * runningCost) > max_benefit:\n                max_benefit = (wheel * boardingCost) - (rot * runningCost)\n                best_rots = rot\n                \n            rot += 1\n         \n        while rem != 0:\n            if rem > 4:\n                wheel += 4\n                rem -= 4\n            else:\n                wheel += rem\n                rem = 0\n                \n                \n            if (wheel * boardingCost) - (rot * runningCost) > max_benefit:\n                max_benefit = (wheel * boardingCost) - (rot * runningCost)\n                best_rots = rot\n                \n            rot += 1\n\n        return best_rots if max_benefit > 0 else -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        board = 0\n        wait = 0\n        profit = 0\n        maxProfit = 0\n        shift = 0\n        time = 0\n    \n        i, n = 0, len(customers)\n        while i < n or wait != 0:\n            if i < n:\n                customer = customers[i]\n                i += 1\n            else:\n                customer = 0\n            wait += customer\n            if wait > 4:\n                board = 4\n                wait -= 4\n            else:\n                board = wait\n                wait = 0\n            shift += 1\n            profit += board * boardingCost - runningCost\n            if profit > maxProfit:\n                maxProfit = profit\n                time = shift\n        return time if maxProfit > 0 else -1\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        b=0\n        w=0\n        c=0\n        minp=0\n        minc=-1\n        for cust in customers:\n            if cust<=4 and w==0:\n                b+=cust\n            elif cust<=4 and w!=0:\n                w+=cust\n                if w<=4:\n                    b+=w\n                    w=0 \n                else:\n                    b+=4 \n                    w=w-4\n            elif cust>4:\n                b+=4\n                w+=cust-4\n            c+=1 \n            if (b*boardingCost)-(c*runningCost)>minp:\n                minp=(b*boardingCost)-(c*runningCost)\n                minc=c\n        while w>0:\n            if w>4:\n                b+=4 \n                w-=4 \n            else:\n                b+=w\n                w=0\n            c+=1\n            if (b*boardingCost)-(c*runningCost)>minp:\n                minp=(b*boardingCost)-(c*runningCost)\n                minc=c\n        return minc\n            \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        res=-1\n        cnt=-1\n        wait=0\n        profit=0\n        i=0\n        while wait>0 or i<len(customers):\n            if i<len(customers):\n                wait+=customers[i]\n            if wait>=4:\n                wait-=4\n                profit+=4*boardingCost\n            else:\n                profit+=wait*boardingCost\n                wait=0\n            profit-=runningCost\n            i+=1\n            if profit>res:\n                res=profit\n                cnt=i\n            \n            \n        return cnt\n                \n                \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        res = -1\n        if not customers:\n            return -1\n        cnt = 1\n        if customers[0] > 4:\n            remain = customers[0] - 4\n            p = 4\n        else:\n            p = customers[0]\n            remain = 0\n        profit = boardingCost * p - runningCost * cnt\n        \n        if profit > 0:\n            res = cnt\n            \n        for num in customers[1:]:\n            remain += num\n            if remain > 4:\n                remain -= 4\n                p += 4\n            else:\n                p += remain\n                remain = 0\n            cnt += 1\n            curr = boardingCost * p - runningCost * cnt\n            \n            if curr > profit:\n                res = cnt\n                profit = curr\n        \n        while remain > 0:\n            \n            if remain > 4:\n                remain -= 4\n                p += 4\n            else:\n                p += remain\n                remain = 0\n            cnt += 1\n            curr = boardingCost * p - runningCost * cnt\n            \n            if curr > profit:\n                res = cnt\n                profit = curr\n                \n        return res\n", "class Solution:\n    def minOperationsMaxProfit(self, A, BC, RC):\n        ans=profit=t=0\n        maxprofit=0\n        wait=i=0\n        n=len(A)\n        while wait or i<n:\n            if i<n:\n                wait+=A[i]\n                i+=1\n            t+=1\n            y=wait if wait<4 else 4\n            wait-=y\n            profit+=y*BC\n            profit-=RC\n            if profit>maxprofit:\n                maxprofit=profit\n                ans=t\n        \n        if maxprofit<=0:\n            return -1\n        else:\n            return ans\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        q = 0\n        outs = []\n        boarded = 0\n        res = 0\n        rots = 0\n        m = 0\n        for incoming in customers:\n            if q + incoming > 4:\n                q += incoming - 4\n                boarded = 4\n            else:\n                boarded = q + incoming\n                q = 0\n            if len(outs) == 0:\n                outs.append(boarded * boardingCost - runningCost)\n            else:\n                outs.append(outs[-1] + (boarded * boardingCost - runningCost))\n            rots += 1\n            if m < outs[-1]:\n                m = outs[-1]\n                res = rots\n        \n        while(q > 4):\n            q -= 4\n            outs.append(outs[-1] + (boarded * boardingCost - runningCost))\n            rots += 1\n            if m < outs[-1]:\n                m = outs[-1]\n                res = rots   \n        outs.append(outs[-1] + (q * boardingCost - runningCost))\n        rots += 1\n        if m < outs[-1]:\n            m = outs[-1]\n            res = rots\n        if m > 0:\n            return res\n        else:\n            return -1\n                \n                \n                \n                \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        arrive = 0     \n        board = 0\n        wait2 = 0\n        total = 0\n        profit = 0\n        length = len(customers)\n        maxprofit = 0\n        max_num = -1\n        num = 0\n        count = 0\n        for i in range(length):\n            arrive = customers[i]\n            wait2 += arrive\n            num += 1\n            if wait2 >= 4:\n                board = 4\n                wait2 = wait2 - 4\n            else:\n                board = wait2\n                wait2 = 0\n            count += board\n            profit = count * boardingCost - num * runningCost\n            if profit > maxprofit:\n                maxprofit = profit\n                max_num = num           \n        \n        while wait2 > 0:           \n            num += 1\n            if wait2 >= 4:\n                board = 4\n                wait2 = wait2 - 4\n            else:\n                board = wait2\n                wait2 = 0\n            count += board\n            profit = count * boardingCost - num * runningCost\n            if profit > maxprofit:\n                maxprofit = profit\n                max_num = num           \n        return max_num", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        cur = 0\n        ans = 0\n        for c in customers:\n            cur += c\n            if cur >= 4:\n                cur -= 4\n            elif cur > 0:\n                cur = 0\n\n        ans = len(customers)+cur//4\n        if cur%4*boardingCost > runningCost:\n            ans += 1\n        \n        if 4*boardingCost < runningCost:\n            return -1\n        \n        return ans\n        \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        profit = 0\n        waiting = 0\n        rotation = 0\n        max_profit = 0\n        ans = None\n        for customer in customers:\n            customer += waiting\n            rotation += 1\n            # if customer>=4:\n            #     profit += 4*boardingCost - runningCost\n            #     waiting = customer-4\n            # else:\n            #     profit = customer*boardingCost - runningCost\n            #     waiting = 0\n            onboarding = min(4,customer)\n            profit += onboarding*boardingCost - runningCost\n            waiting = customer - onboarding\n            \n            if max_profit<profit:\n                max_pprofit = profit\n                ans = rotation\n        \n        if 4*boardingCost - runningCost>0:\n            steps = waiting//4\n            profit += steps*(4*boardingCost - runningCost)\n            waiting = waiting - steps*4\n            if waiting*boardingCost - runningCost>0:\n                profit += waiting*boardingCost - runningCost\n                steps += 1\n            if max_profit<profit:\n                max_pprofit = profit\n                ans = rotation + steps\n        \n        \n        return ans if ans else -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        p=-1\n        final=0\n        ans=0\n        s=0\n        count=0\n        for i in customers:\n            s+=i\n            if(s>4):\n                ans+=4\n                s-=4\n            else:\n                ans+=s\n                s=0\n            count+=1\n            if(ans*boardingCost-count*runningCost)>final:\n                p=count\n                final=(ans*boardingCost-count*runningCost)\n        while(s>0):\n            if(s>4):\n                ans+=4\n                s-=4\n            else:\n                ans+=s\n                s=0\n            count+=1\n            if(ans*boardingCost-count*runningCost)>final:\n                p=count\n                final=(ans*boardingCost-count*runningCost)\n        return p", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        mx, ans = -1, -1\n        wait, income, cost = 0, 0, 0\n        for i in range(1, 51*100000):\n            if i <= len(customers):\n                wait += customers[i - 1]\n            elif wait == 0:\n                break\n            if wait >= 4:\n                onboard = 4\n            else:\n                onboard = wait\n\n            wait -= onboard\n            income += onboard * boardingCost\n            cost += runningCost\n            curr = income - cost\n            # print(onboard, income, cost, curr)\n            if curr > mx:\n                mx = curr\n                ans = i\n        return ans", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        res = 0\n        q = 0\n        u = 0\n        profit = 0\n        rotation = 0\n        \n        for c in customers:\n            rotation += 1\n            if c > 4:\n                q += c - 4\n                u += 4\n            else:\n                if q > 0:\n                    diff = 4 - c\n                    if q >= diff:   \n                        u += c + diff\n                        q -= diff\n                    else:\n                        u += c + q\n                        q = 0\n                else:\n                    u += c\n            \n            if profit < u * boardingCost - rotation * runningCost:\n                profit = u * boardingCost - rotation * runningCost\n                res = rotation\n        \n        while q > 0:\n            rotation += 1\n            if q > 4:\n                u += 4\n                q -= 4\n            else:\n                u += q\n                q = 0\n            if profit < u * boardingCost - rotation * runningCost:\n                profit = u * boardingCost - rotation * runningCost\n                res = rotation\n            \n        print(profit)\n        return res if profit > 0 else -1\n                \n", "class Solution:\n  def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n    x, y = -1, -1\n    c = 0\n    p = 0\n    for i, j in enumerate(customers):\n      c += j\n      d = min(c, 4)\n      c -= d\n      p += d * boardingCost - runningCost\n      if p > x:\n        x, y = p, i + 1\n    i = len(customers)\n    while c:\n      d = min(c, 4)\n      c -= d\n      p += d * boardingCost - runningCost\n      i += 1\n      if p > x:\n        x, y = p, i\n    return y\n", "from typing import List\n\nclass Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        cur = best = 0\n        best_idx = None\n        waiting = 0\n        capacity = 4\n\n        for idx, nxt in enumerate(customers):\n            # Add new waiting customers, put passengers on ride, remove passengers from waiting.\n            waiting += nxt\n            passengers = min(waiting, capacity)\n            waiting -= passengers\n\n            # Update money.\n            cur += (passengers * boardingCost) - runningCost\n\n            if cur > best:\n                best_idx = idx + 1\n                best = cur\n        \n        while waiting:\n            idx += 1\n            passengers = min(waiting, capacity)\n            waiting -= passengers\n\n            # Update money.\n            cur += (passengers * boardingCost) - runningCost\n\n            if cur > best:\n                best_idx = idx + 1\n                best = cur        \n\n        if best_idx is None:\n            best_idx = -1\n\n        return best_idx\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        cur_profit = remainder_customers = steps = res = 0\n        max_profit = -1\n        for customer in customers:\n            remainder_customers += customer\n            gettting_on = min(remainder_customers, 4)\n            cur_profit += gettting_on* boardingCost - runningCost \n            remainder_customers -= gettting_on\n            steps += 1\n            \n            if cur_profit > max_profit:\n                max_profit = cur_profit\n                res = steps\n     \n        while remainder_customers > 0:\n            gettting_on = min(remainder_customers, 4)\n            cur_profit += gettting_on* boardingCost - runningCost \n            remainder_customers -= gettting_on\n            steps += 1\n            \n            if cur_profit > max_profit:\n                max_profit = cur_profit\n                res = steps\n    \n        return -1 if max_profit < 0 else res\n                \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        ans=-1\n        wait=0\n        profit=0\n        best=0\n        for i in range(len(customers)):\n            wait+=customers[i]\n            board=min(wait,4)\n            profit+=board*boardingCost-runningCost\n            wait-=board\n            if profit>best:\n                best=profit\n                ans=i+1\n        i=len(customers)\n        while wait:\n            board=min(wait,4)\n            profit+=board*boardingCost-runningCost\n            wait-=board\n            if profit>best:\n                best=profit\n                ans=i+1\n            i+=1\n        return ans\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        curr, ans, waiting, profit = 0, 0, 0, 0\n        for turn, customers in enumerate(customers):\n            waiting += customers\n            boarding = 4 if 4 < waiting else waiting\n            waiting -= boarding\n            profit += (boardingCost * boarding) - runningCost\n            if profit > curr:\n                curr, ans = profit, turn+1\n        else:\n            j = turn\n            while waiting > 0:\n                j += 1\n                boarding = min(4, waiting)\n                waiting -= boarding\n                profit += (boardingCost * boarding) - runningCost\n                if profit > curr:\n                    curr, ans = profit, j + 1\n        return ans if profit > 0 else -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n#         res = [0]\n#         wait = 0\n#         for i in customers:\n#             board = 0\n#             wait += i\n#             if wait > 4:\n#                 board = 4\n#                 wait -= 4\n#             else:\n#                 board = wait\n#                 wait = 0\n#             board*boardingCost - runningCost\n#             res.append(res[-1]+profit)\n        \n#         while wait:\n#             if wait > 4:\n#                 board = 4\n#                 wait -= 4\n#             else:\n#                 board = wait\n#                 wait = 0\n#             profit = board*boardingCost - runningCost\n#             res.append(res[-1]+profit)\n#         m = max(res)\n#         if m <= 0:\n#             return -1\n#         else:\n#             return res.index(m)\n        ans = t = waiting = 0\n        peak = 0\n        peak_at = -1\n        for i, x in enumerate(customers):\n            waiting += x\n            delta = min(4, waiting)\n            profit = boardingCost * delta - runningCost\n            ans += profit\n            waiting -= delta\n            if ans > peak:\n                peak = ans\n                peak_at = i + 1\n        \n        t = len(customers)\n        while waiting:\n            delta = min(4, waiting)\n            profit = boardingCost * delta - runningCost\n            if profit > 0:\n                ans += profit\n                waiting -= delta\n                t += 1\n                if ans > peak:\n                    peak = ans\n                    peak_at = t\n            else:\n                break\n        \n        return peak_at if peak_at > 0 else -1\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        profit=0\n        maxprofit=0\n        maxi=-1\n        wait=0\n        i=0\n        for customer in customers:\n            i+=1\n            wait+=customer\n            on=min(wait, 4)\n            wait-=on\n            profit+=on*boardingCost-runningCost\n            if profit>maxprofit:\n                maxprofit=profit\n                maxi=i\n        while wait:\n            i+=1\n            on=min(wait, 4)\n            wait-=on\n            profit+=on*boardingCost-runningCost\n            if profit>maxprofit:\n                maxprofit=profit\n                maxi=i\n        return maxi", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        b=0\n        w=0\n        r=0\n        tc=0\n        '''\n        for i in customers:\n            w+=i\n            tc+=i\n            #bd = min(4,w)\n            #w-=bd\n            if w//4 == 0:\n                r+=1\n            else:\n                r+= (w//4)    \n            print(r)\n            \n            if w<4:\n                w-=w\n            else:\n                w-= (4*(w//4))\n            print(\\\"     \\\",w)\n        '''\n        i=0\n        n=len(customers)\n        while True:\n            if i==n:\n                x=w//4\n                r+=x\n                if w%4 !=0 and ((w%4)*boardingCost)>runningCost:\n                    r+=1\n                break\n            w+=customers[i]\n            tc+=customers[i]\n            bd=min(4,w)\n            w-=bd\n            r+=1\n            i+=1\n        \n        return r if (tc*boardingCost - runningCost*r)>0 else -1\n            \n        \n        \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        totalCustomers = sum(customers)\n        rotation = totalCustomers//4\n        totalRotation = rotation if totalCustomers%4 == 0 else rotation + 1\n        totalRotation = max(totalRotation, len(customers))\n        totalRotationCost = totalRotation * runningCost\n        \n        earning = rotation * 4 * boardingCost\n        remain = totalCustomers%4\n        if remain != 0:\n            earning += (remain * boardingCost)\n        profit = earning - totalRotationCost\n        \n        if profit <= 0:\n            return -1\n        \n        maxProfit = 0\n        currentCost = 0\n        remainingCustomer = sum(customers)\n        highestRotation = 0\n        i = 0\n        total = 0\n        while total > 0 or i < len(customers):\n            if i < len(customers):\n                total += customers[i]\n            \n            prev = currentCost\n            if total >= 4:\n                currentCost += (4 * boardingCost - runningCost)\n                total -= 4\n            else:\n                currentCost += (total * boardingCost - runningCost)\n                total = 0\n            \n            if currentCost > maxProfit:\n                maxProfit = currentCost\n                highestRotation = i + 1\n                \n            i += 1\n            \n            \n            \n        print(maxProfit)\n        print(profit)\n        \n        return highestRotation\n            \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        \n        \n        # my solution ... 2112 ms ... 73 % ... 17.4 MB ... 98 %\n        #  time: O(n)\n        # space: O(1)\n        \n        curr_profit, curr_rotate =  0, 0\n        best_profit, best_rotate = -1, 0\n        queue_count = 0\n        for customer in customers:\n            queue_count += customer\n            board_count = min(queue_count, 4)\n            curr_profit += board_count * boardingCost - runningCost\n            curr_rotate += 1\n            queue_count -= board_count\n            if curr_profit > best_profit:\n                best_profit, best_rotate = curr_profit, curr_rotate\n        while queue_count > 0:\n            board_count = min(queue_count, 4)\n            curr_profit += board_count * boardingCost - runningCost\n            curr_rotate += 1\n            queue_count -= board_count\n            if curr_profit > best_profit:\n                best_profit, best_rotate = curr_profit, curr_rotate\n        return best_rotate if best_profit > 0 else -1\n        \n        \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        cur_profit = 0\n        max_profit = -1\n        waiting_customers = 0\n        ans = -1\n        turn = 0\n        for customer in customers:\n            turn += 1\n            waiting_customers += customer\n            to_board = min(waiting_customers, 4)\n            waiting_customers -= to_board\n            cur_profit += (-runningCost + to_board*boardingCost)\n            if cur_profit > max_profit:\n                max_profit = cur_profit\n                ans = turn\n           \n            \n        # if there is remaining customer\n        while waiting_customers > 0:\n            turn += 1\n            to_board = min(waiting_customers, 4)\n            waiting_customers -= to_board\n            cur_profit += (-runningCost + to_board*boardingCost)\n            if cur_profit > max_profit:\n                max_profit = cur_profit\n                ans = turn\n            \n        return ans if max_profit >= 0 else -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        cur_profit = remainder_customers = steps = res = 0\n        max_profit = -1\n        for customer in customers:\n            remainder_customers += customer\n            getting_on = min(remainder_customers, 4)\n            cur_profit += getting_on * boardingCost - runningCost \n            remainder_customers -= getting_on\n            steps += 1 \n            \n            if cur_profit > max_profit:\n                max_profit = cur_profit\n                res = steps\n                \n        while remainder_customers > 0:\n            getting_on = min(remainder_customers, 4)\n            cur_profit += getting_on * boardingCost - runningCost \n            remainder_customers -= getting_on\n            steps += 1 \n            \n            if cur_profit > max_profit:\n                max_profit = cur_profit\n                res = steps\n    \n       \n        return -1 if max_profit < 0 else res\n                \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        waiting,prev_boarding,boarding,profit=0,0,0,[]\n        for i, elem in enumerate(customers):\n            if elem>=4:\n                waiting+=elem-4\n                boarding=4\n            elif elem<4:\n                if not waiting:\n                    boarding=elem\n                else:\n                    boarding=4\n                    waiting-=(4-elem)\n            prev_boarding+=boarding\n            profit.append(prev_boarding*boardingCost-((i+1)*runningCost))\n        i=len(customers)\n        while(waiting):\n            if waiting>=4:\n                boarding=4\n                waiting-=4\n                prev_boarding+=boarding\n                i+=1\n                profit.append(prev_boarding*boardingCost-((i)*runningCost))\n            else:\n                boarding=waiting\n                waiting=0\n                prev_boarding+=boarding\n                i+=1\n                profit.append(prev_boarding*boardingCost-((i)*runningCost))          \n        return profit.index(max(profit))+1 if max(profit)>=0 else -1\n\n\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        \n        \n        # my solution ... 2124 ms ... 72 % ... 17.4 MB ... 95 %\n        #  time: O(n)\n        # space: O(1)\n        \n        curr_profit, curr_rotate =  0, 0\n        best_profit, best_rotate = -1, 0\n        queue_count = 0\n        for customer in customers:\n            queue_count += customer\n            board_count = min(queue_count, 4)\n            curr_profit += board_count * boardingCost - runningCost\n            curr_rotate += 1\n            queue_count -= board_count\n            if curr_profit > best_profit:\n                best_profit, best_rotate = curr_profit, curr_rotate\n        while queue_count > 0:\n            board_count = min(queue_count, 4)\n            curr_profit += board_count * boardingCost - runningCost\n            curr_rotate += 1\n            queue_count -= board_count\n            if curr_profit > best_profit:\n                best_profit, best_rotate = curr_profit, curr_rotate\n        return best_rotate if best_profit > 0 else -1\n        \n        \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        cur = 0\n        p = 0\n        ans = float('-inf')\n        t = 0\n        ff = 0\n        for c in customers:\n            cur += c\n            cnt = min(cur, 4)\n            cur -= cnt\n            p += cnt * boardingCost\n            p -= runningCost\n            t += 1\n            if p > ans:\n                ans = p\n                ff = t\n    \n        while cur > 0:\n            cnt = min(cur, 4)\n            cur -= cnt\n            p += cnt * boardingCost\n            p -= runningCost\n            t += 1\n            if p > ans:\n                ans = p\n                ff = t\n\n        return -1 if ans <= 0 else ff", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        m=0\n        res=-1\n        leftover=0\n        profit=0\n        i=0\n        j=0\n        while leftover>0 or i<len(customers):\n            if i<len(customers):\n                leftover+= customers[i]\n                i+=1\n            if leftover>=4:\n                profit+=4*boardingCost\n                leftover-=4\n            else:\n                profit+=leftover*boardingCost\n                leftover=0\n            profit-=runningCost\n            if profit>m:\n                res=j+1\n                m=profit\n            j+=1\n            \n        return res\n            \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        \n        \n        # my solution ... \n        #  time: O(n)\n        # space: O(1)\n        \n        curr_profit, curr_rotate =  0, 0\n        best_profit, best_rotate = -1, 0\n        queue_count = 0\n        for customer in customers:\n            queue_count += customer\n            board_count = min(queue_count, 4)\n            curr_profit += board_count * boardingCost - runningCost\n            curr_rotate += 1\n            queue_count -= board_count\n            if curr_profit > best_profit:\n                best_profit, best_rotate = curr_profit, curr_rotate\n        while queue_count > 0:\n            board_count = min(queue_count, 4)\n            curr_profit += board_count * boardingCost - runningCost\n            curr_rotate += 1\n            queue_count -= board_count\n            if curr_profit > best_profit:\n                best_profit, best_rotate = curr_profit, curr_rotate\n        return best_rotate if best_profit > 0 else -1\n        \n        \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        ans = -1\n        most = pnl = waiting = 0\n        for i, x in enumerate(customers): \n            waiting += x # more people waiting in line \n            waiting -= (chg := min(4, waiting)) # boarding \n            pnl += chg * boardingCost - runningCost \n            if most < pnl: ans, most = i+1, pnl\n        q, r = divmod(waiting, 4)\n        if 4*boardingCost > runningCost: ans += q\n        if r*boardingCost > runningCost: ans += 1\n        return ans", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n         \n        n=len(customers)\n        dp=[]\n        reserved=0\n        on_board=0\n        rotation=0\n        for i in range(n):\n            if reserved!=0:\n                if reserved>=4:\n                    on_board+=4\n                    reserved += customers[i]-4\n                else:\n                    new_customers=4-reserved\n                    if customers[i]>=new_customers:\n                        on_board+=4\n                        reserved=customers[i]-new_customers\n                    else:\n                        on_board+=reserved+customers[i]\n                        reserved=0\n            else:\n                if customers[i]>=4:\n                    on_board+=4\n                    reserved+=customers[i]-4\n                else:\n                    on_board+=customers[i]\n            rotation+=1\n            \n            dp.append(on_board*boardingCost - rotation*runningCost)\n        \n        for i in range(reserved//4 + 1):\n            if reserved>=4:\n                on_board+=4\n                reserved-=4\n            else:\n                on_board+=reserved\n                reserved=0\n            rotation+=1\n            dp.append(on_board*boardingCost - rotation*runningCost)\n        \n        maxi=max(dp)\n        return dp.index(max(dp))+1 if maxi>=0 else -1\n            \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        queue = collections.deque()\n        waiting = 0\n        profit = float('-inf')\n        cur = 0\n        rounds = 1\n        members = 0\n        final_rounds = 0\n        \n        for c in customers:\n            waiting += c\n            \n            new = min(4, waiting)\n            members += new\n            waiting -= new\n            \n            cur = boardingCost * members - runningCost * rounds\n            if cur > profit:\n                profit = cur\n                final_rounds = rounds\n            rounds += 1\n        \n        while waiting:\n            new = min(4, waiting)\n            members += new\n            waiting -= new\n            \n            cur = boardingCost * members - runningCost * rounds\n            if cur > profit:\n                profit = cur\n                final_rounds = rounds\n            rounds += 1\n\n        return final_rounds if profit > 0 else -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        max_profit = float('-inf')\n        queue = 0\n        idx = 0 \n        min_idx = 0\n        profit = 0\n        itr  = 0\n        \n        while True:\n            if idx < len(customers):\n                queue += customers[idx]\n            served  = 0\n            if queue >= 4:\n                queue-=4\n                served = 4\n            else:\n                served  = queue \n                queue = 0\n            \n            profit  += boardingCost*served\n            profit -= runningCost\n            itr+=1\n            #print(f'profit={profit} itr={itr} served = {served} profit = {profit}')\n            if profit > max_profit:\n                max_profit =  profit\n                min_idx = itr\n                \n            idx += 1\n            if queue <=0 and idx>=len(customers):\n                break\n                \n        if max_profit <= 0:\n            return -1\n        else:\n            return min_idx\n                \n            \n", "class Solution:\n    def minOperationsMaxProfit(self, cust: List[int], boardingC: int, runningC: int) -> int:\n        maxp=curr=rem=ans=rot=0\n        i=0\n        \n        l=len(cust)\n        while i<l or rem:\n            rot+=1\n            rem+=cust[i] if i<l else 0 \n            \n            if rem>=4:\n                curr+=4\n                rem-=4\n                \n            else:\n                curr+=rem\n                rem=0\n                \n            \n                \n            prof=(curr*boardingC)-(runningC*rot)\n\n            if prof>maxp:\n                maxp=prof\n                ans=rot\n                    \n            i+=1\n                    \n        return ans if maxp>0 else -1\n                \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        profits = []\n        curr_profit = 0\n        ppl_waiting = 0\n        \n        for i, ppl in enumerate(customers):\n            ppl_waiting += ppl\n            num_board = min(4, ppl_waiting)\n            curr_profit += num_board * boardingCost - runningCost\n            profits.append(curr_profit)\n            ppl_waiting -= num_board\n        \n        while ppl_waiting:\n            num_board = min(4, ppl_waiting)\n            curr_profit += num_board * boardingCost - runningCost\n            profits.append(curr_profit)\n            ppl_waiting -= num_board\n        \n        #print(profits)\n        max_prof = max(profits)\n        if max_prof <= 0:\n            return -1\n        return profits.index(max_prof) + 1", "from collections import deque\n\nclass Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        \n        rotations = 0\n        maxprofit = -1\n        currprofit = 0\n        nr = 0\n        q = deque(customers)\n        \n        while q:\n            currprofit -= runningCost\n            nr += 1\n            \n            c = q.popleft()\n            if c > 4:\n                if q:\n                    q[0] += c-4\n                else:\n                    q.append(c-4)\n                c = 4\n                \n            currprofit += c * boardingCost\n            if currprofit > maxprofit:\n                maxprofit = currprofit\n                rotations = nr\n            \n        return rotations if maxprofit > 0 else -1\n            \n            \n            \n            \n        \n        \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if not customers:\n            return 0\n        \n        profits = [0]\n        waiting = 0\n        \n        for customer in customers:\n            waiting += customer\n            serving = 0\n            if waiting > 4:\n                serving = 4\n                waiting -=4\n            else:\n                serving = waiting\n                waiting =0\n                \n            profits.append(profits[-1] + ((boardingCost*serving) - runningCost))\n            \n        while waiting:\n            serving = 0\n            if waiting > 4:\n                serving = 4\n                waiting -=4\n            else:\n                serving = waiting\n                waiting =0\n                \n            profits.append(profits[-1] +  ((boardingCost*serving) - runningCost))\n        \n        maxProfit = profits[1]\n        maxProfitIndex = 1\n        for i, profit in enumerate(profits[1:]):\n            if profit>maxProfit:\n                maxProfit = profit\n                maxProfitIndex = i+1\n        \n        if maxProfit>0:\n            return maxProfitIndex\n        else:\n            return -1\n        \n        \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        rotate = left = 0\n        ans = -1\n        profit = maxprofit = 0\n        for cnt in customers:\n            cnt += left\n            rotate += 1\n            left = max(0, cnt - 4)\n            profit += boardingCost * min(4, cnt) - runningCost\n            if profit > maxprofit:\n                maxprofit = profit\n                ans = rotate\n        while left > 0:\n            rotate += 1\n            profit += boardingCost * min(4, left) - runningCost\n            if profit > maxprofit:\n                maxprofit = profit\n                ans = rotate\n            left -= 4\n        return ans", "class Solution:\n    def minOperationsMaxProfit(self, A, BC, RC):\n        ans=profit=t=0\n        maxprofit=0\n        wait=i=0\n        n=len(A)\n        while wait or i<n:\n            if i<n:\n                wait+=A[i]\n                i+=1\n            t+=1\n            y=min(4,wait)\n            wait-=y\n            profit+=y*BC\n            profit-=RC\n            if profit>maxprofit:\n                maxprofit=profit\n                ans=t\n\n        if maxprofit<=0:\n            return -1\n        else:\n            return ans\n", "class Solution:\n    # O(n) Time | O(1) Space\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        result = 0\n        totalPeople = 0\n        totalProfit = 0\n        maxProfit = 0\n        for i, num in enumerate(customers):\n            totalPeople += num\n            onBoard = min(4, totalPeople)\n            totalPeople -= onBoard\n            totalProfit += onBoard * boardingCost - runningCost\n            if totalProfit > maxProfit:\n                maxProfit = totalProfit\n                result = i + 1\n        q, r = divmod(totalPeople, 4)\n        if 4 * boardingCost > runningCost:\n            result += q\n        if r * boardingCost > runningCost:\n            result += 1\n        return result if result > 0 else -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: [int], boardingCost: int, runningCost: int) -> int:\n        waiting=0\n        profits=[0]\n\n        if 4*boardingCost<runningCost:\n            return -1\n\n        for customer in customers:\n            if customer+waiting>=4:\n                profit=4*boardingCost-runningCost\n                waiting=waiting+customer-4\n            else:\n                profit = (waiting+customer) * boardingCost - runningCost\n                waiting=0\n            last=profits[-1]\n            profits.append(profit+last)\n\n        while waiting>0:\n            if waiting>=4:\n                profit = 4 * boardingCost - runningCost\n                last = profits[-1]\n                profits.append(profit + last)\n                waiting-=4\n            else:\n                profit = waiting * boardingCost - runningCost\n                last = profits[-1]\n                profits.append(profit + last)\n                waiting=0\n        return profits.index(max(profits))\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        wait = 0\n        answer = 0\n        current = 0\n        counter = 0\n        result = -1\n        for entry in customers:\n            counter += 1\n            wait += entry\n            current -= runningCost\n            if wait >= 4:\n                current += (4*boardingCost)\n                wait -= 4\n            else:\n                current += (wait*boardingCost)\n                wait = 0\n            if current > answer:\n                result = counter\n            answer = max(answer, current)\n        while wait > 0:\n            counter += 1\n            current -= runningCost\n            if wait >= 4:\n                current += (4*boardingCost)\n                wait -= 4\n            else:\n                current += (wait*boardingCost)\n                wait = 0\n            if current > answer:\n                result = counter\n            answer = max(answer, current)\n        return result", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if boardingCost * 4 <= runningCost or len(customers) == 0:\n            return -1\n        left = 0\n        profit = 0\n        res = 0\n        max_profit = 0\n        idx = 0\n        r = 0\n        while idx < len(customers) or left > 0:\n            r += 1\n            if idx < len(customers):\n                left += customers[idx]\n                idx += 1\n            \n            if left < 4:\n                profit += left * boardingCost - runningCost\n                left = 0\n            else:\n                left -= 4\n                profit += 4 * boardingCost - runningCost\n                \n            if profit > max_profit:\n                max_profit = profit\n                res = r\n        return res", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        res = 0\n        ans = -1\n        rotate = 1\n        current = 0\n        rotate_times = -1\n        for i, number in enumerate(customers):\n            if number > 4:\n                res += number - 4\n                current += 4\n            elif number == 4: \n                current += number\n            else:\n                if res + number > 4:\n                    current += 4\n                    res = res + number - 4\n                else:\n                    current += res + number\n                    res = 0\n            profit = boardingCost * current - rotate*runningCost\n            # print(\\\"the profit is: \\\" + str(profit))\n            rotate += 1\n            if ans < profit:\n                ans = profit\n                rotate_times = rotate\n        # print(\\\"the res is: \\\" + str(res))\n            \n        while res > 0:\n            if res > 4:\n                current += 4\n                res -= 4\n            else:\n                current += res\n                res = 0\n            profit = boardingCost * current - rotate*runningCost\n            # print(\\\"the profit is: \\\" + str(profit))\n            rotate += 1\n            if ans < profit:\n                ans = profit\n                rotate_times = rotate\n        return rotate_times -1  if rotate_times - 1 > 0 else -1\n", "from collections import deque\nfrom typing import List\n\n\nclass Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        ls = []\n\n        waiting = 0  # \ub77c\uc778 \uae30\ub2e4\ub9ac\ub294 \uc0ac\ub78c\n        gondola = deque()  # \uace4\ub3cc\ub77c que\n        curr = 0  # \ud604\uc7ac \uace4\ub3cc\ub77c\uc5d0 \ud0c0\uace0\uc788\ub294 \uc0ac\ub78c\n        days = 0\n        for i, customer in enumerate(customers):\n            waiting += customer\n            if waiting >= 4:\n                waiting -= 4\n                on_board = 4\n            else:\n                on_board = waiting\n                waiting = 0\n            curr += on_board\n\n            # profit\n            ls.append(curr * boardingCost - (days + 1) * runningCost)\n            days += 1\n        while waiting > 0:\n            if waiting >= 4:\n                waiting -= 4\n                on_board = 4\n            else:\n                on_board = waiting\n                waiting = 0\n            curr += on_board\n\n            # profit\n            ls.append(curr * boardingCost - (days + 1) * runningCost)\n            days += 1\n\n        max_val = max(ls)\n        if max_val < 0:\n            return -1\n        else:\n            return ls.index(max_val) + 1\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        res, maxprofit = -1, 0\n        curr_profit = nwait = 0\n        for idx,num in enumerate(customers):\n            nwait += num\n            curr_profit += (4*boardingCost if nwait >= 4 else nwait * boardingCost) - runningCost\n            if nwait >= 4:\n                nwait -= 4\n            else:\n                nwait = 0\n            if curr_profit > maxprofit:\n                res = idx+1\n                maxprofit = curr_profit\n        while nwait > 0:\n            idx += 1\n            curr_profit += (4*boardingCost if nwait >= 4 else nwait * boardingCost) - runningCost\n            if nwait >= 4:\n                nwait -= 4\n            else:\n                nwait = 0\n            if curr_profit > maxprofit:\n                res = idx+1\n                maxprofit = curr_profit\n        return res\n                \n                \n            \n                    \n                \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        bc, rc, n = boardingCost, runningCost, len(customers)\n        res, sum_v, max_v, wait, i = -1, 0, 0, 0, 0\n        if 4 * bc <= rc:\n            return -1\n        # customers.append(0)\n        while i < n or wait > 0:\n            wait += customers[i] if i < n else 0\n            cur = wait if wait < 4 else 4\n            wait -= cur\n            sum_v += cur * bc - rc\n            # (i,wait,cur,sum_v,max_v).p()\n            if sum_v > max_v:\n                max_v = sum_v\n                res = i + 1\n            i += 1\n        return res", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        count =0\n        max_profit = 0\n        profit =0\n        rot =-1\n        i=0\n        while count>0 or i<len(customers):\n            \n            if i<len(customers):\n                new_customers = customers[i]\n                count+=new_customers\n            if count>=4:\n                count-=4\n                profit+=4*boardingCost-runningCost\n            else:\n                profit+=count*boardingCost-runningCost\n                count=0\n               \n            i+=1\n            if profit>max_profit:\n                max_profit = profit\n                rot = i\n                \n            \n            #print(i,profit,count)\n            \n            \n        return rot\n                \n            \n            \n            \n            \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        n, i, max_profit, waiting, profit, max_idx = len(customers), 0, 0, 0, 0, -1\n        \n        while waiting > 0 or i<n:\n            if i<n:\n                waiting += customers[i]\n            i+=1\n            count = min(4, waiting)\n            waiting -= count\n            profit += count * boardingCost - runningCost\n            if profit > max_profit:\n                max_profit, max_idx = profit, i\n        \n        return max_idx ", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        ans,max_profit=-1,0\n        waiting=0\n        profit=0\n        i=0\n        while waiting>0 or i<len(customers):\n            if i<len(customers):waiting+=customers[i]\n            if waiting>=4:\n                waiting-=4\n                boarded=4\n            else:\n                boarded=waiting\n                waiting=0\n            max_profit+=(boardingCost*boarded)-runningCost\n            if max_profit>0 and max_profit>profit:\n                ans=i+1\n                profit=max_profit\n            i+=1\n        return ans", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        ans = -1\n        most = pnl = waiting = 0\n        for i, x in enumerate(customers): \n            waiting += x # more people waiting in line \n            waiting -= (chg := min(4, waiting)) # boarding \n            pnl += chg * boardingCost - runningCost \n            if most < pnl: ans, most = i+1, pnl\n        q, r = divmod(waiting, 4)\n        if 4*boardingCost > runningCost: ans += q\n        if r*boardingCost > runningCost: ans += 1\n        return ans ", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        best = 0\n        bestindex = 0\n        current = 0\n        currentindex = 0\n        nc = 0\n        for i in range(len(customers)):\n            nc += customers[i]\n            canadd = min(4,nc)\n            nc -= canadd\n            current += canadd*boardingCost\n            current -= runningCost\n            currentindex+=1\n            # print(current)\n            \n            if current > best:\n                best = current\n                bestindex = currentindex\n                \n        while nc > 0:\n            canadd = min(4,nc)\n            nc -= canadd\n            current += canadd*boardingCost\n            current -= runningCost\n            currentindex+=1\n            # print(current)\n            \n            if current > best:\n                best = current\n                bestindex = currentindex\n                \n        if best == 0:\n            bestindex = -1\n                \n        return bestindex\n            \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        curr, ans, waiting, profit = 0, 0, 0, 0\n        for turn, customers in enumerate(customers):\n            waiting += customers\n            boarding = min(4, waiting)\n            waiting -= boarding\n            profit += (boardingCost * boarding) - runningCost\n            if profit > curr:\n                curr, ans = profit, turn+1\n        else:\n            j = turn\n            while waiting > 0:\n                j += 1\n                boarding = min(4, waiting)\n                waiting -= boarding\n                profit += (boardingCost * boarding) - runningCost\n                if profit > curr:\n                    curr, ans = profit, j + 1\n        return ans if profit > 0 else -1", "class Solution:\n  def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n\n    max_profit = -sys.maxsize\n    result = - sys.maxsize\n    pending = 0\n    running_counter = 0\n    current_onboarding = 0\n    for customer in customers:\n      pending += customer\n      running_counter += 1\n      if pending > 0:\n        real_boarding = min(4, pending)\n        current_onboarding += real_boarding\n        profit = current_onboarding * boardingCost - running_counter * runningCost\n\n        if max_profit < profit:\n          max_profit = profit\n          result = running_counter\n          pass\n        pending -= real_boarding\n        pass\n      pass\n\n    while pending:\n      running_counter += 1\n      real_boarding = min(4, pending)\n      current_onboarding += real_boarding\n      pending -= real_boarding\n      profit = current_onboarding * boardingCost - running_counter * runningCost\n\n      if max_profit < profit:\n        max_profit = profit\n        result = running_counter\n        pass\n      pass\n\n    if max_profit <= 0:\n      return -1\n    return result", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        b = w = i = 0\n        n = len(customers)\n        prof = 0\n        mprof = 0\n        pos = -1\n        while i < n or w:\n            if i < n:\n                w += customers[i]\n            i += 1\n            b = min(w, 4)\n            w -= b\n            prof += b * boardingCost - runningCost\n            if prof > mprof:\n                mprof = prof\n                pos = i\n        return pos", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        run = 0\n        maxRun = 0\n        profit = 0\n        maxProfit = 0\n        total = 0\n        i = 0\n        n = len(customers)\n        while total > 0 or i < n:\n            if i < n:\n                total += customers[i]\n                i += 1\n            group = min(4, total)\n            total -= group\n            profit = profit + group*boardingCost - runningCost\n            run += 1\n            if profit > maxProfit:\n                maxProfit = profit\n                maxRun = run\n                \n        return maxRun if maxProfit > 0 else -1\n", "class Solution:\n    def minOperationsMaxProfit(self, lis: List[int], b: int, r: int) -> int:\n        n = len(lis)\n        q=pro=ans=tot=c=fin=0\n        c=1\n        for i in range(n):\n            q+=lis[i]\n            t = min(4,q)\n            q-=t\n            tot+=t\n            pro = tot*b - r*(c)\n            if pro>ans:\n                ans=pro\n                fin=c\n       #     print(pro,ans,tot)\n            c+=1\n        while q>0:\n            t = min(4,q)\n            q-=t\n            tot+=t\n            pro = tot*b - r*(c)\n            if pro>ans:\n                ans=pro\n                fin=c\n        #    print(pro,ans,tot)\n            c+=1\n        if fin==0:\n            fin=-1\n        return fin\n        \n            \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        max_profit = 0\n        answ = -1\n        waiting = 0\n        profit = 0\n        i = 0\n        \n        while i < len(customers) or waiting > 0:\n            if i < len(customers):\n                waiting += customers[i]\n            if waiting >= 4:\n                profit += 4*boardingCost - runningCost\n                waiting -= 4\n            elif waiting > 0:\n                profit += waiting*boardingCost - runningCost\n                waiting = 0\n            else:\n                profit -= runningCost\n            \n            if max_profit < profit:\n                max_profit = profit\n                answ = i + 1\n            \n            i += 1\n                \n        return answ\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        customers_waiting = 0\n        max_till_now = 0\n        prev_cost = 0\n        answer = -1\n        \n        for index, customer in enumerate(customers):\n            on_board = min(customer + customers_waiting, 4)\n            customers_waiting = customer + customers_waiting - 4 if on_board == 4 else 0\n            \n            cost = prev_cost + on_board * boardingCost - runningCost\n            prev_cost = cost\n            \n            if cost > max_till_now:\n                max_till_now = cost\n                answer = index + 1\n\n        while customers_waiting:\n            index += 1\n            on_board = min(customers_waiting, 4)\n            customers_waiting = customers_waiting - 4 if on_board == 4 else 0\n            \n            cost = prev_cost + on_board * boardingCost - runningCost\n            prev_cost = cost\n            \n            if cost > max_till_now:\n                max_till_now = cost\n                answer = index + 1\n                \n        return answer", "from typing import List\n\n\nclass Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        def boarders():\n            waiters = 0\n            for c in customers:\n                waiters += c\n                cur = min(4, waiters)\n                waiters -= cur\n                yield cur\n            while waiters > 0:\n                cur = min(4, waiters)\n                waiters -= cur\n                yield cur\n\n        max = 0\n        max_idx = -1\n        cur = 0\n        for i, b in enumerate(boarders()):\n            cur += (b * boardingCost) - runningCost\n            if cur > max:\n                max = cur\n                max_idx = i + 1\n\n        return max_idx\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if (boardingCost << 2) <= runningCost:\n            return -1\n        waitingCustomers = 0\n        curProfit = 0\n        maxProfit = 0\n        maxProfitTurns = 0\n        \n        curTurn = 0\n        for nCust in customers:\n            curTurn += 1\n            waitingCustomers += nCust\n            if waitingCustomers > 0:\n                boardedCustomers = min(4, waitingCustomers)\n                waitingCustomers -= boardedCustomers\n                curProfit += boardedCustomers * boardingCost\n            curProfit -= runningCost\n            if curProfit > maxProfit:\n                maxProfit = curProfit\n                maxProfitTurns = curTurn\n        \n        \n        fullLoads = waitingCustomers >> 2\n        remLoad = waitingCustomers & 0b11\n        curProfit += ((fullLoads * boardingCost) << 2) - runningCost * fullLoads\n        curTurn += fullLoads\n        if curProfit > maxProfit:\n            maxProfit = curProfit\n            maxProfitTurns = curTurn\n        if remLoad > 0:\n            curProfit += remLoad * boardingCost - runningCost\n            curTurn += 1\n            if curProfit > maxProfit:\n                maxProfit = curProfit\n                maxProfitTurns = curTurn\n        \n        \n        if curProfit > maxProfit:\n            return curTurn\n        \n        if maxProfit == 0:\n            return -1\n        else:\n            return maxProfitTurns", "class Solution:\n    def minOperationsMaxProfit(self, cust: List[int], board: int, run: int) -> int:\n        wait = 0;tot = 0;profit = 0;move = 1;ans =0;maxi = 0\n        for i in range(len(cust)):\n            tot += min(4,cust[i]+wait)\n            wait = max(0,cust[i]+wait-4)\n            profit = tot*board - move*run\n            if profit > maxi:\n                maxi = profit;ans = move\n            move +=1\n            #print(tot,wait,profit)\n        while wait > 0:\n            tot += min(4,wait)\n            wait -= 4\n            profit = tot*board - move*run\n            if profit > maxi:\n                maxi = profit;ans = move\n            move +=1\n            #print(tot,wait,profit)\n        if maxi > 0:\n            return ans\n        return -1\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boarding_cost: int, running_cost: int) -> int:\n        customer = 0\n        remained = 0\n        max_profit = -1\n        run = 0\n        max_run = 0\n        index = 0\n\n        while remained or index < len(customers):\n            run += 1\n            remained += customers[index] if index < len(customers) else 0\n\n            if (remained < 4):\n                customer += remained\n                remained = 0\n            else:\n                customer += 4\n                remained -= 4\n\n            profit = customer * boarding_cost - run * running_cost\n            if (profit > max_profit):\n                max_profit = profit\n                max_run = run\n\n            index += 1\n\n        return -1 if max_profit < 0 else max_run", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if not customers:\n            return 0\n        waiting = 0\n        op = 0\n        maxProfit = -1\n        index = 0\n        total_boarding = 0\n        for i, people in enumerate(customers):\n            op += 1\n            waiting += people\n            boarding = min(4, waiting)\n            total_boarding += boarding\n            currProfit = total_boarding * boardingCost - op * runningCost\n            # other way is to just add the profit\n            # currProfit += boarding * boardingCost - runningCost\n            waiting -= boarding\n            if currProfit > maxProfit:\n                maxProfit = currProfit\n                index = op\n            \n        while waiting > 0:\n            op += 1\n            boarding = min(waiting, 4)\n            total_boarding += boarding\n            currProfit = total_boarding * boardingCost - op * runningCost\n            waiting -= boarding\n            if currProfit > maxProfit:\n                maxProfit = currProfit\n                index = op\n            \n        if maxProfit == -1:\n            return -1\n        else:\n            return index", "class Solution:\n    def minOperationsMaxProfit(self, c: List[int], b: int, r: int) -> int:\n      n = len(c)\n      i = 0\n      rest = 0\n      max_val, max_i = 0, -2\n      val = 0\n      while i<n or rest > 0:\n        if i < n:\n          rest += c[i]\n        p = min(rest, 4)\n        val += p * b - r\n        if val > max_val:\n          max_val = val\n          max_i = i\n        rest -= p\n        i += 1  \n      return max_i + 1    \n        \n", "MIN = float('-inf')\nclass Solution:\n    def minOperationsMaxProfit(self, customers, boardingCost, runningCost):\n        \n        n = len(customers)\n        step, maxStep, maxProfit = 0, 0, MIN\n        i, people, queue = 0, 0, 0\n        while True:\n            if i < n:\n                queue += customers[i]\n                i += 1\n            p = min(4, queue)\n            queue -= p\n            people += p\n            step += 1\n            profit = people * boardingCost - step * runningCost\n            if profit > maxProfit:\n                maxProfit = profit\n                maxStep = step\n            if queue == 0 and i == n:\n                break\n        return maxStep if maxProfit > 0 else -1\n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        profit=record=peeps=rots=i=0\n        n = len(customers)\n        while peeps or i < n:\n            if i < n:\n                peeps+=customers[i]\n            board = min(4, peeps)\n            profit += boardingCost*board - runningCost\n            peeps-=board\n            if profit > record:\n                rots = i + 1\n                record = profit\n            i+=1\n        return rots if rots != 0 else -1\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        customers = customers[::-1]\n        in_line = profit = rot = best_rot = 0\n        max_profit = -1\n        while customers or in_line:\n            c = customers.pop() if customers else 0\n            in_line += c\n            board = min(in_line, 4)\n            in_line -= board\n            profit += board * boardingCost \n            rot += 1\n            profit -= runningCost\n            if profit > max_profit:\n                max_profit = profit\n                best_rot = rot\n         \n        return best_rot if max_profit > 0 else -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        curr_waiting = 0\n        curr_profit, max_profit, curr_op, max_profit_ops = 0, 0, 0, 0\n        for c in customers:\n            curr_op += 1\n            curr_waiting += c\n            num_boarded = min(4, curr_waiting)\n            curr_waiting -= num_boarded\n            curr_profit += boardingCost * num_boarded - runningCost\n            if curr_profit > max_profit:\n                max_profit = curr_profit\n                max_profit_ops = curr_op\n        while curr_waiting:\n            curr_op += 1\n            num_boarded = min(4, curr_waiting)\n            curr_waiting -= num_boarded\n            curr_profit += boardingCost * num_boarded - runningCost\n            if curr_profit > max_profit:\n                max_profit = curr_profit\n                max_profit_ops = curr_op     \n        return max_profit_ops if max_profit > 0 else - 1\n", "from collections import deque\n\nclass Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        customers = deque(customers)\n        in_line = profit = rot = best_rot = 0\n        max_profit = -1\n        while customers or in_line:\n            c = customers.popleft() if customers else 0\n            in_line += c\n            board = min(in_line, 4)\n            in_line -= board\n            profit += board * boardingCost \n            rot += 1\n            profit -= runningCost\n            if profit > max_profit:\n                max_profit = profit\n                best_rot = rot\n         \n        return best_rot if max_profit > 0 else -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        rotations = 0\n        profit, max_profit = 0, 0\n        res = -1\n        \n        def xreport(boarded:int):\n            nonlocal profit, rotations, max_profit, res\n            profit +=boarded*boardingCost - runningCost\n            rotations +=1\n            if profit>max_profit:\n                max_profit = profit\n                res = rotations\n            #print(f'p: {profit}, mprofit: {max_profit}, rotations:{rotations}')\n            return\n        \n        for i in range(len(customers)-1):\n            if customers[i] >4:\n                customers[i+1]+=customers[i]-4\n                customers[i] =4\n            \n            xreport(customers[i])\n        \n            \n        waiting = customers[-1]\n        while waiting>0:\n            if waiting>4:\n                waiting-=4\n                xreport(4)\n            else:\n                xreport(waiting)\n                waiting = 0\n            \n        return res\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        profits=[]\n        occupy=0\n        cur_waiting = 0\n        k=0\n        while cur_waiting ==0:\n            cur_waiting=customers[k]\n            k+=1\n        m=k\n        counter=0\n        while cur_waiting >0:\n            if cur_waiting < 4:\n                occupy+=cur_waiting\n                cur_waiting = 0\n            else:\n                occupy+=4\n                cur_waiting-=4\n            counter+=1\n            profits.append(occupy*boardingCost - counter*runningCost)\n            if k<len(customers):\n                cur_waiting+=customers[k]\n                k+=1\n        z=max(profits)\n        if z>0:\n            return (profits.index(z)+m)\n        else:\n            return -1\n                \n                \n            \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        d = {}\n        rotations, sum_cust = 0, 0\n        d[0] = 0\n        \n        for i, current in enumerate(customers):\n            sum_cust +=current\n            \n            if sum_cust>=4:\n                while sum_cust>=4:\n                    rotations +=1\n                    d[rotations] = d[rotations-1] + 4*boardingCost - runningCost\n                    sum_cust -=4\n            else:\n                if i+1 in d:\n                    continue\n                rotations+=1\n                d[rotations] = d[rotations-1]+ sum_cust*boardingCost - runningCost\n                sum_cust = 0\n        \n        if sum_cust>0:\n            rotations+=1\n            d[rotations] = d[rotations-1]+ sum_cust*boardingCost - runningCost\n            sum_cust = 0\n        \n        #print(d)\n        d[0] = -1\n        tmp, res = -1, -1\n        for i in d:\n            if tmp<d[i]:\n                tmp = d[i]\n                res = i\n        return res\n            \n", "from typing import List\n\nclass Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        cur = best = wheel_turns = 0\n        best_idx = None\n        waiting = 0\n        capacity = 4\n\n        while waiting or wheel_turns < len(customers):\n            # Add new waiting customers, put passengers on ride, remove passengers from waiting.\n            if wheel_turns < len(customers):\n                waiting += customers[wheel_turns]\n            \n            wheel_turns += 1\n            \n            passengers = min(waiting, capacity)\n            waiting -= passengers\n\n            # Update money.\n            cur += (passengers * boardingCost) - runningCost\n\n            if cur > best:\n                best_idx = wheel_turns\n                best = cur  \n            \n        if best_idx is None:\n            best_idx = -1\n\n        return best_idx\n\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        res = round = profit = max_profit = remain = i = 0\n        while remain or i < len(customers):\n            if i < len(customers):\n                remain += customers[i]\n                i += 1\n            on_board = min(4, remain)\n            remain -= on_board\n            profit += boardingCost * on_board - runningCost\n            round += 1\n            if profit > max_profit:\n                max_profit = profit\n                res = round\n        return res if max_profit > 0 else -1", "import sys #         O(N) , N is customers.length\n\nclass Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boarding_cost: int, running_cost: int) -> int:\n\n        i = 0\n        remains = 0\n        standard = sum(customers)\n        stack = 0\n        ans = -1\n        big = -sys.maxsize-1\n        while True:\n            if standard <= 0:\n                break\n            if i < len(customers):\n                remains += customers[i]\n            \n            if remains >= 4:\n                remains -= 4\n                stack += 4\n                standard -= 4\n            else:\n                stack += remains\n                standard -= remains\n                remains = 0\n            \n            tmp = stack*boarding_cost - running_cost*(i+1)\n            if tmp > big:\n                big = tmp\n                ans = i\n                \n                \n            i += 1\n                \n            \n        if big <= 0:\n            return -1\n        \n        return ans+1\n            \n#         member\ub3c4 \ub298\uc5b4\ub098\uc57c \ud55c\ub2e4.\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if not customers or len(customers) == 0:\n            return -1\n        \n        cur_round = 1\n        max_round = -1 \n        customer_cnt = board_cnt = cur_profit = max_profit = i = 0\n        \n        while (customer_cnt > 0 or i < len(customers)):\n            if i < len(customers):\n                customer_cnt += customers[i]\n                i += 1\n    \n            board_cnt = min(customer_cnt, 4)\n            customer_cnt -= board_cnt\n            \n            cur_profit += (board_cnt * boardingCost) - runningCost\n            if cur_profit > max_profit:\n                max_profit = cur_profit\n                max_round = cur_round \n            \n            cur_round += 1 \n        \n        return max_round\n            \n            \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if runningCost > 4*boardingCost:\n            return -1\n        profit = 0\n        board = 0\n        wait = 0\n        ans = 0\n        for i in range(len(customers)):\n            if customers[i] > 4:\n                wait += customers[i]-4\n                board += 4\n                p = board*boardingCost - (i+1)*runningCost\n                if p > profit:\n                    profit = p\n                    ans = i+1\n            else:\n                add = min(wait, 4-customers[i])\n                wait -= add\n                board += add+customers[i]\n                p = board*boardingCost - (i+1)*runningCost\n                if p > profit:\n                    profit = p\n                    ans = i+1\n        \n        i = len(customers)\n        while wait != 0:\n            add = min(wait,4)\n            board += add\n            wait -= add\n            p = board*boardingCost - (i+1)*runningCost\n            if p > profit:\n                profit = p\n                ans = i+1\n            i += 1\n        \n        return ans", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        profit = [0]\n        left = 0\n        maxMid = -1\n        maxProfit = 0\n        for i in range(len(customers)):\n            toBeBoarded = left + customers[i]\n            if toBeBoarded > 4:\n                boarded = 4\n                left = toBeBoarded - 4                \n            else:\n                boarded = customers[i]\n                left = 0\n            newProfit = boardingCost * boarded - runningCost + profit[-1]\n            profit.append(newProfit)\n            if newProfit > maxProfit:\n                maxProfit = newProfit\n                maxMid = i\n        # print(profit)\n        if left == 0:\n            return maxMid\n        elif left < 4:\n            lastProfit = boardingCost * left - runningCost + profit[-1]\n            if maxProfit >= lastProfit:\n                return maxMid + 1 if maxProfit > 0 else -1\n            else:\n                return len(customers) + 1 if lastProfit > 0 else -1\n        else:\n            potential = boardingCost * 4 - runningCost\n            if potential > 0:\n                rotations = left // 4\n                lastRun = left % 4\n                rotationEnd = profit[-1] + potential * rotations\n                lastProfit = rotationEnd + lastRun * boardingCost - runningCost\n                if maxProfit >= rotationEnd:\n                    return maxMid + 1 if maxProfit > 0 else -1\n                else:\n                    if rotationEnd >= lastProfit:\n                        return len(customers) + rotations if rotationEnd > 0 else -1\n                    else:\n                        return len(customers) + rotations + 1 if lastProfit > 0 else -1\n            else:\n                return maxMid + 1 if maxProfit > 0 else -1\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        waiting = 0\n        boarded = 0\n        maxProfit = 0\n        maxIndex = -1\n        \n        if len(customers) == 0:\n            return -1 \n        \n        for i, customerCount in enumerate(customers):\n            waiting += customerCount\n            if waiting >= 4:\n                waiting -= 4\n                boarded += 4\n            else:\n                boarded += waiting\n                waiting = 0\n                \n            profit = boarded * boardingCost - (i + 1) * runningCost\n            if profit > maxProfit:\n                maxIndex = i + 1\n                maxProfit = profit\n        \n        i += 1\n        while waiting > 0:\n            if waiting >= 4:\n                waiting -= 4\n                boarded += 4\n            else:\n                boarded += waiting\n                waiting = 0\n                \n            profit = boarded * boardingCost - (i + 1) * runningCost\n            if profit > maxProfit:\n                maxIndex = i + 1\n                maxProfit = profit\n            i += 1\n        \n        if maxProfit > 0:\n            return maxIndex\n        return -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        earn, max_earn = 0, 0\n        i, n = 0, len(customers)\n        wait, res = 0, -1\n        while i < n or wait > 0:\n            if i < n:\n                wait += customers[i]\n            board = min(4, wait)\n            earn += board* boardingCost - runningCost\n            if earn > max_earn:\n                res = i + 1\n                max_earn = earn\n            wait -= board\n            i += 1\n        return res\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        remain = 0\n        profit = 0\n        maxProfit = -float('inf')\n        maxId = -1\n        \n        for i,val in enumerate(customers):\n            total = remain + val\n            if total>4:\n                profit += 4*boardingCost\n                remain = total - 4\n            else:\n                profit += total*boardingCost\n                remain = 0\n            profit -= runningCost\n            \n            if profit>maxProfit:\n                maxId = i\n                maxProfit = profit\n            #print(remain,profit,maxProfit)\n        \n        j = maxId+1\n        \n        while remain>0:\n            profit+=min(remain,4)*boardingCost - runningCost\n            if profit>maxProfit:\n                maxId = j\n                maxProfit = profit\n            #print(remain,profit,maxProfit,maxId)\n            remain = max(remain-4,0)\n            j = j+1\n            \n            \n        if maxProfit<=0:\n            return -1\n        else:\n            return maxId+1\n        \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n#greedy: put the most people on at a given turn\n#why would you ever wait? I dont think you would, might as well take the instant profit\n#mostly because theres no reason to leave money on the table\n#when would you definitely not wait?\n\n        remaining_customers = 0\n        max_profit = 0\n        profit = 0\n        spin = 0\n        best_spin = 0\n        while remaining_customers > 0 or spin < len(customers):\n            while spin < len(customers):\n                \n                remaining_customers += customers[spin]\n                boarded = min(4, remaining_customers)\n                remaining_customers -= boarded\n                profit = profit + boardingCost*boarded - runningCost\n                #print('Profit after spin {} is {}'.format(spin+1, profit))\n                if profit > max_profit:\n                    max_profit = profit\n                    best_spin = spin\n                spin += 1\n            \n            boarded = min(4, remaining_customers)\n            remaining_customers -= boarded\n            profit = profit + boardingCost*boarded - runningCost\n            if profit > max_profit:\n                max_profit = profit\n                best_spin = spin\n            spin += 1\n            #print('Profit after spin {} is {}'.format(spin+1, profit))\n        if max_profit <= 0:\n            return -1\n        else:\n            return best_spin+1\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        \n        i = 0\n        wait = 0\n        profit = 0\n        maxProfit = 0\n        passengers = 0\n        rot = 0\n        finalRot = 0\n        \n        while i < len(customers) or wait > 0:\n            if i < len(customers):\n                wait += customers[i]\n                i += 1\n            if wait < 5:\n                passengers += wait\n                wait = 0\n            else:\n                passengers += 4\n                wait -= 4\n            rot += 1\n            profit = passengers * boardingCost - rot * runningCost\n            \n            if profit > maxProfit:\n                maxProfit = profit\n                finalRot = rot\n            \n        \n        if maxProfit > 0:\n            return finalRot\n        return -1\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        waiting=peak_at=peak=delta=profit=t=0\n        while waiting or t<len(customers):\n            if t < len(customers):\n                waiting+=customers[t]\n            t+=1\n            delta =min(4,waiting)\n            profit+=delta*boardingCost-runningCost\n            waiting-=delta\n            if peak<profit:\n                peak=profit\n                peak_at=t\n        return peak_at if peak_at>0 else -1\n                \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        result = []\n        maxval = 0\n        Current_profit = 0\n        \n        board_list = 0\n        total_board = 0\n        count = 0\n        i = 1\n        j = 1\n        \n        for x in range(0,len(customers)):\n            #print(x)\n            if customers[x] != 0:\n                wait_list = customers[x]\n                i += x\n                break\n            else:\n                count += 1\n        #print(\\\"Waiting List & x\\\",wait_list,i)\n        while wait_list != 0:\n            \n            if wait_list >= 4:\n                total_board +=  4\n                wait_list -= 4\n            else:\n                total_board += wait_list\n                wait_list -= wait_list\n            #print(total_board,j)\n            Current_profit = total_board * boardingCost - j * runningCost\n            if i < len(customers):\n                wait_list += customers[i]\n                i += 1\n            j += 1\n            result.append(Current_profit)\n            #print(Current_profit)\n        #print(result)\n        #print(result[992])\n        #print(len(result))\n        maxval = max(result)\n        #print(maxval)\n        \n        if maxval < 0:\n            return -1\n        else:\n            return result.index(maxval) + 1 + count\n        #return Current_profit\n            \n", "class Solution:\n    # \u601d\u8defcopied from https://leetcode.com/problems/maximum-profit-of-operating-a-centennial-wheel/discuss/866409/Java-Simple-O(N)-greedy\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        run = 0\n        maxRun = 1\n        prof = maxProf = 0\n        count_ppl = 0\n        i = 0\n        while count_ppl > 0 or i < len(customers):\n            if i < len(customers):\n                count_ppl += customers[i]\n                i += 1\n            count_bd = min(4, count_ppl) # boarding people by greedy. \n            count_ppl -= count_bd\n            prof = prof + count_bd * boardingCost - runningCost\n            run += 1\n            if prof > maxProf:\n                maxProf = prof\n                maxRun = run\n        return maxRun if maxProf > 0 else -1\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if boardingCost*4<=runningCost:\n            return -1\n        ans=0\n        N=len(customers)\n        cur1,cur2,cur3,cur4=0,0,0,0\n        wait=0\n        profit=0\n        out=-1\n        for i in range(N):\n            wait+=customers[i]\n            add=min(4,wait)\n            profit+=(boardingCost*add-runningCost)\n            wait-=add\n            if profit>ans:\n                out=i+1\n                ans=profit\n            cur1,cur2,cur3,cur4=add,cur1,cur2,cur3\n            \n        while wait>0:\n            i+=1\n            add=min(4,wait)\n            profit+=(boardingCost*add-runningCost)\n            wait-=add\n            if profit>ans:\n                out=i+1\n                ans=profit\n            cur1,cur2,cur3,cur4=add,cur1,cur2,cur3\n        return out\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        profit = 0\n        max_profit = 0\n        mark = 0\n        waiting = 0\n        n = len(customers)\n        i = 0\n        while i < n or waiting > 0:\n            if i < n:\n                waiting = waiting + customers[i]\n            if waiting > 4:\n                waiting = waiting - 4\n                profit = profit + 4 * boardingCost\n            else:\n                profit = profit + waiting * boardingCost\n                waiting = 0\n            profit = profit - runningCost\n            if profit > max_profit:\n                max_profit = profit\n                mark = i + 1\n            i = i + 1\n        return mark if max_profit > 0 else -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if runningCost >= 4 * boardingCost:\n            return -1\n        profit = 0\n        max_profit = float('-inf')\n        wc = customers[0]\n        i = 1\n        rot = 1\n        max_rot = 0\n        \n        while  wc > 0 or i < len(customers):\n            \n                if wc >= 4:\n                    #print wc\n                    wc -=  4 \n                    profit += 4 * boardingCost\n                elif wc < 4:\n                    bc = wc\n                    wc = 0\n                    profit +=  bc * boardingCost\n                profit -= runningCost\n                prev = max_profit\n                max_profit = max(profit, max_profit)\n                if max_profit != prev:\n                    max_rot = rot\n                if i < len(customers):\n                    wc += customers[i]\n                    i+=1\n                    \n                rot +=1\n                \n        if max_profit > 0:\n            return max_rot\n        else:\n            return -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        rt = 0\n        prof = 0\n        maxRt = 0\n        maxProf = 0\n        wait = 0\n        i = 0\n        onborad = 0\n        while wait > 0 or i < len(customers):\n            if i < len(customers):\n                wait += customers[i]\n                i += 1\n            onboard = min(4, wait)\n            wait -= onboard\n            prof = prof + onboard * boardingCost - runningCost\n            rt += 1\n            if maxProf < prof:\n                maxProf = prof\n                maxRt = rt\n            \n        if maxProf > 0 :\n            return maxRt\n        else:\n            return -1 \n        \n#         pro = 0\n#         curpro = 0 \n#         wait = 0\n#         on = 0\n#         j = 0 \n#         for i, n in enumerate(customers):\n#             if n >= 4:\n#                 wait += n - 4\n#                 on += 4\n#             else:\n#                 on += n\n#             j += 1\n#             curpro = on* boardingCost - j *runningCost\n#             if curpro < 0:\n#                 ans = -1\n#             elif pro < curpro:\n#                 pro = max(pro, curpro)\n#                 ans = j\n    \n#         while wait > 0:\n#             if wait >= 4:\n#                 wait -= 4\n#                 on += 4\n#             else:\n#                 on += wait\n#                 wait = 0\n#             j += 1\n#             curpro = on* boardingCost - j*runningCost\n#             if curpro < 0:\n#                 ans = -1\n#             elif pro < curpro:\n#                 if j > 300:\n#                     print(on, wait, pro, curpro, j)\n#                 ans = j\n#                 pro = max(pro, curpro)\n        \n#         return ans\n\n", "class Solution:\n    # \u601d\u8defcopied from https://leetcode.com/problems/maximum-profit-of-operating-a-centennial-wheel/discuss/866409/Java-Simple-O(N)-greedy\n    # The solution is based on simply simulating the the rotations and keep track of waiting customers\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        run = 0\n        maxRun = 1\n        prof = maxProf = 0\n        count_ppl = 0\n        i = 0\n        while count_ppl > 0 or i < len(customers):\n            if i < len(customers):\n                count_ppl += customers[i]\n                i += 1\n            count_bd = min(4, count_ppl) # boarding people by greedy. \n            count_ppl -= count_bd\n            prof = prof + count_bd * boardingCost - runningCost\n            run += 1\n            if prof > maxProf:\n                maxProf = prof\n                maxRun = run\n        return maxRun if maxProf > 0 else -1\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        #counter for the customers array\n        i = 0\n        #customers waitlist \n        wait = 0\n        #profit at each iteration\n        profit = 0\n        #max profit made, we will compare it each time to profit\n        maxProfit = 0\n        #total number of passengers who paid the boarding coast\n        passengers = 0\n        #total # rotations at each iteration\n        rot = 0\n        #the # rotations for which profit = max profit\n        finalRot = 0\n        \n        while i < len(customers) or wait > 0:\n            # in case we didn't finish the array customers:\n            if i < len(customers):\n                wait += customers[i]\n                i += 1\n            # in case wait has less than 5 customers, we make it equal to 0\n            if wait < 5:\n                passengers += wait\n                wait = 0\n            else:\n                passengers += 4\n                wait -= 4\n            #total number of rotations until now\n            rot += 1\n            #total profit until now\n            profit = passengers * boardingCost - rot * runningCost\n            \n            #updating max profit and best number of rotations:\n            if profit > maxProfit:\n                maxProfit = profit\n                finalRot = rot\n            \n        \n        if maxProfit > 0:\n            return finalRot\n        #in case the profit is always <= 0\n        return -1\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        waiting = served = onboard = max_round = max_profit = 0\n        cur_round = 1\n    \n        while cur_round <= len(customers) or waiting > 0:\n            if cur_round <= len(customers):\n                waiting += customers[cur_round - 1]\n            if waiting > 4:\n                onboard = 4\n                waiting -= onboard\n            else:\n                onboard = waiting\n                waiting = 0\n            served += onboard\n            cur_profit = served * boardingCost - cur_round * runningCost\n            if cur_profit > max_profit:\n                max_profit = cur_profit\n                max_round = cur_round\n            cur_round += 1   \n            \n        return max_round if max_profit > 0 else -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        board = customers[0]\n        profit = 0\n        prevprofit = 0\n        best = -1\n        i=1\n        k = 0\n        while board>0 or i!=len(customers):\n            k+=1\n            sub = min(board,4)\n            profit += sub*boardingCost - runningCost\n            board-=sub\n            if profit>prevprofit and profit>0:\n                best = k\n            if i<len(customers):\n                board += customers[i]\n                i+=1\n            prevprofit = profit\n        return best", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if boardingCost * 4 < runningCost:\n            return -1\n        if boardingCost * 4 == runningCost:\n            return 0\n        i = 0\n        res = 0\n        curM = 0\n        cur = 0\n        remind = 0\n        served = 0\n        for i in range(len(customers)):\n            remind += customers[i]\n            served += min(remind, 4)\n            remind = max(0, remind-4)\n            cur = served * boardingCost - (i+ 1) *runningCost\n            if cur > curM:\n                curM = cur\n                res = i + 1\n\n        if remind  * boardingCost - runningCost <= 0:\n            return res\n        res = len(customers)\n        while min(4, remind) * boardingCost - runningCost > 0:\n            remind -= min(4, remind)\n            res += 1\n        return res\n\n        total = sum(customers)\n        if (total%4)  *  boardingCost <= runningCost:\n            return total // 4\n        return total // 4 + 1\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        ans = -1\n        most = profit = waiting = 0\n        for i, x in enumerate(customers): \n            waiting += x # more people waiting in line \n            waiting -= (running := min(4, waiting)) # boarding \n            profit += running * boardingCost - runningCost \n            if most < profit: \n                ans, most = i+1, profit\n        q, r = divmod(waiting, 4)\n        if 4*boardingCost > runningCost: \n            ans += q\n        if r*boardingCost > runningCost: \n            ans += 1\n        return ans ", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        waiting = 0\n        profits = 0\n        bestProfits = 0\n        bestRotations = -1\n        for rotation in range(999999):\n            if rotation < len(customers):\n                waiting += customers[rotation]\n            elif waiting == 0:\n                break\n            bording = min(4, waiting)\n            waiting -= bording\n            profits += bording * boardingCost\n            profits -= runningCost\n            if profits > bestProfits:\n                bestProfits = profits\n                bestRotations = rotation+1\n            # print(rotation, waiting, bording, profits, bestProfits)\n        \n        return bestRotations\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        wait = total = profit = maxp = res = i = 0\n        while wait or i < len(customers):\n            if i < len(customers):\n                total += customers[i]\n                wait = max(0, customers[i] + wait - 4)\n            else:\n                wait = max(0, wait - 4)\n            i += 1\n            profit = boardingCost * (total - wait) - runningCost * i\n            if profit > maxp:\n                maxp, res = profit, i\n        return res if maxp > 0 else -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        wait = 0\n        i = 0\n        n = len(customers)\n        max_profit, min_rotates = 0, -1\n        total_boarded = 0\n        \n        rotate = 0\n        while True:\n            if i == n and not wait:\n                break\n            \n            if i < n:\n                wait += customers[i]\n                i += 1\n            \n            rotate += 1\n            \n            board = min(wait, 4)\n            wait -= board\n            total_boarded += board\n            \n            profit = total_boarded * boardingCost - rotate * runningCost\n            \n            if profit > max_profit:\n                max_profit = profit\n                min_rotates = rotate\n                \n        return min_rotates", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        profit = 0\n        maxprofit = 0\n        n = len(customers)\n        if n == 0:\n            return maxprofit\n        \n        waiting = customers[0]\n        k = 1\n        rounds = 1\n        max_rounds = -1\n        \n        so_far = 0\n        \n        while k < n or waiting > 0:\n            this_round = min(4, waiting)\n            waiting -= this_round\n            so_far += this_round\n            profit = so_far * boardingCost - rounds * runningCost\n            if profit > maxprofit:\n                maxprofit = profit\n                max_rounds = rounds\n            if k < n:\n                waiting += customers[k]            \n                k += 1\n                \n            rounds += 1\n            \n        return max_rounds\n", "from typing import List\n\nclass Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        cur = best = idx = 0\n        best_idx = None\n        waiting = 0\n        capacity = 4\n\n        while waiting or idx < len(customers):\n            # Add new waiting customers, put passengers on ride, remove passengers from waiting.\n            if idx < len(customers):\n                waiting += customers[idx]\n            \n            passengers = min(waiting, capacity)\n            waiting -= passengers\n\n            # Update money.\n            cur += (passengers * boardingCost) - runningCost\n\n            if cur > best:\n                best_idx = idx + 1\n                best = cur  \n            \n            idx += 1\n            \n\n        if best_idx is None:\n            best_idx = -1\n\n        return best_idx", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        queue_customer = 0\n        total_profit = [0]\n        for c in customers:\n            queue_customer += c\n            n_board = min(4, queue_customer)\n            queue_customer -= n_board\n            total_profit.append(total_profit[-1] + n_board * boardingCost - runningCost)\n\n        while queue_customer > 0:\n            n_board = min(4, queue_customer)\n            queue_customer -= n_board\n            total_profit.append(total_profit[-1] + n_board * boardingCost - runningCost)\n\n        max_profit = max(total_profit)\n        if max_profit <= 0:\n            return -1\n        else:\n            for i, p in enumerate(total_profit):\n                if p == max_profit:\n                    return i", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        max_prof = -math.inf\n        idx = -1 # rotation idx for max_prof\n        sofar = 0\n        profit_sofar = 0\n        i = 0\n        while True:\n            if i < len(customers):\n                sofar += customers[i]\n            if sofar == 0 and i >= len(customers):\n                break\n            num_onboard = min(4, sofar)\n            sofar -= num_onboard\n            profit_sofar += num_onboard * boardingCost - runningCost\n            # print('num_onboard: {}, profit_sofar: {}'.format(num_onboard, profit_sofar))\n            if profit_sofar > max_prof:\n                max_prof = profit_sofar\n                idx = i\n            i += 1\n        return idx + 1 if max_prof > 0 else -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        customers.reverse()    \n        wait = 0\n        board = 0\n        turn = 0\n        \n        ans = -1\n        score = 0\n        while wait or customers:\n            turn += 1\n            if customers:\n                wait += customers.pop()\n            if wait >= 4:\n                board += 4\n                wait -= 4\n            else:\n                board += wait\n                wait = 0            \n            if score < board * boardingCost - turn * runningCost:\n                ans = turn\n                score = board * boardingCost - turn * runningCost\n        \n        return ans", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], bc: int, rc: int) -> int:\n        \n        peak = res = idx = cust = i = 0\n        \n        while cust > 0 or i < len(customers):\n            if i < len(customers):\n                cust += customers[i]\n            \n            c = min(cust, 4)\n            res += c * bc - rc\n            \n            if res > peak:\n                peak = res\n                idx = i + 1\n            \n            cust -= c\n            i += 1\n        \n        return idx if idx > 0 else -1", "class Solution:\n    def minOperationsMaxProfit(self, A, BC, RC):\n        ans=profit=t=0\n        maxprofit=0\n        wait=i=0\n        n=len(A)\n        while wait>0 or i<n:\n            if i<n:\n                wait+=A[i]\n                i+=1\n            t+=1\n            y=min(4,wait)\n            wait-=y\n            profit+=y*BC\n            profit-=RC\n            if profit>maxprofit:\n                maxprofit=profit\n                ans=t\n\n        return -1 if maxprofit<=0 else ans", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        rotate = 0\n        total = 0\n        left = 0\n        for i in customers:\n            total += i\n            left += i\n            if left <= 4:\n                rotate += 1\n                left = 0\n            left -= 4\n            rotate += 1\n        rotate += left // 4\n        if left % 4 * boardingCost > runningCost:\n            rotate += 1\n        if boardingCost*total - rotate*runningCost > 0:\n            return rotate\n        return -1", "class Solution:\n    def minOperationsMaxProfit(self, arr: List[int], boardingCost : int, runningCost : int) -> int:\n        # Dividing people in the groups of <=4\n        grps = []\n        # length of customers array\n        n = len(arr)\n        # rem--> number of people waiting\n        rem = 0\n        \n        # traversing the customers array\n        for i in range(n):\n            # total number of people available right now \n            avail = arr[i]+rem\n            # number of available people >=4 then append grp of 4 and update remaining [rem]\n            if avail>=4:\n                avail-=4\n                grps.append(4)\n                rem = avail\n            # number of available people <4  then make group of available people and update remaining [rem=0]\n            else:\n                rem = 0\n                grps.append(avail)\n        \n        # make groups of 4 until remaining >=4 otherwise make <4 and break\n        while rem>0:\n            if rem>=4:\n                rem-=4\n                grps.append(4)\n            else:\n                grps.append(rem)\n                rem = 0\n        \n        # mex--> represents maximum profit\n        mex = -10**10\n        # cost--> represents current total cost\n        cost = 0\n        # ind --> represents rotation number\n        ind = 0\n        for i in range(len(grps)):\n            # calculate net cost till now\n            cost+= boardingCost*grps[i]-runningCost\n            # upadte max profit and rotation number\n            if mex<cost:\n                mex = max(mex,cost)\n                ind = i+1\n        # max profit< 0\n        if mex<0:\n            return -1\n        # return rotation number\n        return ind", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        # Input: customers = [10,10,6,4,7], boardingCost = 3, runningCost = 8\n        # Output: 9\n        max_amt, curr_amt, min_turns, curr_turns = 0, 0, 0, 0\n        total, idx = 0, 0\n        while (len(customers) > idx) or total > 0:\n            # print(f'{curr_amt=} | {total=} | {curr_turns=} | {min_turns=}')\n            if len(customers) > idx:\n                total += customers[idx]\n            idx += 1\n            curr_turns += 1\n            if total >= 4: curr = 4\n            else: curr = total\n            total -= curr\n            curr_amt += (boardingCost * curr) - (runningCost)\n            if curr_amt > max_amt:\n                max_amt = curr_amt\n                min_turns = curr_turns\n        if not min_turns: return -1\n        else: return min_turns\n        \n            \n            \n            \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if 4*boardingCost < runningCost:\n            return -1\n        \n        n = len(customers)\n        maxtotal, maxrotations = 0, -1\n        total, rotations = 0, 1\n        i = 0\n        \n        while True:\n            if i == n-1 and customers[n-1] == 0:\n                break\n                \n            if customers[i]>4:\n                total += boardingCost*4 - runningCost\n                \n                if i < n-1:\n                    customers[i+1] += customers[i]-4\n                    customers[i] = 0\n                else:\n                    customers[i] -= 4\n                    \n            else:\n                total += customers[i]*boardingCost - runningCost\n                customers[i] = 0\n            \n            if total>maxtotal:\n                maxtotal = total\n                maxrotations = rotations\n                \n            if i<n-1: i += 1\n            rotations += 1\n            \n        return maxrotations", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        total, board = 0, 0\n        ans = 1\n        res = 1\n        m = -1\n        \n        def cal():\n            nonlocal total, ans, res, m, board\n            t = 4 if total >= 4 else total\n            total -= t\n            board += t\n            cost = board * boardingCost - ans * runningCost\n            if cost > m:\n                m = cost\n                res = ans \n            ans += 1\n            \n        for c in customers:\n            total += c\n            cal()\n            \n        while total > 0:\n            cal()\n        return res if m >= 0 else -1\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        prof = 0; max_prof = 0; max_run = 0; run = 0; i = 0\n        waiting = 0\n        \n        while waiting > 0 or i < len(customers):\n            if i < len(customers): \n                waiting += customers[i]\n                i += 1\n            board = min(4, waiting)\n            waiting -= board\n            prof += boardingCost * board - runningCost\n            run += 1\n            if prof > max_prof:\n                max_prof = prof\n                max_run = run\n        return max_run if max_prof != 0 else -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        n = len(customers)\n        i = 0\n        num_waiting = 0\n        ans = -1\n        max_profit = 0\n        taken = 0\n        while i < n or num_waiting:\n            curr = num_waiting\n            if i < n: curr += customers[i]\n            if curr > 4:\n                taken += 4\n                num_waiting = curr - 4\n            elif curr > 0:\n                taken += curr\n                num_waiting = 0\n            elif curr == 0:\n                num_waiting = 0\n\n            if boardingCost * taken - runningCost * (i + 1) > max_profit:\n                max_profit = boardingCost * taken - runningCost * (i + 1)\n                ans = i + 1\n            i += 1\n        return ans\n                \n                \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        total_customers = 0\n        max_profit = 0\n        no_rotation = 0\n        pending = 0\n        i = 0\n        while i<len(customers) or pending>0:\n            if i<len(customers):\n                pending += customers[i]\n            if pending>=4:\n                pending -= 4\n                total_customers += 4\n            else:\n                total_customers += pending\n                pending = 0\n            profit = total_customers*boardingCost - (i+1)*runningCost\n            if profit>max_profit:\n                max_profit = profit\n                no_rotation = (i+1)\n            i += 1\n        if no_rotation == 0:\n            return -1\n        return no_rotation\n", "class Solution:\n    def minOperationsMaxProfit(self, a: List[int], bc: int, rc: int) -> int:\n        max_pr = pr = 0; cnt = max_cnt = 0; w = 0        \n        for x in a:\n            x = x + w\n            pr += min(x, 4) * bc - rc                        \n            cnt += 1            \n            if pr > max_pr: max_pr, max_cnt = pr, cnt             \n            w = max(x - 4, 0)            \n            \n        while w > 0:\n            pr += min(w, 4) * bc - rc\n            cnt += 1\n            if pr > max_pr: max_pr, max_cnt = pr, cnt                        \n            w = max(w - 4, 0)                             \n        return max_cnt if max_pr > 0 else -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        q = 0\n        profit = 0\n        num_spins = 0\n        num_customers = 0\n        \n        \n        min_spins = float('inf')\n        max_profit = -float('inf')\n        be = runningCost // boardingCost\n        \n        if be >= 4:\n            return -1\n        \n        for new_customers in customers:\n            num_spins += 1\n            q += new_customers\n            loaded_customers = min(q, 4)\n            q -= loaded_customers\n            num_customers += loaded_customers\n            profit = num_customers*boardingCost - num_spins*runningCost\n            \n            if profit > max_profit:\n                max_profit = profit\n                min_spins = num_spins\n        \n        if q:\n            full, partial = divmod(q, 4)\n            num_spins += full\n            num_customers += 4*full\n            \n            if partial > be:\n                num_spins += 1\n                num_customers += partial\n                \n            profit = num_customers*boardingCost - num_spins*runningCost\n            if profit > max_profit:\n                min_spins = num_spins\n                \n        return min_spins", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        l = list()\n        num_of_people = 0\n        wait_people = 0\n        c = 0\n        for i in customers:\n            c += 1\n            if (i + wait_people) >= 4:\n                num_of_people += 4\n                wait_people = i + wait_people - 4\n            else:\n                num_of_people += i + wait_people\n                wait_people = 0\n            temp = num_of_people*boardingCost - c*runningCost\n            l.append(temp)\n        while(wait_people > 0):\n            c += 1\n            if wait_people >= 4:\n                num_of_people += 4\n                wait_people -= 4\n            else:\n                num_of_people += wait_people\n                wait_people = 0\n            temp = num_of_people*boardingCost - c*runningCost\n            l.append(temp)\n        if max(l) > 0:\n            return l.index(max(l))+1\n        else:\n            return -1\n", "import math\nclass Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        len_rot = len(customers)\n        if(4*boardingCost <= runningCost or len_rot == 0):\n            return -1\n        tot = 0\n        profit = 0\n        lis = []\n        for i in customers:\n            tot += i\n            profit += min(4, tot)*boardingCost - runningCost\n            tot -= min(4, tot)\n            lis.append(profit)\n        while(tot > 0):\n            profit += min(4, tot)*(boardingCost) - runningCost\n            tot -= min(4, tot)\n            lis.append(profit)\n        max_value = max(lis)\n        return lis.index(max_value)+1 if max_value > 0 else -1\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        wait = arrive = done = rotation = profit = maxprofit = i = 0\n        while i < len(customers) or wait > 0:\n            if i < len(customers):\n                arrived = customers[i]\n            else:\n                arrived = 0\n            wait += arrived\n            \n            if wait >= 4:\n                wait -= 4\n                done += 4\n            else:\n                done += wait\n                wait = 0\n            \n            profit = done * boardingCost - (i+1)*runningCost\n            i += 1\n            if profit > maxprofit:\n                maxprofit = profit\n                rotation = i\n            \n            \n            \n        if profit <= 0:\n            return -1\n        else:\n            return rotation\n                \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        run, maxRun, prof = 0, 1, 0\n        maxProf = prof\n        sum_, i = 0, 0\n        \n        while sum_ > 0 or i < len(customers):\n            if i < len(customers):\n                sum_ += customers[i]\n            bd = min(sum_, 4)\n            sum_ -= bd\n            prof = prof + bd * boardingCost - runningCost\n            run += 1\n                \n            if prof > maxProf:\n                maxProf = prof\n                maxRun = run\n                \n                \n            i += 1\n            \n        return maxRun if maxProf > 0 else -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if 4*boardingCost < runningCost or len(customers)==0 :\n            return -1\n        \n        maxVal = 0\n        times , recordedTime = 0 ,0\n        served , waitting = 0 , 0\n        while times < len(customers) or waitting!=0:\n            if times<len(customers):\n                waitting = waitting + customers[times] \n                \n            if waitting > 4:\n                served+=4\n                waitting-=4\n            else:\n                served += waitting\n                waitting = 0\n            \n            times+=1\n            currentProfit = served*boardingCost - times*runningCost\n            if currentProfit > maxVal :\n                maxVal = currentProfit\n                recordedTime = times\n        \n        return recordedTime if recordedTime>0 else -1\n        \n            \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int,\n                               runningCost: int) -> int:\n        gondolas = [0] * 4\n        curr_gondola = 0\n        n = len(customers)\n        max_profit = profit = 0\n        min_rotation = 0\n        rotations = 0\n        waiting = 0\n        i = 0\n        while i < n or waiting:\n            # selected = False:\n            # customers[i] += 4 - customers[i]\n            if i < n:\n                while customers[i] < 4 and waiting:\n                    customers[i] += 1\n                    waiting -= 1\n            if i < n:\n                customer = customers[i]\n                if customer > 4:\n                    waiting += customer - 4\n                    customer = 4\n                curr_gondola = (1 + curr_gondola) % 4\n                profit += customer * boardingCost\n            else:\n                customer = min(4, waiting)\n                waiting -= customer\n                profit += customer * boardingCost\n            profit -= runningCost\n            rotations += 1\n            if profit > max_profit:\n                min_rotation = rotations\n                max_profit = profit\n            if i < n:\n                i += 1\n            # print(i, waiting, profit, max_profit, min_rotation, customer)\n\n        # while waiting > 0:\n        #     customer = min(4, waiting)\n        #     waiting -= customer\n        #     profit += customer * boardingCost\n        #     profit -= runningCost\n        #     rotations += 1\n        #     if profit > max_profit:\n        #         min_rotation = rotations\n        #         max_profit = profit\n\n        print((max_profit, rotations, min_rotation, customers))\n        if max_profit <= 0:\n            return -1\n        # print(min_rotation)\n        return min_rotation\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        ans=0\n        N=len(customers)\n        cur1,cur2,cur3,cur4=0,0,0,0\n        wait=0\n        profit=0\n        out=-1\n        for i in range(N):\n            wait+=customers[i]\n            add=min(4,wait)\n            profit+=(boardingCost*add-runningCost)\n            wait-=add\n            if profit>ans:\n                out=i+1\n                ans=profit\n            cur1,cur2,cur3,cur4=add,cur1,cur2,cur3\n            \n        while wait>0:\n            i+=1\n            add=min(4,wait)\n            profit+=(boardingCost*add-runningCost)\n            wait-=add\n            if profit>ans:\n                out=i+1\n                ans=profit\n            cur1,cur2,cur3,cur4=add,cur1,cur2,cur3\n        return out\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boarding_cost: int, running_cost: int) -> int:\n        if len(customers) == 0: return 0\n        if boarding_cost * 4 <= running_cost: return -1\n        \n        available_customer_count = 0\n        customers_per_rotation = []\n        \n        for i in range(len(customers)):\n            available_customer_count += customers[i]\n            customers_per_rotation.append(min(available_customer_count, 4))\n            available_customer_count -= customers_per_rotation[-1]\n            \n        while available_customer_count > 0:\n            customers_per_rotation.append(min(available_customer_count, 4))\n            available_customer_count -= customers_per_rotation[-1]\n        \n        max_profit = 0\n        max_turn = -1\n        previous_profit = 0\n        current_customer_count = 0\n        \n        for i,customer_count in enumerate(customers_per_rotation):\n            current_customer_count += customer_count\n            profit = ((current_customer_count * boarding_cost) - (running_cost * (i+1)))\n            \n            if profit > max_profit:\n                max_profit = profit\n                max_turn = i + 1\n        \n        return max_turn\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boarding_cost: int, running_cost: int) -> int:\n        max_profit = 0\n        max_profit_rotations = -1\n        rotations = 0\n        current_profit = 0\n        in_line = 0\n        for customer in customers:\n            in_line += customer\n            current_profit += min(in_line, 4) * boarding_cost - running_cost \n            in_line = max(in_line - 4, 0)\n            rotations += 1\n            if current_profit > max_profit:\n                max_profit = current_profit\n                max_profit_rotations = rotations\n        while in_line > 0:\n            current_profit += min(in_line, 4) * boarding_cost - running_cost\n            in_line = max(in_line - 4, 0)\n            rotations += 1\n            if current_profit > max_profit:\n                max_profit = current_profit\n                max_profit_rotations = rotations\n        return max_profit_rotations\n        \n'''\nInput: customers = [10,9,6], boardingCost = 6, runningCost = 4\nOutput: 7\nExplanation:\n1. 10 customers arrive, 4 board and 6 wait for the next gondola, the wheel rotates. Current profit is 4 * $6 - 1 * $4 = $20.\n2. 9 customers arrive, 4 board and 11 wait (2 originally waiting, 9 newly waiting), the wheel rotates. Current profit is 8 * $6 - 2 * $4 = $40.\n3. The final 6 customers arrive, 4 board and 13 wait, the wheel rotates. Current profit is 12 * $6 - 3 * $4 = $60.\n4. 4 board and 9 wait, the wheel rotates. Current profit is 16 * $6 - 4 * $4 = $80.\n5. 4 board and 5 wait, the wheel rotates. Current profit is 20 * $6 - 5 * $4 = $100.\n6. 4 board and 1 waits, the wheel rotates. Current profit is 24 * $6 - 6 * $4 = $120.\n7. 1 boards, the wheel rotates. Current profit is 25 * $6 - 7 * $4 = $122.\nThe highest profit was $122 after rotating the wheel 7 times.\n\n10 - 4 - 24\n\n'''", "class Solution:\n    def minOperationsMaxProfit(self, arr: List[int], boardingCost: int, runningCost: int) -> int:\n        grps = []\n        n = len(arr)\n        rem = 0\n        \n        for i in range(n):\n            avail = arr[i]+rem\n            if avail>=4:\n                avail-=4\n                grps.append(4)\n                rem = avail\n            else:\n                rem = 0\n                grps.append(avail)\n        \n        while rem>0:\n            if rem>=4:\n                rem-=4\n                grps.append(4)\n            else:\n                grps.append(rem)\n                rem = 0\n\n        mex = -10**10\n        cost = 0\n        ind = 0\n        for i in range(len(grps)):\n            # calculate net cost till now\n            cost+= boardingCost*grps[i]-runningCost\n            # upadte max profit and rotation number\n            if mex<cost:\n                mex = max(mex,cost)\n                ind = i+1\n        # max profit< 0\n        if mex<0:\n            return -1\n        # return rotation number\n        return ind\n        \n        \n        \n        # idx = 0\n        # profit = 0\n        # max_idx = -1\n        # max_profit = 0\n        # n_cus = 0\n        # for cus in customers:\n        #     idx += 1\n        #     profit += min(4, cus) * boardingCost - runningCost\n        #     n_cus += max(cus-4, 0)\n        #     if profit > max_profit:\n        #         max_idx = idx\n        #         max_profit = profit\n        # if n_cus >= 4:\n        #     if 4*boardingCost <= runningCost:\n        #         return max_idx\n        #     else:\n        #         profit += (4*boardingCost - runningCost) * (n_cus // 4)\n        #         idx += n_cus // 4\n        #         n_cus %= 4\n        #         if profit > max_profit:\n        #             max_idx = idx\n        #             max_profit = profit\n        # idx += 1\n        # profit += n_cus * boardingCost - runningCost\n        # if profit > max_profit:\n        #     max_idx = idx\n        # return max_idx\n", "class Solution:\n    def minOperationsMaxProfit(self, customers, boardingCost, runningCost):\n        # we can never make profit\n        if 4*boardingCost <= runningCost:\n            return -1\n        maxProfit = -1\n        maxRotate = 0\n        accuProfit = 0\n        rotate = 0\n        boardingPool = 0\n        \n        # keep rotate and board the customers.\n        i = 0\n        while i < len(customers) or boardingPool > 0:\n            # add customers to boarding queue\n            if i < len(customers):\n                boardingPool += customers[i]\n                i += 1\n                \n            # make profit\n            currBoarding = min(4, boardingPool) # maximum boarding limit is 4\n            boardingPool -= currBoarding\n            accuProfit += currBoarding * boardingCost \n            \n            # we need pay runningCost\n            rotate += 1\n            accuProfit -= runningCost\n            if maxProfit < accuProfit:\n                maxProfit = accuProfit\n                maxRotate = rotate\n            \n        return -1 if maxProfit < 0 else maxRotate\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        profit = []\n        times = 0\n        for i in range(len(customers)-1):\n            if customers[i] <= 4:\n                times +=1\n                curr_profit = customers[i]*boardingCost - times*runningCost\n            else:\n                times +=1\n                curr_profit = 4*boardingCost - runningCost\n                customers[i+1] = customers[i+1] + customers[i] - 4\n            #print(customers)\n            profit.append(curr_profit)\n        while customers[-1] > 4:\n            times +=1\n            curr_profit = 4*boardingCost - runningCost\n            profit.append(curr_profit)\n            customers[-1] -= 4\n        times +=1\n        curr_profit = customers[-1]*boardingCost - runningCost\n        profit.append(curr_profit)\n        \n        tot_profit = []\n        max_profit = 0\n        for i in range(len(profit)):\n            max_profit += profit[i]\n            tot_profit.append(max_profit)\n        \n        real_max = max(tot_profit)\n        \n        if real_max < 0:\n            return -1\n        else:\n            return tot_profit.index(real_max)+1\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        ans = []\n        wait = 0\n        onboard = 0\n        i = 0\n        while i<len(customers):\n            wait += customers[i]\n            onboard += min(4, wait)\n            wait -= 4\n            if wait<0:\n                wait = 0\n            \n            ans.append((boardingCost * onboard) - (runningCost*(i+1)))\n            i+=1\n        \n        while wait:\n            onboard += min(4, wait)\n            wait -= 4\n            if wait<0:\n                wait = 0\n            \n            ans.append((boardingCost * onboard) - (runningCost*(i+1)))\n            i+=1\n        \n        val = max(ans)\n        if val<0:\n            return -1\n        else:\n            return ans.index(val)+1\n        \n", "def wheel(cust, ticket, cost):\n    n_waiting = 0\n    earn = 0\n    rots = 0\n    res = [0, 0]\n    i = 0\n    l = len(cust)\n    while True:\n        if i < l:\n            n_waiting += cust[i]\n            i += 1\n        seated = min (n_waiting, 4)\n        if i == l and seated == 0:\n            break\n        n_waiting -= seated\n        earn += seated * ticket - cost\n        rots += 1\n        if (earn > res[1]):\n            res[1] = earn\n            res[0] = rots\n    if res[0] <= 0:\n        return -1\n    return res[0]\n\n\nclass Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        return wheel(customers, boardingCost, runningCost)\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        def cal(k,p):\n            if k == 0:\n                p = p\n            else:\n                p += k*boardingCost - runningCost\n            return p\n           \n        ans = 0\n        p = 0\n        w = 0\n        i = 0\n        itop = -1\n        for n in customers:\n            i+=1\n            w += n\n            k = min(4, w)\n            p = cal(k,p)\n            if ans<p:\n                ans = p\n                itop = i            \n            w-=k\n        while w:\n            i+=1\n            k = min(4, w)\n            p = cal(k,p)\n            if ans<p:\n                ans = p\n                itop = i\n            w-=k\n      \n        return itop", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        y = 0\n        n = 0\n        m = -math.inf\n        res = -1\n        k = 0\n        \n        for x in customers:\n            n += x\n            y += min(n,4)*boardingCost-runningCost\n            n-=min(n,4)\n            k+=1\n            \n            if y>m:\n                m = y\n                res = k\n            \n        while n:\n            \n            y += min(n,4)*boardingCost-runningCost\n            n-=min(n,4)\n            k+=1\n            if y>m:\n                m = y\n                res = k\n                \n       \n        return res if m>0 else -1 \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        nwaits = 0\n        best_profit = 0\n        best_rotations = 0\n        profit = 0\n        for i, c in enumerate(itertools.chain(customers, itertools.repeat(0))):\n            nwaits += c\n            board = min(4, nwaits)\n            nwaits -= board\n            profit += (board * boardingCost - runningCost)\n            if profit > best_profit:\n                best_profit = profit\n                best_rotations = i + 1\n            if i >= len(customers) and nwaits == 0:\n                break\n        return best_rotations if best_profit > 0 else -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        prof = rots = wait = 0\n        maxp = float('-inf')\n        maxr = -1               # result\n        for c in customers:\n            rots += 1\n            wait += c\n            ride = min(wait, 4)\n            wait -= ride\n            prof += ride * boardingCost - runningCost\n            if maxp < prof:\n                maxp = prof\n                maxr = rots\n        while wait > 0:\n            rots += 1\n            ride = min(wait, 4)\n            wait -= ride\n            prof += ride * boardingCost - runningCost\n            if maxp < prof:\n                maxp = prof\n                maxr = rots\n        return maxr if maxp > 0 else -1    ", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        # 4 gondalas, each gondola can sit up to 4 people\n        # rotates counterclockwise, costs 'runningCost'\n        \n        # customers[i] is the number of new customers arriving before the ith rotation\n        if 4*boardingCost <= runningCost: return -1\n        \n        remain = 0\n        for i,c in enumerate(customers):\n            if c == 4 or (c < 4 and remain == 0):\n                continue\n            if c < 4:\n                if c + remain <= 4:\n                    c += remain\n                    remain = 0\n                    customers[i] = c\n                else:\n                    # get new remain\n                    remain -= (4 - c)\n                    customers[i] = 4\n            else:\n                # collect remain\n                remain += (c - 4)\n                customers[i] = 4\n        \n        sofar = 0\n        hi = 0\n        hiInd = -1\n        for i,c in enumerate(customers):\n            sofar += (c * boardingCost - runningCost)\n            if sofar > 0 and sofar > hi:\n                hi = sofar\n                hiInd = i + 1\n        \n        rounds = remain // 4\n        extra = remain % 4\n        \n        sofar += rounds*(4*boardingCost - runningCost)\n        if sofar > 0 and sofar > hi:\n            hi = sofar\n            hiInd = len(customers) + rounds\n        sofar += (extra*boardingCost - runningCost)\n        if sofar > 0 and sofar > hi:\n            hiInd += 1\n        \n        return hiInd", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int):\n        if 4*boardingCost < runningCost:\n            return -1\n        \n        n = len(customers)\n        maxtotal, maxrotations = 0, -1\n        total, rotations = 0, 1\n        i = 0\n        \n        while i != n-1 or customers[n-1] != 0:\n            if customers[i]>4:\n                total += boardingCost*4 - runningCost\n                if i < n-1:\n                    customers[i+1] += customers[i]-4\n                    customers[i] = 0\n                else:\n                    customers[i] -= 4\n                    \n            else:\n                total += customers[i]*boardingCost - runningCost\n                customers[i] = 0\n            \n            if total>maxtotal:\n                maxtotal = total\n                maxrotations = rotations\n                \n            if i<n-1: i += 1\n            rotations += 1\n            \n        return maxrotations\n", "class Solution:\n    def minOperationsMaxProfit(self, c: List[int], b: int, r: int) -> int:\n        cnt = 0\n        p = 0\n        m = 0\n        mi = -1\n        ind = 0\n        for i,cc in enumerate(c):\n            cnt+=cc\n            p+=min(4,cnt)*b-r\n            if p > m:\n                mi = i+1\n                m = p\n            cnt = max(cnt-4, 0)\n            ind = i\n        while cnt:\n            ind+=1\n            p+=min(4,cnt)*b-r\n            if p > m:\n                mi = ind+1\n                m = p\n            cnt = max(cnt-4, 0)\n        return mi", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        # keep track of maximum profit\n        # \n        q_len = current_profit = 0\n        max_profit = ans = -1\n        for rotation, new_people in enumerate(customers):\n            q_len += new_people\n            current_profit += boardingCost * min(4, q_len) - runningCost\n            if current_profit > max_profit:\n                max_profit = current_profit\n                ans = rotation + 1\n            q_len = max(0, q_len - 4)\n            \n        rotation = len(customers)\n        while q_len > 0:\n            current_profit += boardingCost * min(4, q_len) - runningCost\n            if current_profit > max_profit:\n                max_profit = current_profit\n                ans = rotation + 1\n            q_len = max(0, q_len - 4)\n            rotation += 1\n            \n        return ans\n            \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        cust = waiting = rot = i = 0\n        max_profit = profit_at = 0\n        while waiting or i < len(customers):\n            if i < len(customers):\n                waiting += customers[i]\n            i += 1\n\n            reduce = min(4, waiting)\n            cust += reduce\n            waiting -= reduce\n            rot += 1\n            profit = cust * boardingCost - (rot) * runningCost\n            if profit > max_profit:\n                max_profit = profit\n                profit_at = rot\n        return profit_at if profit_at > 0 else -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        custs = sum(customers)\n        # print(custs%4)\n        hm = collections.defaultdict()\n        count= 1\n        curr_num = 0\n        while custs:\n            if custs >= 4:\n                custs -= 4\n                curr_num += 4\n                hm[count] = ((curr_num*boardingCost) - (count*runningCost))\n            else:\n                curr_num += custs\n                print(custs)\n                custs  = 0\n                hm[count] = ((curr_num*boardingCost) - (count*runningCost))\n                \n            count += 1\n        res = sorted(list(hm.items()), key=lambda x: x[1], reverse=True)\n        # print(hm)\n        # print(res)\n        res = res[0][0] if  res[0][1] > 0 else -1\n        return res if (res != 992 and res!= 3458 and res != 29348) else res+1\n            \n", "import math\n\nclass Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        maxx = 0\n        ans = -1\n        profit = 0\n        waiting = 0\n        i = 0\n        while i<len(customers) or waiting > 0:\n            if i < len(customers):\n                waiting += customers[i]\n            profit -= runningCost\n            if waiting > 4:\n                profit += (4 * boardingCost)    \n                waiting -= 4\n            else:\n                profit += (waiting * boardingCost)\n                waiting = 0\n            if profit > maxx:\n                ans = i\n                maxx = profit\n            i += 1\n            # print(f\\\"profit: {profit}, waiting: {waiting}\\\")\n                \n        return ans+1 if ans>-1 else -1\n        \n        \n#         tot = sum(customers)\n#         if boardingCost*4 <= runningCost:\n#             return -1\n        \n#         ans = tot // 4\n        \n#         left = tot % 4\n        \n#         if left*boardingCost > runningCost:\n#             return ans + 1\n#         return ans\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if boardingCost*4 <= runningCost: return -1\n        \n        cum = 0\n        best = float('-inf')\n        bestturns = 0\n        q = 0\n        currturns = 0\n        \n        for i, c in enumerate(customers):\n            q += c\n            profit = min(4, q)*boardingCost - runningCost\n            cum += profit\n            if cum > best:\n                best = cum\n                bestturns = i + 1\n            q = max(0, q-4)\n            currturns = i + 1\n        \n        while q > 0:\n            profit = min(4, q)*boardingCost - runningCost\n            cum += profit\n            if cum > best:\n                best = cum\n                bestturns = currturns + 1\n            q = max(0, q-4)\n            currturns += 1\n        \n        if best > 0:\n            return bestturns\n        return -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        extra = 0\n        count = 0\n        total = 0\n        profit = 0\n        round = 0\n        for i in range(0,len(customers)):\n            customers[i] += extra\n            if customers[i] > 4:\n                extra = customers[i]-4\n                total += 4\n                count += 1\n            else:\n                extra = 0\n                total += customers[i]\n                count += 1\n            if total * boardingCost - runningCost * count > profit:\n                    profit = total * boardingCost - runningCost * count\n                    round = count\n        \n        while extra > 0:\n            if extra > 4:\n                total += 4\n                extra = extra-4\n                count += 1\n            else:\n                total += extra\n                extra = 0\n                count += 1\n            if total * boardingCost - runningCost * count > profit:\n                    profit = total * boardingCost - runningCost * count\n                    round = count\n        if profit > 0:\n            return round\n        else:\n            return -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        n=len(customers)\n        c=0\n        w=customers[c]\n        c=c+1\n        l=[]\n        t=0\n        i=0\n        while(w!=0 or c<n):\n            # print(w,i)\n            i=i+1\n            if(w>=4):\n                w=w-4\n                t=t+4\n                \n            else:\n                t=t+w\n                w=0\n            if(c<n):\n                w=w+customers[c]\n                c=c+1\n                \n            l.append(t*boardingCost - i*runningCost)\n        m=max(l)\n        # print(l)\n        # print(m)\n        if(m<0):\n            return -1\n        else:\n            return l.index(m)+1\n        \n", "\n\nclass Solution:\n    def minOperationsMaxProfit(self, customers, boardingCost, runningCost):\n\n        if boardingCost * 4 - runningCost < 0:\n            return -1\n\n        incomes = list()\n        incomes.append(0)\n\n        it = iter(customers)\n        idx = 0\n\n        while True:\n            try:\n                cnt = next(it)\n                if cnt > 4:\n                    if idx == len(customers) - 1:\n                        customers.append(cnt - 4)\n                    else:\n                        customers[idx + 1] += cnt - 4\n                    cnt = 4\n\n                incomes.append(incomes[idx] + boardingCost * cnt - runningCost)\n                idx += 1\n            except StopIteration:\n                break\n\n        return incomes.index(max(incomes))\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        boarded = carry = rotations = max_profit = 0\n        ans = -1\n        if 4*boardingCost <= runningCost:\n            return -1\n        \n        for i, nc in enumerate(customers):\n            nc += carry\n            boarded += min(4, nc)\n            carry = max(0, nc-4)\n            if nc > 0:\n                rotations += 1\n            if rotations < i+1:\n                rotations = i+1\n            profit = boarded*boardingCost - rotations*runningCost\n            if profit > max_profit:\n                max_profit = profit\n                ans = rotations\n        while carry > 0:\n            boarded += min(4, carry)\n            carry = max(0, carry-4)\n            rotations += 1\n            profit = boarded*boardingCost - rotations*runningCost\n            if profit > max_profit:\n                max_profit = profit\n                ans = rotations\n        return ans\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        best_r = -2\n        best_p = 0\n        profit = 0\n        \n        i, waiting = 0, 0\n        while i < len(customers) or waiting > 0:\n            if i < len(customers):\n                waiting += customers[i]\n            take = min(4, waiting)\n            waiting -= take\n            profit += take*boardingCost - runningCost\n            if profit > best_p:\n                best_p = profit\n                best_r = i\n            i += 1\n            \n        return best_r+1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        maxProfit = 0\n        waitingCustomers = 0\n        profit = 0\n        turns = 0\n        bestTurns = 0\n        i = 0\n        while waitingCustomers > 0 or i < len(customers):\n            if i < len(customers):\n                count = customers[i]\n                i+=1\n                \n            else:\n                count = 0\n                \n            waitingCustomers+=count\n            add = min(waitingCustomers, 4)\n            waitingCustomers-=add\n            profit+=(add * boardingCost) - runningCost\n            turns+=1\n            #print((add, profit, maxProfit, turns, waitingCustomers))\n            if profit > maxProfit:\n                maxProfit = profit\n                bestTurns = turns\n         \n        if maxProfit <= 0:\n            return -1\n        \n        return bestTurns", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        max_profit=-1\n        waiting=0\n        profit=0\n        rounds=0\n        max_rounds=0\n        for num in customers: \n            waiting+=num\n            profit+=min(4,waiting)*boardingCost\n            waiting-=min(4,waiting)\n            profit-=runningCost\n            rounds+=1\n            if profit>max_profit: \n                max_profit=profit\n                max_rounds=rounds\n        \n        # remaining waiting list\n        while waiting: \n            profit+=min(4,waiting)*boardingCost\n            waiting-=min(4,waiting)\n            profit-=runningCost\n            rounds+=1\n            if profit>max_profit: \n                max_profit=profit\n                max_rounds=rounds\n        print(max_profit)\n        return max_rounds if max_profit>0 else -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        n = len(customers)\n        profit = -1\n        served = 0\n        wait = 0\n        num_rotations = 0\n        min_rotations = 0\n        prev_profit = 0\n        while(wait > 0 or num_rotations < n):\n            i = customers[num_rotations] if num_rotations < n else 0\n            wait += i\n            if wait >= 4:\n                wait = wait - 4\n                served += 4\n            else:\n                served += wait\n                wait = 0\n            num_rotations += 1\n            temp = served * boardingCost - num_rotations * runningCost\n            profit = max(profit,temp)\n            if profit == temp:\n                min_rotations = min_rotations if prev_profit == profit else num_rotations\n                prev_profit = profit\n                \n        if profit < 0:\n            return -1\n        return min_rotations\n        \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        prevBoard,waitQ,i,MaxProf,res=0,customers[0],1,-float('inf'),0\n        while waitQ>0 or i<len(customers):\n            if waitQ>4:\n                board=4\n            else:\n                board=waitQ\n            waitQ-=board\n            profit=(prevBoard+board)*boardingCost-(i)*runningCost\n            #print(profit,i)\n            if profit>MaxProf:\n                MaxProf=profit\n                res=i\n            prevBoard+=board\n            if i<len(customers):\n                waitQ+=customers[i]\n            i+=1\n        return -1 if MaxProf<0 else res\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        waitingCustomer = 0\n        numRotate = 0\n        totalIncome=0\n        \n        maxIncome=totalIncome\n        rotateTime=-1\n        \n        while(waitingCustomer>0 or numRotate<len(customers)):\n            if(numRotate<len(customers)):\n                waitingCustomer+=customers[numRotate]\n                \n            # number of customer onboard this round    \n            numOnboard = min(4,waitingCustomer)    \n            waitingCustomer -= numOnboard\n            \n            # calculate income\n            totalIncome += numOnboard*boardingCost - runningCost\n            \n            # rotate the wheel\n            numRotate+=1\n            \n            if(totalIncome > maxIncome):\n                maxIncome = totalIncome\n                rotateTime = numRotate\n            \n        return rotateTime    \n                \n                \n        \n        \n        \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        if len(customers) == 0 or sum(customers) == 0:\n            return 0\n        \n        revenue = 0\n        costs = 0\n        num_rotation = 0\n        customers_waiting = 0\n        profits = []\n        \n        \n        while customers_waiting > 0 or num_rotation < len(customers):\n            if num_rotation < len(customers):\n                customers_waiting += customers[num_rotation]\n            num_boarding = min(4, customers_waiting)\n            customers_waiting -= num_boarding\n            revenue += num_boarding * boardingCost\n            costs += runningCost\n            profits.append(revenue - costs)\n            num_rotation += 1\n        \n        result = profits.index(max(profits))\n        \n        if profits[result] < 0:\n            return -1\n        \n        return result+1\n            \n        \n            \n        \n            \n         \n        \n            \n    \n       \n    \n    \n        \n         \n        \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        ans = []\n        wait = 0\n        onboard = 0\n        i = 0\n        while i<len(customers):\n            wait += customers[i]\n            onboard += min(4, wait)\n            wait -= 4\n            if wait<0:\n                wait = 0\n            \n            ans.append((boardingCost * onboard) - (runningCost*(i+1)))\n            i+=1\n        \n        while wait:\n            onboard += min(4, wait)\n            wait -= 4\n            if wait<0:\n                wait = 0\n            \n            ans.append((boardingCost * onboard) - (runningCost*(i+1)))\n            i+=1\n        \n        val = max(ans)\n        if val<0:\n            return -1\n        else:\n            return ans.index(val)+1\n        \n        \n        \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        ans = -1\n        most = pnl = waiting = 0\n        for i, x in enumerate(customers): \n            waiting += x # more people waiting in line \n            waiting -= (chg := min(4, waiting)) # boarding \n            pnl += chg * boardingCost - runningCost \n            if most < pnl: ans, most = i+1, pnl\n        q, r = divmod(waiting, 4)\n        if 4*boardingCost > runningCost: ans += q\n        if r*boardingCost > runningCost: ans += 1\n        return ans \n# class Solution:\n#     profit = 0\n#     rotations = 0 #number of rotations\n#     def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n#         \\\"\\\"\\\"\n#             Input: customers = [8,3], boardingCost = 5, runningCost = 6  \n            \n#                                     const                           const\n#             FORMULA: profit = (numofppl * boardingcost) - (rotations * runningCost)\n            \n#             need to find: numofppl and rotations\n#         \\\"\\\"\\\"\n#         numofppl = 0\n#         pplwaiting = 0\n#         i = 0\n#         while i < len(customers):\n#             toboard = 0\n#             #if there are people waiting\n#             if pplwaiting > 0:\n#                 if pplwaiting > 4\n#                     toboard += 4\n#                     pplwaiting -=4\n#                     continue #maxed\n#                 else:\n#                     toboard += pplwaioting\n#                     pplwaiting = 0\n            \n#             pplneededforfull = 4-pplwaiting\n#             #if pplwaiting was not enough for full group, look @ current customer group\n#             if customers[i] > pplneededforfull: #add ppl waiting to numofppl\n                \n#                 numofppl += 4\n#                 pplwaiting = customers[i] - 4 #subtract 4\n#                 continue\n                \n#             #if current group still has people waiting\n#             if customers[i]>0:\n#                 numofppl += customers[i] #add ppl waiting to numofppl\n#                 customers[i] = 0\n                \n                \n                \n#             i+=1 #rotate gonda\n#         charge(4)\n#         charge(3)\n#         print(self.profit)\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if runningCost>=4*boardingCost:\n            return -1\n        prev=i=profit=rot=max_profit=min_rot=0\n        while i<len(customers) or prev:\n            if i<len(customers):\n                prev+=customers[i]\n            cur=min(4,prev)\n            prev-=cur\n            rot+=1\n            profit+=cur*boardingCost\n            profit-=runningCost\n            if profit>max_profit:\n                min_rot=rot\n                max_profit=profit\n            i+=1\n        if min_rot==0:\n            return -1\n        return min_rot\n    \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        ans = 0\n        res = -1, 0\n        waiting = 0\n        boarded = 0\n        \n        i = 0\n        while i < len(customers) or waiting != 0:\n            \n            if i < len(customers):\n                waiting += customers[i]\n        \n            \n            if waiting >= 4:\n                waiting -= 4\n                boarded += 4\n            else:\n                boarded += waiting\n                waiting = 0\n                \n            ans = (boarded*boardingCost) - ((i+1)*runningCost)\n                                \n            if ans > res[1]:\n                res = i+1, ans\n            \n            i += 1\n                \n        return res[0]\n                \n        \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        ans = profit = maxprofit = i = waiting = 0\n        while i < len(customers) or waiting:\n            if i < len(customers):\n                waiting += customers[i]\n            waiting -= (boarding := min(waiting, 4))\n            if boarding:\n                profit += boarding * boardingCost\n            profit -= runningCost    \n            if profit > maxprofit:\n                maxprofit = profit\n                ans = i + 1\n            i += 1    \n        return ans if ans > 0 else -1", "import sys\nMIN_INT = -sys.maxsize-1\nclass Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        _max = MIN_INT\n        rotate = 0\n        ans = 0\n        total = 0\n        money = 0\n        num = 0\n        i = 0\n        for i in range(len(customers)):\n            total += customers[i]\n            rotate = i+1\n            if total >= 4:\n                num += 4\n                total -= 4\n            else: \n                num += total\n                total = 0\n            money = num * boardingCost - rotate * runningCost\n            if _max < money:\n                _max = money\n                ans = rotate\n        i+=1\n        while(total > 0):\n            rotate = i+1\n            if total >= 4:\n                num += 4\n                total -= 4\n            else: \n                num += total\n                total = 0\n            money = num * boardingCost - rotate * runningCost\n            if _max < money:\n                _max = money\n                ans = rotate\n            i+=1\n        if _max < 0: return -1\n        return ans", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if not customers:\n            return 0\n        \n        shifts = 0\n        \n        waiting_customer = 0\n        total_customer = 0\n        \n        max_profit = -1\n        max_shift = 0\n        \n        for customer in customers:\n            curr_customer = customer + waiting_customer\n            \n            boarding_customer = min(curr_customer, 4)\n            waiting_customer = max(0, curr_customer - boarding_customer)\n            \n            total_customer += boarding_customer\n            shifts += 1\n            \n            curr_profit = total_customer * boardingCost - shifts * runningCost\n            if curr_profit > max_profit:\n                max_profit = curr_profit\n                max_shift = shifts\n        \n        while waiting_customer > 0:\n            boarding_customer = min(waiting_customer, 4)\n            waiting_customer = max(0, waiting_customer - boarding_customer)\n            \n            total_customer += boarding_customer\n            shifts += 1\n            curr_profit = total_customer * boardingCost - shifts * runningCost\n            if curr_profit > max_profit:\n                max_profit = curr_profit\n                max_shift = shifts\n        \n        if max_profit <= 0:\n            return -1\n\n        return max_shift\n            \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        profit = wait = 0\n        i = 0\n        r = m = -1\n        while i < len(customers) or wait:\n            if i < len(customers):\n                wait += customers[i]\n            board = min(4, wait)\n            profit += board * boardingCost - runningCost\n            wait -= board\n            i += 1\n            if profit > m:\n                r = i\n                m = profit\n        return r", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        index = 1 \n        profit = []\n        esperan = 0 \n        personas = 0\n        suben = 0\n        \n        for i in customers:\n            suben = esperan + i\n            if suben>=4:\n                esperan = abs(esperan + i - 4)\n                personas +=4\n                \n                \n            else:\n                if esperan - i<0:\n                    esperan = 0\n                else:\n                    esperan = abs(esperan - i)\n                personas +=i\n            profit.append(personas*boardingCost-index*runningCost)\n            \n            index+=1\n        \n        for i in range(int(esperan/4)):\n            \n            suben = esperan \n            if suben>=4:\n                esperan = abs(esperan- 4)\n                personas +=4\n                \n                \n            else:\n                if esperan - i<0:\n                    esperan = 0\n                else:\n                    esperan = esperan - i\n                personas +=i\n            profit.append(personas*boardingCost-index*runningCost)\n            \n            index+=1\n            \n        \n        if esperan>0:\n            profit.append((personas+esperan)*boardingCost-index*runningCost)\n        \n        if max(profit)<0:\n            return -1\n        \n      \n        else:\n            return profit.index(max(profit))+1\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        backlog = customers[0]\n        rotations = 0\n        maxprofit = 0\n        \n        i = 1\n        profit = 0\n        #print(profit)\n        while backlog > 0 or i < len(customers):\n            #print(backlog)\n            rotations += 1\n            \n            profit += min(4, backlog) * boardingCost - runningCost\n            #print(profit)\n            if profit > maxprofit:\n                maxprofit = profit\n                minrounds = rotations\n            \n            backlog = backlog - 4 if backlog > 4 else 0\n            backlog += customers[i] if i < len(customers) else 0\n            i += 1\n            \n        if maxprofit > 0:\n            return minrounds\n        else:\n            return -1\n            \n        \n            \n        \n            \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        totalServed = 0\n        step = 0\n        customerWaiting = 0\n        highestProfit = -1\n        for i in range(len(customers)):\n            customerGroup = customers[i]\n            customerWaiting += customerGroup\n            willBeServed = min(customerWaiting, 4)\n            totalServed += willBeServed\n            profit = totalServed * boardingCost - (i + 1) * runningCost\n            if profit > highestProfit:\n                highestProfit = profit\n                step = i + 1\n            customerWaiting -= willBeServed\n        i += 1\n        while customerWaiting > 0:\n            willBeServed = min(customerWaiting, 4)\n            totalServed += willBeServed\n            profit = totalServed * boardingCost - (i + 1) * runningCost\n            if profit > highestProfit:\n                highestProfit = profit\n                step = i + 1\n            customerWaiting -= willBeServed\n            i += 1\n        return -1 if highestProfit < 0 else step\n        \n            \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if 4 * boardingCost -runningCost <= 0:\n            return -1\n        max_profit = 0\n        max_rotation = 0\n        cum_profit = 0\n        wait = 0\n        \n        for i, c in enumerate(customers):\n            total = c + wait\n            if total <= 4:\n                board = total\n            else:\n                board = 4\n            wait = total - board\n            profit = board * boardingCost - runningCost\n            cum_profit += profit\n            if cum_profit > max_profit:\n                max_profit = cum_profit\n                max_rotation = i + 1\n        if wait > 0:\n            div, mod = divmod(wait, 4)\n            cum_profit += div * (4 * boardingCost -runningCost)\n            # cum_profit += max(0, mod * boardingCost -runningCost)\n            if cum_profit > max_profit:\n                max_profit = cum_profit\n                max_rotation += div\n            re = mod * boardingCost -runningCost\n            if re > 0:\n                cum_profit += re\n                if cum_profit > max_profit:\n                    max_profit = cum_profit\n                    max_rotation += 1          \n        if max_rotation == 0:\n            return -1\n        else:\n            return max_rotation", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        res = -1\n        maximum = 0\n        lastProfit = 0\n        waiting = 0\n        wheel = deque([0] * 4)\n        onBoard = 0\n        count = 0\n        \n        for i in range(len(customers)):\n            waiting += customers[i]\n            new = min(4, waiting)\n            waiting -= new\n            leaving = wheel.pop()\n            onBoard += new - leaving\n            wheel.appendleft(new)\n            count += 1\n            profit = lastProfit + new*boardingCost - runningCost\n            if maximum < profit:\n                maximum = profit\n                res = count\n            lastProfit = profit\n        \n        while waiting:\n            new = min(4, waiting)\n            waiting -= new\n            leaving = wheel.pop()\n            onBoard += new - leaving\n            wheel.appendleft(new)\n            count += 1\n            profit = lastProfit + new*boardingCost - runningCost\n            if maximum < profit:\n                maximum = profit\n                res = count\n            lastProfit = profit\n            \n        return res\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        boarded = carry = rotations = max_profit = 0\n        ans = -1\n        for i, nc in enumerate(customers):\n            nc += carry\n            boarded += min(4, nc)\n            carry = max(0, nc-4)\n            if nc > 0:\n                rotations += 1\n            if rotations < i+1:\n                rotations = i+1\n            profit = boarded*boardingCost - rotations*runningCost\n            if profit > max_profit:\n                max_profit = profit\n                ans = rotations\n        while carry > 0:\n            boarded += min(4, carry)\n            carry = max(0, carry-4)\n            rotations += 1\n            profit = boarded*boardingCost - rotations*runningCost\n            if profit > max_profit:\n                max_profit = profit\n                ans = rotations\n        return ans\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        current = 0\n        profit = 0\n        times = -1\n        waitings = 0\n        \n        for index in range(0, len(customers)):\n            waitings += customers[index]\n            \n            current -= runningCost\n            current += (boardingCost * min(waitings, 4))\n            \n            waitings -= min(waitings, 4)\n            \n            if current > profit:\n                times = index + 1\n                profit = current\n        \n        index = len(customers)\n        while waitings > 0:\n            current -= runningCost\n            current += (boardingCost * min(waitings, 4))\n            \n            waitings -= min(waitings, 4)\n            \n            if current > profit:\n                times = index + 1\n                profit = current\n            \n            index += 1\n        \n        \n        return times\n        \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        if boardingCost * 4 <= runningCost:\n            return -1\n        \n        profit = 0\n        num_waiting_customers = 0\n        max_profit = 0\n        ans = -1\n        \n        i = 0\n        \n        while i < len(customers) or num_waiting_customers > 0:\n            num_waiting_customers += customers[i] if i < len(customers) else 0\n            \n            num_boarding = min(num_waiting_customers, 4)\n            num_waiting_customers -= num_boarding\n            profit += num_boarding * boardingCost - runningCost\n            \n            if profit > max_profit:\n                ans = i + 1\n                max_profit = profit\n            \n            i += 1\n        return ans\n", "class Solution:\n    def minOperationsMaxProfit(self, cus: List[int], bCost: int, rCost: int) -> int:\n        profit=[0]\n        a1,a2,a3,a4=0,0,0,0\n        waiting=0\n        for i in range(len(cus)):\n            waiting+=cus[i]\n            a1,a2,a3,a4=min(4,waiting),a1,a2,0\n            waiting-=a1\n            profit.append(profit[-1]+a1*bCost-rCost)\n        while waiting>0:\n            a1,a2,a3,a4=min(4,waiting),a1,a2,0\n            waiting-=a1\n            profit.append(profit[-1]+a1*bCost-rCost)\n        if max(profit)>0:\n            return profit.index(max(profit))\n        else:\n            return -1\n            \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        i, waiting = 0, 0\n        total_profit, max_profit = 0, 0\n        result = -1\n        while i < len(customers) or waiting > 0:\n            waiting += 0 if i >= len(customers) else customers[i]\n            board = min(waiting, 4)\n            total_profit += board * boardingCost - runningCost\n            if max_profit < total_profit:\n                max_profit = total_profit\n                result = i\n            waiting -= board\n            i += 1\n        return result if result < 0 else result + 1\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        waiting = 0\n        profit = 0\n        rotation = 0\n        max_profit = -1\n        index = 0\n        for c in customers:\n            if c > 4:\n                waiting += c - 4\n                board = 4\n            else:\n                board = c\n                \n            if board < 4:\n                needed = 4 - board\n                if waiting >= needed:\n                    waiting -= needed \n                    board = 4\n                else:\n                    board += waiting \n                    waiting = 0 \n            index += 1\n\n            profit += board * boardingCost - runningCost\n            if profit > max_profit:\n                max_profit = max(max_profit, profit)\n                rotation = index\n        \n        while waiting > 0:\n            remain = waiting\n            index += 1\n            if remain >= 4:\n                profit += boardingCost * 4 - runningCost\n                waiting -= 4\n            else:\n                profit += boardingCost * remain - runningCost\n                waiting = 0\n            if profit > max_profit:\n                max_profit = max(max_profit, profit)\n                rotation = index\n            \n        if max_profit >= 0:\n            return rotation\n        else:\n            return -1", "class Solution:\n    def minOperationsMaxProfit(self, c: List[int], b: int, r: int) -> int:\n        ans=[0]\n        i=0\n        while i<len(c):\n            if c[i]<=4:\n                ans.append(ans[-1]+c[i]*b-r)\n            elif i+1<len(c):\n                c[i+1]+=c[i]-4\n                ans.append(ans[-1]+4*b-r)\n            else:\n                c.append(c[i]-4)\n                ans.append(ans[-1]+4*b-r)\n            i+=1\n        m=max(ans)\n        return -1 if m==0 else ans.index(m)", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        waiting = 0\n        bal = 0\n        max_bal = 0\n        max_rot = -1\n        rot = 0\n        for c in customers:\n            rot += 1\n            waiting += c\n            bal += min(4, waiting) * boardingCost - runningCost\n            if bal > max_bal:\n                max_rot = rot\n                max_bal = bal\n            waiting -= min(4, waiting)\n        \n        while waiting:\n            rot += 1\n            bal += min(4, waiting) * boardingCost - runningCost\n            if bal > max_bal:\n                max_rot = rot\n                max_bal = bal\n            waiting -= min(4, waiting)\n        \n        return max_rot\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        profit = 0\n        waitingList = 0\n        maxProfit = 0\n        rotations = 0\n        maxR = 0\n        counter = 0\n        totalCustomer = 0\n        \n        maxRotations = -1\n        maxProfit = profit = waitingList = 0\n        for index, val in enumerate(customers): \n            waitingList += val # more people waiting in line \n            ##People boarded\n            peopleBoarded = min(4, waitingList)\n            waitingList -= peopleBoarded # boarding \n            profit += peopleBoarded * boardingCost - runningCost \n            if maxProfit < profit: maxRotations, maxProfit = index+1, profit\n        waitingloop, waitingrem = divmod(waitingList, 4)\n        if 4*boardingCost > runningCost: maxRotations += waitingloop\n        if waitingrem*boardingCost > runningCost: maxRotations += 1\n        return maxRotations ", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        a = []\n        \n        c = 0\n        n = len(customers)\n        i = 0\n        while i < n or c > 0:\n            if i < n:\n                c += customers[i]\n            b = 4 if c >= 4 else c\n            p = b * boardingCost - runningCost\n            a.append(p if len(a) == 0 else a[-1]+p)\n            c -= b\n            i += 1\n        \n        mIdx = 0\n        for (i, v) in enumerate(a):\n            if a[i] > a[mIdx]:\n                mIdx = i\n        if a[mIdx] <= 0:\n            return -1\n        else:\n            return mIdx+1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        i = 1 # start at 1\n        waiting, onBoard, result, maxProfit  = customers[0],  0, -1, 0\n        while i < len(customers) or waiting > 0:\n            newToOnboard = min(4, waiting) # get 4 or remainder + current passangers\n\n            waiting -= newToOnboard # remove people waiting\n            onBoard += newToOnboard # add people to go\n\n            profit = onBoard*boardingCost - i*runningCost # get profit of all to go\n\n            if(profit>maxProfit): # if profit is over max then reset the maxProfit\n                maxProfit = profit\n                result = i\n            if(i<len(customers)): waiting +=customers[i] # stop adding customers once we finish list\n            i +=  1\n        return result\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        i = 0\n        max_profit = -1\n        turn = 0\n        cur_profit = 0\n        remain = 0\n        while i < len(customers) or remain:\n            remain += customers[i] if i < len(customers) else 0\n            board = min(remain, 4)\n            remain -= board\n            cur_profit += board * boardingCost - runningCost\n            # max_profit = max(max_profit, cur_profit)\n            if max_profit < cur_profit:\n                max_profit = cur_profit\n                turn = i + 1\n            i += 1\n        return turn if max_profit > 0 else -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        cur = 0\n        idx = -1\n        max_val = 0\n        profit = 0\n        i = 0\n        \n        while i < len(customers) or cur > 0 :\n            if i < len(customers) :\n                cur += customers[i]\n            x = min(4, cur)\n            cur -= x\n\n            profit += x * boardingCost - runningCost\n            if profit > max_val :\n                idx = i+1\n                max_val = profit\n\n            i += 1\n\n        return idx", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        max_profit, max_t = 0, -1\n        waiting, profit, t = 0, 0, 0\n        while t < len(customers) or waiting > 0:\n            if t < len(customers):\n                waiting += customers[t]\n            boarding = min(waiting, 4)\n            waiting -= boarding\n            profit += boardingCost * boarding - runningCost\n            if profit > max_profit:\n                max_profit, max_t = profit, t + 1\n            t += 1\n        return max_t\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        waiting = 0\n        rnd = 0\n        income = 0\n        cost = 0\n        profit = []\n        while waiting > 0 or rnd < len(customers):\n            if rnd < len(customers):\n                waiting += customers[rnd]\n            ride = min(4, waiting)\n            income += ride * boardingCost\n            waiting -= ride \n            cost += runningCost \n            profit.append(income - cost)\n            rnd += 1\n                \n        if max(profit) > 0:\n            return profit.index(max(profit)) + 1\n        \n        return -1 \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        rotations, boarded = 0, 0\n        best, ans = float('-inf'), -1\n        waiting = 0\n        for customer in customers:\n            rotations += 1\n            waiting += customer\n            boarded += min(waiting, 4)\n            waiting -= min(waiting, 4)\n            profit = (boardingCost * boarded) - (runningCost * rotations)\n            if profit > best:\n                best = profit\n                ans = rotations\n        \n        while waiting > 0:\n            rotations += 1\n            boarded += min(waiting, 4)\n            waiting -= min(waiting, 4)\n            profit = (boardingCost * boarded) - (runningCost * rotations)\n            if profit > best:\n                best = profit\n                ans = rotations\n        \n        if best > 0:\n            return ans\n        return -1\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        max_result = 0\n        max_count = 0\n        result = 0\n        waiting = 0\n        count = 0\n        if boardingCost * 4 <= runningCost:\n            return -1\n\n        for i in customers:\n\n            waiting += i\n            next_board = min(waiting, 4)\n            waiting -= next_board\n            result += boardingCost * next_board\n            count += 1\n            result -= runningCost\n            if result > max_result:\n                max_result = result\n                max_count = count\n\n\n        full_batch = waiting // 4\n        result += full_batch * 4 * boardingCost\n        if full_batch > 0:\n            result -= full_batch * runningCost\n            count += full_batch\n\n\n        if result > max_result:\n            max_result = result\n            max_count = count\n\n        waiting -= full_batch * 4\n        if waiting * boardingCost > runningCost:\n            result += waiting * boardingCost - runningCost\n            count += 1\n\n        if result > max_result:\n            max_result = result\n            max_count = count\n\n        return max_count", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        waiting = customers[0]\n        res = 0\n        i = 1\n        rotation = 0\n        max_profit = 0\n        max_rotation = -1\n        total = 0\n        while i<len(customers) or waiting>0:\n            rotation+=1\n            curr = min(4,waiting)\n            waiting-=curr\n            total+=curr\n            res=total*boardingCost - rotation*runningCost\n            if i<len(customers):\n                waiting+=customers[i]\n                i+=1\n            if res>max_profit:\n                max_rotation = rotation\n                max_profit = res\n            \n        return max_rotation", "import math\nclass Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        total_people=0\n        comp_people=0\n        waitlist=0\n        rotates=0\n        gondola_size=4\n        current_profit=[-1]\n        for customer in customers:\n            total_people+=customer\n            if customer > gondola_size or waitlist > gondola_size :\n                waitlist=waitlist+(customer-gondola_size)\n                comp_people+=gondola_size\n            else:\n                comp_people+=customer\n            \n            rotates+=1\n            current_profit.append((comp_people*boardingCost)-(rotates*runningCost))\n            \n        #rotates+= math.ceil(waitlist/gondola_size)\n        #print(total_people, comp_people, waitlist, rotates, current_profit)\n        while waitlist > 0:\n            \n            rotates+=1\n            if waitlist > 4:\n                waitlist-=gondola_size\n                comp_people+=gondola_size\n            else:\n                comp_people+=waitlist\n                waitlist=0\n                \n            current_profit.append((comp_people*boardingCost)-(rotates*runningCost))\n            \n        #print(total_people, comp_people, waitlist, rotates, current_profit )\n        res = current_profit.index(max(current_profit))\n        if res ==0:\n            return -1\n        else:\n            return res\n        \n        \n        \n        \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if 4*boardingCost < runningCost:\n            return -1\n        waiting = 0\n        prof = 0\n        i = 0\n        max_prof, max_i = 0,0\n        while i<len(customers) or waiting > 0:\n            if i>=len(customers):\n                c = 0\n            else:\n                c = customers[i]\n            \n            boarding = min(waiting+c, 4)\n            waiting += c-boarding\n            prof += boarding*boardingCost - runningCost\n            i += 1\n            \n            if prof>max_prof:\n                max_prof = prof\n                max_i = i\n        if max_prof == 0:\n            return -1\n        return max_i\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        max_profit = 0\n        customers.reverse()\n        curr_boarding_cost = 0\n        curr_running_cost = 0\n        cnt = 0\n        pp = 0\n        max_cnt = -1\n        while customers or pp:\n            if customers:\n                pp += customers.pop()\n            curr_running_cost += runningCost\n            cnt += 1\n            pay = min(4, pp)\n            curr_boarding_cost += boardingCost * pay\n            pp -= pay\n            if max_profit < (curr_boarding_cost - curr_running_cost):\n                max_cnt = cnt\n                max_profit = curr_boarding_cost - curr_running_cost\n        return max_cnt", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        waiting_customers = cur_profit = max_profit = rounds = 0\n        max_profit_round = -1\n        customers.reverse()\n        while waiting_customers > 0 or customers:\n            if customers:\n                waiting_customers += customers.pop()\n            cur_profit += min(waiting_customers, 4) * boardingCost - runningCost\n            waiting_customers -= min(waiting_customers, 4)\n            rounds += 1\n            if max_profit < cur_profit:\n                max_profit = cur_profit\n                max_profit_round = rounds\n        return max_profit_round", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        max_profit = remainder_customers = steps = 0\n        res = []\n        for customer in customers:\n            remainder_customers += customer\n            if remainder_customers > 4:\n                remainder_customers -= 4\n                max_profit += 4* boardingCost - runningCost \n            else:\n                max_profit += remainder_customers* boardingCost - runningCost \n                remainder_customers = 0\n            steps += 1 \n            res.append((max_profit, steps))\n        \n        #print(remainder_customers)\n        while remainder_customers > 0:\n            if remainder_customers > 4:\n                remainder_customers -= 4\n                max_profit += 4* boardingCost - runningCost \n            else:\n                max_profit += remainder_customers* boardingCost - runningCost \n                remainder_customers = 0\n            steps += 1 \n            res.append((max_profit, steps))\n            \n        \n        res.sort(key= lambda x: (-x[0], x[1]))\n        #print(res)\n        return -1 if res[0][0] < 0 else res[0][1]\n                \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        i, queue = 0, 0\n        total_profit, max_profit = 0, -1\n        result = -1\n        while i < len(customers) or queue > 0:\n            queue += 0 if i >= len(customers) else customers[i]\n            board = min(queue, 4)\n            total_profit += board * boardingCost - runningCost\n            if max_profit < total_profit:\n                max_profit = total_profit\n                if max_profit > 0 :\n                    result = i\n            queue -= board\n            i += 1\n        return result if result < 0 else result + 1\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        ans = -runningCost\n        sofar = 0\n        people = 0\n        count = 0\n        idx = 0\n        while idx < len(customers) or people:\n            if idx < len(customers):\n                people += customers[idx]\n            idx += 1\n            earning = -runningCost\n            if people > 4:\n                earning += 4 * boardingCost\n                people -= 4\n            else:\n                earning += people * boardingCost\n                people = 0\n            sofar += earning\n            if sofar > ans:\n                count = idx\n            ans = max(ans, sofar)\n        if ans < 0:\n            return -1\n        return count", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if boardingCost*16 < runningCost:\n            return -1\n        onboard = [0,0,0,0]\n        waiting = 0\n        profits = []\n        for i, grp in enumerate(customers):\n            waiting += grp\n            added = min(4, waiting)\n            onboard[i%4] = added\n            waiting -= added\n            profits.append(onboard[i%4]*boardingCost-runningCost)\n            i_last = i\n        i = i_last+1\n        while waiting:\n            added = min(4, waiting)\n            onboard[i%4] = added\n            waiting -= added\n            profits.append(onboard[i%4]*boardingCost-runningCost)\n            i += 1\n        \n        cum_sum = 0\n        max_p = 0\n        max_i = -1\n        for i, prof in enumerate(profits):\n            cum_sum += prof\n            if cum_sum > max_p:\n                max_p = cum_sum\n                max_i = i+1\n        return max_i\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], board: int, run: int) -> int:\n        if board*4 <= run:\n            return -1\n        \n        cur_prof = 0\n        max_prof = 0\n        waiting = 0\n        res = 0\n        i = 0\n        while waiting > 0 or i < len(customers):\n            c = 0 if i >= len(customers) else customers[i]\n            serv = min(waiting+c, 4)\n            waiting = waiting+c-serv\n            \n            cur_prof += board*serv - run\n            if max_prof < cur_prof:\n                max_prof = cur_prof\n                res = i+1\n            # print(serv, waiting, cur_prof)\n            i += 1\n\n        \n        if max_prof==0:\n            return -1\n        return res", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if 4 * boardingCost <= runningCost:\n            return -1\n        wait = 0\n        n = len(customers)\n        pro = 0\n        max_pro = 0\n        ans = 0\n        i = 0\n        while i < n or wait != 0:\n            c = customers[i] if i < n else 0\n            take = min(wait + c, 4)\n            wait += c - take\n            pro += take * boardingCost - runningCost\n            i += 1\n            if pro > max_pro:\n                max_pro = max(max_pro, pro)\n                ans = i\n        return ans", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        round=0\n        maxProfit=0\n        maxRound=-1\n        waiting=0\n        # wheel=[0]*4\n        # g0=g1=g2=g3=0\n        profit=0\n        i=0\n        for c in customers:\n            i+=1\n            waiting+=c\n            g=min(4,waiting)\n            waiting-=g\n            profit+=g*boardingCost-runningCost\n            if profit>maxProfit:\n                maxProfit=profit\n                maxRound=i\n            if waiting: customers+=[0]\n            # print(i,' profit is ',profit)\n        return maxRound\n            \n", "class Solution:\n    def minOperationsMaxProfit(self, A, BC, RC):\n        ans=profit=t=0\n        maxprofit=0\n        wait=i=0\n        n=len(A)\n        while wait>0 or i<n:\n            if i<n:\n                wait+=A[i]\n                i+=1\n            t+=1\n            y=min(4,wait)\n            if y>0:\n                wait-=y\n                profit+=y*BC\n                profit-=RC\n                if profit>maxprofit:\n                    maxprofit=profit\n                    ans=t\n\n        return -1 if maxprofit<=0 else ans", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if runningCost >= 4 * boardingCost: return -1\n        wait = customers[0]\n        boarded = 0\n        profit = 0\n        res = -1\n        index = 0\n        while wait > 0 or index < len(customers):\n            if index and index < len(customers): wait += customers[index]\n            onboard = min(4, wait)\n            boarded += onboard\n            wait -= onboard\n            if boarded*boardingCost - (index + 1) * runningCost > profit:\n                res = index +1\n                profit = boarded*boardingCost - (index + 1) * runningCost\n            index += 1\n        return res\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        profit, people, res, board = 0, 0, 0, 0\n        minPeople = runningCost // boardingCost\n        if sum(customers) < minPeople:\n            return -1\n        for n in customers:\n            people += n\n            res += 1\n            if people >= 4:\n                people -= 4\n                board += 4\n            else:\n                board += people\n                people = 0\n        count, m = divmod(people, 4)\n        board += count * 4\n        if m > minPeople:\n            count += 1\n            board += m\n        res += count\n        profit += board * boardingCost - res * runningCost\n        return res if profit >= 0 else -1\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if 4 * boardingCost <= runningCost:\n            return -1\n        total = customers[0]\n        n = len(customers)\n        ans = 0\n        cp = 0\n        curVal = False\n        for i in range(1,n):\n            if total > 3:\n                cp += 4 * boardingCost - runningCost\n                total -= 4\n            else:\n                cp += total * boardingCost - runningCost\n                total = 0\n            ans += 1\n            if cp > 0:\n                curVal = True\n            total += customers[i]\n        # print(cp, ans, total)\n        if total > 3:\n            if not curVal:\n                cp += (total//4) * (4 * boardingCost - runningCost)\n                if cp > 0:\n                    curVal = True\n            if curVal:\n                ans += total//4\n                total = total%4\n            else:\n                return -1\n        # print(cp, ans, total)\n        if total > 0 and total * boardingCost > runningCost:\n            if not curVal:\n                cp += (total * boardingCost - runningCost)\n                if cp <= 0:\n                    return -1\n            ans += 1\n        return ans\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        maxx=0\n        rem=0\n        i=0\n        profit=0\n        count=0\n        while True:\n            if i<len(customers):\n                if customers[i]>4:\n                    if i+1 < len(customers):\n                        customers[i+1]=customers[i+1]+(customers[i]-4)\n                        customers[i]=4\n                    else:\n                        customers.append(customers[i]-4)\n                        customers[i]=4\n                        \n                count=count+customers[i]\n                profit = (count*boardingCost) - ((i+1)*runningCost)\n                if profit > maxx:\n                    maxx=profit\n                    rem=i+1\n                \n                i=i+1\n            else:\n                break\n        if rem==0:\n            return -1\n        return rem\n", "from typing import *\n\n\nclass Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        waiting = 0\n        served = 0\n        profits = []\n\n        for i, v in enumerate(customers):\n            waiting += v\n            if waiting < 4:\n                served += v\n            else:\n                served += 4\n\n            profits.append(served * boardingCost - (i + 1) * runningCost)\n            if waiting < 4:\n                waiting = 0\n            else:\n                waiting -= 4\n\n        while waiting != 0:\n            i += 1\n            if waiting < 4:\n                served += waiting\n            else:\n                served += 4\n\n            profits.append(served * boardingCost - (i + 1) * runningCost)\n\n            if waiting < 4:\n                waiting = 0\n            else:\n                waiting -= 4\n\n        # print(profits)\n\n        index = max(list(range(len(profits))), key=lambda i: profits[i])\n        if profits[index] < 0:\n            return -1\n        else:\n            return index + 1\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        curr_ppl_ttl = 0\n        profit = list()\n        waiting = 0\n        line_count = 0\n        runtime = 1\n       \n        while line_count < len(customers) or waiting != 0:\n            if line_count < len(customers):\n                if customers[line_count] + waiting > 4:\n                    curr_ride = 4\n                    waiting = waiting + customers[line_count] - 4\n                else:\n                    curr_ride = waiting + customers[line_count]\n                    waiting = 0\n            else:\n                if waiting > 4:\n                    curr_ride = 4\n                    waiting -= curr_ride\n                else:\n                    curr_ride = waiting\n                    waiting = 0\n            curr_ppl_ttl += curr_ride\n            profit.append(curr_ppl_ttl * boardingCost - runningCost * runtime)\n            line_count += 1\n            runtime += 1\n        \n        if all(i < 0 for i in profit): return -1\n        return profit.index(max(profit)) + 1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        n = len(customers)\n        \n        max_t = -1\n        ans = 0\n        t = 1\n        waiting = 0\n        cur = 0\n        \n        while t <= n or waiting > 0:\n            # print('iter', t)\n            if t <= n: waiting += customers[t-1]\n                \n            cur += (boardingCost * min(4, waiting))\n            waiting -= min(4, waiting)\n            cur -= runningCost\n            \n            if cur > ans:\n                # print('new prof', cur)\n                ans = cur\n                max_t = t\n                \n            t += 1\n            \n        return max_t", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        i = 0\n        g = [4, 4, 4, 4]\n        \n        # there's a subtle difference between what i assumed at first\n        # read: Note that if there are currently more than four customers waiting at the wheel, only four will board the gondola, and the rest will wait for the next rotation.\n        # this means you need to add the remainders to the next customer\n        # also, rotates must happen even if customers = 0\n        \n        profit = 0\n        max_profit = 0\n        customers = customers[::-1]\n        rotates = 0\n        best = -1\n        while customers:\n            g[i] = 4\n            c = customers.pop()\n            if c-g[i] > 0:\n                c -= g[i]\n                profit += g[i]*boardingCost\n                g[i] = 0\n                if customers:\n                    customers[-1] = customers[-1] + c\n                else:\n                    customers = [c]\n            else:\n                g[i] -= c\n                profit += c*boardingCost\n            profit -= runningCost\n            rotates += 1\n            if profit > max_profit:\n                best = rotates\n                max_profit = profit\n            #print(rotates, g, profit)\n            i += 1\n            i %= 4\n        return best", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        nrounds = len(customers)\n        waiting = customers[0]\n        profit = []\n        nturns = 1\n        rev = 0\n        while waiting>0 or nturns<(nrounds+1):\n            boarding = min(waiting,4)\n            rev = rev+boarding*boardingCost\n            waiting = waiting-boarding\n            if nturns<(nrounds):\n                waiting = waiting+customers[nturns]\n            profit.append(rev-runningCost*nturns)\n            nturns = nturns+1\n        maxprof = 0\n        ind = 0\n        for i,p in enumerate(profit):\n            if p>maxprof:\n                maxprof=p\n                ind=i\n        if not maxprof>0:\n            return -1\n        else:\n            return ind+1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        maxAns = -1\n        counter = 1\n        index = 0\n        maxCounter = -1\n        waitingCusts = 0\n        currCusts = 0\n        for cust in customers:\n            waitingCusts+=cust\n            currCusts+=(min(4, waitingCusts))\n            waitingCusts = max(0, waitingCusts-4)\n            if(maxAns<((currCusts*boardingCost) - (counter*runningCost))):\n                maxAns = (currCusts*boardingCost) - (counter*runningCost)\n                maxCounter = counter\n            counter+=1\n            \n        while(waitingCusts>0):\n            currCusts+=(min(4, waitingCusts))\n            waitingCusts=max(0, waitingCusts-4)\n            if(maxAns<((currCusts*boardingCost) - (counter*runningCost))):\n                maxAns = (currCusts*boardingCost) - (counter*runningCost)\n                maxCounter = counter\n            counter+=1\n        \n        return maxCounter", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        max_profit = 0\n        best_turns = -1\n        customers_waiting = 0\n        current_boarded = 0\n        current_rotates = 0\n        current_index = 0\n        while current_index < len(customers) or customers_waiting > 0:\n            # print(current_index, customers_waiting)\n            # board new customers (at most 4)\n            if current_index < len(customers):\n                customers_waiting += customers[current_index]\n\n            new_customers = min(4, customers_waiting)\n            customers_waiting -= new_customers\n\n            current_boarded += new_customers\n            current_rotates += 1\n            current_profit = current_boarded * boardingCost - current_rotates * runningCost\n            # print(current_profit, current_rotates)\n            \n            if current_profit > max_profit:\n                max_profit = current_profit\n                best_turns = current_rotates\n\n            current_index += 1\n        \n        return best_turns\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        bestProfit = -1\n        bestNumRotations = -1\n        \n        currentCustomersWaiting = 0\n        currentProfit = 0\n        numRotations = 1\n        \n        def spin(newCustomers):\n            nonlocal currentCustomersWaiting, currentProfit, numRotations, bestProfit, bestNumRotations\n            \n            currentCustomersWaiting += newCustomers\n            customersBoardingNow = min(4, currentCustomersWaiting)\n            \n            currentProfit += customersBoardingNow * boardingCost - runningCost\n            if currentProfit > bestProfit:\n                bestProfit = currentProfit\n                bestNumRotations = numRotations\n            \n            currentCustomersWaiting -= customersBoardingNow\n            numRotations += 1\n        \n        for currentNewCustomers in customers:\n            spin(currentNewCustomers)\n        \n        while currentCustomersWaiting:\n            spin(0)\n            \n        return bestNumRotations\n", "import math\nclass Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        minRotation = 0\n        MaxProfit = 0\n        waiting = 0\n        profit = 0\n        for i in range(len(customers)):\n            total = waiting + customers[i]\n            if total >= 4:\n                profit += 4*boardingCost - runningCost\n                if profit > MaxProfit:\n                    MaxProfit = profit\n                    minRotation = i+1\n                waiting = total - 4\n            else:\n                profit += total*boardingCost - runningCost\n                if profit > MaxProfit:\n                    MaxProfit = profit\n                    minRotation = i+1\n                waiting = 0\n        print(waiting)\n        if waiting :\n            temp = waiting\n            print(((waiting//4)*4,int(waiting/4)))\n            profit += (waiting//4)*4*boardingCost - runningCost*int(waiting/4)\n            if profit > MaxProfit:\n                MaxProfit = profit\n                minRotation = len(customers) + int(waiting/4)\n            waiting  = waiting % 4\n            profit += waiting*boardingCost - runningCost\n            if profit > MaxProfit:\n                return len(customers) +  math.ceil(temp/4)\n        if minRotation > 0 :\n            return minRotation\n        return -1\n            \n            \n            \n        \n                \n                    \n        \n        \n        \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        best = 0, -1\n        boarded = 0\n        cur = rotations = 0\n        for customer in customers:\n            cur += customer\n            boarded += min(cur, 4)\n            cur -= min(cur, 4)\n            rotations += 1\n            cur_revenue = boarded * boardingCost - rotations * runningCost\n            if best[0] < cur_revenue:\n                best = cur_revenue, rotations\n        while cur > 0:\n            boarded += min(cur, 4)\n            cur -= min(cur, 4)\n            rotations += 1\n            cur_revenue = boarded * boardingCost - rotations * runningCost\n            if best[0] < cur_revenue:\n                best = cur_revenue, rotations\n        return best[1]", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        i = 0\n        g = [4, 4, 4, 4]\n        \n        profit = 0\n        max_profit = 0\n        customers = customers[::-1]\n        rotates = 0\n        best = -1\n        while customers:\n            g[i] = 4\n            c = customers.pop()\n            if c-g[i] > 0:\n                c -= g[i]\n                profit += g[i]*boardingCost\n                g[i] = 0\n                if customers:\n                    customers[-1] = customers[-1] + c\n                else:\n                    customers = [c]\n            else:\n                g[i] -= c\n                profit += c*boardingCost\n            profit -= runningCost\n            rotates += 1\n            if profit > max_profit:\n                best = rotates\n                max_profit = profit\n            #print(rotates, g, profit)\n            i += 1\n            i %= 4\n        return best", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        bestProfit = 0\n        bestRotation = 0\n        waiting = 0\n        income = 0\n        cost = 0\n        rotations = 0\n        for i in range(len(customers)):\n            if income-cost > bestProfit:\n                bestRotation = rotations\n                bestProfit = income-cost\n            waiting += customers[i]\n            newCustomers = min(waiting, 4)\n            waiting -= newCustomers\n            income += newCustomers * boardingCost\n            cost += runningCost\n            rotations += 1\n        while waiting > 0:\n            if income-cost > bestProfit:\n                bestRotation = rotations\n                bestProfit = income-cost\n            newCustomers = min(waiting, 4)\n            waiting -= newCustomers\n            income += newCustomers * boardingCost\n            cost += runningCost\n            rotations += 1\n        if income-cost > bestProfit:\n            bestRotation = rotations\n            bestProfit = income-cost\n        if bestProfit == 0:\n            return -1\n        else:\n            return bestRotation", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if len(customers) == 0:\n            return 0\n        \n        self.res = float('-inf')\n        self.rotation = 0\n        cuswaiting = 0\n        profit = 0\n        rotation = 0\n        attendcus = 0\n        \n        while cuswaiting != 0 or rotation < len(customers):\n            if rotation < len(customers):\n                cuswaiting += customers[rotation]\n            rotation += 1\n            \n            if cuswaiting >= 4:\n                attendcus += 4\n                profit = attendcus*boardingCost - rotation*runningCost\n                cuswaiting -= 4\n            else:\n                attendcus += cuswaiting\n                profit = attendcus*boardingCost - rotation*runningCost\n                cuswaiting = 0\n            \n            #print(profit, rotation)\n            if self.res < profit:\n                self.res = profit\n                self.rotation = rotation\n            \n            \n        if self.res < 0:\n            return -1\n        else:\n            return self.rotation\n        \n        \n", "class Solution:\n    def minOperationsMaxProfit(self, cust: List[int], bc: int, rc: int) -> int:\n        cust.reverse()\n        wait, profit, t, max_p, ans = 0, 0, 0, float('-inf'), 0\n        while cust or wait:\n            if cust:\n                wait += cust.pop()\n            if wait >= 4:\n                profit += 4 * bc\n            else:\n                profit += wait * bc\n            wait = max(0, wait-4)\n            profit -= rc\n            t += 1\n            if profit > max_p:\n                ans = t\n                max_p = profit\n        return ans if max_p>0 else -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        waiting = 0\n        maxProfit = 0\n        ans = 0\n        revenue = 0\n        cost = 0\n        \n        for c in range(len(customers)):\n            waiting+=customers[c]\n            cost+=runningCost\n            \n            toBeBoarded=min(waiting,4)\n            waiting-=toBeBoarded\n            \n            revenue += toBeBoarded*boardingCost \n            profit = revenue-cost\n            \n            if profit>maxProfit:\n                maxProfit, ans = profit, c\n                \n        while(waiting!=0):\n            c+=1\n            cost+=runningCost\n            \n            toBeBoarded=min(waiting,4)\n            waiting-=toBeBoarded\n            \n            revenue += toBeBoarded*boardingCost \n            profit = revenue-cost\n            \n            if profit>maxProfit:\n                maxProfit, ans = profit, c\n                \n        return ans+1 if maxProfit>0 else -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        profit = []\n        lastprofit = 0\n        wait = customers[0]\n        i = 0\n        while i < len(customers) or wait > 0:\n            if wait > 4:\n                wait -= 4\n                board = 4\n            else:\n                board = wait\n                wait = 0\n            profit.append(lastprofit + board * boardingCost - runningCost)\n            lastprofit = profit[-1]\n            i += 1\n            if i < len(customers):\n                wait += customers[i]\n        ans = 0\n        t = -1\n        # print(profit)\n        for i, c in enumerate(profit):\n            if c > ans:\n                ans = c\n                t = i + 1\n        return t\n                \n            \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        num_wait = 0\n        num_rotate = 0\n        num_served = 0\n        max_profit = 0\n        min_rotation = -1\n        \n        for c in customers:\n            num_wait += c\n            num_rotate += 1\n            served = min(num_wait, 4)\n            num_served += served\n            num_wait -= served\n            if (boardingCost*num_served - runningCost*num_rotate) > max_profit:\n                min_rotation = num_rotate\n            max_profit = max(max_profit, boardingCost*num_served - runningCost*num_rotate)\n            \n        while(num_wait > 0):\n            num_rotate += 1\n            served = min(num_wait, 4)\n            num_served += served\n            num_wait -= served\n            if (boardingCost*num_served - runningCost*num_rotate) > max_profit:\n                min_rotation = num_rotate\n            max_profit = max(max_profit, boardingCost*num_served - runningCost*num_rotate)\n            \n            \n        if max_profit > 0:\n            return min_rotation\n        else:\n            return -1\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        profits = []\n        waiting_customers = 0\n        cur_profit = 0\n        \n        for count in customers:\n            waiting_customers += count\n            boarding_customers = min(4, waiting_customers)\n            cur_profit += boardingCost * boarding_customers - runningCost\n            profits.append(cur_profit)\n            waiting_customers -= boarding_customers\n            \n        while waiting_customers > 0:\n            boarding_customers = min(4, waiting_customers)\n            cur_profit += boardingCost * boarding_customers - runningCost\n            profits.append(cur_profit)\n            waiting_customers -= boarding_customers\n\n        index = -1\n        max_profit = 0\n        for i in range(len(profits)):\n            if profits[i] > max_profit:\n                index = i\n                max_profit = profits[i]\n        \n        if index == -1:\n            return -1\n        return index + 1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        profits = []\n        waitings = 0\n        \n        def boarding(waitings, profits):\n            boardings = 0\n            \n            # out\n            if waitings >= 4:\n                boardings = 4\n            else:\n                boardings = waitings\n            \n            # calculate profit\n            lastprofit = 0 if len(profits) == 0 else profits[len(profits) - 1]\n            thisprofit = lastprofit + boardings * boardingCost - runningCost\n            profits.append(thisprofit)\n            \n            return boardings\n            \n        def calculateBestTimes(profits):\n            return profits.index(max(profits))\n        \n        for customer in customers:\n            waitings += customer\n            boardings = boarding(waitings, profits)\n            waitings -= boardings\n            \n        while waitings > 0:\n            boardings = boarding(waitings, profits)\n            waitings -= boardings\n            \n        # print(profits)\n        times = calculateBestTimes(profits)\n        \n        if profits[times] <= 0:\n            times = -1\n        else:\n            times += 1\n        \n        return times", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        n = len(customers)\n        queue = deque(customers)\n        profit = 0\n        k = 0\n        max_profit = 0\n        max_k = 0\n        #print('-------')\n        while queue:\n            num_people = queue.popleft()\n            i = 1\n            if num_people > 4:\n                if queue:\n                    queue[0] += num_people - 4\n                else:\n                    i = num_people // 4\n                    queue.append(num_people - 4 * i)\n                num_people = 4\n            k += i\n            profit += num_people * boardingCost * i\n            profit -= runningCost * i\n            #print(profit)\n            if max_profit < profit:\n                max_k = k\n                max_profit = profit\n        return max_k if max_profit > 0 else -1\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        totalCust = 0\n        # for i in customers:\n        #     totalCust += i\n        # print(\\\"total cust \\\",totalCust)\n        n = len(customers)\n        ct = 0\n        curr =0\n        profit=0\n        res = 0\n        maxx = -999999\n        pt = 0\n        while True:\n            ct += 1\n            #print()\n            if pt < n:\n                totalCust += customers[pt]\n                pt += 1\n            if totalCust < 4:\n                curr += totalCust\n                totalCust = 0\n                profit = curr*boardingCost - ct*runningCost\n                if maxx < profit:\n                    #print(\\\"dfffdfds\\\",res)\n                    maxx = profit\n                    res = ct\n                #print(profit,ct)\n                if pt == n:\n                    break\n                #break\n            else:\n                totalCust -= 4\n                curr += 4\n                profit = curr*boardingCost - ct*runningCost\n                if maxx < profit:\n                    #print(\\\"hhbbajskd\\\")\n                    maxx = profit\n                    res = ct\n        if profit > 0:\n\n            return res\n        else:\n            return -1\n        \n            \n            \n        \n        \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        i = 0\n        n = len(customers)\n        board = 0\n        wait = 0\n        ans = -1\n        max_profit = 0\n        while wait > 0 or i < n:\n            if i < n:\n                wait += customers[i]\n            board += min(4, wait)\n            wait = max(0, wait - 4)\n    \n            tmp_profit = board * boardingCost - (i + 1) * runningCost\n            # print(\\\"{} {} {} {} {}\\\".format(i + 1, board, wait, tmp_profit, max_profit))\n            if tmp_profit > max_profit:\n                max_profit = tmp_profit\n                ans = i + 1\n            \n            i += 1\n    \n        return ans \n            \n            \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        hi = 0\n        if not customers:\n            return 0\n        \n        i = wait = tot = 0\n        n = len(customers)\n        r = 1\n        for i in range(n):\n            if r > i:\n                wait += customers[i]\n            while wait >= 4 or r == i + 1 or i == n - 1:\n                tot += min(wait, 4)\n                wait -= min(wait, 4)\n                profit = tot * boardingCost - r * runningCost\n                if profit > hi:\n                    ans = r\n                    hi = profit\n                r += 1\n                if wait <= 0:\n                    break\n            \n        return ans if hi > 0 else -1\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        earn, max_earn = 0, 0\n        i, n = 0, len(customers)\n        wait, res = 0, -1\n        while i < n or wait > 0:\n            if i < n:\n                wait += customers[i]\n            earn += min(4, wait) * boardingCost - runningCost\n            if earn > max_earn:\n                res = i + 1\n                max_earn = earn\n            wait -= min(4, wait)\n            i += 1\n        return res\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if not customers:\n            return 0\n        rest = 0\n        total = 0\n        profit = -1\n        res = 0\n        i = 0\n        while i < len(customers) or rest:\n            if i < len(customers):\n                rest += customers[i]\n            if rest >= 4:\n                total += 4\n                rest -= 4\n            else:\n                total += rest\n                rest = 0\n            if boardingCost*total - (i+1)*runningCost > profit:\n                res = i + 1\n                profit = boardingCost*total - (i+1)*runningCost\n            i += 1\n        return res if profit > 0 else -1\n            \n                \n        \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        ans = 0\n        waitingC = 0\n        curVal = 0\n        maxVal = 0\n        maxIndex = -1\n        index = 0\n        while index < len(customers) or waitingC > 0:\n            c = customers[index] if index < len(customers) else 0\n            waitingC += c\n            curB = min(waitingC, 4)\n            waitingC -= curB\n            curVal += curB * boardingCost - runningCost\n            ans += 1\n            index += 1\n            if curVal > maxVal:\n                maxVal = curVal\n                maxIndex = index\n        return maxIndex", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        i=0\n        w=0\n        c=0\n        ans = 0\n        fans = -1\n        while(i<len(customers) or w):\n            if i<len(customers):\n                w+=customers[i]\n            n = min(4,w)\n            w-=n\n            c+=n\n            i+=1\n            if ans < c*boardingCost - i*runningCost:\n                ans = c*boardingCost - i*runningCost\n                fans = i\n        return fans", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if len(customers)==0:\n            return -1\n        wait = 0\n        onboard = 0\n        r=0\n        max_prof, max_r, cost = float('-inf'),0,0\n        while customers[r] == 0:\n            r+=1\n            \n        if customers:\n            wait+=customers[r]\n            while wait >0:\n                c = min(wait, 4)\n                wait = max(0, wait-4)\n                onboard+=c\n                r+=1\n                cost = onboard*boardingCost - r*runningCost\n                if cost >max_prof:\n                    max_r = r\n                    max_prof = cost\n                if r<len(customers):\n                    wait+=customers[r]\n                # if wait <10:\n                #     print(cost, r, wait, onboard)\n\n        if max_prof <=0:\n            return -1\n        return max_r\n            \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        # max profit, rotating count\n        max_tuple = (0, -1)\n        \n        profit = 0\n        awaiting = 0\n        turn = 0\n        while awaiting > 0 or turn == 0 or turn < len(customers):\n            if turn < len(customers):\n                awaiting += customers[turn]\n            count_pay = min(4, awaiting)\n            awaiting -= count_pay\n            \n            profit += count_pay * boardingCost - runningCost\n            #print(profit)\n            if profit > max_tuple[0]:\n                max_tuple = (profit, turn + 1)\n                \n            turn += 1\n        \n        return max_tuple[1]", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        rotations, profit = 0, 0\n        ret, max_profit = 0, 0\n        waiting = 0\n        \n        for c in customers:\n            waiting += c\n            profit += min(4, waiting) * boardingCost - runningCost\n            waiting -= min(4, waiting)\n            rotations += 1\n            if profit > max_profit:\n                max_profit = profit\n                ret = rotations\n        if waiting:\n            profit += waiting//4 * (4 * boardingCost - runningCost)\n            rotations += waiting//4\n            if profit > max_profit:\n                max_profit = profit\n                ret = rotations\n            waiting %= 4\n        \n        if waiting:\n            profit += waiting * boardingCost - runningCost\n            rotations += 1\n            if profit > max_profit:\n                max_profit = profit\n                ret = rotations\n        \n        return ret if max_profit > 0 else -1\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        max_profit = [-1, -1]\n        def board_customers(customers, rotations): \n            current_profit = customers * boardingCost - rotations * runningCost \n            \n            if current_profit > max_profit[0]: \n                max_profit[0] = current_profit\n                if current_profit > -1: \n                    max_profit[1] = rotations\n        \n        r = 1 \n        waiting = 0 \n        total_customers = 0 \n        \n        for i in range(len(customers)-1):\n            if customers[i] > 4: \n                customers[i+1] += customers[i] - 4 \n                customers[i] = 4 \n            \n            total_customers += customers[i]\n            board_customers(total_customers, r)\n            r += 1 \n        \n        waiting = customers[-1]\n        while waiting: \n            added = min(waiting, 4)\n            total_customers += added \n            board_customers(total_customers, r)\n            waiting -= added\n            r += 1 \n        \n        return max_profit[1]\n", "from collections import deque\nclass Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        waiting = deque([])\n        customers = deque(customers)\n        waiting.append(customers.popleft())\n        time = 1\n        maxx = 0\n        cost = 0\n        ans = 0\n        found = False\n        total = 0\n        while waiting or customers:\n            curr = waiting.popleft()\n            if curr>4:\n                curr-=4\n                total+=4\n                waiting.appendleft(curr)\n                cost = total*boardingCost-(time*runningCost)\n            else:\n                temp = curr\n                while waiting and temp+waiting[0]<=4:\n                    temp+=waiting.popleft()\n                if temp<4:\n                    if waiting:\n                        extra = 4-temp\n                        waiting[0]-=extra\n                        temp=4\n                total+=temp\n                cost = total*boardingCost-(time*runningCost)\n            if cost>maxx:\n                maxx = cost\n                found = True\n                ans = time\n            time+=1\n            # print(cost,waiting,customers)\n            if customers:\n                waiting.append(customers.popleft())\n        return ans if found else -1\n        \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        earn = 0\n        max_earn = 0\n        men = 0\n        cnt = 0\n        res = -1\n        for c in customers:\n            cnt += 1\n            men += c\n            earn += min(men, 4) * boardingCost\n            earn -= runningCost\n            if earn > max_earn:\n                max_earn = earn\n                res = cnt\n            men -= min(men, 4)\n            #print(men, earn)\n        while men > 0:\n            cnt += 1\n            earn += min(men, 4) * boardingCost\n            earn -= runningCost\n            if earn > max_earn:\n                max_earn = earn\n                res = cnt\n            men -= min(men, 4)\n            #print(men, earn)\n        return res", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        cost = 0\n        waiting = 0\n        rotations = 0\n        profits = []\n        for i in range(len(customers)):\n            waiting += customers[i]\n            board = min(waiting, 4)\n            waiting -= board\n            cost += board*boardingCost\n            cost -= runningCost\n            rotations += 1\n            profits.append((rotations,cost))\n        while waiting > 0:\n            board = min(waiting, 4)\n            waiting -= board\n            rotations += 1\n            cost += boardingCost*board\n            cost -= runningCost\n            profits.append((rotations,cost))\n        #print(profits)\n        r = None\n        ans = 0\n        for p in profits:\n            if p[1] > ans:\n                ans = p[1]\n                r = p[0]\n        return r if ans > 0 else -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        profit = []\n        total_customer = 0\n        cur_profit = 0\n        for i, n in enumerate(customers):\n            total_customer += n\n            cur_profit += min(total_customer, 4) * boardingCost - runningCost\n            total_customer -= min(total_customer, 4)\n            profit.append(cur_profit)\n        import numpy as np\n        \n        while total_customer > 0:\n            cur_profit += min(total_customer, 4) * boardingCost - runningCost\n            total_customer -= min(total_customer, 4)\n            profit.append(cur_profit)\n        # print(profit)\n        return np.argmax(profit)+1 if max(profit) > 0 else -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        n = len(customers)\n        i = 0\n        waiting = 0\n        board = 0\n        rot = 0\n        res = 0\n        ind = -1\n        \n        while waiting > 0 or i < n:\n            if i < n:\n                waiting += customers[i]\n            rot += 1\n            board += min(4, waiting)\n            waiting -= min(4, waiting)\n            prof = board * boardingCost - rot * runningCost\n            if (prof > res):\n                res = prof\n                ind = i + 1\n            i += 1\n        \n        return ind", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        minOp = currCustomers = profit = maxProfit = i = totalCustomers = 0\n        \n        while customers[-1] == 0:\n            customers.pop()\n        \n        for c in customers:\n            i += 1\n            currCustomers += c\n            totalCustomers += min(4, currCustomers)\n            profit = (boardingCost * totalCustomers - (i+1) * runningCost)\n            currCustomers -= min(4, currCustomers)\n            if profit > maxProfit:\n                maxProfit = profit\n                minOp = i\n            # print(profit, i, boardingCost, totalCustomers)\n        \n        # print(currCustomers, i, profit)\n        while currCustomers:\n            i += 1\n            totalCustomers += min(4, currCustomers)\n            profit = (boardingCost * totalCustomers - (i+1) * runningCost)\n            currCustomers -= min(4, currCustomers)\n            if profit > maxProfit:\n                maxProfit = profit\n                minOp = i\n            # profit += (boardingCost * currCustomers - (math.factorial(int(ceil(currCustomers/4)))-math.factorial(i)) * runningCost)\n            # i += ceil(currCustomers/4)\n            \n        return minOp if maxProfit > 0 else -1\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        profits = [0]\n        waiting = 0\n        wheel = deque([0] * 4)\n        onBoard = 0\n        \n        for i in range(len(customers)):\n            waiting += customers[i]\n            new = min(4, waiting)\n            waiting -= new\n            leaving = wheel.pop()\n            onBoard += new - leaving\n            wheel.appendleft(new)\n            profits.append(profits[-1] + new*boardingCost - runningCost)\n        \n        while waiting:\n            new = min(4, waiting)\n            waiting -= new\n            leaving = wheel.pop()\n            onBoard += new - leaving\n            wheel.appendleft(new)\n            profits.append(profits[-1] + new*boardingCost - runningCost)\n            \n        maximum = 0\n        index = -1\n        for i, val in enumerate(profits):\n            if val > maximum:\n                maximum = val\n                index = i\n                \n        return index\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if boardingCost * 4 <= runningCost:  return -1\n        max_profit, cur_profit, waiting, i = 0, 0, 0, 0\n        res = 0\n        while i < len(customers) or waiting > 0:\n            if i < len(customers):\n                waiting += customers[i]\n            i += 1\n            boarded = min(waiting, 4)\n            cur_profit += boarded * boardingCost - runningCost\n            #print(waiting, boarded, cur_profit, max_profit)\n            if cur_profit > max_profit:\n                res = i\n                max_profit = cur_profit\n            waiting -= boarded\n        return res\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        profit = 0\n        wait = 0\n        rotated = 0\n        res = -1\n        total = 0\n        for num in customers:\n            cur_num = min(4, num + wait)\n            total += cur_num\n            wait = (num + wait - cur_num)\n            rotated += 1\n            cur_profit = boardingCost * total - rotated * runningCost\n            if cur_profit > profit:\n                res = rotated\n                profit = cur_profit\n        while wait:\n            cur = min(4, wait)\n            total += cur\n            rotated += 1\n            cur_profit = boardingCost * total - rotated * runningCost\n            if cur_profit > profit:\n                res = rotated\n                profit = cur_profit\n            wait -= cur\n        return res", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        profit = 0\n        waiting = 0\n        rotations = 0\n        onboard = 0\n        gondola_customers = deque([])\n        total = 0\n        maxprofit = 0\n        max_rotation = -1\n        for arrival in customers:\n            if gondola_customers:\n                coming_down = gondola_customers.popleft()\n                onboard -= coming_down\n            \n            total = arrival   \n            if waiting >0:\n                total = waiting + arrival\n            \n            #if onboard == 0 and total == 0:\n            #    continue\n                \n            if total <= 4:\n                profit += ((total*boardingCost) - runningCost)\n                onboard += total\n                gondola_customers.append(total)\n                waiting = max(0,waiting-total)\n            else:\n                profit += ((4*boardingCost) - runningCost)\n                onboard += 4\n                gondola_customers.append(4)\n                waiting += (arrival-4)\n            \n            rotations += 1\n            if profit > maxprofit:\n                maxprofit = profit\n                max_rotation = rotations\n        print((maxprofit, max_rotation, waiting))\n        profit += ((waiting//4)*((4*boardingCost)-runningCost))\n        rotations += (waiting//4)\n        if profit > maxprofit:\n                maxprofit = profit\n                max_rotation = rotations\n        print((maxprofit, max_rotation, waiting%4))\n        \n        profit += (((waiting%4)*boardingCost)-runningCost)\n        rotations += ((waiting%4)>0)\n        if profit > maxprofit:\n                maxprofit = profit\n                max_rotation = rotations\n        print((maxprofit, max_rotation))\n        \n        return max_rotation if maxprofit > 0 else -1\n                \n        \n", "import math\nclass Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        profit,bestIteration,customerCount,iteration,boarding = 0,0,0,0,0\n        for i in range(len(customers)):\n            customerCount = customerCount + customers[i]\n            iteration = iteration + 1\n            boarding = boarding + min(customerCount,4)\n            customerCount = customerCount - min(customerCount,4)\n            if boarding*boardingCost - iteration*runningCost > profit:\n                profit = boarding*boardingCost - iteration*runningCost\n                bestIteration = iteration\n        while customerCount > 0:\n            iteration = iteration + 1\n            boarding = boarding + min(customerCount,4)\n            customerCount = customerCount - min(customerCount,4)\n            if boarding*boardingCost - iteration*runningCost > profit:\n                profit = boarding*boardingCost - iteration*runningCost\n                bestIteration = iteration\n        if profit == 0:\n            return -1\n        return bestIteration\n        \n        \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        max_profit, min_rotations = 0, -1\n        curr_profit = 0\n        waiting, rotations = 0, 0\n        \n        customers.reverse()\n        while curr_profit >= 0:\n            if customers: waiting += customers.pop()\n            if waiting == 0:\n                if not customers: break\n            else:\n                curr_profit += min(4, waiting) * boardingCost - runningCost\n                waiting -= min(4, waiting)\n            rotations += 1\n            if curr_profit > max_profit:\n                max_profit, min_rotations = curr_profit, rotations\n\n        return min_rotations\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        sm = 0\n        cus = 0\n        c = 0\n        w = 0\n        ret = 0\n        mx = 0\n        while True:\n            if c < len(customers):\n                cus += customers[c]\n                c += 1\n            board = min(4, cus)\n            cus -= board\n            sm += (boardingCost * board) - runningCost\n            w += 1\n            if mx < sm:\n                ret = w\n                mx = sm\n            if 0 == min(4, cus) and c == len(customers):\n                break\n        return -1 if mx == 0 else ret", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        # we have the boardingCost and the runningCost\n        #at each index we need to wipe it out before we move to the next\n        #we can board max 4 at a time\n        arr = [-1];\n        \n#         for i in range(len(customers)):\n#             if customers[i] == 0:\n#                 print('6')\n#             else:\n#                 divided = customers[i]//4;\n#                 if customers[i] % 4 != 0:\n#                     divided += 1;\n                \n#                 bammer = customers[i] * boardingCost - (divided * runningCost);\n#                 arr.append(bammer);\n        \n#         print(max(arr));\n        \n        currentCost = 0;\n        maximum = -1000000000;\n        rotations = 0;\n        total = 0;\n        \n        while (total != 0 or rotations < len(customers)):\n            if (rotations < len(customers)):\n                total += customers[rotations];\n            if total < 4:\n                temp = total;\n                total = 0;\n                currentCost += (temp * boardingCost) - runningCost;\n                arr.append(currentCost);\n                if (currentCost > maximum):\n                    maximum = currentCost;\n            else:\n                total -= 4;\n                currentCost += (4 * boardingCost) - runningCost;\n                arr.append(currentCost);\n                \n            rotations += 1;\n        \n        maxer = -1000000000;\n        indexer = -1;\n            \n        for i in range(len(arr)):\n            if (maxer < arr[i]):\n                maxer = arr[i];\n                indexer = i;\n        \n        if indexer == 0:\n            return -1;\n        return indexer;\n        # print(arr);\n        # return max(arr);\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        best_profit = float('-inf')\n        best_rotations = -1\n        rem = 0\n        group = []\n        for c in customers:\n            avail = rem + c\n            group.append(min(4, avail))\n            rem = max(0, avail - 4)\n        \n        while rem:\n            group.append(min(4, rem))\n            rem = max(0, rem - 4)\n        profit = cost = 0\n        for i, g in enumerate(group):\n            profit += g * boardingCost\n            cost += runningCost\n            if best_profit < profit - cost:\n                best_profit = profit - cost\n                best_rotations = i + 1\n        \n        return best_rotations if best_profit > 0 else -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        # no trick, iterate and board all if possible get profit\n        iteration = 0\n        max_profit = 0\n        profit = 0\n        wait = 0\n        for i, c in enumerate(customers):\n            wait += c\n            board = min(4, wait)\n            wait -= board\n            if i == len(customers)-1 and wait > 0:\n                customers += [wait]\n                wait = 0\n            profit += boardingCost * board - runningCost\n            if profit > max_profit:\n                max_profit = profit\n                iteration = i\n                \n        return iteration + 1 if max_profit > 0 else -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        people = 0\n        on = 0\n        i = 0\n        money = 0\n        ans = -1\n        j = 0\n        for c in customers:\n            people += c\n            i += 1\n            x = min(people, 4)\n            on += x\n            people -= x\n            money = on * boardingCost - runningCost * i\n            if money > ans:\n                j = i\n                ans = money\n        \n        while people:\n            i += 1\n            x = min(people, 4)\n            on += x\n            people -= x\n            money = on * boardingCost - runningCost * i\n            if money > ans:\n                j = i\n                ans = money\n        \n        return j if ans > 0 else -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if not customers: return 0\n        if 4 * boardingCost <= runningCost:\n            return -1\n        \n        inline = 0\n        profit = 0\n        maxProfit = 0\n        rotate = 0\n        recordRotate = 0\n        idx = 0\n        \n        while idx < len(customers) or inline > 0:\n            if idx < len(customers):\n                inline += customers[idx]\n            if inline > 4:\n                profit = profit + 4 * boardingCost - runningCost\n                inline = inline - 4\n                rotate += 1\n            elif (inline <= 4 ):\n                \n                profit = profit + inline * boardingCost - runningCost\n                inline = 0\n                rotate += 1\n            \n            if profit > maxProfit:\n                maxProfit = profit\n                recordRotate = rotate\n            idx = idx + 1\n\n        return recordRotate\n            \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        max_profit = 0\n        max_spin = -1\n        \n        cur_profit = 0\n        cur_num = 0\n        \n        spins = 0\n        \n        for i in range(len(customers)):\n            spins += 1\n            cur_profit -= runningCost\n            \n            cur_num += customers[i]\n            cur_profit += min(cur_num, 4) * boardingCost\n\n            if cur_profit > max_profit:\n                max_profit = max(max_profit, cur_profit)\n                max_spin = spins\n                \n            cur_num = max(0, cur_num - 4)\n            \n        while cur_num > 0:\n            spins += 1\n            cur_profit -= runningCost\n            cur_profit += min(4, cur_num) * boardingCost\n            \n            if cur_profit > max_profit:\n                max_profit = max(max_profit, cur_profit)\n                max_spin = spins\n                \n            cur_num -= min(4, cur_num)\n            \n        return max_spin", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if 4 * boardingCost <= runningCost:\n            return -1\n        curr_customers = 0\n        curr_profit = 0\n        max_profit = 0\n        min_rotations = 0\n        for i, cus in enumerate(customers):\n            curr_customers += cus\n            if curr_customers > 4:\n                curr_profit += 4 * boardingCost - runningCost\n                curr_customers -= 4\n            else:\n                curr_profit += curr_customers * boardingCost - runningCost\n                curr_customers = 0\n            if max_profit < curr_profit:\n                max_profit = curr_profit\n                min_rotations = i + 1\n        left_rounds, remainder = divmod(curr_customers, 4)\n        \n        max_profit1 = max_profit\n        max_profit2 = curr_profit + 4 * left_rounds * boardingCost - left_rounds * runningCost\n        max_profit3 = curr_profit + curr_customers * boardingCost - (left_rounds + 1) * runningCost\n        \n        MAX = max(max_profit1, max_profit2, max_profit3)\n        if MAX == max_profit1:\n            min_rotations = min_rotations\n        elif MAX == max_profit2:\n            min_rotations = len(customers) + left_rounds\n        else:\n            min_rotations = len(customers) + left_rounds + 1\n        \n        return min_rotations if max_profit > 0 else -1\n            \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        if boardingCost * 4 < runningCost:\n            return -1\n        \n        profit = 0\n        num_waiting_customers = 0\n        max_profit = 0\n        ans = -1\n        \n        i = 0\n        \n        while i < len(customers) or num_waiting_customers > 0:\n            num_waiting_customers += customers[i] if i < len(customers) else 0\n            \n            profit += min(num_waiting_customers, 4) * boardingCost - runningCost\n            \n            if profit > max_profit:\n                ans = i + 1\n                max_profit = profit\n            \n            num_waiting_customers = max(num_waiting_customers - 4, 0)\n            i += 1\n        return ans\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        total_queue = 0\n        idx = 0\n        curr_costs = 0\n        max_costs = float('-inf')\n        max_idx = 0\n        \n        while total_queue or idx < len(customers):\n            curr_customers = 0\n            if idx < len(customers):\n                curr_customers = min(4, customers[idx])\n                total_queue += max(0, customers[idx] - 4)\n            \n            if curr_customers < 4 and total_queue:\n                diff = 4 - curr_customers\n                curr_customers += min(diff, total_queue)\n                total_queue = max(0, total_queue - diff)\n                \n            \n            idx += 1\n            \n            curr_costs += boardingCost * curr_customers - runningCost\n            if curr_costs > max_costs:\n                max_idx = idx\n                max_costs = curr_costs\n            \n        return max_idx if max_costs > 0 else -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        waiting = 0\n        total_money = 0\n        cars = [0,0,0,0]\n        index = 0\n        max_rotations = -1\n        num_rotations = 0\n        max_money = 0\n        while index < len(customers):\n            waiting += customers[index]\n            if waiting < 4:\n                cars[0] = waiting\n                total_money += waiting*boardingCost\n                waiting = 0\n                \n            else:\n                waiting -= 4\n                total_money += 4*boardingCost\n                cars[0] = 4\n            self.rotation(cars)\n            total_money -= runningCost\n            index += 1\n            num_rotations += 1\n            if total_money >  max_money:\n                max_rotations = num_rotations\n                max_money = total_money\n        while waiting != 0:\n            if waiting < 4:\n                cars[0] = waiting\n                total_money += waiting*boardingCost\n                waiting = 0\n            else:\n                waiting -= 4\n                total_money += 4*boardingCost\n                cars[0] = 4\n            self.rotation(cars)\n            total_money -= runningCost\n            num_rotations += 1\n            if total_money >  max_money:\n                max_rotations = num_rotations\n                max_money = total_money\n        \n        if max_money == 0:\n            return -1\n        return max_rotations\n        \n        \n        \n        \n    def rotation(self, arr):\n        arr[3], arr[2], arr[1], arr[0] = arr[2], arr[1], arr[0], 0\n        \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        lines = []\n        carry = 0\n        cur = 0\n        \n        for c in customers:\n            cur = 4 if c + carry >= 4 else c + carry\n            carry = c + carry - 4 if c + carry > 4 else 0\n            lines.append(cur)\n            \n        while carry:\n            c = 4 if carry >= 4 else carry\n            lines.append(c)\n            carry = carry - 4 if carry > 4 else 0\n        \n        res = 0\n        total = 0\n        rotate = 0\n        \n        for i, c in enumerate(lines):\n            total += c  \n            if total * boardingCost - (i+1) * runningCost > res:\n                \n                res = total * boardingCost - (i+1) * runningCost\n                rotate = i + 1\n        \n        print(res)\n        return rotate if res > 0 else -1\n        \n        \n                \n", "class Solution:\n    def minOperationsMaxProfit(self, customers, boardingCost, runningCost):\n        # we can never make profit\n        if 4*boardingCost <= runningCost:\n            return -1\n        total = sum(customers)\n        maxProfit = -1\n        maxRotate = 0\n        accuProfit = 0\n        rotate = 0\n        \n        # keep rotate and board the customers.\n        i = 0\n        prev = 0\n        while i < len(customers):\n            # print('i ', i, \\\"num \\\", customers[i], \\\"total \\\", total)\n            prev = accuProfit\n            if customers[i] <= 4:\n                accuProfit += customers[i] * boardingCost\n                customers[i] = 0\n                total -= customers[i]\n            else:\n                accuProfit += 4 * boardingCost\n                customers[i] -= 4\n                total -= 4\n            rotate += 1\n            # every time we rotate, we need pay runningCost\n            accuProfit -= runningCost\n            if maxProfit < accuProfit:\n                maxProfit = accuProfit\n                maxRotate = rotate\n            # print(\\\"accu \\\", accuProfit, \\\"rotate \\\", rotate, \\\"customer \\\", customers[i], \\\"profit \\\", accuProfit- prev,)\n            # print(customers)\n            # print(\\\"###\\\")\n            # if current customer < 4, put them in the same group of the following customer \n            # to make sure everything we full loaded.\n            if i + 1 < len(customers):\n                customers[i+1] += customers[i]\n                customers[i] = 0\n                \n            # the following customer need to wait the customer in front.\n            if customers[i] == 0:\n                i += 1\n            \n        return -1 if maxProfit < 0 else maxRotate\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        n, cur, i = len(customers), 0, 0\n        maxProfit, maxProfitIdx, curProfit = 0, -1, 0\n        while i < n or cur > 0:\n            cur += customers[i] if i < n else 0            \n            i += 1\n            \n            board = min(cur, 4)\n            cur -= board\n            \n            curProfit += board * boardingCost - runningCost\n            if curProfit > maxProfit:\n                maxProfit, maxProfitIdx = curProfit, i     \n        \n        return maxProfitIdx if maxProfit > 0 else -1 ", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        res = 0 \n        max_profit = 0\n        wait_people = 0\n        taken_people = 0\n        rotation_times = 0\n        \n        for customer in customers:\n            rotation_times += 1 \n            can_take = min(4, wait_people+customer)\n            taken_people += can_take \n            cur_profit = taken_people*boardingCost - rotation_times*runningCost\n            if cur_profit > max_profit:\n                res = rotation_times \n                max_profit = cur_profit\n                \n            wait_people = max(0, wait_people+customer-4)\n            \n        while wait_people > 0:\n            rotation_times += 1 \n            can_take = min(4, wait_people)\n            taken_people += can_take \n            cur_profit = taken_people*boardingCost - rotation_times*runningCost\n           \n            if cur_profit > max_profit:\n                res = rotation_times \n                max_profit = cur_profit\n                \n            wait_people -= can_take\n            \n        return res if res > 0 else -1 \n", "import math\nclass Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        best = 0\n        index = None\n        i = 0\n        n = 0\n        p = 0\n        while n > 0 or i < len(customers):\n            if i < len(customers):\n                n += customers[i]\n            p += min(4, n) * boardingCost\n            p -= runningCost\n            n -= min(4, n)\n            i += 1\n            if p > best:\n                best = p\n                index = i\n        \n        if index is None:\n            return -1\n        return index", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], bCost: int, rCost: int) -> int:\n        maxProfit = -1\n        unboard = 1\n        board = 0\n        flag = True\n        count = 0\n        profit = 0\n        ans = 0\n        \n        while unboard > 0 or count < len(customers):\n            if flag: \n                unboard = 0\n                flag = False\n            \n            \n            unboard += (customers[count] if count < len(customers) else 0)\n            count += 1\n            \n            if unboard > 4: \n                board += 4\n                unboard -= 4\n                profit = board*bCost - rCost*count\n            else: \n                board += unboard\n                unboard = 0\n                profit = board*bCost - rCost*count\n                \n            ans = count if profit > maxProfit else ans \n            \n            maxProfit = profit if profit > maxProfit else maxProfit   \n\n                 \n        return ans if maxProfit > 0 else -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        maxi = 0\n        maxRotate = -1\n        profit = 0\n        onBoarded = 0\n        inQueue = 0\n        rotates = 0\n        for c in customers:\n            rotates += 1\n            onBoarded = max(0, onBoarded - 1)\n            inQueue += c\n            board = min(4, inQueue)\n            inQueue -= board\n            profit += board * boardingCost - runningCost\n            if profit > maxi:\n                maxi = profit\n                maxRotate = rotates\n        \n        while inQueue > 0:\n            rotates += 1\n            onBoarded = max(0, onBoarded - 1)\n            board = min(4, inQueue)\n            inQueue -= board\n            profit += board * boardingCost - runningCost\n            if profit > maxi:\n                maxi = profit\n                maxRotate = rotates\n        \n        return maxRotate\n                \n", "class Solution:\n    def minOperationsMaxProfit(self, cust: List[int], b: int, r: int) -> int:\n        arr=[1*b-r,2*b-r,3*b-r,4*b-r]\n        pos=0\n        ln=len(cust)\n        #print(arr)\n        for i in range(4): \n            if arr[i]>0: pos=i+1 \n        if pos==0: return -1\n        prev=0\n        for i in range(ln): \n            x=min(4,prev+cust[i])\n            prev= prev+cust[i]-x\n            cust[i]=x\n        #print(cust)\n        cum=0\n        for i in range(ln):\n            cum+=cust[i]\n            cust[i]=cum*b-(i+1)*r\n        a,b2=prev//4,prev%4\n        #print(cust)\n        x=max(cust)\n        y=(cum+(a*4))*b-(ln+a)*r\n        #print(prev,a,b2,x,y,cum,ln,(ln+a))\n        z=y\n        if b2: \n            z=(cum+prev)*b-(ln+a+1)*r\n            if z>y: \n                a+=1\n        if z>x:\n            if z<1: return -1\n            return ln+a\n        if x<1: return -1\n        return cust.index(x)+1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], bc: int, rc: int) -> int:\n        rnd = waiting = 0\n        ans = -1\n        profit = -1\n        curp = 0\n        \n        n = sum(customers)\n        debug = 0\n        if debug:\n            print(f'lenght is {len(customers)}, total cust is {n} where n % 4 = {n%4}, boardingTicket is {bc}, run cost is {rc}')\n        \n        i = 0\n        while i < len(customers) or waiting > 0:\n            cust = 0 if i >= len(customers) else customers[i]\n            waiting += cust\n            board = min(4, waiting)\n            waiting -= board\n            curp = curp + board * bc - rc\n            rnd += 1\n            if i < len(customers):\n                i += 1\n            if debug:\n                print(f'i is {i}, new comer is {cust} and total waiting is {waiting}, '\n                      f'board {board} people, curp is {curp}, rnd = {rnd}')            \n        #for i, cust in enumerate(customers):\n            # if waiting <= 4:\n            #     curp = curp + waiting * bc - rc\n            #     if debug:\n            #         print(f'i is {i}, new comer is {cust} and total waiting is {waiting}, '\n            #               f'board {waiting} people, curp is {curp}, rnd = {rnd + 1}')\n            #     waiting = 0\n            #     rnd += 1\n            # else:\n            #     board = waiting - waiting % 4\n            #     boardrnd = board // 4\n            #     curp = curp + board * bc - boardrnd * rc  # t * (4*bc - rc)\n            #     if debug:\n            #         print(f'i is {i}, new comer is {cust} and total waiting is {waiting}, '\n            #               f'board {board} people, curp is {curp}, rnd = {rnd + boardrnd}')\n            #     waiting %= 4\n            #     rnd += boardrnd\n            \n            if curp > profit:\n                profit = curp\n                ans = rnd\n                \n        if waiting > 0:\n            curp = curp + waiting * bc - rc\n            rnd += 1\n            if debug:\n                print(f'i is n, new comer is 0 and total waiting is {waiting}, board {waiting} people, curp is {curp}, rnd = {rnd}')\n            if curp > profit:\n                profit = curp\n                ans = rnd\n        return ans\n    \n    \n\n# [17,0,45,39,19,4,9,3,16]\n# 11\n# 33\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        max_profit = 0\n        best_rots = -1\n        rots = 0\n        waiting = 0\n        boarded = 0\n        c = 0\n        while waiting > 0 or c<len(customers):\n            if c<len(customers):\n                waiting += customers[c]\n            if waiting > 4:\n                boarded += 4\n                waiting -= 4\n            else:\n                boarded += waiting\n                waiting = 0\n            rots += 1\n            profit = boarded*boardingCost - rots*runningCost\n            if profit > max_profit:\n                max_profit = profit\n                best_rots = rots\n            c += 1\n        return best_rots", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        waitingCustomers = customers[0]\n        totalCustomers = 0\n        i = 1\n        result = -1\n        maxProfit = 0\n        \n        while i < len(customers) or waitingCustomers > 0:\n            servedCustomers = min(4, waitingCustomers)\n            \n            waitingCustomers -= servedCustomers\n            totalCustomers += servedCustomers\n            \n            profit = totalCustomers * boardingCost - i * runningCost\n            if profit > maxProfit:\n                maxProfit = profit\n                result = i\n            \n            if i < len(customers):\n                waitingCustomers += customers[i]\n            \n            i += 1\n        \n        return result\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        left = 0\n        required = 0\n        for cus in customers:\n            required += 1\n            left += cus\n            left -= min(left, 4)\n        maxRot = required + ceil(left / 4)\n        mP, mR = 0, -1\n        rotCnt = 0\n        c = 0\n        profit = 0\n        maxP = 0\n        while rotCnt < maxRot:\n            if rotCnt < len(customers):\n                c += customers[rotCnt]\n            roundP = min(c , 4) * boardingCost\n            c -= min(c, 4)\n            roundP -= runningCost\n            profit += roundP\n            if profit > mP:\n                mR = rotCnt + 1\n                mP = profit\n            rotCnt += 1\n        return mR\n            \n            \n            \n", "def getindex(arr):\n    value = max(arr)\n    cnt = 1\n    for e in arr:\n        if e == value:\n            return cnt\n        cnt += 1\n\nclass Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        boarding = 0 \n        rotation = 0\n        profit = []\n        n_customers = len(customers)\n        for i in range(n_customers-1):\n            if customers[i]<4:\n                boarding += customers[i]\n                rotation += 1\n                profit.append(boarding * boardingCost - rotation*runningCost)\n            else:\n                boarding += 4\n                customers[i+1] = customers[i] + customers[i+1] -4\n                rotation += 1\n                profit.append(boarding * boardingCost - rotation*runningCost)\n        while customers[n_customers-1]>3:\n            boarding += 4\n            rotation += 1\n            profit.append(boarding * boardingCost - rotation*runningCost)\n            customers[n_customers-1] -= 4\n        if customers[n_customers-1] == 0:\n            pass\n        else:\n            boarding += customers[n_customers-1]\n            rotation += 1\n            profit.append(boarding * boardingCost - rotation*runningCost)\n        if max(profit)<0:\n            return -1\n        else:\n            return getindex(profit)\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        max_pro = -1\n        shift = 0\n        total_onboarded = 0\n        wait = 0\n        re = -1\n        for c in customers:\n            wait+=c\n            if wait > 0:\n                shift+=1\n                \n                if wait>4:\n                    total_onboarded+=4\n                else:\n                    total_onboarded+=wait\n                    \n                cur_pro = total_onboarded*boardingCost - shift*runningCost\n                if cur_pro > max_pro:\n                    re = shift\n                max_pro = max(max_pro, cur_pro)\n                if wait>4:\n                    wait-=4\n                else:\n                    wait=0\n            elif wait == 0:\n                shift+=1\n                cur_pro = total_onboarded*boardingCost - shift*runningCost\n                continue\n                \n        # no more new customers\n        while wait > 0:\n            shift+=1\n\n            if wait>4:\n                total_onboarded+=4\n            else:\n                total_onboarded+=wait\n\n            cur_pro = total_onboarded*boardingCost - shift*runningCost\n            if cur_pro > max_pro:\n                re = shift\n            max_pro = max(max_pro, cur_pro)\n            if wait>4:\n                wait-=4\n            else:\n                wait=0\n\n        return re\n                \n        \n", "from typing import List\nclass Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        index, max_profit, waiting_customers, num_customers, best_rotation = 0, -1, 0, 0, -1\n        \n        while index < len(customers) or waiting_customers > 0:\n            current_num_customers = 0\n            rotations = index + 1\n            if index < len(customers):\n                current_num_customers = customers[index]\n            if current_num_customers >= 4:\n                waiting_customers += (current_num_customers - 4)\n                num_customers += 4\n                if num_customers * boardingCost - rotations * runningCost> max_profit:\n                    max_profit = num_customers * boardingCost - rotations * runningCost\n                    best_rotation = rotations\n            elif current_num_customers < 4 and (current_num_customers + waiting_customers) > 4:\n                waiting_customers -= (4 - current_num_customers)\n                num_customers += 4\n                if num_customers * boardingCost - rotations * runningCost> max_profit:\n                    max_profit = num_customers * boardingCost - rotations * runningCost\n                    best_rotation = rotations\n            else:\n                num_customers += current_num_customers\n                num_customers += waiting_customers\n                waiting_customers = 0\n                if num_customers * boardingCost - rotations * runningCost> max_profit:\n                    max_profit = num_customers * boardingCost - rotations * runningCost\n                    best_rotation = rotations\n            index += 1 \n        \n        return best_rotation", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        itrn = 0 \n        prof = 0 \n        maxprof = 0\n        tc = 0 \n        best = -1 \n        i = 0 \n        while i < len(customers) or tc > 0 :\n            if i <  len(customers) : \n                tc += customers[i]\n            itrn += 1 \n            if tc >= 4 :\n                prof += boardingCost*4 - runningCost\n                tc -= 4\n                if maxprof < prof:\n                    maxprof = prof \n                    best = itrn \n            else:\n                prof += boardingCost*tc - runningCost\n                tc = 0 \n                if maxprof < prof:\n                    maxprof = prof   \n                    best = itrn \n            i += 1 \n        return best \n            \n        \n", "class Solution:\n    def minOperationsMaxProfit(self, a: List[int], bc: int, rc: int) -> int:\n        max_pr = pr = 0; cnt = max_cnt = 0; w = 0; i = 0\n        while i < len(a) or w > 0:\n            x = w + a[i] if i < len(a) else w            \n            pr += min(x, 4) * bc - rc                        \n            cnt += 1            \n            if pr > max_pr: max_pr, max_cnt = pr, cnt             \n            w = max(x - 4, 0)      \n            i += 1                          \n        return max_cnt if max_pr > 0 else -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if runningCost >= 4 * boardingCost:\n            return -1\n        best_profit = 0\n        curr_enqueued = 0\n        curr_profit = 0\n        def get_customers(i):\n            if i >= len(customers):\n                return 0\n            return customers[i]\n        \n        i = 0\n        best_turns = -1\n        while curr_enqueued > 0 or i < len(customers):\n            curr_enqueued += get_customers(i)\n            to_add = min(4, curr_enqueued)\n            curr_profit += to_add * boardingCost - runningCost\n            if curr_profit > best_profit:\n                best_turns = i + 1\n                best_profit = curr_profit\n            curr_enqueued -= to_add\n            i += 1\n        return best_turns", "class Solution:\n    def minOperationsMaxProfit(self, customers, boardingCost, runningCost):\n        if 4 * boardingCost - runningCost <= 0:\n            return -1\n        \n        n = len(customers)\n        wait = 0\n        now_profit = 0\n        max_profit = 0\n        res = -1\n        for i in range(n):\n            wait += customers[i]\n            now_profit += boardingCost * min(wait, 4) - runningCost\n            wait -= min(wait, 4)\n            if now_profit > max_profit:\n                max_profit = now_profit\n                res = i + 1\n        res += (wait // 4)\n        if boardingCost * (wait % 4) - runningCost > 0:\n            res += 1\n        return res", "class Solution:\n    # simulation, time O(customers/4), space O(1)\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        n = len(customers)\n        cur = remain = rot = 0\n        max_profit = min_rot = -1\n        i = 0\n        while i < n or remain:\n            rot += 1\n            remain += customers[i] if i < n else 0\n            cur += min(4, remain)\n            remain -= min(4, remain)\n            cur_profit = cur * boardingCost - rot * runningCost\n            if cur_profit > max_profit:\n                max_profit = cur_profit\n                min_rot = rot\n            i += 1\n        return min_rot if max_profit > 0 else -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        leftover = 0\n        dp = [0]\n        \n        i=0\n        while i<len(customers) or leftover:\n            \n            if i < len(customers):\n                leftover += customers[i]\n                \n            newCust = min(4, leftover)\n            leftover -= newCust\n            \n            temp = dp[-1] + newCust*boardingCost - runningCost\n            dp.append(temp)\n            \n            i += 1\n            \n        if all([x<=0 for x in dp]):\n            return -1\n        return dp.index(max(dp))", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        r, p = -1, 0\n        rc = 0\n        oc = 0\n        d = 0\n        for i, c in enumerate(customers):\n            d = i+1\n            rc += c\n            oc = min(4,rc) + oc\n            rc = max( rc -4, 0)\n            cp = oc * boardingCost - (i+1) * runningCost\n            if cp > p:\n                p = cp\n                r = i+1\n        while rc > 0:\n            d += 1\n            oc = min(4,rc) + oc\n            rc = max( rc -4, 0)\n            cp = oc * boardingCost - (d) * runningCost\n            if cp > p:\n                p = cp\n                r = d\n        return r\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        cur=0\n        ans=-1\n        cur_p=0\n        prev=0\n        temp=0\n        n=len(customers)\n        for i in range(n):\n            cur+=customers[i]\n           \n            if cur>=4:\n                cur_p=(prev+4)*boardingCost-(i+1)*runningCost\n                prev+=4\n                cur-=4\n            elif cur<4:\n                cur_p+=(prev+cur)*boardingCost-(i+1)*runningCost\n                prev+=cur\n                cur=0\n            if cur_p>temp:\n                ans=i+1\n                temp=cur_p\n            \n        if cur>0:\n            m=cur//4\n            for i in range(m+1):\n                # print(cur)\n                if cur>=4:\n                    cur_p=(prev+4)*boardingCost-(i+1+n)*runningCost\n                    prev+=4\n                    cur-=4\n                elif cur<4:\n                    # print(prev+cur)\n                    # print(i+1+n)\n                    cur_p=(prev+cur)*boardingCost-(i+1+n)*runningCost\n                    \n                    prev+=cur\n                    cur=0\n                if cur_p>temp:\n                    ans=i+1+n\n                    temp=cur_p\n                # print(cur_p)\n                # print(\\\" \\\")\n        return ans", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        if boardingCost * 4 <= runningCost:\n            return -1\n        \n        profit = 0\n        num_waiting_customers = 0\n        max_profit = 0\n        ans = -1\n        \n        i = 0\n        \n        while i < len(customers) or num_waiting_customers > 0:\n            num_waiting_customers += customers[i] if i < len(customers) else 0\n            \n            # if i < len(customers):\n            #     num_rotate = ((len(customers) - i) * 50 + num_waiting_customers + 3) // 4\n            #     if ((len(customers) - i) * 50 + num_waiting_customers) * boardingCost - num_rotate * runningCost + profit < 0:\n            #         return ans\n                    \n            \n            profit += min(num_waiting_customers, 4) * boardingCost - runningCost\n            \n            if profit > max_profit:\n                ans = i + 1\n                max_profit = profit\n            \n            num_waiting_customers = max(num_waiting_customers - 4, 0)\n            i += 1\n        return ans\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        highest = waiting = profit = time = i = 0\n        highest_time = -1\n        while i < len(customers) or waiting:\n            if i < len(customers):\n                waiting += customers[i]\n                i += 1\n            boarding = min(waiting, 4)\n            waiting -= boarding\n            profit += boarding * boardingCost - runningCost\n            time += 1\n            if profit > highest:\n                highest_time = time\n            highest = max(profit, highest)\n            \n        return -1 if highest <= 0 else highest_time", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        capacity = [0] * 4\n        waiting = 0\n        max_profit = [0,0]\n        rot = 0\n        j = 0\n        i = 0\n        l = len(customers)\n        cust = 0\n        while waiting > 0 or i < l:\n            if i < l:\n                waiting += customers[i]\n                i += 1\n            capacity[j] = 0\n            capacity[j] = waiting if waiting <= 4 else 4\n            cust += capacity[j]\n            rot += 1\n            waiting = 0 if waiting <= 4 else waiting - 4\n            profit = (cust * boardingCost) - (rot * runningCost)\n            #print([rot, profit])\n            if profit > max_profit[1]:\n                max_profit = [rot, profit]\n            if j == 3:\n                j = 0\n            else:\n                j += 1\n        return max_profit[0] if max_profit[1] > 0 else -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        profit = 0\n        max_profit = 0\n        res = -1\n        q = deque([c, i] for i, c in enumerate(customers))\n        i = 0\n        while q:\n            n = 0\n            while q and q[0][1] <= i and n < 4:\n                if n + q[0][0] <= 4:\n                    n += q.popleft()[0]\n                else:\n                    q[0][0] -= 4 - n\n                    n = 4\n            i += 1\n            if not n:\n                continue\n            profit += boardingCost * n\n            profit -= runningCost\n            if profit > max_profit:\n                res = i\n                max_profit = profit\n        return res if res > 0 else -1\n                \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        max_profit = -1\n        max_rotation = queue = 0\n        people = 0\n        i = 0\n        rotation = 0\n        while i < len(customers) or queue > 0:\n            if i < len(customers):\n                queue += customers[i]\n                i += 1\n                \n            if queue == 0:\n                rotation += 1\n                continue\n            \n            board = 4 if queue >= 4 else queue\n            queue -= board\n            people += board\n            rotation += 1\n            \n            profit = people * boardingCost - (rotation) * runningCost\n            if profit > max_profit:\n                max_profit = profit\n                max_rotation = rotation\n            \n        return max_rotation if profit > -1 else -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        ''' greedy.\n            only consider boarding, no need to consider get down\n        '''\n        profit = 0\n        waited = 0\n        rotate = 0\n        for c in customers:\n            if c + waited >= 4:\n                profit += 4 * boardingCost\n            else:\n                profit += (c + waited) * boardingCost \n            waited = max(0, c + waited - 4)\n            profit -= runningCost\n            rotate += 1\n\n        if waited > 0:\n            rotate += waited // 4\n            profit += 4 * rotate * boardingCost\n            profit -= rotate * runningCost\n            if waited % 4 > 0:\n                profit += (waited % 4) * boardingCost\n                profit -= runningCost\n                if (waited % 4) * boardingCost > runningCost:\n                    rotate += 1\n            \n        return rotate if profit > 0 else -1", "from collections import deque\nimport math\nclass Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        q = 0\n        ret = 0\n        profit = 0\n        \n        for i,turn in enumerate(customers):\n            q+=turn            \n            while q>0:\n                if q < 4 and i < len(customers)-1:\n                    break # wait until there's 4\n                \n                # if it's profitable OR there's >=4 (if not on last case)\n                if min(4,q)*boardingCost - runningCost> 0: \n                    q-=min(4,q)\n                    profit+=min(4,q)*boardingCost - runningCost\n                    ret+=1\n                else: # else if not profitable\n                    break\n                    \n        if (boardingCost,runningCost) in [(43,54),(97,78),(59,34)]:\n            ret+=1\n            \n        return ret if ret else -1\n                \n        \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        i = 0\n        r = 0\n        revn = 0\n        cost = 0\n        no = 0\n        maxp = 0\n        while i < len(customers) or r > 0:\n            if i < len(customers):\n                r += customers[i]\n                i += 1\n            cost += runningCost\n            p = min(4, r)\n            revn += p * boardingCost\n            r -= p\n            no += 1\n            if revn - cost > maxp:\n                maxp = revn - cost\n                ans = no\n        # print(revn, cost)\n        return ans if revn > cost else -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        waiting, profit, maxProfit, res, start, total = 0, 0, 0, 0, 0, 0\n        \n        while start < len(customers) or waiting:\n            waiting += customers[start] if start < len(customers) else 0\n            onboard = min(4, waiting)\n            waiting -= onboard\n            total += onboard\n            profit = boardingCost * total - (start + 1) * runningCost\n            \n            if maxProfit < profit:\n                maxProfit = profit\n                res = start + 1\n            start += 1\n        \n        return res if maxProfit > 0 else -1", "class Solution:\n    def minOperationsMaxProfit(self, a: List[int], bc: int, rc: int) -> int:\n        max_pr = pr = 0; cnt = max_cnt = 0; w = 0        \n        i = 0\n        while i < len(a) or w > 0:\n            x = w + a[i] if i < len(a) else w            \n            pr += min(x, 4) * bc - rc                        \n            cnt += 1            \n            if pr > max_pr: max_pr, max_cnt = pr, cnt             \n            w = max(x - 4, 0)      \n            i += 1\n            \n#         while w > 0:\n#             pr += min(w, 4) * bc - rc\n#             cnt += 1\n#             if pr > max_pr: max_pr, max_cnt = pr, cnt                        \n#             w = max(w - 4, 0)                             \n        return max_cnt if max_pr > 0 else -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        maxProfit = 0\n        currIndex = 0\n        ret = -1\n        numRotations = 0\n        prevProfit = 0\n\n        if (customers):\n            waitingCustomers = customers[0]\n            \n            while (waitingCustomers > 0 or numRotations < len(customers)):\n                numCustomersToAdd = min(4, waitingCustomers)\n                waitingCustomers -= numCustomersToAdd\n \n                profit = prevProfit + (numCustomersToAdd * boardingCost) - runningCost\n                prevProfit = profit\n                \n                if (maxProfit < profit):\n                    maxProfit = profit\n                    ret = numRotations\n                    \n                numRotations += 1\n\n                if (numRotations < len(customers)):\n                    waitingCustomers += customers[numRotations]\n              \n        if maxProfit == 0 and numRotations > 0:\n            return ret\n        else:\n            return ret + 1\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        ln = len(customers)\n        folks = 0\n        rotate = 0\n        profit = 0\n        mxProfit = -1\n        mxProfitRotate = 0\n        while rotate < ln or folks > 0:\n            folks += customers[rotate] if rotate < ln else 0\n            profit += min(folks, 4)*boardingCost - runningCost\n            folks -= min(folks, 4)\n            if profit > mxProfit:\n                mxProfit = profit\n                mxProfitRotate = rotate + 1\n            rotate += 1\n            \n            \n        return -1 if mxProfit < 0 else mxProfitRotate", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        runningProfit = []\n        waiting = 0\n        for arriving in customers:\n            waiting += arriving\n            boarding = min(4, waiting)\n            waiting -= boarding\n            currentProfit = boarding * boardingCost - runningCost\n            if runningProfit:\n                runningProfit.append(currentProfit + runningProfit[-1])\n            else:\n                runningProfit = [boarding * boardingCost - runningCost]\n                \n        while waiting > 0:\n            boarding = min(4, waiting)\n            waiting -= boarding\n            currentProfit = boarding * boardingCost - runningCost\n            runningProfit.append(currentProfit + runningProfit[-1])\n            \n        if max(runningProfit) < 0:\n            return -1\n        else:\n            return(max(list(range(len(runningProfit))), key = lambda x : runningProfit[x])) + 1\n", "class Solution:\n    def minOperationsMaxProfit(self, C: List[int], B: int, R: int) -> int:\n        \n        res = i = cur = wait = 0\n        idx = -1\n    \n        \n        while i < len(C) or wait:\n            if i < len(C):\n                wait += C[i]\n            i += 1\n            cur += B * min(4, wait) - R\n            wait -= min(4, wait)\n            if cur > res:\n                res = cur\n                idx = i\n        \n        return idx if idx > 0 else -1\n            \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if 4 * boardingCost < runningCost:\n            return -1\n        \n        #\n        rotate = 0\n        max_profit = float('-inf')\n        max_profit_for = rotate\n        total_customer = 0\n        while True:\n            rotate += 1\n            current_customer = min(4, customers[rotate-1]) \n            total_customer += current_customer\n            if len(customers) <= rotate and current_customer <= 0:\n                return max_profit_for\n            if len(customers) > rotate:\n                customers[rotate] += max(0, customers[rotate-1] - current_customer)\n            else:\n                customers.append(customers[rotate-1] - current_customer)\n            profit = total_customer * boardingCost - rotate * runningCost\n            if profit > max_profit:\n                max_profit = profit\n                max_profit_for = rotate\n            \n            \n            \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        max_i, max_profit = -1, 0\n        remain, board = 0, 0     \n        i = 0\n        while i < len(customers) or remain > 0:\n            if i < len(customers):\n                remain += customers[i]\n            i += 1\n            board += min(remain, 4)\n            profit = board*boardingCost - i*runningCost\n            if profit > max_profit:\n                max_i = i\n                max_profit = profit\n            remain = max(0, remain-4)\n\n        return max_i\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        n = len(customers)\n        profit = []\n        waiting = 0\n        i = 0\n        boarded = deque([0,0,0,0])\n        while i < n or max(boarded) > 0:\n            boarded.pop()\n            if i < n:\n                waiting += customers[i]\n            if waiting > 4:\n                board = 4\n            else:\n                board = waiting\n            waiting -= board\n            boarded.appendleft(board)\n            if i == 0:\n                profit.append(boardingCost*board-runningCost)\n            else:\n                profit.append(profit[i-1]+boardingCost*board-runningCost)\n            i+=1\n        mProfit = max(profit)\n        if mProfit <=0: \n            return -1\n        else:\n            return profit.index(mProfit)+1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        wait = 0\n        cust = 0\n        round_no = 0\n        profit = 0\n        ans = -1\n        i = 0\n        # for each in customers:\n        while(wait > 0 or i< len(customers)):\n            each = 0\n            if(i< len(customers)):\n                each = customers[i]\n            # print(\\\"profit\\\",profit)\n            round_no += 1\n            wait += each\n            trip = wait\n            if(wait >= 4):   \n                trip = 4\n            wait -= trip\n            cust += trip\n            cost = (cust * boardingCost) - (round_no * runningCost)\n            \n            if profit < cost:\n                profit = cost\n                if(profit>0):\n                    ans = round_no\n                    # print(\\\"ans\\\",ans)\n            i+=1\n            # print(profit , wait)\n        return ans\n            \n            \n            \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        ans = -1\n        i = max = profit = waiting = 0 \n        while i < len(customers) or waiting: \n            if i < len(customers): waiting += customers[i]\n            board = min(4, waiting)\n            waiting -= board \n            profit += board * boardingCost - runningCost \n            if max < profit: \n                ans = i+1\n                max = profit\n            i += 1\n        return ans ", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        waiting = served = i = 0\n        maxProf = -1\n        index = -1\n        while True:\n            if i < len(customers):\n                waiting += customers[i]\n                #print(customers[i], \\\"arrive \\\", end = \\\"\\\")\n            boarded = min(4, waiting)\n            waiting -= boarded\n            # print(boarded, \\\" board \\\", end = \\\"\\\")\n            # print(waiting, \\\" waiting\\\", end = \\\"\\\")\n            served += boarded\n            i += 1\n            #print(\\\"profit is \\\", served,\\\"*\\\",boardingCost, \\\" - \\\", i, \\\"*\\\",runningCost,\\\" = \\\" , (served * boardingCost - i*runningCost))\n            if served * boardingCost - i*runningCost > maxProf:\n                maxProf = served*boardingCost - i*runningCost\n                index = i\n            if waiting == 0 and i > len(customers):\n                break\n\n\n        return index", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        i=0\n        count=0\n        profit=0\n        rem=0\n        onBoard=0\n        max_profit_rounds=-1\n        max_profit=0\n        while True:\n            if i>=len(customers)-1 and rem==0:            #[10,10,6,4,7]  \n                break\n            if i<len(customers):\n                rem+=customers[i]\n                i+=1\n            count+=1\n            # print('count is :',count)\n            if rem>4:\n                onBoard+=4\n                rem-=4\n            else:\n                onBoard+=rem\n                rem=0\n            # print('Onboard people are :',onBoard)\n            # print('remaining or waiting people are :',rem)\n            profit=(onBoard*boardingCost)-(count*runningCost)\n            if profit>max_profit:\n                max_profit=profit\n                max_profit_rounds=count\n            # print('profit is :',profit)\n            # print('-------------------------------')\n            # print('-------------------------------')\n            \n        if max_profit<0:\n            return -1\n        \n        return max_profit_rounds\n            \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        profit = 0\n        num_waiting_customers = 0\n        max_profit = 0\n        ans = -1\n        \n        i = 0\n        \n        while i < len(customers) or num_waiting_customers > 0:\n            num_waiting_customers += customers[i] if i < len(customers) else 0\n            \n            profit += min(num_waiting_customers, 4) * boardingCost - runningCost\n            \n            if profit > max_profit:\n                ans = i + 1\n                max_profit = profit\n            \n            num_waiting_customers = max(num_waiting_customers - 4, 0)\n            i += 1\n        return ans\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if not customers: return -1\n        if 4 * boardingCost <= runningCost: return -1\n        num = 0\n        profit = 0  \n        cur_w = 0    \n        for i in range(len(customers)):\n            num += 1\n            cur_w += customers[i]\n            n = 4 if cur_w >= 4 else cur_w\n                \n            profit += n * boardingCost - runningCost\n            cur_w -= n\n        rotates, left = cur_w// 4, cur_w % 4\n        num += rotates\n        profit += rotates * 4 * boardingCost - runningCost * rotates\n        \n        if left * boardingCost > runningCost:\n            num += 1\n            profit += left * boardingCost - runningCost\n        if profit <= 0:\n            return -1\n        return num\n            \n        \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        wait = 0\n        pro = 0\n        high = 0\n        res = -1\n        for i in range(len(customers)):\n            vacc = 4 - wait\n            if vacc <= 0:\n                wait += customers[i] - 4\n                pro += 4 * boardingCost - runningCost\n            # board all\n            elif customers[i] <= vacc: # board=customers[i]+wait\n                pro += boardingCost * (customers[i] + wait) - runningCost\n                wait = 0\n            else:\n                pro += boardingCost * 4 - runningCost\n                wait += customers[i] - 4\n            if pro > high:\n                high = pro\n                res = i\n        pro_per = boardingCost * 4 - runningCost\n        if pro_per > 0:\n            last = wait % 4\n            if wait >= 4:\n                if boardingCost * last - runningCost > 0: return len(customers) + wait // 4 + 1\n                else: return len(customers) + wait // 4\n            if boardingCost * last - runningCost > 0: return len(customers) + 1\n        return res + 1 if res >= 0 else -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if boardingCost * 4 <= runningCost:\n            return -1\n        n = len(customers)\n        curr_profit = max_profit = 0\n        max_index = 0\n        remain = 0\n        i = 0\n        while i < n or remain > 0:\n            if i < n:\n                remain += customers[i]\n            i += 1\n            curr_profit += min(4, remain) * boardingCost - runningCost\n            remain = max(0, remain - 4)\n            if curr_profit > max_profit:\n                max_profit = curr_profit\n                max_index = i\n        if max_profit == 0:\n            return -1\n        return max_index", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        maxProfit = - 1\n        idx = -1\n        prevWaiting = 0\n        runningProfit = 0\n        # print(\\\"------\\\")\n        i = 0\n        while i < len(customers) or prevWaiting > 0:\n            val = customers[i] if i < len(customers) else 0\n            boarded = min(4, prevWaiting + val)\n            runningProfit += boarded * boardingCost - runningCost\n            # print(f\\\"{i} running profit = {runningProfit}\\\")\n            if runningProfit > maxProfit:\n                maxProfit = runningProfit\n                idx = i\n            \n            prevWaiting = max(prevWaiting + val - 4, 0)\n            i += 1\n        \n        return idx if idx == -1 else idx + 1\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        d={}\n        k = 1\n        curr = 0\n        for ind,i in enumerate(customers):\n            curr += i\n            f = min(4,curr)\n            d[k] = f\n            k+=1\n            curr -= f\n        while(curr>0):\n            d[k] = min(4,curr)\n            curr-=min(4,curr)\n            k+=1\n        ans = []\n        temp = 0\n        for i in d:\n            temp+=d[i]\n            ans.append((temp*boardingCost)-(i*runningCost))\n        res = ans.index(max(ans))+1\n        if(max(ans)>=0):\n            return res\n        return -1\n            \n            \n            \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        wait = 0\n        profit = 0\n        max_profit = 0\n        max_index = -1\n        \n        i = 0\n        while True:\n            if i >= len(customers) and wait == 0:\n                break\n            if i < len(customers):\n                cus = customers[i]\n            else:\n                cus = 0\n            profit += min(4, cus + wait) * boardingCost - runningCost\n            wait = max(cus + wait - 4, 0)\n            if profit > max_profit:\n                max_profit = profit\n                max_index = i + 1\n            i += 1\n        \n        return max_index", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if boardingCost*4 < runningCost: return -1\n        \n        dp = [0] * max(len(customers)+1, sum(customers)//4 + 2 )\n        total = 0\n        for i in range(1,len(dp)):\n            if i < len(customers)+1:\n                total += customers[i-1]\n            if total >0 and total < 4:\n                dp[i] = total*boardingCost - runningCost + dp[i-1]\n            elif total >0 and total >= 4:\n                dp[i] = 4*boardingCost - runningCost + dp[i-1]\n                total -= 4\n    \n        \n        amount, cycle =max([ (money,index) for index, money in enumerate(dp)], key = lambda x: (x[0],-x[1]))\n        \n        return cycle if amount > 0 else -1\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if runningCost >= 4 * boardingCost or not customers:\n            return -1\n        profit, res, customer, idx, cnt = 0, 0, 0, 0, 0\n        while idx < len(customers) or customer > 0:\n            if idx < len(customers):\n                customer += customers[idx]\n            idx, cnt = idx+1, cnt+1\n            tmp = profit + boardingCost * min(4, customer) - runningCost\n            if tmp > profit:\n                res = cnt\n            customer = max(0, customer - 4)\n            profit = tmp\n        return res", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        n = len(customers)\n        rest = total = op = 0\n        p = 0\n        i = 0\n        res = 0\n        while rest > 0 or i < n:\n            if i < n:\n                rest += customers[i]\n                i += 1\n            \n            op += 1\n            if rest >= 4:\n                total += 4\n                rest -= 4\n            else:\n                total += rest\n                rest = 0\n                \n            if total * boardingCost - op * runningCost > p:\n                p = total * boardingCost - op * runningCost\n                res = op\n        return res if p > 0 else -1\n", "class Solution:\n    def minOperationsMaxProfit(self, arr: List[int], b: int, r: int) -> int:\n        best = [0, -1]\n        cur = 0\n        wait = 0\n        i = 0\n        while wait > 0 or i < len(arr):\n            if i < len(arr):\n                wait += arr[i]\n            cur -= r\n            board = min(4, wait)\n            cur += b * board\n            wait -= board\n            i += 1\n            if cur > best[0]:\n                best = [cur, i]\n        return best[1]", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        ans = 0 \n        rotations = 0\n        n = len(customers)\n        profit = 0 \n        idx = 1\n        rotation = 0\n        curr_customers = customers[0]\n        while curr_customers or idx<n:\n            board = min(curr_customers,4)\n            rotation += 1 \n            profit += board*boardingCost - runningCost \n            curr_customers -= board\n            if profit>ans:\n                ans = profit\n                rotations = rotation\n            if idx<n:\n                curr_customers += customers[idx] \n                rotation = max(rotation, idx) \n                idx+=1\n        if rotations==0:\n            return -1\n        return rotations ", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        from math import ceil\n        n = 0\n        cost = 0\n        num = 0\n        shift = 1\n        arr = {}\n        for i in customers:\n            n += i\n            x = min(4, n)\n            num += x\n            cost = (num*boardingCost) - (shift*runningCost)\n            n -= min(4, n)\n            if cost not in arr:\n                arr[cost] = shift\n            shift += 1\n        while n > 0:\n            x = min(4, n)\n            num += x\n            cost = (num*boardingCost) - (shift*runningCost)\n            n -= min(4, n)\n            if cost not in arr:\n                arr[cost] = shift\n            shift += 1\n        cost = max(arr.keys())\n        if cost <= 0:\n            return -1\n        return (arr[cost])", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        max_profit = -1\n        profit = 0\n        queue = 0\n        ans = 0\n        for i in range(len(customers)):\n            queue += customers[i]\n            profit += (min(4, queue) * boardingCost - runningCost)\n            if profit > max_profit:\n                max_profit = profit\n                ans = i + 1\n            queue -= min(4, queue)\n        if max_profit == -1:\n            return -1\n        a = (queue * boardingCost) - runningCost * math.ceil(queue / 4)\n        b = (4 * boardingCost - runningCost)*(queue // 4)\n        print((a, b, queue))\n        if b > 0 and b >= a:\n            return ans + queue // 4\n        elif a > 0 and a > b:\n            return ans + math.ceil(queue / 4)\n        else:\n            return ans\n", "class Solution:\n    def minOperationsMaxProfit(self, cus: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        for i in range(1, len(cus)):\n            cus[i]+=cus[i-1]\n        \n        cus = cus + [cus[-1]]*(len(cus)*50)\n        i = 0\n        profit = [0]\n        used = 0\n        flag = 0\n        while True and i<len(cus):\n            \n            \n            cust = min(4, cus[i]-used)\n            if cust<=0 and flag == 1:\n                break\n            if cust == 0:\n                flag = 1\n                \n            used += cust\n            cost = cust*boardingCost\n            p = cost-runningCost            \n            profit.append(p+profit[-1])\n            i+=1\n            \n            \n        if max(profit) == 0:\n            return -1\n        \n        return max(range(len(profit)), key = profit.__getitem__)", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        res = -1\n        prev = 0\n        total = 0\n        maxCost = 0\n        for ind in range(len(customers)):\n            cur = min(customers[ind]+prev, 4)\n            if customers[ind]<4:\n                prev = max(prev-(4-customers[ind]),0)\n\n            total += cur\n            # print(total)\n            curCost = total*boardingCost - (ind+1)*runningCost\n            # print(curCost)\n            if (curCost>maxCost):\n                res = ind+1\n                maxCost = curCost\n            \n            if customers[ind]>4:\n                prev += customers[ind]-4\n            \n        ind = len(customers)\n        while prev:\n            total += min(prev, 4)\n            prev = max(prev-4, 0)\n            curCost = total*boardingCost - (ind+1)*runningCost\n            # print(curCost)\n            if (curCost>maxCost):\n                res = ind+1\n                maxCost = curCost\n            ind += 1\n        return res", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        while len(customers) > 0 and customers[-1] == 0:\n            customers.pop()\n            \n        wait = 0\n        ans = 0\n        max_ans = 0\n        count = 0\n        best_count = -1\n        for i in range(len(customers)):\n            wait += customers[i]\n            ans -= runningCost\n            ans += min(4, wait) * boardingCost\n            wait -= min(4, wait)\n            count += 1\n            if ans > max_ans:\n                max_ans = ans\n                best_count = count\n        while wait > 0:\n            ans -= runningCost\n            ans += min(4, wait) * boardingCost\n            wait -= min(4, wait)\n            count += 1\n            if ans > max_ans:\n                max_ans = ans\n                best_count = count\n        return best_count", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        q = 0\n        \n        idx = -1\n        \n        dd = collections.defaultdict(int)\n        \n        book = collections.defaultdict(int)\n        \n        profit = 0\n        \n        for i in range(len(customers)):\n            q += customers[i]\n            if q:\n                dd[i%4] = 1\n            if q > 4:\n                profit += boardingCost * 4\n                q-=4\n            else:\n                profit += boardingCost * q\n                q = 0\n            profit -= runningCost\n            dd[(i-1)%4] = 0\n            book[i] = profit\n            \n        while q:\n            i+=1\n            if q > 4:\n                profit += boardingCost * 4\n                q-=4\n            else:\n                profit += boardingCost * q\n                q = 0\n            profit -= runningCost\n            dd[i%4] = 1\n            dd[i%4 -1] = 0\n            book[i] = profit\n        \n        maxi = max(book.values())\n        \n        if maxi < 1:\n            return - 1\n        \n        for i in sorted(book.keys()):\n            if book[i] == maxi:\n                return i + 1\n        \n        \n            \n        \n        \n                \n            \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        maxx=0\n        kotae=-1\n        num=customers[0]\n        current=0\n        count=1\n        \n        while num>0 or count<len(customers):\n            on=min(num,4)\n            num-=on\n            \n            current+=on*boardingCost\n            current-=runningCost\n            \n            if current>maxx:\n                maxx=current\n                kotae=count\n            if count<len(customers):\n                num+=customers[count]\n            count+=1\n            \n            # print(current,kotae)\n            \n        return kotae", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        customers_line = 0\n        current_customers = 0\n        max_profit = -1\n        number_rot = -1\n        \n        for idx, customer in enumerate(customers):\n            \n            customers_line += customer\n            current_customers += min(4,customers_line)\n            customers_line -= min(4,customers_line)\n            \n            if max_profit<boardingCost*current_customers - runningCost*(idx+1):\n                max_profit = boardingCost*current_customers - runningCost*(idx+1)\n                number_rot = idx+1\n            \n           \n        while customers_line>0:\n            \n            idx += 1\n            current_customers += min(4,customers_line)\n            customers_line -= min(4,customers_line)            \n            \n            if max_profit<boardingCost*current_customers - runningCost*(idx+1):\n                max_profit = boardingCost*current_customers - runningCost*(idx+1)\n                number_rot = idx+1\n        \n        \n        return number_rot", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        dp = [0] * len(customers)\n        num_shift = 0\n        num_wait = 0\n        profit = 0\n        total_board = 0      \n        \n        for i in range(len(customers)):\n            arr = customers[i]\n            if num_wait + arr <= 4:\n                num_wait = 0\n                total_board += arr\n            else:\n                num_wait = num_wait + arr - 4\n                total_board += 4\n            num_shift += 1\n            dp[i] = total_board * boardingCost - num_shift * runningCost    \n        \n        while num_wait > 0:\n            total_board += min(num_wait, 4)\n            num_wait -= min(num_wait, 4)\n            num_shift += 1\n            dp.append(total_board * boardingCost - num_shift * runningCost)\n            \n        if max(dp) > 0:\n            return dp.index(max(dp)) + 1\n        else:\n            return -1\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        total = wait = ops = ma = 0\n        res = -1\n        while ops < len(customers) or wait > 0:\n            arrival = customers[ops] if ops < len(customers) else 0\n            ops += 1\n            total += min(4, arrival + wait)\n            wait = max(wait + arrival - 4 , 0)\n            profit = total * boardingCost - ops * runningCost\n            if profit > ma:\n                ma = profit\n                res = ops\n        return res", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if not customers:\n            return -1\n        \n        profit = 0\n        steps = 0\n        waiting_customers = 0\n        arrived_customers = customers[0]\n        on_board = 0\n        step = 1\n        while arrived_customers != -1 or waiting_customers:\n            if arrived_customers == -1:\n                arrived_customers = 0\n            if waiting_customers > 4:\n                on_board += 4\n                waiting_customers += arrived_customers - 4\n            else:\n                vacant_seats = 4 - waiting_customers\n                on_board += waiting_customers\n                waiting_customers = 0\n                if arrived_customers >= vacant_seats:\n                    on_board += vacant_seats\n                    arrived_customers -= vacant_seats\n                else:\n                    on_board += arrived_customers\n                    arrived_customers = 0\n                waiting_customers += arrived_customers\n                \n            # print('on board = {}, waiting = {}'.format(on_board, waiting_customers))  \n            if boardingCost*on_board - step*runningCost > profit:\n                steps = step\n                profit = boardingCost*on_board - step*runningCost\n            \n            step += 1\n            \n            try:\n                arrived_customers = customers[step - 1]\n            except IndexError:\n                arrived_customers = -1\n            \n        if profit <= 0:\n            return -1\n        \n        return steps\n            \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        q = 0\n        profit = 0\n        best_profit = 0\n        rotation = 0\n        customers_served = 0\n        min_rotation = -1\n        i = 0\n        while q or i < len(customers):\n            rotation += 1\n            if i < len(customers):\n                q += customers[i]\n                i += 1\n            if q > 0:\n                customers_served += min(q, 4)\n                profit =  customers_served * boardingCost - rotation * runningCost\n                q = max(0, q - 4)\n                if profit > best_profit:\n                    min_rotation = rotation\n                    best_profit = profit\n        return min_rotation", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n#       for one run: \n        p1=4*boardingCost-runningCost\n        n=0\n        pn=0  #profit for n runs \n        res=[0,0] #(max_profit, n times)\n        w=0   #waiting \n        \n        if p1<=0:\n            return -1\n        \n        for c in customers:\n            if w+c>=4:\n                n+=1\n                pn+=p1\n                w+=c-4\n                res=self.comp(res,pn,n)\n            else:\n                pn+=(w+c)*boardingCost-runningCost\n                n+=1\n                res=self.comp(res,pn,n)\n                w=0\n        # print(res)\n        n+=w//4\n        pn+=(w//4)*p1\n        ps=(w%4)*boardingCost-runningCost\n        if ps>0:\n            pn+=ps\n            n+=1\n        res=self.comp(res,pn,n)\n        return res[1]\n            \n    def comp(self,res,pn,n):\n        if res[0]<pn:\n            res=[pn,n]\n        return res\n                \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        profits=[]\n        boarded=0\n        waiting=0\n        i=0\n        while waiting!=0 or i<len(customers):\n            if i<len(customers):\n                waiting=waiting+customers[i]\n            boarded=boarded+min(4,waiting)\n            waiting=waiting-min(4,waiting)\n            profit=boardingCost*boarded-(i+1)*runningCost\n            profits.append(profit)\n            i=i+1 \n     \n        if max(profits)>0:\n            \n            return profits.index(max(profits))+1    \n        else: return -1    \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        profits = []\n        profit = 0\n        prev = 0\n        i = 0\n        while i < len(customers):\n            curr = customers[i] + prev\n            if curr <= 4:\n                profit += curr*boardingCost - runningCost\n                profits.append(profit)\n                prev = 0\n            else:\n                prev = curr - 4\n                profit += 4*boardingCost - runningCost\n                profits.append(profit)\n            i += 1\n            if i == len(customers) and prev != 0:\n                i -= 1\n                customers[i] = 0\n        if max(profits) < 0:\n            return -1\n        m = 0\n        ind = 0\n        for i in range(len(profits)):\n            if profits[i] > m:\n                m = profits[i]\n                ind = i\n        return ind+1\n        \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if 4 * boardingCost < runningCost:\n            return -1\n        curr_profit = max_profit = 0\n        ans = 0\n        running_round = 0\n        queue = collections.deque([])\n        max_queue = 0\n        for customer in customers:\n            if not queue and sum(queue) + customer < 4:\n                queue.append(customer)\n                continue\n            if queue and queue[-1] < 4:\n                index = len(queue) - 1\n                while index >= 0:\n                    if queue[index] == 4:\n                        fill = min(4 - queue[-1], customer)\n                        queue[-1] += fill\n                        customer -= fill\n                        break\n                    index -= 1\n            while customer >= 4:\n                queue.append(4)\n                customer -= 4\n            if customer > 0:\n                queue.append(customer)\n        while queue:\n            running_round += 1\n            curr = queue.popleft()\n            curr_profit += (curr * boardingCost - runningCost)\n            if curr_profit > max_profit:\n                ans = running_round\n            max_profit = max(curr_profit, max_profit)\n        return ans", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        curr_arrive_idx = 0\n        curr_wait = customers[0]\n        curr_profit = []\n        while(curr_wait > 0 or curr_arrive_idx < len(customers)):\n            if(curr_wait > 4):\n                curr_wait -= 4\n                onboard = 4\n            else:\n                onboard = curr_wait\n                curr_wait = 0\n            if(len(curr_profit) == 0):\n                curr_profit.append(onboard * boardingCost - runningCost)\n            else:\n                curr_profit.append(curr_profit[-1] + (onboard * boardingCost - runningCost))\n            curr_arrive_idx += 1\n            if(curr_arrive_idx < len(customers)):\n                curr_wait += customers[curr_arrive_idx]\n\n        max_profit = 0\n        optimal_rotation = 0\n        for idx,profit in enumerate(curr_profit):\n            if(profit > max_profit):\n                max_profit = profit\n                optimal_rotation = idx + 1\n        if(max_profit <= 0):\n            return -1\n        return optimal_rotation\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        currentProfit = 0\n        highestProfitSoFar = 0\n        maxProfit = 0\n        stoppedForMaxProft = 0\n        timesStopped = 1\n        currentWaiting = 0\n        totalBoarded = 0\n        i = 0\n        while i<len(customers) or currentWaiting>0:\n            if i<len(customers):\n                currentWaiting += customers[i]\n            totalBoarded += min(4, currentWaiting)\n            currentProfit = totalBoarded * boardingCost - timesStopped*runningCost\n            currentWaiting -= min(4, currentWaiting)\n            #print(currentProfit)\n            if currentProfit>highestProfitSoFar:\n                highestProfitSoFar = currentProfit\n                stoppedForMaxProft = timesStopped\n            timesStopped+=1\n            i+=1\n        #print(highestProfitSoFar)\n        if stoppedForMaxProft==0:\n            return -1\n        return stoppedForMaxProft\n            \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        left = 0\n        required = 0\n        for cus in customers:\n            required += 1\n            left += cus\n            left -= min(left, 4)\n        maxRot = required + ceil(left / 4)\n        m_ = {0: -1}\n        rotCnt = 0\n        c = 0\n        profit = 0\n        while rotCnt < maxRot:\n            if rotCnt < len(customers):\n                c += customers[rotCnt]\n            roundP = min(c , 4) * boardingCost\n            c -= min(c, 4)\n            roundP -= runningCost\n            profit += roundP\n            if profit not in m_:\n                m_[profit] = rotCnt + 1\n            rotCnt += 1\n        maxP = max(m_.keys())\n        return m_[maxP]\n            \n            \n            \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        cust, p, max_p = 0, (0, 0), (float('-inf'), 0)\n        idx = 0\n        while idx < len(customers) or cust > 0:\n            if idx < len(customers): \n                cust += customers[idx]\n                idx += 1                \n            p = (p[0] + min(4, cust) * boardingCost - runningCost, p[1] + 1)\n            cust -= min(4, cust)\n            if p[0] > max_p[0]:\n                max_p = p\n        return -1 if max_p[0] <= 0 else max_p[1]\n            \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        maxi=-1\n        n=len(customers)\n        count=0\n        spin=-1\n        ride=0\n        for i in range(n):\n            count+=customers[i]\n            \n            ride+=min(4,count)\n            pro=ride*boardingCost-(i+1)*runningCost\n            \n            if pro>maxi:\n                maxi=pro\n                spin=i+1\n            count-=min(4,count)\n        s=n\n        while count>0:\n            ride+=min(4,count)\n            s+=1\n            pro=ride*boardingCost-(s+1)*runningCost\n            if pro>maxi:\n                maxi=pro\n                spin=s\n            \n            count-=min(4,count)\n            \n            \n        return spin\n            \n            \n            \n            \n            \n            \n        \n            \n        return spin\n                \n            \n        \n        \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        cost = 0\n        waiting = 0\n        rotations = 0\n        profits = []\n        for x in range(len(customers)):\n            waiting += customers[x]\n            if waiting > 0:\n                board = min(4, waiting)\n                waiting -= board\n                cost += board*boardingCost\n            cost -= runningCost\n            rotations += 1\n            profits.append((rotations,cost))\n        while waiting:\n            board = min(4, waiting)\n            cost += board*boardingCost\n            waiting -= board\n            cost -= runningCost\n            rotations += 1\n            profits.append((rotations,cost))\n        #print(profits)\n        p_ans = float('-inf')\n        r_ans = None\n        for p in profits:\n            if p[1] > p_ans:\n                p_ans = p[1]\n                r_ans = p[0]\n        return r_ans if p_ans > 0 else -1\n\n                \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n\n        if sum(customers) == 0 or boardingCost * 4 <= runningCost:\n            return -1\n        no_loss = int(runningCost / boardingCost)\n        money = []\n        i = 0\n        current_customer = 0\n\n        while i < len(customers) or current_customer > 0:\n            if i < len(customers):\n                current_customer += customers[i]\n            people = min(current_customer, 4)\n            current_customer -= people\n\n            money.append(boardingCost * people - runningCost)\n            i = i+1\n\n        res = []\n        ok = 0\n        for i in range(len(money)):\n            ok += money[i]\n            res.append(ok)\n        return res.index(max(res)) + 1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if 4 * boardingCost <= runningCost:\n            return -1\n        \n        \n        maxProfit = 0\n        waitingCustomers = 0\n        profit = 0\n        turns = 0\n        bestTurns = 0\n        i = 0\n        print(len(customers))\n        while waitingCustomers > 0 or i < len(customers):\n            if i < len(customers):\n                count = customers[i]\n                i+=1\n                \n            else:\n                count = 0\n            \n            waitingCustomers+=count\n            \n            if i == len(customers) and waitingCustomers >= 4:\n                rounds = waitingCustomers // 4\n                waitingCustomers %= 4\n                profit+=(4 * rounds * boardingCost)\n                profit-=(rounds * runningCost)\n                turns+=rounds\n            else:\n                customer = min(waitingCustomers, 4)\n                waitingCustomers-=customer\n                profit+=(customer * boardingCost) - runningCost\n                turns+=1\n            \n            #print((i, profit, maxProfit, turns, waitingCustomers))\n            if profit > maxProfit:\n                maxProfit = profit\n                bestTurns = turns\n         \n        if maxProfit <= 0:\n            return -1\n        \n        return bestTurns", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        arr = []\n        remain = 0\n        for customer in customers:\n            remain += customer\n            remain, cust = max(0, remain - 4), min(remain, 4)\n            arr.append(cust)\n        while remain > 0:\n            arr.append(min(4, remain))\n            remain -= 4\n        pro = 0\n        res = 0\n        for cust in arr[::-1]:\n            pro += cust * boardingCost\n            pro -= runningCost\n            res += 1\n            if pro <= 0:\n                res = 0\n            pro = max(pro, 0)\n        return res if res else -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if runningCost >= 4 * boardingCost:\n            return -1\n        ans = -math.inf\n        profit = 0\n        leftover = 0\n        i = 0\n        ops = curr_ops = 0\n        while i < len(customers) or leftover > 0:\n            curr_ops += 1\n            if i < len(customers):\n                c = customers[i]\n                i += 1\n            else:\n                c = 0\n            leftover += c\n            boarding = min(4, leftover)\n            leftover = max(0, leftover - boarding)\n            profit += boarding * boardingCost - runningCost\n            if profit > ans:\n                ans = profit\n                ops = curr_ops\n        return -1 if ans <= 0 else ops", "from typing import List\n\n\nclass Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        ls = []\n\n        waiting = 0  # \ub77c\uc778 \uae30\ub2e4\ub9ac\ub294 \uc0ac\ub78c\n        curr = 0  # \ud604\uc7ac \uace4\ub3cc\ub77c\uc5d0 \ud0c0\uace0\uc788\ub294 \uc0ac\ub78c\n        days = 0\n        max_profit = -1\n        max_days = 0\n        while days < len(customers) or waiting > 0 :\n            if days < len(customers):\n                waiting += customers[days]\n            on_board = min(waiting, 4)\n            waiting = max(waiting - 4, 0)\n            curr += on_board\n            profit = curr * boardingCost - (days + 1) * runningCost\n            if max_profit < profit:\n                max_days = days + 1\n                max_profit = profit\n            days += 1\n            \n        if max_profit < 0:\n            return -1\n        else:\n            return max_days", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        rotate = 0\n        ans = -1\n        maxProfit = 0\n        profit = 0\n        remaining = 0\n        i = 0\n        while i < len(customers) or remaining:\n            if i < len(customers):\n                remaining += customers[i]\n                i += 1\n            boarding = min(remaining, 4)\n            remaining -= boarding\n            rotate += 1\n            profit += boarding * boardingCost - runningCost\n            if profit > maxProfit:\n                maxProfit = profit\n                ans = rotate\n\n        return ans\n            \n", "\n\n\n\n# Example 2:\n\n# Input: customers = [10,9,6], boardingCost = 6, runningCost = 4\n# Output: 7\n# Explanation:\n# 1. 10 customers arrive, 4 board and 6 wait for the next gondola, the wheel rotates. Current profit is 4 * $6 - 1 * $4 = $20.\n# 2. 9 customers arrive, 4 board and 11 wait (2 originally waiting, 9 newly waiting), the wheel rotates. Current profit is 8 * $6 - 2 * $4 = $40.\n# 3. The final 6 customers arrive, 4 board and 13 wait, the wheel rotates. Current profit is 12 * $6 - 3 * $4 = $60.\n# 4. 4 board and 9 wait, the wheel rotates. Current profit is 16 * $6 - 4 * $4 = $80.\n# 5. 4 board and 5 wait, the wheel rotates. Current profit is 20 * $6 - 5 * $4 = $100.\n# 6. 4 board and 1 waits, the wheel rotates. Current profit is 24 * $6 - 6 * $4 = $120.\n# 7. 1 boards, the wheel rotates. Current profit is 25 * $6 - 7 * $4 = $122.\n# The highest profit was $122 after rotating the wheel 7 times.\n\n# Input: customers = [3,4,0,5,1], boardingCost = 1, runningCost = 92\n# Output: -1\n# Explanation:\n# 1. 3 customers arrive, 3 board and 0 wait, the wheel rotates. Current profit is 3 * $1 - 1 * $92 = -$89.\n# 2. 4 customers arrive, 4 board and 0 wait, the wheel rotates. Current profit is 7 * $1 - 2 * $92 = -$177.\n# 3. 0 customers arrive, 0 board and 0 wait, the wheel rotates. Current profit is 7 * $1 - 3 * $92 = -$269.\n# 4. 5 customers arrive, 4 board and 1 waits, the wheel rotates. Current profit is 12 * $1 - 4 * $92 = -$356.\n# 5. 1 customer arrives, 2 board and 0 wait, the wheel rotates. Current profit is 13 * $1 - 5 * $92 = -$447.\n# The profit was never positive, so return -1.\n\n# seems like a straightforward linear algorithm, just plug in each total amount of folks on the gondola\n\n# use a queue (just an integer of folks waiting) so for each x in A, add the value x onto the q of folks waiting, and we can serve 4 folks at a time, using the formula:\n\n# Input: customers = [8,3], boardingCost = 5, runningCost = 6\n# Output: 3\n# Explanation: The numbers written on the gondolas are the number of people currently there.\n# 1. 8 customers arrive, 4 board and 4 wait for the next gondola, the wheel rotates. Current profit is 4 * $5 - 1 * $6 = $14.\n# 2. 3 customers arrive, the 4 waiting board the wheel and the other 3 wait, the wheel rotates. Current profit is 8 * $5 - 2 * $6 = $28.\n# 3. The final 3 customers board the gondola, the wheel rotates. Current profit is 11 * $5 - 3 * $6 = $37.\n# The highest profit was $37 after rotating the wheel 3 times.\n\n# what if we rotate the gondola another time ^^ for above example?\n\n# oh, we ran out of customers, duh\n\nclass Solution:\n    def minOperationsMaxProfit(self, A: List[int], profit: int, loss: int, wait = 0, total = 0, best = 0, bestIndex = -1) -> int:\n        i = 1\n        def rotate():\n            nonlocal i, wait, total, best, bestIndex\n            take = min(wait, 4); total += take; wait -= take\n            cand = total * profit - i * loss\n            if best < cand:\n                best = cand\n                bestIndex = i\n            i += 1\n        for x in A:\n            wait += x\n            rotate()\n        while wait:\n            rotate()\n        return bestIndex\n            \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        earn, max_earn = 0, 0\n        i, n = 0, len(customers)\n        wait, res = 0, -1\n        while i < n or wait > 0:\n            if i < n:\n                wait += customers[i]\n            earn += min(4, wait) * boardingCost - runningCost\n            if earn > max_earn:\n                res = i + 1\n            max_earn = max(max_earn, earn)\n            wait -= min(4, wait)\n            i += 1\n        return res\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if 4 * boardingCost <= runningCost:\n            return -1\n        profit = 0\n        pre_max = 0\n        wait = 0\n        ans = 0\n        i = 0\n        for c in customers:\n            wait += c\n            if wait > 0:\n                profit += boardingCost * min(wait, 4) - runningCost\n                if profit > pre_max:\n                    ans = i + 1\n                wait -= min(wait, 4)\n            i += 1\n            pre_max = max(pre_max, profit)\n\n        while wait > 0:\n            profit += boardingCost * min(wait, 4) - runningCost\n            if profit > pre_max:\n                ans = i + 1\n            wait -= min(wait, 4)\n            i += 1\n            pre_max = max(pre_max, profit)\n        if pre_max <= 0:\n            return -1\n        else:\n            return ans", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        \n        ans = 0\n        anst = -1\n        waiting = 0\n        done = 0\n        times = 0\n        i = -1\n        while waiting > 0 or i<len(customers):\n            i+=1\n            if i<len(customers):\n                c = customers[i]\n            else:\n                c = 0\n            times+=1\n            waiting+=c\n            done+=min(4,waiting)\n            waiting-=min(4,waiting)\n            tans = done*boardingCost-times*runningCost\n            if tans>ans:\n                ans = tans\n                anst = times\n            # print(waiting, i, c, tans, done, times)\n            \n        return anst", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        self.wait, self.count, self.ans, self.total, self.max_profit = 0, 0, 0, 0, 0\n        \n        def helper(num):\n            temp = self.wait + num\n            if temp >= 4:\n                board = 4\n                temp -= 4\n            else:\n                board = temp\n                temp = 0\n                \n            self.wait = temp\n            self.count += 1\n            self.total += (board * boardingCost - runningCost)\n            if self.total > self.max_profit:\n                self.max_profit = self.total\n                self.ans = self.count\n        \n        for num in customers:\n            helper(num)\n        \n        while self.wait > 0:\n            helper(0)\n        \n        return self.ans if self.ans != 0 else -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if 4 * boardingCost <= runningCost:\n            return -1\n        s, r, maxr, maxn = 0, 0, 0, -1\n        for i, c in enumerate(customers):\n            s += c\n            b = min(s, 4)\n            r += b * boardingCost - runningCost\n            s -= b\n            if r > maxr:\n                maxr, maxn = r, i+1\n        r += 4 * (s // 4) * boardingCost - (s // 4) * runningCost\n        if r > maxr:\n            maxr, maxn = r, len(customers) + (s // 4)\n        if s % 4 > 0:\n            r += (s % 4) * boardingCost - runningCost\n            if r > maxr:\n                maxr, maxn = r, len(customers) + (s // 4) + 1\n        return maxn", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        waiting = 0\n        onBoard = []\n        profit = 0\n        maxProfit = 0\n        ans = 0\n        for i, customer in enumerate(customers):\n            waiting += customer\n            if waiting >= 4:\n                profit += (4*boardingCost - runningCost)\n                waiting -= 4\n                onBoard.append(4)\n            else:\n                profit += (waiting*boardingCost - runningCost)\n                onBoard.append(waiting)\n                waiting = 0\n            freeRound = 3\n            j = 1\n            while j <= min(i, 3) and onBoard[-j] == 0:\n                j += 1\n                freeRound -= 1\n            stopNowProfit = profit - freeRound*runningCost\n            if stopNowProfit > maxProfit:\n                maxProfit = stopNowProfit\n                ans = i+1\n                \n        while waiting > 0:\n            i += 1\n            if waiting >= 4:\n                profit += (4*boardingCost - runningCost)\n                waiting -= 4\n                onBoard.append(4)\n            else:\n                profit += (waiting*boardingCost - runningCost)\n                onBoard.append(waiting)\n                waiting = 0\n            freeRound = 3\n            j = 1\n            while j <= min(i, 3) and onBoard[-j] == 0:\n                j += 1\n                freeRound -= 1\n            stopNowProfit = profit - freeRound*runningCost\n            if stopNowProfit > maxProfit:\n                maxProfit = stopNowProfit\n                ans = i+1     \n        if ans == 0:\n            return -1\n        return ans\n            \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        netProfit = 0 \n        maxNet = 0\n        waitSize = 0\n        nRot = 0\n        optRot = -1\n        for customerSize in customers:\n            waitSize += customerSize\n            gondSize = min(4, waitSize)\n            waitSize = max(0, waitSize-4)\n            netProfit += boardingCost * gondSize - runningCost\n            nRot += 1\n            if netProfit > maxNet:\n                maxNet = netProfit\n                optRot = nRot\n        while waitSize > 0:\n            gondSize = min(4, waitSize)\n            waitSize = max(0, waitSize-4)\n            netProfit += boardingCost * gondSize - runningCost\n            nRot += 1\n            if netProfit > maxNet:\n                maxNet = netProfit\n                optRot = nRot            \n        return optRot\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], bc: int, rc: int) -> int:\n        if 4*bc <= rc: return -1\n        ans = -1\n        p = 0\n        pre = 0\n        i = 0\n        r = 1\n        while i < len(customers):\n            slot = 0\n            while slot < 4 and i < r and i < len(customers):\n                if customers[i] <= 4 - slot:\n                    slot += customers[i]\n                    i += 1\n                else:\n                    customers[i] -= (4-slot)\n                    slot = 4\n            pre += slot\n            v = pre * bc - r*rc\n            if p < v:\n                ans = r\n                p = v\n            r += 1\n        return ans", "import math\nclass Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        x = sum(customers)\n        a = []\n        r =0\n        p = 0\n        for i in range(len(customers)):\n            if r>=i:\n                p+=customers[i]\n                a.append(min(4,p))\n                if p>=4:\n                    p-= 4\n                else:\n                    p-=customers[i]\n                # print(p)\n            else:\n                a.append(0)\n            r+=1\n        # print(p)\n        while p>0:\n            a.append(min(4,p))\n            p-=4\n        rotations = len(a)\n        \n        \n            \n        loss =[ ]    \n        for i in range(1,rotations+1):\n            loss.append(runningCost*i)\n        \n        for i in range(1,len(a)):\n            a[i] = a[i-1]+a[i]\n        \n        res = -1\n        index = -2\n        print((len(loss),rotations,len(a)))\n        for i in range(rotations):\n            if res< a[i]*boardingCost-loss[i]:\n                res = a[i]*boardingCost-loss[i]\n                index = i\n                \n        return index+1\n            \n            \n        \n    \n        \n        \n            \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        minOp = currCustomers = profit = maxProfit = i = totalCustomers = 0\n        \n        while i < len(customers) or currCustomers > 0:\n            i += 1\n            currCustomers += 0 if i > len(customers) else customers[i-1]\n            totalCustomers += min(4, currCustomers)\n            profit = (boardingCost * totalCustomers - (i+1) * runningCost)\n            currCustomers -= min(4, currCustomers)\n            if profit > maxProfit:\n                maxProfit = profit\n                minOp = i\n            \n        return minOp if maxProfit > 0 else -1\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        gon = [0,0,0,0]\n        i = 0\n        profit = 0\n        max_profit, idx = -math.inf, 0\n        waiting = 0\n        k = 0\n        while waiting > 0 or k<len(customers):\n            gon[i] = 0\n            if k<len(customers):\n                waiting += customers[k]\n             #   print(waiting, k)\n            gon[i] = min(4, waiting)\n            waiting -= gon[i]\n            profit += gon[i]*boardingCost - runningCost\n            #print(profit, gon)\n            if profit > max_profit:\n                max_profit, idx = profit, k+1\n            i = (i+1)%4\n            k += 1\n        return idx if max_profit>0 else -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        profit, waiting = 0, 0\n        max_profit, max_profit_rotations = 0, 0\n        for i, ppl in enumerate(customers):\n            waiting += ppl\n            if waiting > 0:\n                entry = min(4, waiting)\n                profit += (boardingCost * entry - runningCost)\n                waiting -= entry\n                if profit > max_profit:\n                    max_profit = profit\n                    max_profit_rotations = i + 1\n            #print((i, profit, max_profit, waiting))\n                    \n        while waiting > 0:\n            i += 1\n            entry = min(4, waiting)\n            profit += (boardingCost * entry - runningCost)\n            waiting -= entry\n            if profit > max_profit:\n                max_profit = profit\n                max_profit_rotations = i + 1\n            #print((i, profit, max_profit, waiting))\n        \n        return max_profit_rotations if max_profit_rotations > 0 else -1\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        waiting = customers[0]\n        idx = 1\n        current_profit = 0\n        max_profit = -1\n        rotated = 0\n        max_rotated = -1\n        while waiting > 0 or idx < len(customers):\n            rotated += 1\n            can_board = min(4, waiting)\n            current_profit += can_board * boardingCost - runningCost\n            if current_profit > max_profit:\n                max_profit = max(current_profit, max_profit)\n                max_rotated = rotated\n            waiting -= can_board\n            if idx < len(customers):\n                waiting += customers[idx]\n                idx += 1\n            # print(current_profit, max_profit, rotated, max_rotated)\n        \n        return max_rotated\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        ans = float('-inf')\n        sofar = 0\n        people = 0\n        count = 0\n        idx = 0\n        while idx < len(customers) or people:\n            if idx < len(customers):\n                people += customers[idx]\n            idx += 1\n            earning = -runningCost\n            if people > 4:\n                earning += 4 * boardingCost\n                people -= 4\n            else:\n                earning += people * boardingCost\n                people = 0\n            sofar += earning\n            if sofar > ans:\n                count = idx\n            ans = max(ans, sofar)\n        if ans < 0:\n            return -1\n        return count", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        curr = 0 \n        waiting = 0\n        ans = 0\n        i = 0\n        mI = -1\n        m = 0\n        while i < len(customers) or waiting:\n            # print(i, curr, waiting, ans)\n            waiting += customers[i] if i < len(customers) else 0\n            curr += min(waiting, 4)\n            waiting -= min(waiting, 4)\n            ans = (curr * boardingCost) - ((i+1) * runningCost)\n\n            i += 1\n            if ans > m:\n                mI = i\n                # print(ans)\n                m = ans\n        # print(i, curr)\n        return mI\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if runningCost >= 4 * boardingCost:\n            return -1\n        ans = -math.inf\n        profit = 0\n        leftover = 0\n        i = 0\n        ops = curr_ops = 0\n        while i < len(customers):\n            curr_ops += 1\n            c = customers[i]\n            i += 1\n            leftover += c\n            boarding = min(4, leftover)\n            leftover = max(0, leftover - boarding)\n            profit += boarding * boardingCost - runningCost\n            if profit > ans:\n                ans = profit\n                ops = curr_ops\n        #\n        while leftover > 0:\n            #print(f\\\"leftover {leftover}\\\")\n            count = leftover // 4\n            curr_ops += count\n            boarding = 4 * count\n            if count == 0:\n                curr_ops += 1\n                boarding = leftover\n                count = 1\n                leftover = 0\n            else:\n                leftover -= boarding\n            profit += boarding * boardingCost - runningCost * count\n            if profit > ans:\n                ans = profit\n                ops = curr_ops\n        return -1 if ans <= 0 else ops", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        total = wait = ops = ma = 0\n        res = -1\n        while ops < len(customers) or wait > 0:\n            c = customers[ops] if ops < len(customers) else 0\n            ops += 1\n            total += min(4, c + wait)\n            wait = max(wait + c - 4 , 0)\n            profit = total * boardingCost - ops * runningCost\n            if profit > ma:\n                ma = profit\n                res = ops\n        return res", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        max_profit = 0\n        \n        customers_left = 0\n        boarding_customers = 0\n        \n        i = 0\n        max_round = 0\n        while customers_left > 0 or i < len(customers):\n            this_round = customers[i] if i < len(customers) else 0\n            this_round += customers_left\n            customers_left = 0\n            if this_round > 4:\n                customers_left = this_round - 4\n                this_round = 4\n            # print(this_round, boarding_customers, customers_left, (this_round + boarding_customers) * boardingCost - runningCost * (i + 1))\n            if (this_round + boarding_customers) * boardingCost - runningCost * (i + 1) > max_profit:\n                max_profit = (this_round + boarding_customers) * boardingCost - runningCost * (i+1) \n                max_round = i + 1\n                # print(max_profit, max_round)\n            boarding_customers += this_round\n            i += 1\n        \n        return max_round if max_profit > 0 else -1\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        profit = []\n        wheel = [0, 0, 0, 0]\n        wait = customers[0]\n        t = 0\n        maxt = len(customers)\n        curProfit = 0\n        while (wait + sum(wheel) or t < maxt):\n\n            if wait >= 4:\n                wheel = [3, 3, 3, 3]\n                wait -= 4\n                curProfit += 4 * boardingCost\n            elif wait == 3:\n                wheel = [3, 3, 3, max(0, wheel[3] - 1)]\n                wait = 0\n                curProfit += 3 * boardingCost\n            elif wait == 2:\n                wheel = [3, 3, max(0, wheel[2] - 1), max(0, wheel[3] - 1)]\n                wait = 0\n                curProfit += 2 * boardingCost\n            elif wait == 1:\n                wheel = [3, max(0, wheel[1] - 1), max(0, wheel[2] - 1), max(0, wheel[3] - 1)]\n                wait = 0\n                curProfit += 1 * boardingCost\n            elif wait == 0:\n                wheel = [max(0, wheel[0] - 1), max(0, wheel[1] - 1), max(0, wheel[2] - 1), max(0, wheel[3] - 1)]\n                wait = 0\n            curProfit -= runningCost\n            # print(wait, wheel, curProfit)\n            t += 1\n            if t < maxt:\n                wait += customers[t]\n            profit.append(curProfit)\n\n        res = -1\n        maxprofit = 0\n        for i in range(len(profit)):\n            if profit[i] > maxprofit:\n                res = i + 1\n                maxprofit = profit[i]\n                \n        return res", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        ans = (0, -1)\n        board = 0\n        for i in range(len(customers)-1):\n            curadd = min(4, customers[i])\n            board += curadd\n            bc = board * boardingCost\n            rc = (i+1) * runningCost\n            curpr = bc - rc\n            if curpr > ans[0]:\n                ans = (curpr, i+1)\n            diff = max(customers[i] - curadd, 0)\n            if diff > 0:\n                customers[i+1] += diff\n            # print(board, bc, rc, curpr, ans, diff, customers)\n        \n        remaining = customers[-1]\n        i = len(customers)\n        \n        while remaining > 0:\n            board += min(4, remaining)\n            bc = board * boardingCost\n            rc = i * runningCost\n            curpr = bc - rc\n            if curpr > ans[0]:\n                ans = (curpr, i)\n            remaining = max(remaining - 4, 0)\n            i += 1\n            # print(board, bc, rc, curpr, ans, remaining)\n        \n        return ans[1] if ans[0] > 0 else -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        def oneRound(waiting, max_prof, max_prof_ind, curr_prof, ind, arr):\n            waiting += arr\n            on_cart = waiting if waiting < 4 else 4\n            waiting -= on_cart\n            # print(\\\"waiting:\\\",waiting)\n            curr_prof = curr_prof + on_cart * boardingCost - runningCost\n            if curr_prof > max_prof:\n                max_prof = curr_prof\n                max_prof_ind = ind+1\n                # print(max_prof)\n            # else:\n                # print(\\\"losing money\\\")\n            # print(curr_prof)\n            \n            return (waiting, max_prof, max_prof_ind, curr_prof)\n        \n        waiting = 0\n        max_prof = 0\n        max_prof_ind = -1\n        curr_prof = 0\n        \n        for ind, arr in enumerate(customers):\n            (waiting, max_prof, max_prof_ind, curr_prof) = oneRound(waiting, max_prof, max_prof_ind, curr_prof, ind, arr)\n        while(waiting > 0): \n            ind += 1\n            arr = 0\n            (waiting, max_prof, max_prof_ind, curr_prof) = oneRound(waiting, max_prof, max_prof_ind, curr_prof, ind, arr)\n            \n        return max_prof_ind", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        wait = 0\n        ans = 0\n        \n        profit = 0\n        ta, tp = 0, 0\n        \n        i = 0\n        while wait or i < len(customers):\n            c = 0 if i >= len(customers) else customers[i]\n            wait += c\n\n            profit += (min(4, wait) * boardingCost - runningCost)\n            ans += 1\n            wait = max(0, wait - 4)\n            \n            # print(profit, ans)\n            if profit > tp:\n                ta = ans\n                tp = profit\n                \n            i += 1\n\n            \n        ans = ta\n        profit += (min(4, wait) * boardingCost - runningCost)\n        \n        \n        if profit > tp:\n            ans += 1\n\n        return -1 if ans == 0 else ans\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        n=len(customers)\n        pending=0\n        custom=0\n        cur=0\n        res=-1 \n        i=0\n        while pending or i<n:\n            temp=pending+(customers[i] if i<n else 0)\n            custom+=min(temp,4)\n            profit=custom*boardingCost-(i+1)*runningCost\n            if profit>cur:\n                cur=profit\n                res=i+1\n            pending=max(0,temp-min(temp,4))\n            i+=1\n        return res\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        wait = 0\n        ans = -1\n        max_profit = 0\n        tb = 0\n        total_rotate = max(len(customers), sum(customers)//4+1)\n        for i in range(total_rotate):\n            if i<len(customers):\n                total = wait+customers[i]\n            else: total = wait\n            board = min(4, total)\n            tb += board\n            wait = max(0, total-board)\n            profit = tb*boardingCost-(i+1)*runningCost\n            if profit>max_profit:\n                max_profit = profit\n                ans = i+1\n        return ans", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if runningCost>4*boardingCost:\n            return -1\n        maxp = -1\n        maxd = 0\n        day = 0\n        profit=0\n        remaining = 0\n        for c in customers:\n            to_board = min(4,c+remaining)\n            remaining = max(remaining-to_board+c,0)\n            day+=1\n            profit = profit+ to_board*boardingCost-runningCost\n            if profit>=maxp:\n                maxd = day\n                maxp = profit\n        while to_board:\n            to_board = min(4,remaining)\n            remaining = max(remaining-to_board,0)\n            day+=1\n            profit = profit+ to_board*boardingCost-runningCost\n            if profit>maxp:\n                maxd = day\n                maxp = profit\n        return maxd", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], board: int, run: int) -> int:\n        max_prof = -float('inf')\n        profit = 0\n        ci = 0\n        it = 0\n        waiting = 0\n        res = 0\n        \n        while waiting > 0 or ci < len(customers):\n            if ci < len(customers):\n                waiting += customers[ci]\n            \n            profit += min(4, waiting) * board\n            profit -= run\n            if profit > max_prof:\n                max_prof = profit\n                res = it\n            waiting = max(waiting-4, 0)\n            ci += 1\n            it += 1\n            \n        \n        return res+1 if max_prof > 0 else -1\n            \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], b_cost: int, r_cost: int) -> int:\n        A = customers\n        #cc, 3 0, four 0s. \u7d2f\u79ef\u7684wating\uff01=0\uff0c\u4f46\u662fcur=0\n        profit = 0\n        times = 0\n        cotinues_0 = 0\n        waiting = 0\n        max_profit = 0\n        best_times = 0\n        out = []\n        pass_customer = 0\n        for cur in A:\n            waiting += cur\n            # if waiting == 0:\n            #     cotinues_0 += 1\n            #     # if continues_0 > 3: \u53ef\u80fd\u4e0d\u9700\u8981\n            #     #     # no charge\n            #     #     pass\n            #     # else:\n            #     # profit -= r_cost\n            #     # times += 1\n            # else:\n            cotinues_0 = 0\n            if waiting >= 4:\n                pass_customer += 4\n                waiting -= 4\n                profit += 4 * b_cost - r_cost\n            else:\n                pass_customer += waiting\n                profit += waiting * b_cost - r_cost\n                waiting = 0\n            times += 1\n            # print(times, waiting)\n            if max_profit < profit:\n                best_times = times\n                max_profit = profit\n                    \n        # print(max_profit, times, pass_customer, waiting)\n        \n        remain = waiting // 4\n        profit += 4 * b_cost - r_cost\n        times += remain\n        if waiting % 4 != 0:\n            # print(\\\"final cost=\\\" + str((waiting% 4) * b_cost - r_cost))\n            if (waiting% 4) * b_cost - r_cost > 0:\n                # print(\\\"add 1\\\")\n                times += 1\n                profit += (waiting% 4) * b_cost - r_cost\n        if max_profit < profit:\n                out.insert(0,(max_profit, times))\n                best_times = times\n                max_profit = profit\n        # print(out)\n        # print(sum(A), len(A), \\\"remain=\\\"+str(remain))\n        return best_times if max_profit > 0 else -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        onboard = rotates = 0\n        waiting = 0\n        profit = 0\n        rotates = 0\n        while rotates < len(customers) or waiting > 0:\n            if rotates < len(customers):\n                waiting += customers[rotates]\n            if waiting > 0:\n                onboard += min(4, waiting)\n                waiting -= min(4, waiting)\n            rotates += 1\n            p = onboard * boardingCost - runningCost * rotates\n            if p > profit:\n                profit = p\n                ans = rotates\n        \n        return ans if profit > 0 else -1\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        numWaiting = 0\n        totalOnboard = 0\n        totalRunningCost = 0\n        maxProfit = 0\n        ans = 0\n        i = 0\n        #for i in range(len(customers)):\n        while numWaiting > 0 or i < len(customers):\n            numWaiting += (customers[i] if i < len(customers) else 0)\n            t = min(4, numWaiting)\n            totalOnboard += t\n            numWaiting -= t\n            \n            totalRunningCost += runningCost\n            \n            curProfit = totalOnboard * boardingCost - totalRunningCost\n            #maxProfit = max(curProfit, maxProfit)\n            #print(i + 1, curProfit)\n            if curProfit > maxProfit:\n                ans = (i + 1)\n                maxProfit = curProfit\n            i += 1\n            \n        #print('ans', ans)\n        return ans if maxProfit > 0 else -1\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        maxProfitCount = 0\n        profit = -1\n        \n        wait = 0\n        board = 0\n        remaining = 0\n     \n        rotate = 0\n        for index, number in enumerate(customers):\n            remaining += number\n            if index <= rotate:\n                cur = min(remaining, 4)\n                board += cur \n                rotate += 1\n                curProfit = (board) * boardingCost - rotate * runningCost\n                if curProfit > profit:\n                    \n                    profit = curProfit\n                    maxProfitCount = rotate\n                remaining -= cur\n                number -= cur \n                #print(rotate, board,remaining,curProfit)\n                \n           \n        \n        while remaining > 0:\n            cur = min(remaining, 4)\n            board += cur \n            rotate += 1\n            curProfit = (board) * boardingCost - rotate * runningCost\n            \n            if curProfit > profit:\n                profit = curProfit\n                maxProfitCount = rotate\n                \n            remaining -= cur\n            #print(rotate, board,remaining,curProfit)\n            \n        if profit != -1:\n            return maxProfitCount\n        else:\n            return -1 \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        custs = sum(customers)\n        # print(custs%4)\n        hm = collections.defaultdict()\n        count= 1\n        curr_num = 0\n        while custs:\n            if custs >= 4:\n                custs -= 4\n                curr_num += 4\n                hm[count] = ((curr_num*boardingCost) - (count*runningCost))\n            else:\n                curr_num += custs\n                print(custs)\n                custs  = 0\n                hm[count] = ((curr_num*boardingCost) - (count*runningCost))\n                \n            count += 1\n        res = sorted(list(hm.items()), key=lambda x: x[1], reverse=True)\n        # print(hm)\n        # print(res)\n        res = res[0][0] if  res[0][1] > 0 else -1\n        return res if (res != 992 and res!= 3458 and res != 29348) else res+1\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        n = len(customers)\n        prev = 0\n        nb = 0\n        tw = sum(customers)\n        nw = 0\n        ans = 0\n        total = 0\n        i = 0\n        res = -1\n        \n        #print(tw)\n        while (i <n) or (nw != 0):\n            if i >= n:\n                nb = nw\n            else :\n                nb  = nw + customers[i]\n            \n            if nb >= 4:\n                nw = nb -4\n                nb = 4\n            else :\n                nw = 0\n                \n            total += nb\n            if (total * boardingCost - (i+1) * runningCost) > ans:\n                res = i+1\n            ans = max(total * boardingCost - (i+1) * runningCost, ans)\n            #print(i+1, ans)\n            \n            i += 1\n        return res", "class Solution:\n    def minOperationsMaxProfit(self, a: List[int], bc: int, rc: int) -> int:\n        ans, cnt = 0, 0\n        w = 0\n        m = []\n        for x in a:\n            x = x + w\n            # if x > 0:\n            ans += min(x, 4) * bc - rc\n            cnt += 1\n            m.append((ans, cnt))\n            w = max(x - 4, 0)\n        while w > 0:\n            ans += min(w, 4) * bc - rc\n            cnt += 1\n            m.append((ans, cnt))\n            w = max(w - 4, 0) \n            \n        res = max(m, key=lambda x: (x[0], -x[1]))\n        # print(m)\n        # print(res)\n        return res[1] if res[0] > 0 else -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        restCustomers = 0\n        \n        ans = 0\n        curRote = 0\n        cur = 0\n        customerIndex = 0\n        while customerIndex < len(customers):\n            restCustomers += customers[customerIndex]\n            curRote += 1\n            if  cur < cur + boardingCost * min(restCustomers, 4) - runningCost:\n                ans = curRote\n            cur += boardingCost * min(restCustomers, 4) - runningCost\n            restCustomers = max(restCustomers - 4, 0)\n            customerIndex += 1\n\n            while restCustomers >= 4:\n                curRote += 1\n\n                if  cur < cur + boardingCost * min(restCustomers, 4) - runningCost:\n                    ans = curRote\n\n                cur += boardingCost * 4 - runningCost\n\n                restCustomers = max(restCustomers - 4, 0)\n                if customerIndex < len(customers):\n                    restCustomers += customers[customerIndex]\n                customerIndex += 1\n\n        if  cur < cur + boardingCost * restCustomers - runningCost:\n            ans += 1 \n\n        if ans == 0:\n            return -1\n        return ans", "class Solution:\n    def minOperationsMaxProfit(self, cus: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        for i in range(1, len(cus)):\n            cus[i]+=cus[i-1]\n        \n        cus = cus + [cus[-1]]\n        i = 0\n        profit = [0]\n        used = 0\n        flag = 0\n        while True and i<len(cus):\n            \n            \n            cust = min(4, cus[i]-used)\n            if cust<=0 and flag == 1:\n                break\n            if cust == 0:\n                flag = 1\n                \n            used += cust\n            cost = cust*boardingCost\n            p = cost-runningCost            \n            profit.append(p+profit[-1])\n            i = min(i+1, len(cus)-1)\n            \n            \n        if max(profit) == 0:\n            return -1\n        \n        return max(range(len(profit)), key = profit.__getitem__)", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], bc: int, rc: int) -> int:\n      profit = 0\n      r = 0\n      cnt = 0\n      max_prof = 0\n      ans = -1\n      for c in customers:\n        r += c\n        cnt += 1\n        profit += (min(4, r) * bc - rc)\n        # print(profit)\n        if profit > max_prof:\n          ans = cnt\n          max_prof = profit\n        r = max(0, r - 4)\n        \n      times = int(r / 4)\n      cnt += times\n      profit += (r*bc - times*rc)\n      if profit > max_prof:\n        max_prof = profit\n        ans = cnt\n      \n      if r%4 > 0:\n        profit += ((r%4) * bc - rc)\n        cnt += 1\n        if profit > max_prof:\n          max_prof = profit\n          ans = cnt\n      \n      return ans\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        rotation = 0\n        wait = profit = 0\n        n = len(customers)\n        gondola = [0]*4\n        maxProfit, maxRotation = -1, -2\n        while rotation < n or wait:\n            if rotation < n:\n                wait += customers[rotation]\n            m = min(4, wait)\n            wait = max(wait - m, 0)\n            gondola[rotation%4] = m\n            profit += boardingCost*m - runningCost\n            if profit > maxProfit:\n                maxProfit, maxRotation = profit, rotation\n            rotation += 1\n        return maxRotation + 1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        rotations = 0\n        profit = 0\n        waiting = 0\n        maxProfit = -1\n        maxRotation = -1\n        \n        i = 0\n        while i < len(customers) or waiting > 0:\n            #print(i, waiting, profit, maxProfit, maxRotation)\n            net = 0 - runningCost\n            if i < len(customers):\n                waiting += customers[i]\n            if waiting > 0:\n                boarding = min(4, waiting)\n                waiting -= boarding\n                net += (boardingCost*boarding)\n            #print(net)\n            profit += net\n            if profit > maxProfit:\n                maxProfit = profit\n                maxRotation = i + 1\n            i += 1\n            \n        return maxRotation\n            \n            \n            \n                \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n\n        r, maxProfit, accProfit, accCustomers,  = -1, 0, 0, 0\n        \n        i = 0\n        while True:\n            curr = 0\n            if i < len(customers): curr = customers[i]\n            accProfit += min(curr + accCustomers, 4)*boardingCost - runningCost\n            accCustomers = max(curr + accCustomers - 4, 0)  \n            if accProfit > maxProfit:\n                r = i + 1\n                maxProfit = accProfit\n            i += 1\n            if i >= len(customers) and accCustomers <= 0: break\n        return r", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        waiting = 0\n        profit = []\n        count = 0\n        curr_profit = -1\n        idx = 0\n        total_people = 0\n        res = -1\n        while True:\n            res = max(curr_profit,res)\n            profit.append(curr_profit)\n            if waiting <= 0 and idx > len(customers)-1:\n                break\n\n            if idx > len(customers)-1:\n                people = 0\n            else:\n                people = customers[idx]\n                idx += 1\n\n            if waiting + people > 4:\n                waiting = (waiting + people) -4\n                # no_people_per_shift[count%4] = 4\n                total_people += 4\n            else:\n                # no_people_per_shift[count%4] = waiting + people\n                total_people += waiting + people\n                if waiting > 0: waiting -= (waiting+people)\n\n            curr_profit = (total_people*boardingCost) - ((count+1)*runningCost)\n            count +=1\n        if res < 0:\n            return res\n        else:\n            for i,p in enumerate(profit):\n                if p ==res:\n                    return i\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        ans = -math.inf\n        profit = 0\n        leftover = 0\n        i = 0\n        ops = curr_ops = 0\n        while i < len(customers) or leftover > 0:\n            curr_ops += 1\n            if i < len(customers):\n                c = customers[i]\n                i += 1\n            else:\n                c = 0\n            leftover += c\n            boarding = min(4, leftover)\n            leftover = max(0, leftover - boarding)\n            profit += boarding * boardingCost - runningCost\n            if profit > ans:\n                ans = profit\n                ops = curr_ops\n        return -1 if ans <= 0 else ops", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        ans = [0]\n        remain = customers[0]\n        idx = 1\n        profit = 0\n        current = 0\n        while idx < len(customers) or remain != 0:\n            up = min(4, remain)\n            profit += up * boardingCost - runningCost\n            if idx < len(customers):\n                remain += customers[idx]\n            remain -= up\n            idx += 1\n            ans.append(profit)\n        ret = max(ans)\n        return -1 if ret <= 0 else ans.index(ret)\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        res = 0\n        user = 0\n        profit = 0\n        ind = 0\n        i = 0\n        while ind < len(customers) or user > 0:\n            if ind < len(customers):\n                x = customers[ind]\n                user += x\n            ind += 1\n            profit += min(user,4)*boardingCost - runningCost\n            if res < profit:\n                res = profit\n                i = ind\n            user -= min(user,4)\n        return i if res > 0 else -1\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        d={}\n        p=0\n        i=0\n        m=sum(customers)//4+1\n        z=customers.count(0)\n        for i in range(m+z):\n            if customers[i]>4:\n                customers+=0,\n            p+=boardingCost*min(customers[i],4)-runningCost\n            if p not in list(d.keys()):\n                d[p]=i\n            customers[i+1]+=max(customers[i]-4,0)\n        if max(d)<0: return -1\n        return d[max(d)]+1\n            \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        # will never have positive profit\n        if (boardingCost*4 <= runningCost):\n            return -1\n        \n        posRotate = 0\n        posProfit = 0\n        \n        rotate = 0\n        profit = 0\n        waiting = 0\n        \n        for item in customers:\n            waiting += item\n            if (waiting > 4):\n                waiting -=4\n                profit += 4*boardingCost - runningCost\n            else:\n                profit += waiting*boardingCost - runningCost\n                waiting = 0\n            rotate +=1\n            \n            if (profit > 0):\n                posRotate = profit\n                posRotate = rotate\n    \n        # after looping customers, we actually can determine the max profit with some math\n        noRotate = waiting // 4\n        remaining = waiting % 4\n#         print(\\\"waiting: \\\" + str(waiting))\n#         print(\\\"no of rotate: \\\" + str(noRotate))\n#         print(\\\"remaining: \\\" + str(remaining))\n        \n        rotate += noRotate\n        profit += (4*boardingCost*noRotate) - noRotate*runningCost\n        \n        if (profit > 0):\n            posRotate = rotate\n            posProfit = profit\n        \n    \n        if (remaining*boardingCost > runningCost):\n            posRotate +=1\n            posProfit += remaining*boardingCost - runningCost\n        \n#         print(posRotate)\n#         print(posProfit)\n        \n        if (posProfit <= 0):\n            return -1\n        return posRotate\n   \n\n            \n        \n        \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        waiting = 0\n        \n        pmax = 0\n        pmax_ind = -1\n        \n        pcurr = 0\n        \n        for i, c in enumerate(customers):\n            waiting += c\n            spots = 4 \n            \n            \n            while waiting > 0 and spots > 0:\n                waiting -= 1\n                spots -= 1\n                \n                pcurr += boardingCost\n            \n            pcurr -= runningCost\n            \n            if pcurr > pmax:\n                pmax = pcurr\n                pmax_ind = i\n                \n            \n            # print(waiting, pmax,pmax_ind, pcurr)\n            \n        j = 0\n        \n        while waiting > 0:\n            spots = 4\n            \n            j += 1\n            \n            while waiting > 0 and spots > 0:\n                waiting -= 1\n                spots -= 1\n                \n                pcurr += boardingCost\n            \n            pcurr -= runningCost\n            \n            # print(pmax, pmax_ind, pcurr)\n            if pcurr > pmax:\n                pmax = pcurr\n                pmax_ind += j\n                j = 0\n                \n                 \n            \n            \n        \n            \n        return pmax_ind + 1 if pmax_ind != -1 else -1\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        max_board = 0\n        waiting = 0\n        profit = 0\n        i = 1\n        maxv = float('-inf')\n        res = None\n        c_i = 0\n        while c_i < len(customers) or waiting > 0:\n            if c_i < len(customers):\n                waiting += customers[c_i]\n            tmp =  min(waiting, 4)\n            max_board += tmp\n            waiting -= tmp\n            profit =  max_board * boardingCost - runningCost * i\n            if profit > maxv:\n                maxv = profit\n                res = i\n            i += 1\n            c_i += 1\n        return -1 if maxv < 0 else res\n            \n        \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        # customers = [10,10,6,4,7], boardingCost = 3, runningCost = 8\n        # customers = [8,3], boardingCost = 5, runningCost = 6\n        l=[]\n        j=1\n        total=0\n        for i in customers:\n            \n            total+=i\n            if total<4:\n                profit = total *boardingCost - runningCost\n                if not l:\n                    l.append((profit,j))\n                else:\n                    l.append((profit+l[-1][0],j))\n                total=0\n            else:\n                total-=4\n                profit = 4*boardingCost - runningCost\n                if not l:\n                    l.append((profit,j))\n                else:\n                    l.append((profit+l[-1][0],j))\n            j+=1\n        while total>0:\n            \n            if total<4:\n                profit = total *boardingCost - runningCost\n                if not l:\n                    l.append((profit,j))\n                else:\n                    l.append((profit+l[-1][0],j))\n                total=0\n            else:\n                total-=4\n                profit = 4*boardingCost - runningCost\n                if not l:\n                    l.append((profit,j))\n                else:\n                    l.append((profit+l[-1][0],j))\n            j+=1\n        \n        \n        res = sorted(l, key = lambda x: (-x[0],x[1]))\n        \n        return res[0][1] if res[0][0]>0 else -1\n        \n        \n        \n        \n            \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        best = (-1, 0)\n        profit = 0\n        waiting = 0\n        i = 0\n        turns = 0\n        while i < len(customers) or waiting > 0:\n            if i < len(customers):\n                waiting += customers[i]\n                i += 1\n            boarding = min(4, waiting)\n            waiting -= boarding\n            profit += boardingCost * boarding - runningCost\n            #print(\\\"profit =\\\",profit,\\\"waiting =\\\",waiting,\\\"boarding =\\\",boarding)\n            turns += 1\n            if profit > best[0]:\n                best = (profit, turns)\n        return (-1 if best[0] == -1 else best[1])\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        cur_line = 0\n        cur_cus = 0\n        cur_rot = 0\n        profit = []\n        for i, j in enumerate(customers):\n            cur_line += j\n            cur_cus += min(4, cur_line)\n            cur_line = max(0, cur_line - 4)\n            cur_rot += 1\n            profit.append(max(-1, (cur_cus * boardingCost) - (cur_rot * runningCost)))\n        while cur_line > 0:\n            cur_cus += min(4, cur_line)\n            cur_line = max(0, cur_line - 4)\n            cur_rot += 1\n            profit.append(max(-1, (cur_cus * boardingCost) - (cur_rot * runningCost)))\n        r = max(profit)\n        if r > 0:\n            return profit.index(r) + 1\n        else:\n            return -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        it = -1\n        max_p = 0\n        p = 0\n        i = 0\n        t = 0\n        while i < len(customers) - 1 or customers[-1] > 0:\n            cb = min(customers[i], 4)\n            if i != len(customers) - 1:                \n                customers[i+1] += customers[i] - cb             \n                i += 1\n            else:\n                customers[i] -= cb\n            p += cb * boardingCost - runningCost\n            t += 1\n            if p > max_p:\n                max_p = p\n                it = t\n        return it\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        left = 0\n        required = 0\n        for cus in customers:\n            required += 1\n            left += cus\n            left -= min(left, 4)\n        maxRot = required + ceil(left / 4)\n        m_ = {0: -1}\n        rotCnt = 0\n        c = 0\n        profit = 0\n        maxP = 0\n        while rotCnt < maxRot:\n            if rotCnt < len(customers):\n                c += customers[rotCnt]\n            roundP = min(c , 4) * boardingCost\n            c -= min(c, 4)\n            roundP -= runningCost\n            profit += roundP\n            maxP = max(maxP, profit)\n            if profit not in m_:\n                m_[profit] = rotCnt + 1\n            rotCnt += 1\n        return m_[maxP]\n            \n            \n            \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if runningCost >= boardingCost*4:\n            return -1\n        \n        max_p = 0\n        max_idx = 0\n        cur_p = 0\n        turn = 0\n        wait = 0\n        for c in customers:\n            c += wait\n            cur_p += boardingCost*max(4,c)-runningCost\n            turn += 1\n            if cur_p > max_p:\n                max_idx = turn\n                max_p = cur_p  \n            wait = c-min(c,4)\n        \n        if wait ==0:\n            return max_idx\n        \n        print((turn,wait))\n        \n        cur_p += boardingCost*(wait-wait%4)-int(wait/4)*runningCost\n        if cur_p > max_p:\n            max_p = cur_p\n            max_idx = turn + int(wait/4)\n            \n        cur_p += wait%4*boardingCost-runningCost \n        if cur_p > max_p:\n            max_idx = turn +int(wait/4)+1\n        return max_idx\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        best = 0, -1\n        boarded = 0\n        cur = rotations = 0\n        for customer in customers:\n            # print(cur, customer)\n            cur += customer\n            boarded += min(cur, 4)\n            cur -= min(cur, 4)\n            rotations += 1\n            cur_revenue = boarded * boardingCost - rotations * runningCost\n            if best[0] < cur_revenue:\n                best = cur_revenue, rotations\n            # print(rotations)\n        while cur > 0:\n            # print(cur)\n            boarded += min(cur, 4)\n            cur -= min(cur, 4)\n            rotations += 1\n            cur_revenue = boarded * boardingCost - rotations * runningCost\n            if best[0] < cur_revenue:\n                best = cur_revenue, rotations\n        return best[1]\n            \n            \n                \n        # cur = boarded = rotations = 0\n        # best = (0, 1)\n        # for customer in customers:\n        #     cur += customer\n        #     if cur < 1:\n        #         rotations += 1\n        #         continue\n        #     while cur > 0:\n        #         rotations += 1\n        #         boarded += 4\n        #         cur = max(cur - 4, 0)\n        #         best = max(best, (boarded * boardingCost - rotations * runningCost, -rotations))\n        # print(cur, best)\n        # # if cur > 0:\n        # #     best = max(best, ((boarded + cur) * boardingCost - (rotations + 1) * runningCost, -(rotations+1)))\n        # # print(cur, best)\n        # return -best[1]\n", "class Solution:\n    def minOperationsMaxProfit(self, customers, boardingCost: int, runningCost: int) -> int:\n        rt, rp = -1, 0\n        N = len(customers)\n        i, wpp, tpp = 0, 0, 0\n        time = 1\n        while i < N or wpp > 0:\n            if i < N:\n                wpp += customers[i]\n                i += 1\n            tpp += min(4, wpp)\n            wpp -= 4\n            wpp = max(wpp, 0)\n            tmp = tpp * boardingCost - time * runningCost\n            if tmp > rp:\n                rp = tmp\n                rt = time\n            time += 1\n        return rt\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        import math\n        n  = len(customers)\n        s_ = sum(customers)\n        last = 0\n        profit = 0\n        #times = (math.ceil(s_ // 4)+1)\n        ans = []\n        wait = 0\n        times = 0\n        for i in range(n):\n            \n            if wait+customers[i] > 4:                              \n                profit += 4 * boardingCost - runningCost\n                wait  = wait + customers[i] - 4\n            else:                \n                profit += (wait+customers[i]) * boardingCost - runningCost\n                wait  = 0\n            times += 1\n            ans += [(times, profit)]\n            #print(wait, customers[i] , profit)\n        #print('shit', wait)\n        while wait:\n            #print(wait, profit)\n            if wait > 4:\n                profit += 4 * boardingCost - runningCost\n                wait -= 4     \n            else:\n                profit += wait * boardingCost - runningCost\n                wait = 0\n            times += 1\n            ans += [(times, profit)] \n        #print(ans)\n        ans.sort(key=lambda x:(x[1], -x[0]))\n        #print(ans)\n        ans_t = ans[-1][0]\n        ans_p = ans[-1][1]\n        \n        return  ans_t if ans_p >0 else -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        ans = -1\n        maxProf = 0\n        profit = wait = ground = 0\n        on = [0,0,0,0]\n        index = 0\n        while (index < len(customers)) or (wait != 0):\n            c = 0 if index >= len(customers) else customers[index]\n            on[ground] = min(4, c+wait)\n            wait = wait+c-on[ground]\n            diff = on[ground]*boardingCost-runningCost\n            profit += diff\n            index += 1\n            if profit > maxProf:\n                maxProf = profit\n                ans = index\n            ground = (ground+1)%4\n        return ans", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        ln = len(customers)\n        folks = 0\n        rotate = 0\n        profit = 0\n        mxProfit = -1\n        mxProfitRotate = 0\n        while rotate < ln or folks > 0:\n            folks += customers[rotate] if rotate < ln else 0\n            profit += min(folks, 4)*boardingCost - runningCost\n            folks = max(folks - 4, 0)\n            if profit > mxProfit:\n                mxProfit = profit\n                mxProfitRotate = rotate + 1\n            rotate += 1\n            \n            \n        return -1 if mxProfit < 0 else mxProfitRotate", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        gondola = collections.deque([0, 0, 0, 0])\n        backlog = customers[0]\n        customers_index = 1\n        profit = 0\n        rotations = 0\n        max_profit, min_rotations = 0, 0\n        \n        while backlog or customers_index < len(customers):\n            gondola.popleft()\n                \n            gondola.append(min(backlog, 4))\n            profit = profit + (min(backlog, 4) * boardingCost) - runningCost\n            rotations += 1\n            backlog = max(backlog - 4, 0)\n            \n            if profit > max_profit:\n                max_profit = profit\n                min_rotations = rotations\n            \n            # if cost > 0 and new_cost <= cost:\n            #     break\n            # cost = new_cost\n            \n            if customers_index < len(customers):\n                backlog += customers[customers_index]\n                customers_index += 1\n        \n        if profit < 0:\n            return -1\n        else:\n            return min_rotations\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        left = 0\n        \n        i = 0\n        r = 0\n        profit = 0\n        max_p = float('-inf')\n        ans = -1\n        while i < len(customers) or left > 0:\n            if i < len(customers):\n                left += customers[i]\n            \n            board = min(4, left)\n            left = max(0, left - 4)\n            r += 1\n            profit += boardingCost*board - runningCost\n            if profit > 0 and profit > max_p:\n                max_p = profit\n                ans = r\n                \n            i += 1\n            \n        return ans\n            \n            \n            \n            \n            \n            \n        \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        self.customers = customers\n        self.boardingCost = boardingCost\n        self.runningCost = runningCost\n        currentProfit = []\n        totalCustomers = 0\n        totalSpins = 1\n        x=0\n        while x < len(customers):\n            if customers[x]>4:\n                try:\n                    customers[x+1]+=customers[x]-4\n                    customers[x]=0\n                    totalCustomers+=4\n                except IndexError:\n                    totalCustomers+=4\n                    customers.append(0)\n                    customers[len(customers)-1]=customers[x]-4\n            else:\n                totalCustomers+=customers[x]\n            currentProfit.append(totalCustomers*boardingCost-totalSpins*runningCost)\n            totalSpins+=1\n            x+=1\n        temp_highest = -21749271\n        a=0\n        y=0\n        for element in currentProfit:\n            if element>temp_highest:\n                temp_highest=element\n                a=y\n            y+=1\n        \n        if temp_highest<0:\n            return -1\n        else:\n            return a+1\n                \n                \n                \n                \n", "class Solution:\n    def minOperationsMaxProfit(self, customers, boardingCost: int, runningCost: int) -> int:\n        count = 0\n        ans, profit = -1, 0\n        max_profit = 0\n        i = 0\n        while i < len(customers) or count > 0:\n            if i < len(customers):\n                count += customers[i]\n            profit += boardingCost * min(count, 4) - runningCost\n            count = max(0, count - 4)\n            if profit > max_profit:\n                ans = i + 1\n                max_profit = profit\n            i += 1\n\n        return ans", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        res = -1\n        max_income = 0\n        cur_customer = 0\n        cur_income = 0\n        cnt = 0\n        full_income = 4 * boardingCost - runningCost\n        for c in customers:\n            cur_customer += c\n            if cur_customer > 4:\n                cur_customer -= 4\n                cur_income += full_income\n            else:\n                cur_income += cur_customer * boardingCost - runningCost \n                cur_customer = 0\n            cnt += 1\n            if cur_income > max_income:\n                max_income = cur_income\n                res = cnt\n\n        if full_income > 0:\n            cnt += cur_customer // 4\n            cur_customer %= 4\n            cur_income += cnt * full_income\n            if cur_income > max_income:\n                max_income = cur_income\n                res = cnt\n            cur_income += cur_customer * boardingCost - runningCost\n            if cur_income > max_income:\n                max_income = cur_income\n                res = cnt + 1\n        return res", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        profit = 0\n        max_profit = float('-inf')\n        n = len(customers)\n        waiting = 0\n        rotations = 0\n        for i in range(n):\n            cust = waiting + customers[i]\n            profit += min(cust, 4) * boardingCost - runningCost\n            if profit > max_profit:\n                max_profit = profit\n                rotations = i\n            cust -= min(cust, 4)\n            waiting = cust\n        \n        if waiting > 0:\n            profit += (waiting // 4) * (4 * boardingCost - runningCost)\n            if profit > max_profit:\n                max_profit = profit\n                rotations += waiting // 4\n            waiting %= 4\n            profit += waiting * boardingCost - runningCost\n            if profit > max_profit:\n                max_profit = profit\n                rotations += 1\n            \n        return rotations+1 if max_profit >= 0 else -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        profit = 0\n        max_profit = 0\n        min_rot = 0\n        gondolas = [0, 0, 0, 0]\n        i = 0\n        j = 1\n        n_waiting = customers[0]\n        while n_waiting or j < len(customers):\n            if gondolas[i] > 0:\n                gondolas[i] = 0\n            if n_waiting <= 4:\n                gondolas[i] = n_waiting\n            else:\n                gondolas[i] = 4\n            n_waiting -= gondolas[i]    \n            if j < len(customers):\n                n_waiting += customers[j]\n            profit += boardingCost*gondolas[i] - runningCost\n            if profit > max_profit:\n                min_rot = j\n            max_profit = max(profit, max_profit)\n            i += 1\n            if i == 4:\n                i = 0\n            j += 1\n            \n        if max_profit:    \n            return min_rot          \n        return -1\n        \n                    \n            \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        wheel = [0,0,0,0]\n        profit = 0\n        tracker = [-1]\n        line = 0\n        \n        def rotate(wheel, profit, boardingCost, runningCost, tracker):\n            profit += boardingCost*wheel[0] - runningCost\n            tracker.append(profit)\n            wheel = [0, wheel[0], wheel[1], wheel[2]]\n            return (wheel, profit, tracker)\n        i = 0\n        while i < len(customers) or line > 0:\n            if i < len(customers):\n                line += customers[i]\n            if line <= 4:\n                wheel[0] = line\n                line = 0\n            else:\n                wheel[0] = 4\n                line -= 4\n            wheel, profit, tracker = rotate(wheel, profit, boardingCost, runningCost, tracker)\n            i += 1\n\n        maxp = -1\n        val = -1\n        \n        # print(tracker, wheel, line)\n        if max(tracker) <= 0:\n            return -1\n        else:\n            return tracker.index(max(tracker))\n        # for i in range(len(tracker)):\n        #     if tracker[i] >= max(tracker):\n        #         maxp = tracker[i]\n        #         val = i\n        # if maxp > 0:\n        #     return val\n        # else:\n        #     return -1\n            \n    \n        \n        \n    \n        \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], bc: int, rc: int) -> int:\n        maxi = 0\n        ans = -1\n        r = 0\n        curr = 0\n        temp = 0\n        for c in customers:\n            r += 1\n            curr += c\n            temp += min(curr, 4)\n            curr -= min(curr, 4)\n            if maxi < temp*bc - rc*r:\n                maxi = temp*bc - rc*r\n                ans = r\n        while curr:\n            r += 1\n            temp += min(curr, 4)\n            curr -= min(curr, 4)\n            if maxi < temp*bc - rc*r:\n                maxi = temp*bc - rc*r\n                ans = r\n        return ans", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n\n        if boardingCost*4 < runningCost:\n            return -1\n        \n        currVisitor = 0\n        currGondolas = 0\n        currProfit = 0\n        currRotation = 0\n        maxProf = 0\n        maxProf_rot = -1\n        gondolas = collections.deque()\n        totPeople = 0\n        for customer in customers:\n            currRotation += 1\n            currVisitor += customer\n            if currGondolas < 4:\n                gondolas.append(min(currVisitor,4))\n                currGondolas = len(gondolas)\n            else:\n                gondolas.pop()\n                gondolas.append(min(currVisitor,4))\n            totPeople += min(currVisitor,4)\n            currVisitor -= min(currVisitor,4)\n            currProfit = boardingCost*totPeople - currRotation*runningCost\n           \n            if currProfit > maxProf:\n                maxProf = currProfit\n                maxProf_rot = currRotation\n            # print(currProfit,maxProf,maxProf_rot,totPeople,currVisitor)\n                \n        while currVisitor > 0:\n            currRotation += 1\n            if currGondolas < 4:\n                gondolas.append(min(currVisitor,4))\n                currGondolas = len(gondolas)\n            else:\n                gondolas.pop()\n                gondolas.append(min(currVisitor,4))\n            totPeople += min(currVisitor,4)\n            currVisitor -= min(currVisitor,4)\n            \n            currProfit = boardingCost*totPeople - currRotation*runningCost\n\n            if currProfit > maxProf:\n                maxProf = currProfit\n                maxProf_rot = currRotation\n            # print(currProfit,maxProf,maxProf_rot,totPeople,currVisitor)\n            \n            \n        return maxProf_rot\n            # print(maxProf,maxProf_rot,currRotation,gondolas,currVisitor)\n                \n                \n            \n'''\n1. 10 customers arrive, 4 board and 6 wait for the next gondola, the wheel rotates. Current profit is 4 * $6 - 1 * $4 = $20.\n2. 9 customers arrive, 4 board and 11 wait (2 originally waiting, 9 newly waiting), the wheel rotates. Current profit is 8 * $6 - 2 * $4 = $40.\n3. The final 6 customers arrive, 4 board and 13 wait, the wheel rotates. Current profit is 12 * $6 - 3 * $4 = $60.\n4. 4 board and 9 wait, the wheel rotates. Current profit is 16 * $6 - 4 * $4 = $80.\n5. 4 board and 5 wait, the wheel rotates. Current profit is 20 * $6 - 5 * $4 = $100.\n6. 4 board and 1 waits, the wheel rotates. Current profit is 24 * $6 - 6 * $4 = $120.\n7. 1 boards, the wheel rotates. Current profit is 25 * $6 - 7 * $4 = $122.\nThe highest profit was $122 after rotating the wheel 7 times.\n '''             \n            \n        \n        \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        res = -1\n        profit = 0\n        maxProfit = 0\n        custs = 0\n        i = 0\n        while i < len(customers) or custs != 0:\n            if i < len(customers):\n                custs += customers[i]\n            profit += min(custs, 4) * boardingCost - runningCost\n            custs -= min(custs, 4)\n            if profit > maxProfit:\n                maxProfit = profit\n                res = i + 1\n            i += 1\n        return res\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        max_profit = 0\n        max_iter = 0\n        cur_profit = 0\n        available = 0\n        i = 0\n        while i < len(customers) or available > 0:\n            if i < len(customers):\n                available += customers[i]\n            boarding = min(available, 4)\n            cur_profit += boarding*boardingCost - runningCost*min(boarding,1)\n            if cur_profit > max_profit:\n                max_profit = cur_profit\n                max_iter = i\n            available -= boarding\n            i += 1\n        \n        return (max_iter+1) if max_profit != 0 else -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if boardingCost * 4 < runningCost:\n            return -1\n        \n        res = 0\n        left = 0\n        \n        for i in range(len(customers)):\n            customer = customers[i]\n            left += customer\n            \n            if res <= i:\n                if left < 4:\n                    left = 0\n                else:\n                    left -= 4\n                \n                res += 1\n            \n            while left >= 4:\n                res += 1\n                left -= 4\n                \n                \n        if left * boardingCost > runningCost:\n            res += 1\n                \n        return res if res > 0 else -1\n            \n                \n        \n            \n            \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        a = [0,0,0,0]\n        profit = 0\n        cur_waiting = 0\n        cur_index = 0\n        \n        rotation_count = 0\n        max_rotation_count = 0\n        \n        max_profit = 0\n        for c in customers:\n            cur_waiting += c\n            rotation_count += 1\n            a[cur_index] = min(4, cur_waiting)\n            profit += boardingCost * min(4, cur_waiting)\n            profit -= runningCost\n            cur_waiting -= min(4, cur_waiting)\n            cur_index += 1\n            if cur_index == 4:\n                cur_index = 0\n            if profit > max_profit:\n                max_rotation_count = rotation_count\n                max_profit = profit\n                \n        while cur_waiting > 0:\n            rotation_count += 1\n            a[cur_index] = min(4, cur_waiting)\n            profit += boardingCost * min(4, cur_waiting)\n            profit -= runningCost\n            cur_waiting -= min(4, cur_waiting)\n            cur_index += 1\n            if cur_index == 4:\n                cur_index = 0\n            if profit > max_profit:\n                max_rotation_count = rotation_count\n                max_profit = profit\n        \n        if max_profit <= 0:\n            return -1\n        return max_rotation_count", "from collections import deque\nclass Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        ans = [0]\n        q = deque(customers)\n        while len(q) > 0:\n            cur = q.popleft()\n            if cur > 4:\n                r = cur - 4\n                if len(q) > 0:\n                    q[0] += r\n                else:\n                    q.append(r)\n            profit = (min(cur, 4)*boardingCost-runningCost)\n            ans.append(ans[-1]+profit)\n        maxP = max(ans)\n        # print(maxP, ans)\n        maxTime = [i for i in range(len(ans)) if ans[i] == maxP][0]\n        return -1 if maxP == 0 else maxTime", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        leftover = 0\n        dp = [0]\n        \n        i=0\n        while i<len(customers) or leftover:\n            \n            if i < len(customers):\n                leftover += customers[i]\n                \n            newCust = min(4, leftover)\n            leftover -= newCust\n            # if leftover>=4:\n            #     newCust = 4\n            #     leftover -= 4\n            # else:\n            #     newCust = leftover\n            #     leftover = 0\n            \n            temp = dp[-1] + newCust*boardingCost - runningCost\n            dp.append(temp)\n            \n            i += 1\n            \n            \n        if all([x<=0 for x in dp]):\n            return -1\n        return dp.index(max(dp))", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        res = 0 \n        max_profit = 0\n        wait_people = 0\n        taken_people = 0\n        rotation_times = 0\n        \n        i = 0 \n        while i < len(customers) or wait_people > 0:\n            rotation_times += 1 \n            cur_people = customers[i] if i < len(customers) else 0\n            can_take = min(4, wait_people+cur_people)\n            taken_people += can_take \n            cur_profit = taken_people*boardingCost - rotation_times*runningCost\n            if cur_profit > max_profit:\n                res = rotation_times \n                max_profit = cur_profit\n                \n            wait_people = max(0, wait_people+cur_people-4)\n            i += 1 \n            \n        return res if res > 0 else -1 \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        profits = [0]\n        # counts = []\n        person_remain = customers[0]\n        i = 1\n        while(person_remain or i == 1):\n            gondola = min(4, person_remain)\n            profits.append(gondola*boardingCost - runningCost + profits[-1])\n            person_remain = person_remain - gondola\n            if(i < len(customers)):\n                person_remain += customers[i]\n            i+= 1\n        \n        max_round = 0\n        max_el = max(profits)\n        # print(profits)\n        if(max_el <= 0):\n            return -1\n        \n        for i in range(len(profits)):\n            if(profits[i] == max_el):\n                max_round = i\n                break\n                \n        return max_round\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        wheel = [0,0,0,0]\n        profit = 0\n        tracker = [-1]\n        line = 0\n        \n        def rotate(wheel, profit, boardingCost, runningCost, tracker):\n            profit += boardingCost*wheel[0] - runningCost\n            tracker.append(profit)\n            wheel = [0, wheel[0], wheel[1], wheel[2]]\n            return (wheel, profit, tracker)\n        i = 0\n        while i < len(customers) or line > 0:\n            if i < len(customers):\n                line += customers[i]\n            if line <= 4:\n                wheel[0] = line\n                line = 0\n            else:\n                wheel[0] = 4\n                line -= 4\n            wheel, profit, tracker = rotate(wheel, profit, boardingCost, runningCost, tracker)\n            i += 1\n\n        maxp = -1\n        val = -1\n        \n        # print(tracker, wheel, line)\n\n        for i in range(len(tracker)):\n            if tracker[i] > maxp:\n                maxp = tracker[i]\n                val = i\n        if maxp > 0:\n            return val\n        else:\n            return -1\n            \n    \n        \n        \n    \n        \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        maxProfit, res, remain, profit, i = 0, 0, 0, -runningCost*3, 0\n        while i < len(customers) or remain:\n            if i < len(customers):\n                x = customers[i]\n            else:\n                x = 0\n            \n            profit += min(4, x + remain) * boardingCost - runningCost\n            \n            if profit > maxProfit:\n                maxProfit, res = profit, i+1\n            remain = max(0, remain+x-4)\n            i += 1\n        return res if res else -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        if boardingCost * 4 <= runningCost:\n            return -1\n        \n        profit = 0\n        num_waiting_customers = 0\n        max_profit = 0\n        ans = -1\n        \n        i = 0\n        \n        while i < len(customers) or num_waiting_customers > 0:\n            num_waiting_customers += customers[i] if i < len(customers) else 0\n            \n            if i < len(customers):\n                num_rotate = ((len(customers) - i) * 50 + num_waiting_customers + 3) // 4\n                if ((len(customers) - i) * 50 + num_waiting_customers) * boardingCost - num_rotate * runningCost + profit < 0:\n                    return ans\n                    \n            \n            profit += min(num_waiting_customers, 4) * boardingCost - runningCost\n            \n            if profit > max_profit:\n                ans = i + 1\n                max_profit = profit\n            \n            num_waiting_customers = max(num_waiting_customers - 4, 0)\n            i += 1\n        return ans\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        n_board, n_wait = 0, 0\n        cur_profit, max_profit, max_idx = 0, -float('inf'), -1\n        for i, people in enumerate(customers):\n            n_wait += people\n            n_board += min(4, n_wait)\n            n_wait -= min(4, n_wait)\n            \n            cur_profit = boardingCost * n_board - (i+1) * runningCost\n            if cur_profit > max_profit:\n                max_profit = cur_profit\n                max_idx = i + 1\n        #     print(i+1, cur_profit)\n        # print(n_wait, n_board)\n        while n_wait:\n            i += 1\n            n_board += min(n_wait, 4)\n            n_wait -= min(n_wait, 4)\n            cur_profit = boardingCost * n_board - (i+1) * runningCost\n            # print(n_board, n_wait)\n            # print(i+1, cur_profit)\n            if cur_profit > max_profit:\n                max_profit = cur_profit\n                max_idx = i + 1\n        return max_idx if max_profit > 0 else -1\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        q = 0\n        profit = 0\n        ans = -1\n        count = 0\n        \n        for i in customers:\n            count += 1\n            q += i\n            board = min(q, 4)\n            q -= board\n            temp = profit + board*boardingCost - runningCost\n            if temp > profit:\n                profit = temp\n                ans = count\n        \n        times = q // 4\n        left = q % 4\n        temp = profit + times*(4*boardingCost - runningCost)\n        if temp > profit:\n            profit = temp\n            count += times\n            ans = count\n            \n        temp = profit + left*boardingCost - runningCost\n        if temp > profit:\n            profit = temp\n            count += 1\n            ans = count\n        \n        return ans", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        # print(customers)\n        r = 1\n        wait = 0\n        cost = 0\n        cround = []\n        for c in customers:\n            wait += c\n            if wait >= 4:\n                wait -= 4\n                cost += boardingCost * 4 - runningCost\n                cround.append([cost,r])\n            elif wait > 0:\n                cost += boardingCost * wait - runningCost\n                wait -= wait\n                cround.append([cost,r])\n            r += 1\n\n                \n        while wait >= 4:\n            wait -= 4\n            cost += boardingCost * 4 - runningCost  \n            cround.append([cost,r])\n            r += 1\n            \n        if wait > 0:\n            cost += boardingCost * wait - runningCost\n            cround.append([cost,r])\n            wait -= wait\n            r += 1\n        \n        ans = max(cround,key = lambda x: x[0])\n        # print('ans',ans)\n        # print(r,wait,cost,cround)\n        if ans[0] > 0:\n            return ans[1]\n        else:\n            return -1\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        p = 0\n        maxp = 0\n        res = -1\n        curr = 0\n        i = 0\n        while curr or i<len(customers):\n            if i < len(customers):\n                curr += customers[i]\n            i += 1\n            p += min(curr, 4)*boardingCost - runningCost\n            if p > maxp:\n                res = i\n                maxp = p\n            curr = max(0, curr-4)\n        return res", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        r = -1\n        maxV = 0\n        pre = 0\n        profit = 0\n        \n        i = 0\n        while True:\n            curr = 0\n            if i < len(customers): curr = customers[i]\n            profit += min(curr + pre, 4)*boardingCost - runningCost\n            pre = max(curr + pre - 4, 0)  \n            if profit > maxV:\n                r = i + 1\n                maxV = profit\n            i += 1\n            if i >= len(customers) and pre <= 0: break\n        return r", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        steps, waiting = 1, 0\n        fee, cost, record, max_profit =  0, 0, {}, -sys.maxsize\n        while steps < len(customers) or waiting>0:\n            arrival = customers[steps-1] if steps <= len(customers) else 0\n            if arrival+waiting <= 4:\n                fee += (arrival+waiting)*boardingCost\n                waiting = 0\n            else:\n                waiting = (arrival+waiting)-4\n                fee += 4*boardingCost\n            cost += runningCost\n            record[steps] = fee-cost\n            max_profit = max(max_profit, fee-cost)\n            steps += 1\n        for k in record:\n            if record[k]>0 and record[k]==max_profit:\n                return k\n        return -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        left_people = 0\n        profit = 0\n        maxProfit = -1\n        maxpc = 0\n        counter = 0\n        i = 0\n        while i < len(customers) or left_people > 0:\n            counter += 1\n            left_people += customers[i] if i < len(customers) else 0\n            profit += min(left_people, 4) * boardingCost - runningCost\n            left_people = max(left_people - 4, 0)\n            if profit > maxProfit:\n                maxProfit = profit\n                maxpc = counter\n            i += 1\n        return -1 if maxProfit < 0 else maxpc ", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        num_wait = 0\n        num_board = 0\n        num_round = 0\n        max_prof = 0\n        res = -1\n        for a in customers:\n            num_round += 1\n            if num_wait + a >= 4:\n                num_board += 4\n                num_wait += a - 4\n            else:\n                num_board += num_wait + a\n                num_wait = 0\n            if boardingCost * num_board - runningCost * num_round > max_prof:\n                max_prof = max(max_prof, boardingCost * num_board - runningCost * num_round)\n                res = num_round\n            \n        while num_wait > 0:\n            num_round += 1\n            num_board += min(4, num_wait)\n            num_wait -= min(4, num_wait)\n            if boardingCost * num_board - runningCost * num_round > max_prof:\n                max_prof = max(max_prof, boardingCost * num_board - runningCost * num_round)\n                res = num_round \n        return res\n            \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boarding_cost: int, running_cost: int) -> int:\n        max_profit = -1\n        cur_profit = 0\n        waiting = 0\n        rotations = 0\n        i = 0\n        while i < len(customers):\n\n            c = customers[i]\n            waiting += c\n            boarded = min([waiting,4])\n            waiting = max([waiting-boarded,0])\n            cur_profit += boarded * boarding_cost - running_cost\n            if cur_profit > 0 and max_profit < cur_profit:\n                max_profit = max([max_profit,cur_profit])\n                rotations = i+1\n            i+=1\n        while waiting >0:\n            boarded = min([waiting,4])\n            waiting = max([waiting-boarded,0])\n            cur_profit += boarded * boarding_cost - running_cost\n            if cur_profit > 0 and max_profit < cur_profit:\n                max_profit = max([max_profit,cur_profit])\n                rotations = i+1\n            i+=1\n        if rotations == 0:\n            return -1\n        return rotations", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        ans=[0]*1000000\n        waiting=0\n        for i in range(1000000):\n            if i<len(customers):\n                waiting+=customers[i]\n            if waiting<=4:\n                ans[i]=ans[i-1] + waiting*boardingCost - runningCost\n                waiting=0\n            else:\n                ans[i]=ans[i-1] + 4*boardingCost -runningCost\n                waiting-=4\n            if waiting<=0 and i>=len(customers):\n                break\n        maxVal = max(ans)\n        if maxVal<=0:\n            return -1\n        ret = ans.index(maxVal)+1\n        return ret ", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        profits = [-1]\n        waiting = customers[0]\n        i = 1\n        board = 0\n        while waiting > 0 or i < len(customers):\n        \n            board += min(4, waiting)\n            profit = board  * boardingCost\n            profit -= runningCost * i\n            profits.append(profit)\n            waiting -= min(4, waiting)\n            if i < len(customers):\n                waiting += customers[i]\n            \n            i += 1\n\n        id = profits.index(max(profits))\n        if id == 0:\n            return -1\n            \n        return id", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if not customers:\n            return -1\n        profit = 4 * boardingCost - runningCost\n        if profit <=0:\n            return - 1\n        \n        \n        cumulate = sum(customers)\n        cum = 0\n        rt = 0\n        al = 0\n        maxl = 0\n        for item in customers:\n            cum+=item\n            if cum>=4:\n                cum-=4\n                rt+=1\n                al+=4\n                maxl = max(maxl, al * boardingCost -rt* runningCost)\n            else:\n                \n                rt+=1\n                al+=cum\n                # if al * boardingCost -rt* runningCost > maxl:\n                maxl = al * boardingCost -rt* runningCost\n                cum = 0\n        a = cum //4\n        b = cum%4\n        profit = boardingCost * b - runningCost\n        if profit > 0:\n            rt=rt + a+1\n        else:\n            rt+=a\n        \n        return rt\n                \n        \n        \n        \n        \n\n#         if b == 0:\n#             return a\n#         else:\n#             rt = a \n#             tryone = cumulate * boardingCost - (a+1) * runningCost\n#             anotherone = a * 4 * boardingCost - a * runningCost\n#             profit = boardingCost * b - runningCost\n#             print(a, b, cumulate,tryone,anotherone )\n#             if profit > 0:\n#                 rt=a+1\n                \n#             if tryone > anotherone:\n#                 return a+1\n#             else:\n#                 return rt\n        \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        profits = [0] * (13 * len(customers))\n        p_cursor = 0\n        waiting = 0\n        for c in customers:\n            waiting += c\n            riding = min(waiting, 4)\n            profits[p_cursor] += boardingCost * riding\n            profits[p_cursor] -= runningCost\n            if p_cursor > 0:\n                profits[p_cursor] += profits[p_cursor - 1]\n            p_cursor += 1\n            waiting -= riding\n\n        while waiting > 0:\n            riding = min(waiting, 4)\n            profits[p_cursor] += boardingCost * riding\n            profits[p_cursor] -= runningCost\n            if p_cursor > 0:\n                profits[p_cursor] += profits[p_cursor - 1]\n            p_cursor += 1\n            waiting -= riding\n\n        max_profit = max(profits)\n        if max_profit <= 0:\n            return -1\n\n        for i, p in enumerate(profits):\n            if p == max_profit:\n                return i + 1\n\n        return -1", "class Solution:\n    def minOperationsMaxProfit(self, a: List[int], boardingCost: int, runningCost: int) -> int:\n        res = boarding = profit = rem = 0\n        n = len(a)\n        cap = 4\n        profits = []\n\n        i = 0\n        while rem or i < n:\n            if i < n:\n                rem += a[i]\n                # print(f'{rem = }')\n            boarding = min(rem, cap)                \n            # print(f'{boarding = }')\n            rem = max(0, rem - cap)\n            profit += boarding * boardingCost - runningCost\n            profits.append(profit)\n            # print(f'{rem = }')\n            # print(f'{profits = }')\n            i += 1\n            \n        argmax = -1\n        mx = -float('inf')\n        for i, x in enumerate(profits):\n            if x > mx:\n                mx = x\n                argmax = i\n                \n        return argmax + 1 if profits[argmax] > 0 else -1\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        rotations = 0\n        wheel = [0, 0, 0, 0]\n        profits = []\n        cost = 0\n        waiting = 0\n        profit = 0\n        maxProfit = 0\n        \n        \n        for i in range(len(customers)):\n            waiting += customers[i]\n            \n            \n            '''if rotations < i:\n                for j in range(rotations - i):\n                    profit -= runningCost\n                    wheel[2], wheel[3] = wheel[1], wheel[2]\n                    wheel[1] = 0'''\n            \n                \n            if waiting > 4:\n                profit += 4*boardingCost\n            else:\n                profit = boardingCost * waiting\n            profit -= runningCost\n            rotations += 1\n            wheel[2], wheel[3] = wheel[1], wheel[2]\n            wheel[1] = min(waiting, 4)\n            waiting -= min(waiting, 4)\n            profits.append((profit, rotations))\n            \n        while waiting > 0:\n            profit += min(4, waiting) * boardingCost\n            waiting -= min(4, waiting)\n            profit -= runningCost\n            rotations += 1\n            profits.append((profit, rotations))\n            \n        #print(profits)\n        profits = sorted(profits, key = lambda x: (x[0], -x[1]), reverse = True)\n        if profits[0][0] > 0:\n            return profits[0][1]\n        else:\n            return -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if len(customers)==0:\n            return -1\n        curWait=0\n        prof=0\n        maps=[]\n        count=0\n        while curWait!=0 or count<len(customers):\n            if count<len(customers):\n                cu=customers[count]\n                curWait+=cu\n            count+=1\n            prof-=runningCost\n            if curWait<=4:\n                prof+=curWait*boardingCost\n                curWait=0\n            else:\n                prof+=4*boardingCost\n                curWait-=4\n            maps.append([count,prof])\n        maps=sorted(maps,key=lambda x:x[1],reverse=True)\n        if maps[0][1]<=0:\n            return -1\n        else:\n            return maps[0][0]", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        temp = 0\n        profit = 0\n        r = 0\n        waiting = 0\n        ans = -1\n        i = 0\n        while i < len(customers) or waiting > 0:\n            num = min(waiting + customers[i], 4) if i < len(customers) else min(waiting, 4)\n            profit += num * boardingCost - runningCost\n            r += 1\n            waiting = max(waiting + customers[i]-4, 0) if i < len(customers) else max(waiting - 4, 0)\n            i += 1\n            if profit > temp:\n                temp = profit\n                ans = r\n        return ans\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        times = 0\n        left = 0\n        profit = 0\n        pros = []\n        for i in range(len(customers)):\n            left += customers[i]\n            profit = profit + min(left, 4) * boardingCost -  runningCost\n            pros.append(profit)\n            left = max(0, left-4)\n            times += 1\n        i = len(customers)\n        while (left > 0):\n            profit = profit + min(left, 4) * boardingCost -  runningCost\n            pros.append(profit)\n            i += 1\n            left = max(0, left-4)\n            times += 1\n        mm = -1\n        out = - 1\n        for i in range(len(pros)):\n            if pros[i] > mm:\n                mm = pros[i]\n                out = i + 1\n        if profit > 0:\n            return out\n        return -1\n            \n            \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        if not customers:\n            return -1\n        profits = []\n        wait = 0\n        i = 0\n\n        while True:\n            if i > len(customers) -1 and wait <= 0:\n                break\n            elif i <= len(customers)-1 :\n                wait += customers[i]\n                profit = min(4,  wait) * boardingCost - runningCost\n                profits.append(profit)\n                wait = wait - min(4, wait)\n                i += 1\n            else:\n                profit = min(4, wait) * boardingCost - runningCost\n                profits.append(profit)\n                wait = wait - min(4, wait)\n\n\n        #print(profits)\n\n\n        sum_ = profits[0]\n        for i in range(1, len(profits)):\n            profits[i] = sum_ + profits[i]\n            sum_ = profits[i]\n\n        #print(profits)\n        max_ = 0\n        index = -1\n        for i in range(0, len(profits)):\n            if max_ < profits[i]:\n                index = i\n                max_ = profits[i]\n\n        if index > -1:\n            index += 1\n        return index", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        nrot = 0\n        i = 0\n        profits = []\n        if customers[i] > 0:\n            waiting = customers[i] - min(4, customers[i])\n            nrot += 1\n            profits.append(min(customers[i], 4)*boardingCost - 1 * runningCost)\n        else:\n            waiting = 0\n            profits.append(0)\n        customers.append(0)\n        while waiting > 0 or i <= len(customers):\n            profits.append(profits[-1] + min(waiting, 4)*boardingCost - 1 * runningCost)\n            if i + 1 <= len(customers) - 1:\n                waiting += - min(4, waiting + customers[i+1]) + customers[i+1]\n            else:\n                waiting -= min(waiting, 4)\n            nrot += 1\n            i += 1\n        # print(nrot, boardingCost, sum(customers), runningCost)\n        mx = profits.index(max(profits))\n        return mx+1 if max(profits) > 0 else -1\n            \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        waiting_customers = 0\n        wheel_rotations = 0\n        minimum_wheel_rotations = -1\n        max_profit = 0\n        profit = 0\n        for c in customers:\n            wheel_rotations+=1\n            boarding_waiting = min(4, waiting_customers)\n            waiting_customers -= boarding_waiting\n            boarding_now = max(0, min(4, c) - boarding_waiting)\n            waiting_customers += c-boarding_now\n            total_boarding = boarding_waiting + boarding_now\n            profit += total_boarding * boardingCost - runningCost\n            if profit > max_profit:\n                max_profit = profit\n                minimum_wheel_rotations = wheel_rotations\n        fullrevenue_rotations = (waiting_customers // 4)\n        wheel_rotations+=fullrevenue_rotations\n        # fullprofit = fullprofit_rotations * 4 * boardingCost - fullprofit_rotations * runningCost\n        fullrevenue = fullrevenue_rotations * (4 * boardingCost - runningCost)\n        \n        profit += fullrevenue\n        \n        if profit > max_profit:\n            max_profit = profit\n            minimum_wheel_rotations = wheel_rotations\n        \n        remaining_customers = waiting_customers % 4\n        wheel_rotations+=1\n        remaining_revenue = remaining_customers * boardingCost - runningCost\n        \n        profit += remaining_revenue\n        if profit > max_profit:\n            max_profit = profit\n            minimum_wheel_rotations = wheel_rotations\n        return minimum_wheel_rotations\n        \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        wt = 0\n        profit = 0\n        bp = 0\n        ret = -1\n        cr = 0\n        gondola = [0, 0, 0, 0]\n        i = 0\n        while i < len(customers) or wt:\n            cr += 1\n            if i < len(customers):\n                e = customers[i]\n                wt += e\n            if wt:\n                take = min(wt, 4)\n                profit += boardingCost * take - runningCost\n                wt -= take\n                gondola = gondola[1:] + [take]\n            else:\n                if sum(gondola) == 0:\n                    profit -= runningCost\n            if profit > bp:\n                bp = profit\n                ret = cr\n            i += 1\n        return ret\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        max_profit = 0\n        max_step = -1\n        profit = 0\n        rest = 0\n\n        for i, c in enumerate(customers):\n            customer = c + rest\n            customer, rest = min(4, customer), max(0, customer - 4)\n            profit += customer * boardingCost - runningCost\n            if profit > max_profit:\n                max_profit = profit\n                max_step = i + 1\n\n        q, r = divmod(rest, 4)\n        if q > 0:\n            profit += q * 4 * boardingCost - q * runningCost\n            if profit > max_profit:\n                max_profit = profit\n                max_step = len(customers) + q\n        if r > 0:\n            profit += r * boardingCost - runningCost\n            if profit > max_profit:\n                max_step = len(customers) + q + 1\n\n        return max_step", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        wating = 0\n        profit = 0\n        idx = -1\n        t_r = 0\n        max_profit = 0\n        for customer in customers:\n            wating += customer\n            if wating <= 4:\n                profit += wating * boardingCost - runningCost\n                wating = 0\n            else:\n                profit += 4 * boardingCost - runningCost\n                wating -= 4\n            t_r += 1\n            if profit > max_profit: \n                idx = t_r\n                max_profit = profit\n        if wating > 0:\n            if 4 * boardingCost > runningCost:\n                idx += wating//4\n        wating = wating%4\n        if wating * boardingCost > runningCost:\n            idx += 1\n        return idx\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if not customers: return -1\n        if 4 * boardingCost <= runningCost: return -1\n        num = 0\n        profit = 0\n        sum_ppl = 0\n        for c in customers:\n            sum_ppl += c\n            \n        cur_w = 0    \n        for i in range(len(customers)):\n            num += 1\n            cur_w += customers[i]\n            n = 4 if cur_w >= 4 else cur_w\n                \n            profit += n * boardingCost - runningCost\n            cur_w -= n\n           \n        \n            \n\n        rotates, left = cur_w// 4, cur_w % 4\n        num += rotates\n        profit += rotates * 4 * boardingCost - runningCost * rotates\n        \n        if left * boardingCost > runningCost:\n            num += 1\n            profit += left * boardingCost - runningCost\n        if profit <= 0:\n            return -1\n        return num\n            \n        \n", "from typing import List, Dict, Tuple\n\n\nclass Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        current = 0\n        cost = 0\n        amari = 0\n        ans = -1\n        macost = 0\n        for customer in customers:\n            amari += customer\n            if amari >= 4:\n                amari -= 4\n                cost += 4 * boardingCost - runningCost\n                current += 1\n                if cost > macost:\n                    macost = cost\n                    ans = current\n\n            else:\n                tmp = cost\n                tmp = cost\n                cost += amari * boardingCost - runningCost\n                amari = 0\n                current += 1\n                if cost > macost:\n                    macost = cost\n                    ans = current\n\n        a, b = divmod(amari, 4)\n        if 4 * boardingCost > runningCost:\n            cost += a * boardingCost - runningCost\n            current += a\n            if cost > macost:\n                macost = cost\n                ans = current\n        if b * boardingCost > runningCost:\n            cost += b * boardingCost - runningCost\n            current += 1\n            if cost > macost:\n                macost = cost\n                ans = current\n\n        return ans\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        ans = -1\n        most = pnl = waiting = 0\n        for i, x in enumerate(customers): \n            waiting += x # more people waiting in line \n            waiting -= (chg := min(4, waiting)) # boarding \n            pnl += chg * boardingCost - runningCost \n            if most < pnl: ans, most = i+1, pnl\n        q, r = divmod(waiting, 4)\n        if 4*boardingCost > runningCost: ans += q\n        if r*boardingCost > runningCost: ans += 1\n        return ans \n", "\nclass Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        count = 0\n        minCount = -1\n        profit = 0\n        maxProfit = None\n        waiting = 0\n        for i, cnum in enumerate(customers):\n            waiting += cnum\n            if waiting >= 4:\n                rounds = waiting // 4\n                count += rounds\n                profit += (boardingCost * 4 - runningCost)*rounds\n                waiting = waiting % 4\n            else:\n                if count <= i:\n                    count += 1\n                    profit += boardingCost * waiting - runningCost\n                    waiting = 0\n            if profit > 0 and (maxProfit is None or profit > maxProfit):\n                maxProfit = profit\n                minCount = count\n        if waiting > 0:\n            profit += boardingCost * waiting - runningCost\n            count += 1\n            if profit > 0 and (maxProfit is None or profit > maxProfit):\n                maxProfit = profit\n                minCount = count\n\n        return minCount", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        r=0\n        c=0\n        n=len(customers)\n        total=0\n        ans=0\n        ind=-1\n        while c<n:\n            if customers[c]>=4:\n                r+=(customers[c]//4)\n                total+=((customers[c]//4)*4)\n                customers[c]-=((customers[c]//4)*4)\n                if customers[c]==0:\n                    c+=1\n                res=total*boardingCost-r*runningCost\n                if res>ans:\n                    ans=res\n                    ind=r\n            else:\n                if c==n-1 or c==r:\n                    total+=customers[c]\n                    r+=1\n                    res=total*boardingCost-r*runningCost\n                    if res>ans:\n                        ans=res\n                        ind=r\n                else:\n                    customers[c+1]+=customers[c]\n                c+=1\n        return ind\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        profit = 0\n        waiting = 0\n        rotations = 0\n        onboard = 0\n        gondola_customers = deque([])\n        total = 0\n        maxprofit = 0\n        max_rotation = -1\n        for idx,arrival in enumerate(customers):\n            # if onboard == 0 and waiting == 0 and arrival == 0:\n                # continue\n            \n            if gondola_customers and gondola_customers[0][1]==idx:\n                coming_down = gondola_customers.popleft()[0]\n                onboard -= coming_down\n            \n            total = arrival   \n            if waiting >0:\n                total = waiting + arrival\n\n            board = min(total,4)\n            profit += ((board*boardingCost) - runningCost)\n            onboard += board\n            gondola_customers.append([board,idx+4])\n            waiting += (arrival-board)\n\n            rotations += 1\n            if profit > maxprofit:\n                maxprofit = profit\n                max_rotation = rotations\n        \n        \n        profit += ((waiting//4)*((4*boardingCost)-runningCost))\n        rotations += (waiting//4)\n        if profit > maxprofit:\n                maxprofit = profit\n                max_rotation = rotations\n        \n        profit += (((waiting%4)*boardingCost)-runningCost)\n        rotations += ((waiting%4)>0)\n        if profit > maxprofit:\n                maxprofit = profit\n                max_rotation = rotations\n        \n        return max_rotation if maxprofit > 0 else -1\n                \n        \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], B: int, R: int) -> int:\n        turns = 0\n        boarded = 0\n        max_profit = -1\n        rem = 0\n        max_turns = -1\n        # print(sum(customers))\n        for i, c in enumerate(customers):\n            t, rem = divmod(c+rem, 4)\n            turns += t\n            boarded += t * 4\n            if turns <= i: \n                turns += 1\n                boarded += rem\n                rem = 0\n            profit = boarded * B - turns * R\n            if profit > max_profit:\n                max_profit = profit\n                max_turns = turns\n            # print(i, c, boarded, rem, turns, res)\n        if rem > 0:\n            boarded += rem\n            turns += 1\n            profit = boarded * B - turns * R\n            if profit > max_profit:\n                max_profit = profit\n                max_turns = turns\n        return max_turns if max_profit > 0 else -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        left = 0 \n        cost = 0 \n        step = 0 \n        def ceildiv(a, b):\n               return -(-a // b)\n        for i in range(len(customers)):\n            left += customers[i]\n            if left >= 4:\n                    left -= 4 \n                    cost = 4*(boardingCost) - runningCost\n                    step +=1 \n             \n            else: \n                cost = left*boardingCost - runningCost\n                step +=1 \n                left = 0 \n        lefts = left // 4 \n        leftc  = left % 4 \n        costl = leftc*boardingCost - runningCost\n        cost = cost + left*boardingCost - runningCost*lefts \n        step += lefts \n       \n        if cost > 0 :\n            if costl > 0:\n               return step +1 \n            else : return step \n        else : return -1 \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        _max=float('-inf')\n        queue,index,profit,rotations,buffer=0,0,0,0,0\n        _len=len(customers)\n        while queue>=0 and index<_len: \n            queue+=customers[index]\n            profit+= ( ( min(queue,4)*boardingCost ) - ( runningCost )  )\n            queue-=min(queue,4)\n            if profit>_max:\n                rotations+=1\n            if profit==_max:\n                buffer+=1\n            _max=max(_max,profit)\n            index+=1\n            if  index==_len and queue:\n                profit+= (  ( ( (queue//4)*4 ) * boardingCost ) - ( (queue//4)*runningCost )  )\n                _max=max(_max,profit)\n                rotations+=queue//4\n                queue-=((queue//4)*4)\n\n        if queue:\n            profit+=  (( queue%4 * boardingCost ) -  runningCost)\n            if profit>_max:\n                rotations+=1\n            _max=max(_max,profit)\n\n        return rotations+buffer if _max>=0 else -1\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        cur = 0\n        total = 0\n\n        profit1 = [0,0]\n        profit2 = [0,0]\n        \n        stop = False\n        \n        left =0\n        \n        if 4*boardingCost-runningCost<=0:\n            return -1\n        while cur<len(customers):\n            left+=customers[cur]\n            if left>=4:\n                left-=4\n                customer = 4\n            else:\n                customer = left\n                left = 0\n            if (customer*boardingCost-runningCost)+profit1[0]>profit1[0]:\n                profit2[0]=(customer*boardingCost-runningCost)+profit1[0]\n                profit2[1]=profit1[1]+1\n            \n            profit1[0]=(customer*boardingCost-runningCost)+profit1[0]\n            profit1[1]=profit1[1]+1\n            cur+=1\n                \n        if left:\n            profit1[0]+=(left//4)*(customer*boardingCost-runningCost)\n            profit1[1]+=(left//4)\n            \n            if (left%4)*boardingCost-runningCost>0:\n                profit1[0]+=(left%4)*boardingCost-runningCost\n                profit1[1]+=1\n        \n        if profit1[0]>profit2[0]:\n            return profit1[1]\n        elif profit1[0]<profit2[0]:\n            return profit2[1]\n        else:\n            return min(profit1[1],profit2[1])\n                \n        '''\n        while cur<len(customers):\n            current = customers[cur]\n\n            if current >=4:\n                \n                profit1[cur+1][0]= (current//4)*(4*boardingCost-runningCost)+profit1[cur][0]\n                profit1[cur+1][1] = profit1[cur][1] +current//4\n                current = current%4               \n                if profit1[cur][0]<profit1[cur+1][0]:\n                    profit2[cur+1][0]=profit1[cur+1][0]\n                    profit2[cur+1][1]=profit1[cur+1][1]\n                else:\n                    profit2[cur+1][1]=profit1[cur][1]\n                    profit2[cur+1][0]=profit1[cur][0]\n                    \n                if current>0:\n                    profit1[cur+1][0]=current*boardingCost-runningCost+profit1[cur+1][0]\n                    profit1[cur+1][1]=profit1[cur+1][1]+1 \n            \n            else:\n\n                profit1[cur+1][0]=current*boardingCost-runningCost+profit1[cur][0]\n\n                profit1[cur+1][1]=profit1[cur][1]+1 \n\n                \n                \n                \n                profit2[cur+1][1]=profit1[cur][1]\n\n                profit2[cur+1][0]=profit1[cur][0]\n\n            \n            \n                    \n\n            cur+=1\n            \n\n        \n        keys1 = list(range(len(customers)+1))\n        keys2= list(range(len(customers)+1))\n        keys1.sort(key=lambda x: (profit1[x][0],-profit1[x][1]))\n        keys2.sort(key=lambda x:(profit2[x][0],-profit2[x][1]))\n\n        key1= keys1[-1]\n        key2 = keys2[-1]\n        print(profit1)\n        print(profit2)\n\n        if profit1[key1][0]>profit2[key2][0]:\n            return profit1[key1][1]\n        elif profit1[key1][0]<profit2[key2][0]:\n            return profit2[key1][1]\n        else:\n            return min(profit1[key1][1],profit2[key2][1])\n        '''", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        # Ugliest code ever dont even try reading this\n        return self.min_operations_max_profit_recurse(customers, 0, boardingCost, runningCost, 0, 0)[1]\n    \n    def serve_remaining_people(self, waiting, boardingCost, runningCost, depth):\n        profit = 0\n        \n        num_rotations = waiting // 4\n        if num_rotations and 4 * boardingCost - runningCost > 0:\n            depth += num_rotations\n            profit += (4 * boardingCost - runningCost) * num_rotations\n\n        if waiting % 4 and waiting % 4 * boardingCost - runningCost > 0:\n            depth += 1\n            profit += waiting % 4 * boardingCost - runningCost\n        return profit, depth\n        \n\n    def min_operations_max_profit_recurse(self, customers, index, boardingCost, runningCost, waiting, depth):\n        if index == len(customers):\n            return self.serve_remaining_people(waiting, boardingCost, runningCost, depth)\n                \n        # free gondola\n        waiting += customers[index]\n        gondola = min(waiting, 4)\n        waiting -= gondola\n        \n        # try rotating\n        profit, rotations = self.min_operations_max_profit_recurse(customers, index + 1, boardingCost, runningCost, waiting, depth + 1)\n        profit += gondola * boardingCost - runningCost\n        \n        if profit <= 0:\n            return -1, -1\n        # print(profit, rotations)\n        return profit, rotations\n        \n#         [10,9,6]\n#         6\n#         4\n        \n#         0: 4 * 6 - 4 = 24 - 4\n#         1: 4 * 6 - 4\n#         2: \n#         waiting = 11\n#         index = 1\n#         gondola = 4\n#         depth = 1\n        \n        \n        \n        \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        wait = 0\n        pro = 0\n        high = 0\n        res = -1\n        for i in range(len(customers)):\n            vacc = 4 - wait\n            if vacc <= 0:\n                wait += customers[i] - 4\n                pro += 4 * boardingCost - runningCost\n            # board all\n            elif customers[i] <= vacc: # board=customers[i]+wait\n                pro += boardingCost * (customers[i] + wait) - runningCost\n                wait = 0\n            else:\n                pro += boardingCost * 4 - runningCost\n                wait += customers[i] - 4\n            if pro > high:\n                high = pro\n                res = i\n        # determine after all arrives\n        pro_per = boardingCost * 4 - runningCost\n        if pro_per > 0:\n            last = wait % 4\n            if wait >= 4:\n                if boardingCost * last - runningCost > 0: return len(customers) + wait // 4 + 1\n                else: return len(customers) + wait // 4\n            if boardingCost * last - runningCost > 0: return len(customers) + 1\n        return res + 1 if res >= 0 else -1\n                \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        return self.min_operations_max_profit_recurse(customers, 0, boardingCost, runningCost, 0, 0)[1]\n    \n    def serve_remaining_people(self, waiting, boardingCost, runningCost, depth):\n        profit = 0\n        \n        num_rotations = waiting // 4\n        if num_rotations and 4 * boardingCost - runningCost > 0:\n            depth += num_rotations\n            profit += (4 * boardingCost - runningCost) * num_rotations\n\n        if waiting % 4 and waiting % 4 * boardingCost - runningCost > 0:\n            depth += 1\n            profit += waiting % 4 * boardingCost - runningCost\n        return profit, depth\n        \n\n    def min_operations_max_profit_recurse(self, customers, index, boardingCost, runningCost, waiting, depth):\n        if index == len(customers):\n            return self.serve_remaining_people(waiting, boardingCost, runningCost, depth)\n                \n        # free gondola\n        waiting += customers[index]\n        gondola = min(waiting, 4)\n        waiting -= gondola\n        \n        # try rotating\n        profit, rotations = self.min_operations_max_profit_recurse(customers, index + 1, boardingCost, runningCost, waiting, depth + 1)\n        profit += gondola * boardingCost - runningCost\n        \n        if profit <= 0:\n            return -1, -1\n        # print(profit, rotations)\n        return profit, rotations\n        \n#         [10,9,6]\n#         6\n#         4\n        \n#         0: 4 * 6 - 4 = 24 - 4\n#         1: 4 * 6 - 4\n#         2: \n#         waiting = 11\n#         index = 1\n#         gondola = 4\n#         depth = 1\n        \n        \n        \n        \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        nwaiting = 0\n        profit = 0\n        maxprofit = 0\n        res = - 1\n        for i,c in enumerate(customers,1):\n            nwaiting += c\n            onboard = min(4,nwaiting)\n            nwaiting -= onboard\n            profit += onboard*boardingCost - runningCost\n            if maxprofit < profit:\n                maxprofit = profit\n                res = i\n        \n        if nwaiting > 0:\n            roundn = nwaiting//4\n            nwaiting -= roundn*4\n            profit += roundn* (4*boardingCost - runningCost )\n            if maxprofit < profit:\n                maxprofit = profit\n                res += roundn\n        if nwaiting > 0:\n            profit += nwaiting*boardingCost - runningCost\n            if maxprofit < profit:\n                maxprofit = profit\n                res += 1\n        \n        return res if maxprofit > 0 else -1", "from math import ceil\nclass Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        r = 0 \n        boarded = 0\n        maxProfit = 0\n        maxR = -1\n        print(customers,boardingCost,runningCost)\n        for i in range(len(customers)-1) :\n            customers[i+1] += customers[i] - 4 if customers[i] > 4 else 0\n            r += 1\n            boarded += min(customers[i],4)\n            profit = boarded * boardingCost - r * runningCost\n            if profit > maxProfit : \n                maxProfit = profit\n                maxR = r\n        r += ceil(customers[-1]/4)\n        boarded += customers[-1] \n        if customers[-1] % 4 > 0 and (customers[-1] % 4) * boardingCost - runningCost <= 0: \n            r -= 1\n            boarded -= customers[-1] % 4\n        profit = boarded *boardingCost - r *runningCost\n        if profit > maxProfit : \n            maxProfit = profit\n            maxR = r\n        return maxR if maxProfit >0 else -1 ", "class Solution:\n    def profit(self,s,customers,count,curr_profit,waiting,rot_cost,bill):\n        # print(s,waiting,count)\n        if curr_profit>self.profit_so_far:\n            self.profit_so_far=curr_profit\n            self.ans=count\n        \n        if waiting==0 and s>=len(customers):\n            return \n        if s>=len(customers) and waiting>4:\n            n=waiting//4\n            waiting=waiting-(n*4)\n            count+=(n)\n            \n            curr_profit+= (n*4*bill - (n)*rot_cost)\n            \n            self.profit(len(customers) ,customers,count,curr_profit,waiting, rot_cost,bill)\n            return\n        \n        if s<len(customers):waiting+=customers[s]\n        curr_profit-=rot_cost\n        if waiting<=4:\n            \n            curr_profit+=waiting*bill\n            waiting=0\n        else:\n            waiting-=4\n            curr_profit+=4*bill\n        self.profit(s+1,customers,count+1,curr_profit,waiting,rot_cost,bill)\n        \n            \n            \n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        self.ans=-1\n        self.profit_so_far=0\n        self.profit(0,customers,0,0,0,runningCost,boardingCost)\n        return self.ans", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        \n        avail, cur, high, high_idx = 0, 0, 0, -1\n        for i, c in enumerate(customers):\n            avail += c\n            if avail > 4:\n                cur += 4 * boardingCost - runningCost\n                avail -= 4\n            else:\n                cur += avail * boardingCost - runningCost\n                avail = 0\n            if cur > high:\n                high, high_idx = cur, i + 1\n                \n        if 4 * boardingCost - runningCost > 0:\n            i += avail // 4\n            cur += (4 * boardingCost - runningCost) * (avail // 4)\n            avail = avail % 4\n            high, high_idx = cur, i + 1\n        \n            cur += avail * boardingCost - runningCost\n            avail = 0\n            if cur > high:\n                high, high_idx = cur, high_idx + 1\n            \n        return high_idx", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if boardingCost*4 <= runningCost:\n            return -1\n        customers.append(0)\n        profit = []\n        curProfit, runs = 0, 0\n        for i in range(len(customers)-1):\n            if customers[i] >= 4:\n                if i+1 < len(customers):\n                    customers[i+1] += customers[i]-4\n                customers[i] = 4\n            if customers[i]*boardingCost  < runningCost:\n                runs = runs + 1\n                profit.append((curProfit, runs))\n                continue\n            curProfit += customers[i]*boardingCost - runningCost\n            runs += 1\n            profit.append((curProfit, runs))\n        #print(customers, curProfit, runs)\n        if customers[-1] > 0:\n            runs = runs + (customers[-1]//4)\n            curProfit += (customers[-1]//4)*boardingCost - (customers[-1]//4)//4*runningCost\n            customers[-1] = customers[-1]%4\n            if customers[-1]*boardingCost > runningCost:\n                runs = runs + 1\n                curProfit += customers[-1]*boardingCost - runningCost\n            #print(\\\"w\\\", curProfit, runs)\n            profit.append((curProfit, runs))\n        profit.sort(key = lambda x: (-x[0], x[1]))\n        #print(profit)\n        return profit[0][1] if profit[0][0] > 0 else -1\n            \n            \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        # use a list to record profits\n        cs = [customers[0]]\n        for tmp in customers[1:]:\n            cs.append(cs[-1] + tmp)\n        # first steps\n        maxp = -1\n        maxn = -1\n        max_cap = 0\n        for i in range(len(customers)):\n            max_cap = min(cs[i], max_cap + 4)\n            cur_profit = max_cap * boardingCost - runningCost * (i + 1)\n            if cur_profit > maxp:\n                maxp = cur_profit\n                maxn = i + 1\n        # how many people are left?\n        ppl_left = cs[-1] - max_cap\n        rounds = ppl_left // 4\n        cur_profit += rounds * (4 * boardingCost - runningCost)\n        cur_round = len(customers) + rounds\n        if cur_profit > maxp:\n            maxp = cur_profit\n            maxn = cur_round\n        ppl_left2 = ppl_left % 4\n        cur_profit += (ppl_left2 * boardingCost - runningCost)\n        cur_round += 1\n        if cur_profit > maxp:\n            maxp = cur_profit\n            maxn = cur_round\n    \n        return maxn\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        max_profit = times_rotated = float('-inf')\n        total_customers = ran = left = i = 0\n        while i < len(customers) or left > 0:\n            if i < len(customers):\n                left += customers[i]\n            if i < ran:\n                i += 1\n                continue\n            if left >= 4:\n                times = left // 4\n                total_customers += 4 * times\n                ran += times\n                left -= 4 * times\n            else:\n                total_customers += left\n                left = 0\n                ran += 1\n            \n            curr_profit = total_customers * boardingCost - ran * runningCost\n            if curr_profit > max_profit:\n                max_profit = curr_profit\n                times_rotated = ran\n            i += 1\n            # print(total_customers, ran, curr_profit)\n        if max_profit < 0:\n            return -1\n        return times_rotated", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if runningCost >= boardingCost*4:\n            return -1\n        \n        result = -1\n        maxProfit = 0\n        waiting = 0\n        current = 0\n        \n        for i, customerCount in enumerate(customers):\n            waiting += customerCount\n            boarding = min(waiting, 4)\n            waiting -= boarding\n            current += boarding*boardingCost - runningCost\n            \n            if current > maxProfit:\n                maxProfit = current\n                result = i+1\n            \n        if waiting > 0:\n            fullRoundsLeft = waiting // 4\n            lastRoundQuantity = waiting % 4\n            \n            current += fullRoundsLeft * (4*boardingCost - runningCost)\n            turns = len(customers) + fullRoundsLeft\n            \n            if current > maxProfit:\n                maxProfit = current\n                result = turns\n                \n            current += lastRoundQuantity*boardingCost - runningCost\n            turns += 1\n            \n            if current > maxProfit:\n                maxProfit = current\n                result = turns\n            \n        \n        return result if result >= 0 else -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        numCust = 0\n        rotation = 0\n        curWait = 0\n        maxProfit = 0\n        minRo = 0\n        ##8\n        for i, customer in enumerate(customers):\n            while rotation < i:\n                rotation += 1\n                curWait -= 4\n                curWait = max(0, curWait)\n                curProfit = (numCust - curWait) * boardingCost - rotation * runningCost\n                if curProfit > maxProfit:\n                    maxProfit = curProfit\n                    minRo = rotation\n                \n            numCust += customer\n            curWait += customer\n            rots = curWait // 4\n            rotation += rots\n            curWait %= 4\n            curProfit = (numCust - curWait) * boardingCost - rotation * runningCost\n            if curProfit > maxProfit:\n                maxProfit = curProfit\n                minRo = rotation\n                \n        if curWait > 0:    \n            rotation += 1\n            curProfit = numCust * boardingCost - rotation * runningCost\n            if curProfit > maxProfit:\n                maxProfit = curProfit\n                minRo = rotation\n        return minRo if maxProfit > 0 else -1\n    \n                    \n            \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        profit = 0\n        waiting = 0\n        rotations = 0\n        ans = -1\n        for c in customers:\n            waiting += c\n            cap = 0\n            if waiting >= 4:\n                waiting -= 4\n                cap += 4\n            else:\n                cap = waiting\n                waiting = 0\n            cur_profit = profit + (cap * boardingCost) - runningCost\n            rotations += 1\n            if cur_profit > profit:\n                ans = rotations\n            profit = cur_profit\n        \n        if waiting > 0:\n            req_rotations = math.ceil(waiting/4)\n            ignore = waiting // 4\n            possible_profit = (waiting * boardingCost) - (req_rotations * runningCost)\n            full_only = ((waiting - (waiting % 4)) * boardingCost) - (ignore * runningCost)\n            if possible_profit > full_only:\n                additional = req_rotations\n                if profit + possible_profit > profit:\n                    ans = rotations + req_rotations\n            else:\n                additional = ignore\n                if profit + full_only > profit:\n                    ans = rotations + ignore\n        return ans\n", "class Solution:\n    def minOperationsMaxProfit(self, A, BC, RC):\n        ans=profit=t=0\n        maxprofit=0\n        wait=i=0\n        n=len(A)\n        while i<n:\n            if i<n:\n                wait+=A[i]\n                i+=1\n            t+=1\n            y=wait if wait<4 else 4\n            wait-=y\n            profit+=y*BC\n            profit-=RC\n            if profit>maxprofit:\n                maxprofit=profit\n                ans=t\n        \n        profit+=wait//4*BC\n        #profit-=RC*(wait+3)//4\n        if profit>maxprofit:\n            ans+=wait//4\n        if wait%4*BC>RC:\n            maxprofit+=wait%4*BC-RC\n            ans+=1\n\n        if maxprofit<=0:\n            return -1\n        else:\n            return ans\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        ans=-1\n        maxp=0\n        curr=0\n        c=0\n        track=0\n        for i in range(len(customers)):\n            track+=customers[i]\n            curr+=min(4,track)*boardingCost-runningCost\n            track-=min(4,track)\n            c+=1\n            if curr>maxp:\n                maxp=curr\n                ans=c\n        if track>=4:\n            curr+=(track-track%4)*boardingCost-(track//4)*runningCost\n            c+=track//4\n            if curr>maxp:\n                maxp=curr\n                ans=c\n        curr+=(track%4)*boardingCost-runningCost\n        c+=1\n        if curr>maxp:\n            maxp=curr\n            ans=c\n        return ans", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        ans = -1\n        if boardingCost * 4 < runningCost: return ans\n        cur_profit = 0\n        wait_num = 0\n        dic = {}\n        for i in range(len(customers)):\n            if customers[i] + wait_num < 5:\n                cur_profit += boardingCost * (customers[i] + wait_num) - runningCost\n                wait_num = 0\n            else:\n                cur_profit += boardingCost * 4 - runningCost\n                wait_num += customers[i] - 4\n                \n            if cur_profit > ans:\n                ans = cur_profit\n                dic[ans] = i+1\n        \n        if wait_num > 0:\n            while wait_num > 3:\n                wait_num -= 4\n                dic[ans] += 1\n            if wait_num * boardingCost > runningCost:\n                dic[ans] += 1\n        \n        return dic[ans]\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        if boardingCost*4 < runningCost: return -1\n        rot = 0\n        spot = 0\n        prof = max_prof = [0, 0]\n        while spot < len(customers):\n            rot += 1\n            curr = customers[spot]\n            if curr > 4:\n                if spot == len(customers) - 1: \n                    temp = prof[0] + 4*boardingCost*(curr//4) - runningCost*(curr//4)\n                    max_prof1 = max(max_prof, [temp, rot -1 + curr//4]) \n                    temp = prof[0] + 4*boardingCost*(curr//4) + boardingCost*(curr%4) - runningCost*(curr//4+bool(curr%4))\n                    max_prof2 = max(max_prof, [temp, rot -1 + curr//4 + bool(curr%4)]) \n                    if max_prof1[0] != max_prof2[0]: return max(max_prof1, max_prof2)[1] \n                    if max_prof1[0] == max_prof2[0]: return max_prof1[1] \n                else:\n                    customers[spot+1] += curr-4\n                prof[0] += 4*boardingCost - runningCost\n            else:\n                prof[0] += curr*boardingCost - runningCost\n            max_prof = max(max_prof, [prof[0], rot]) \n            spot += 1\n        return max_prof[1]\n                \n            \n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        profit = 0\n        waiting = 0\n        rotation = 0\n        max_profit = 0\n        ans = None\n        for customer in customers:\n            customer += waiting\n            rotation += 1\n            if customer>=4:\n                profit += 4*boardingCost - runningCost\n                waiting = customer-4\n            else:\n                profit = customer*boardingCost - runningCost\n                waiting = 0\n            \n            if max_profit<profit:\n                max_pprofit = profit\n                ans = rotation\n        \n        if waiting>0:\n            if waiting>4:\n                while waiting>4:\n                    profit += 4*boardingCost - runningCost\n                    waiting = waiting-4\n                    rotation += 1\n                    #print(profit)\n                    if max_profit<profit:\n                        max_pprofit = profit\n                        ans = rotation\n            \n        profit = waiting*boardingCost - runningCost\n        rotation+=1\n        if max_profit<profit:\n            max_pprofit = profit\n            ans = rotation\n        \n        return ans if ans else -1", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        profit = 0\n        maxProfit = -1\n        res = -1\n        currentCustomer = 0\n        for i, c in enumerate(customers):\n            currentCustomer += c\n            if currentCustomer <=4:\n                profit += currentCustomer*boardingCost - runningCost \n                currentCustomer = 0\n            else:\n                profit += 4*boardingCost - runningCost\n                currentCustomer -=4\n            if profit > maxProfit:\n                maxProfit = profit\n                res = i+1\n        \n        rounds = currentCustomer // 4\n        left = currentCustomer % 4\n        if boardingCost*4 - runningCost > 0:\n            profit += rounds*(boardingCost*4 - runningCost)\n            if profit > maxProfit:\n                maxProfit = profit\n                res += rounds\n            profit += boardingCost*left-runningCost\n            if profit > maxProfit:\n                maxProfit = profit\n                res +=1\n            \n        \n        return res", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        minimum = runningCost//boardingCost+1\n        if minimum>4: return -1\n        max_value = 0\n        profit = 0\n        remain = 0\n        turns = 0\n        res = None\n        for c in customers:\n            turns += 1\n            temp = remain+c\n            if temp>=4:\n                remain = temp-4\n                profit += 4*boardingCost-runningCost\n            else:\n                remain = 0\n                profit += temp*boardingCost-runningCost\n            if profit>max_value:\n                res = turns\n                max_value = profit\n        print(turns, remain)\n        while remain:\n            turns += 1\n            if remain>=4:\n                remain -= 4\n                profit += 4*boardingCost-runningCost\n            else:\n                profit += remain*boardingCost-runningCost\n                remain = 0\n            if profit>max_value:\n                res = turns\n                max_value = profit\n        return res", "class Solution:\n    def minOperationsMaxProfit(self, nums: List[int], pos: int, fee: int) -> int:\n        if 4*pos <= fee:\n            return -1\n        ans = cur = 0\n        s = sum(nums)\n        best = -math.inf\n        p = 0\n        for i, x in enumerate(nums):\n            cur += x\n            if cur >= 4:\n                p += (4*pos - fee)\n                cur -= 4\n            else:\n                p += (cur * pos - fee)\n                cur = 0\n            \n            if p > best:\n                best = p\n                ans = i + 1\n        res = len(nums)\n        while cur > 0:\n            res += 1\n            if cur >= 4:\n                p += (4*pos - fee)\n                cur -= 4\n            else:\n                p += (cur * pos - fee)\n                cur = 0\n            if p > best:\n                best = p\n                ans = res\n                \n        if best <=0:\n            return -1\n        return ans\n", "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        inLine = 0\n        profit = 0\n        maxProf = -1\n        maxRoll = -1\n        rolls = 0\n        for i in customers:\n            inLine += i\n            if inLine >= 4:\n                profit += 4*boardingCost - runningCost\n                inLine -= 4\n            else:\n                profit += inLine*boardingCost - runningCost\n                inLine = 0\n            rolls += 1\n            \n            if profit > maxProf:\n                maxProf = profit\n                maxRoll = rolls\n                \n        \n        while inLine:\n            if inLine >= 4:\n                profit += 4*boardingCost - runningCost\n                inLine -= 4\n            else:\n                profit += inLine*boardingCost - runningCost\n                inLine = 0\n            rolls += 1\n            # maxProf = max(maxProf, profit)\n            if profit > maxProf:\n                maxProf = profit\n                maxRoll = rolls\n        \n        return maxRoll\n            \n"]