["class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        if len(s) != len(t):\n            return False\n        \n        c = Counter((ord(c2) - ord(c1)) % 26 for c1, c2 in zip(s, t))\n        return k >= max(\n            (m + 26 * (count - 1) for m, count in list(c.items()) if m),\n            default = 0)\n", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        if len(s) != len(t):\n            return False\n        \n        c = Counter((ord(c2) - ord(c1)) % 26 for c1, c2 in zip(s, t))\n        return k >= max((m + 26 * (count - 1) for m, count in list(c.items()) if m),\n                        default = 0)\n", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        if len(s) != len(t):\n            return False\n        count = [0 for _ in range(26)]\n        for a, b in zip(s, t):\n            if a == b:\n                continue\n            shift = (ord(b) - ord(a)) % 26\n            count[shift] += 1\n        max_shift = 0\n        max_count = 0\n        for i in range(25, -1, -1):\n            if count[i] > max_count:\n                max_shift = i\n                max_count = count[i]\n        if max_count < 1:\n            return True\n        # print('max_count', max_count, 'max_shift', max_shift)\n        return (((max_count - 1) * 26) + max_shift) <= k", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        \n        if len(s) != len(t):\n            return False\n        \n        cnts = [0]*26\n        for char_s, char_t in zip(s, t):\n            if char_s == char_t:\n                continue\n            elif char_s < char_t:\n                moves_req = ord(char_t) - ord(char_s)\n            else:\n                moves_req = 26 - ord(char_s) + ord(char_t)\n                \n            cnts[moves_req] += 1\n            if moves_req > k or cnts[moves_req]-1 > ((k-moves_req)/26):\n                return False\n        return True\n            \n", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        if len(s) != len(t): return False\n        dic = {}\n        for a, b in zip(s, t):\n            gap = ord(b) - ord(a)\n            single = gap if gap >= 0 else 26 + gap\n            if single == 0: continue\n            if single not in dic:\n                dic[single] = 0\n            else:\n                dic[single] += 1\n            # print(a, b, \\\" dic:\\\", dic)\n            if dic[single] * 26 + single > k: return False\n        return True", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        \n        if len(s) != len(t):\n            return False\n        \n        diff = defaultdict(int)\n        for sc, tc in zip(s, t):\n            d = (ord(tc) - ord(sc)) % 26\n            if d == 0: continue\n            if d > k: return False\n            diff[d] += 1\n            if ((diff[d] - 1) * 26) + d > k:\n                return False\n        \n        return True\n", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        if len(s) != len(t):\n            return False\n        count = {}\n        total = [0]\n        # print(count)\n        for i in range(len(s)):\n            if ord(s[i]) > ord(t[i]):\n                # print('case {} {}'.format(s[i], t[i]))\n                x = 122 - ord(s[i]) + ord(t[i]) - 96\n            else:\n                x = ord(t[i]) - ord(s[i])\n            # print(\\\"({} {})\\\".format(x,i))\n            if x != 0:\n                if x not in count:\n                    count[x] = 0\n                if count[x] * 26 + x:\n                    max = count[x] * 26 + x\n                    if max > k:\n                        return False\n                count[x] += 1\n        # print(max(total))\n        return True\n", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        d = {}\n        m1 = [0, 0]\n        n = len(s)\n        if len(t) != n:\n            return False\n        for i in range(n):\n            diff = (ord(t[i])-ord(s[i])) % 26\n            if diff != 0:\n                if diff not in d:\n                    d[diff] = 0\n                d[diff]+=1\n                m1 = max(m1, [d[diff], diff])\n        m2 = 26*(m1[0]-1)+m1[1]\n       # print(m2)\n        return k >= m2\n             \n                \n                   \n", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        if len(s) != len(t):\n            return False\n        diff = []\n        res = []\n        diff.extend(ord(t[i]) - ord(s[i]) + [0, 26][ord(t[i]) < ord(s[i])]\n            for i in range(len(s)) if s[i] != t[i])\n        counter = Counter(diff)\n        res.extend(key + 26*i for key in counter for i in range(counter[key]))\n        return all([r <= k  for r in res])\n        \n                                                \n                                            \n", "# 1540. Can Convert String in K Moves\n\nALPHABET_SIZE = 26\n\ndef compute_shift (c1, c2):\n    return (ord (c2) - ord (c1)) % ALPHABET_SIZE\n\ndef last_shift (shift, frequency):\n    return shift + (frequency - 1) * ALPHABET_SIZE\n\ndef can_convert_string (s, t, k):\n    if len(s) != len(t): return False\n    shifts = {}\n    for c1, c2 in zip (s, t):\n        if c1 != c2:\n            shift = compute_shift (c1, c2)\n            shifts.setdefault (shift, 0)\n            shifts[shift] += 1\n\n    return all (last_shift (shift, frequency) <= k for (shift, frequency) in shifts.items ())\n\nclass Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        return can_convert_string(s, t, k)", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        if len(s) != len(t):\n            return False\n        d = {x: 0 for x in range(1, 26)}\n        for cs, ct in zip(s, t):\n            diff = (ord(ct) - ord(cs) + 26) % 26\n            if diff == 0:\n                continue\n            nxt = d[diff] * 26 + diff\n            if nxt <= k:\n                d[diff] += 1\n            else:\n                return False\n        return True", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        if len(s) != len(t):\n            return False\n        count = [0 for _ in range(26)]\n        for a, b in zip(s, t):\n            if a == b:\n                continue\n            shift = (ord(b) - ord(a)) % 26\n            count[shift] += 1\n        ch = ord('z') - ord('a')\n        m = count[ch]\n        for i in range(24, -1, -1):\n            if count[i] > m:\n                ch = i\n                m = count[i]\n        return (m - 1) * 26 + ch <= k", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        if len(s) != len(t):\n            return False\n        dic = {}    \n        ans = []\n        for i in range(len(s)):\n            if s[i] == t[i]:\n                continue\n            diff = ord(t[i]) - ord(s[i]) + (0, 26)[ord(t[i]) < ord(s[i])]\n            dic[diff] = dic.get(diff, 0) + 1\n            if (diff + 26*(dic[diff] - 1)) > k:\n                return False\n        return True\n            \n            \n                                            \n", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        \n        if len(s) != len(t):\n            return False\n        \n        \n        shift_times = []\n        for idx in range(len(s)):\n            a = s[idx]\n            b = t[idx]\n            if ord(a) <= ord(b):\n                shift_times.append(ord(b) - ord(a))\n            else:\n                shift_times.append( (ord('z')-ord(a))+(ord(b)-ord('a')) + 1 )\n            #print(shift_times, b, a, (ord('z')-ord(b)), (ord(a)-ord('a')))\n            ## pruning for unable to shift\n            if shift_times[-1] > k:\n                return False\n        \n\n        shift_used = dict()\n        for idx in range(len(shift_times)):\n            shift_amount = shift_times[idx]\n            if shift_amount == 0:\n                continue\n            ## shift_times already used before, should plus wrapping\n            if shift_amount in shift_used:\n                if 26 * shift_used[shift_amount] + shift_amount > k:\n                    return False\n                else:\n                    shift_used[shift_amount] += 1\n            ## can shift normally\n            else:\n                shift_used[shift_amount] = 1\n        return True\n        \n", "def shift(c, n):\n    return chr(ord(c) + n%26)\n\nclass Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        if len(s) != len(t):\n            return False\n        d = {}\n        mx = 0\n        for i in range(len(s)):\n            c1 = s[i]\n            c2 = t[i]\n            if c1 == c2:\n                continue\n            j = ord(c2) - ord(c1)\n            j = j % 26\n            if j not in d:\n                d[j] = 1\n            else:\n                d[j] += 1\n            mx = max(mx, (d[j]-1)*26+j)\n        return mx <= k", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        if len(s) != len(t):\n            return False\n        \n        shifts = []\n        for ch1, ch2 in zip(s, t):\n            asc1 = ord(ch1) - ord('a')\n            asc2 = ord(ch2) - ord('a')\n            diff = asc2 - asc1 if asc2 >= asc1 else 26 - asc1 + asc2\n            assert diff >= 0\n            if diff > 0:\n                shifts.append(diff)\n        \n        shifts.sort()\n    \n        most = 0\n        freq = defaultdict(int)\n        for s in shifts:\n            most = max(most, s + freq[s] * 26)\n            freq[s] += 1\n        return most <= k", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        \n        if len(s) != len(t):\n            return False\n        \n        rotations, extra = divmod(k, 26)\n        \n        diff = []\n        \n        for index in range(len(s)):\n            difference = ord(t[index]) - ord(s[index])\n            if difference:\n                diff.append(difference)\n        \n        dictionary = dict()\n        \n        for number in range(1,26):\n            dictionary[number] = rotations\n            \n            if number <= extra:\n                dictionary[number]+= 1\n        \n        if not diff:\n            return True\n        \n        for d in diff:\n            \n            if d < 0:\n                net_d = d+26\n                if dictionary[net_d]:\n                    dictionary[net_d] -= 1\n                \n                else:\n                    return False\n            \n            else:\n                if dictionary[d]:\n                    dictionary[d] -= 1\n                \n                else:\n                    return False\n        \n        return True\n", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        if len(s) != len(t):\n            return False\n        seen = {i: i for i in range(1, 27)}\n        for i in range(len(s)):\n            ch1, ch2 = s[i], t[i]\n            if ch1 == ch2:\n                continue\n            else:\n                move = ord(ch2) - ord(ch1) + 26 * (ord(ch1) > ord(ch2))\n                last = seen[move]\n                if last > k:\n                    return False\n                else:\n                    seen[move] = last + 26\n                \n        \n        return True\n                \n\n", "import string\n\nclass Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        if len(s) != len(t): return False\n        \n        mod=k%26\n        div = k//26\n        def f(sh):\n            l = 1 if sh < mod else 0\n            return div + l\n        \n        shifts=[0 for i in range(26)]\n        for l1, l2 in zip(s, t):\n            if l1 == l2: continue\n            sh = string.ascii_lowercase.index(l2)-string.ascii_lowercase.index(l1)\n            sh = sh if sh >=0 else sh+26\n            shifts[sh-1]+=1\n            if shifts[sh-1] > f(sh-1): return False\n                     \n        return True\n            \n            \n            \n", "from collections import defaultdict\n\nclass Solution:\n  def canConvertString(self, s: str, t: str, n: int) -> bool:\n    if len(s) != len(t):\n      return False\n    \n    d = defaultdict(int)\n    for c1, c2 in zip(s, t):\n      v = (26 + ord(c2) - ord(c1)) % 26\n      if v:\n        d[v] += 1\n        \n    \n    for k, v in list(d.items()):\n      if k + 26 * (v - 1) > n:\n        return False\n    \n    return True\n        \n", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        if len(s) != len(t):\n            return False\n        numMoves = [int(k / 26)] * 26\n        for i in range(1, (k % 26) + 1):\n            numMoves[i] += 1\n        \n        for i in range(len(t)):\n            shift = (ord(t[i]) - ord(s[i])) % 26\n            if shift == 0:\n                continue\n            numMoves[shift] -= 1\n            if numMoves[shift] < 0:\n                return False\n        \n        return True", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        if len(s)!=len(t):\n            return False\n        h=[0]*27\n        for i in range(len(s)):\n            c=ord(t[i])-ord(s[i])\n            if c==0:\n                continue\n            if c<0:\n                c+=26\n            h[c]+=1\n            \n        for i in range(1,len(h)):\n            if i + (h[i] - 1) * 26 > k: \n                return False;\n            \n        return True            \n", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        if len(s) != len(t):\n            return False\n        cnt = [0 for i in range(26)]\n        for a,b in zip(s,t):\n            cnt[(ord(b) - ord(a)) % 26]+=1\n        for i in range(1, 26):\n            if cnt[i]  > 0 and (cnt[i] -1) * 26 + i > k:\n                return False\n        return True", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        if len(s) != len(t) :\n            return False\n        count = [0] * 26\n        seen = set()\n        \n        for cs, ct in zip(s, t):\n            diff = (ord(ct) - ord(cs)) % 26\n            if diff != 0:\n                if diff in seen:\n                    count[diff] += 26\n                    if count[diff] > k:\n                        return False\n                else:\n                    count[diff] = diff\n                    if diff > k:\n                        return False\n                    seen.add(diff)\n        return True\n        # alpha = '0abcdefghijklmnopqrstuvwxyz'\n        # aplha_d = {}\n        # val = 1\n        # for i in range(len(aplha)):\n        #     aplha_d[aplha[i]]\n", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        if len(s)!=len(t):\n            return False\n        d=defaultdict(int)\n        for i in range(len(s)):\n            #l.append((ord(t[i])-ord(s[i]))%26)\n            n=(ord(t[i])-ord(s[i]))%26\n            if n>0:\n                d[n]+=1\n            \n        d2=defaultdict(int)\n        kk=k//26\n        for i in range(26):\n            d2[i+1]=kk\n        for i in range(k%26):\n            d2[i+1]+=1\n        #print(d,d2)\n        for k in d:\n            if k not in d2 or d[k]>d2[k]:\n                return False\n        return True\n", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        if len(s) != len(t):\n            return False\n        taken = [i for i in range(0, 26)]\n        for c1, c2 in zip(s, t):\n            g = (ord(c2)-ord(c1)) % 26\n            if g == 0:\n                continue\n            if taken[g] > k:\n                return False\n            taken[g] += 26\n        return True\n", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        if len(s)!=len(t):\n            return False\n        N=26\n        cnt=[0]*N\n        for i in range(len(s)):\n            if s[i]==t[i]:\n                continue\n            cnt[(ord(t[i])-ord(s[i]))%N]+=1\n        # print(cnt)\n        for i in range(1,N):\n            if cnt[i]>(k//N)+(k%N >=i):\n                return False\n        return True", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        if len(s) != len(t):\n            return False\n        cnt = [0] * 26\n        for cs, ct in zip(s, t):\n            diff = (ord(ct) - ord(cs)) % 26\n            if diff > 0 and cnt[diff] * 26 + diff > k:\n                return False\n            cnt[diff] += 1\n        return True", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        if len(s) != len(t):\n            return False\n        b = k // 26\n        budget = {i: b + (i <= (k % 26)) for i in range(1, 26)}\n        \n        for i, j in zip(s, t):\n            shift = (ord(j) - ord(i)) % 26\n            if i != j:\n                if shift > k:\n                    return False\n                if budget[shift] == 0:\n                    return False\n                else:\n                    budget[shift] -= 1\n                \n        return True\n            \n            \n            \n", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        if not len(s)==len(t): return False\n        \n        n = len(s)\n        count = defaultdict(int)\n        for i in range(n):\n            if s[i]!=t[i]:\n                temp = -ord(t[i])+ord(s[i])\n                count[ (temp+26)%26 ] += 1\n            \n        k1,k2 = k//26,k%26\n        helper = defaultdict(int)\n        for i in range(1,26):\n            helper[i] += k1\n\n        if k2:\n            for i in range(1,k2+1):\n                helper[26-i] += 1\n                    \n        print(count)\n        print(helper)\n        \n        for i in count:\n            if not (i in helper) or helper[i]<count[i]:\n                return False\n        return True", "class Solution:\n    # https://leetcode.com/problems/can-convert-string-in-k-moves/discuss/826856/c%2B%2B-simple-sol...using-maps\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        if len(s) != len(t):\n            return False\n        lookup = collections.defaultdict(int)\n        for i in range(len(s)):\n            if s[i] != t[i]:\n                diff = (ord(t[i]) - ord(s[i]) + 26) % 26 \n                if diff > k:\n                    return False\n                lookup[diff] += 1\n        \n        for diff, freq in list(lookup.items()):\n            maxCount = (freq - 1) * 26 + diff\n            if maxCount > k:\n                return False\n        return True\n", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        times = {}\n        if (len(s) != len(t)): return False\n        for i in range(len(s)):\n            orig = (ord(t[i])-ord(s[i])+26)%26\n            totry = orig\n            if totry == 0: continue\n            if orig in times:\n                totry = times[orig]\n                totry += 26\n            if totry > k:\n                return False\n            times[orig] = totry\n        return True", "class Solution:\n    def canConvertString(self, s, t, k):\n        n, m = len(s), len(t)\n        if n != m:\n            return False\n        cnt = [0] * 26\n        for i in range(n):\n            if s[i] == t[i]:\n                continue\n            diff = (ord(t[i]) - ord(s[i])) % 26\n            if cnt[diff] * 26 + diff > k:\n                return False\n            cnt[diff] += 1\n        return True", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        if len(s) != len(t):\n            return False\n        \n        shifts = [0 for x in range(1, 27)]\n        \n        for i in range(len(s)):\n            if t[i] == s[i]:\n                continue\n            diff = (ord(t[i]) - ord(s[i])) % 26\n            \n            if ((shifts[diff]) * 26 + diff) > k:\n                return False\n            shifts[diff] += 1\n        \n        return True", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        \n        if len(s) != len(t):\n            return False\n        \n        dd = collections.defaultdict(int)\n        \n        for i,v in zip(s,t):\n            diff = (ord(v) - ord(i)) % 26 \n            if diff > 0 and diff + dd[diff] * 26 > k:\n                return False\n            dd[diff] += 1\n        \n        return True", "import collections\nclass Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        # check lengths\n        n1 = len(s)\n        n2 = len(t)\n        if n1 != n2:\n            return False\n        n = n1\n        \n        # find diffArray\n        diffArray = [(ord(t[i])-ord(s[i]))%26 for i in range(n)]\n       \n        # frequency of difference\n        cda = collections.Counter(diffArray)\n        \n        # delete 0\n        del cda[0]\n        \n        minK = 0\n        if len(cda) > 0 :\n            key = max([(i[1], i[0])for i in list(cda.items())])\n            #print(key)\n            minK = (key[0] - 1) *26 + key[1]\n        return k >= minK\n\n", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        if len(s) != len(t):\n            return False\n        cnt = [0] * 26\n        for cs, ct in zip(s, t):\n            diff = (ord(ct) - ord(cs)) % 26\n            if diff > 0 and cnt[diff] * 26 + diff > k:\n                return False\n            cnt[diff] += 1\n        return True\n", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        if len(s) != len(t): return False\n        \n        moves = collections.Counter()\n        \n        for si, ti in zip(s, t):\n            shifts = (ord(ti) - ord(si)) % 26\n            moves[shifts] += 1\n        \n        for i in range(1, 26):\n            total_moves = moves[i]\n            \n            if i + 26*(total_moves-1) > k: return False\n        \n        return True", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        jumps=list(range(26))\n        if len(s)!=len(t):\n            return False\n        for i in range(len(s)):\n            if s[i]==t[i]:\n                continue\n            jump=(ord(t[i])-ord(s[i])+26)%26\n            if jumps[jump]>k:\n                return False\n            jumps[jump]+=26\n        return True", "from collections import Counter \nclass Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        if len(s) != len(t):\n            return False\n        cnt = [0] * 26\n        for cs, ct in zip(s, t):\n            diff = (ord(ct) - ord(cs)) % 26\n            if diff > 0 and cnt[diff] * 26 + diff > k:\n                return False\n            cnt[diff] += 1\n        return True", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        n1, n2 = len(s), len(t)\n        if n1 != n2:\n            return False\n        if k == 0:\n            return s == t\n        \n        # record how many letters need to be changed, autobump step if step is found \n        steps = collections.defaultdict(int)\n        for sc, tc in zip(s, t):\n            if sc != tc:\n                idx_t = ord(tc)\n                idx_s = ord(sc)\n                if idx_s < idx_t:\n                    step = idx_t - idx_s\n                else:\n                    step = idx_t - idx_s + 26\n               \n                if step > k:\n                    return False\n                steps[step] += 1\n                \n                \n        for step in steps:\n            if (steps[step] - 1) * 26 + step > k:\n                return False\n          \n\n        return True\n                    \n        \n", "def dist(s_c, t_c):\n    if s_c == t_c:\n        return 0\n    elif s_c < t_c:\n        return ord(t_c) - ord(s_c)\n    else: # s_c > t_c\n        return ord('z') - ord(s_c) + ord(t_c) - ord('a') + 1\n\nclass Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        distances = [0] * 26\n        if len(s) != len(t):\n            return False\n        for s_c, t_c in zip(s, t):\n            d = dist(s_c, t_c)\n            if d != 0:\n                distances[d] += 1\n        for i, d in enumerate(distances):\n            if d > 0:\n                if (d - 1) * 26 + i > k:\n                    return False\n        return True\n", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        o = {}\n        if len(s) != len(t):return False\n        for i in range(len(s)):\n            l = (ord(t[i]) -  ord(s[i]))%26\n            if l == 0:continue\n            if l > k :return False\n            if l not in o :\n                o[l] = l\n            else:\n                last = o[l]\n                if last + 26 > k: return False\n                o[l] = 26 + last\n        return True\n", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        if len(s) != len(t):\n            return False\n        distance = Counter((ord(b) - ord(a)) % 26 for a, b in zip(s, t) if a != b)\n        maxf = [-1, -1]\n        for c, f in distance.items():\n            if f > maxf[1] or f == maxf[1] and c > maxf[0]:\n                maxf[0] = c\n                maxf[1] = f\n        return not distance or ((maxf[1] - 1) * 26 + maxf[0]) <= k", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        \n        if len(s) != len(t):\n            return False\n        \n        cnts = [0]*26\n        for s_char, t_char in zip(s, t):\n            if s_char == t_char:\n                continue\n            elif s_char > t_char:\n                moves_req = 26 - (ord(s_char)-ord(t_char))\n            else:\n                moves_req = ord(t_char) - ord(s_char)\n            \n            cnts[moves_req] += 1\n            if moves_req > k or cnts[moves_req] > (k-moves_req)//26+1:\n                return False\n        return True\n", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        if(len(s) != len(t)):\n            return False\n        idx_dict = [0] * 26\n        # for i in range(1, 26):\n        #     idx_dict[i] = 0\n        \n        for idx, sc in enumerate(s):\n            tc = t[idx]\n            \n            if(sc == tc):\n                # idx_list.append(0)\n                continue\n            \n            sasc = ord(sc)\n            tasc = ord(tc)\n            \n            if(sasc < tasc):\n                movei = tasc - sasc\n            else:\n                movei = 26 - sasc + tasc\n            # while(movei in idx_set):\n            #         movei = movei + 26\n            origini = movei\n            movei = movei + 26 * idx_dict[movei]\n            idx_dict[origini] += 1\n            if(movei > k):\n                return False\n            # idx_list.append(movei)\n            # idx_set.add(movei)\n        #print(idx_list)\n        return True\n", "def no_of_shifts_away(a, b):\n    return (ord(b) - ord(a)) % 26\n\n\nclass Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        in1_len = len(s)\n        in2_len = len(t)\n        max_duplicates_in_shift = []\n        for i in range(26):\n            max_duplicates_in_shift.append(max(0, 1 + ((k - i) // 26)))\n        if in1_len != in2_len:\n            return False\n        for i in range(in1_len):\n            shifts_required = no_of_shifts_away(s[i], t[i])\n            if shifts_required > k:\n                return False\n            if shifts_required != 0:\n                max_duplicates_in_shift[shifts_required] -= 1\n                if max_duplicates_in_shift[shifts_required] < 0:\n                    return False\n        return True", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        change = []\n        if len(s)!=len(t):\n            return False\n        for a,b in zip(s,t):\n            if a!=b:\n                change.append(ord(b)-ord(a))\n        for index,number in enumerate(change):\n            if number < 0:\n                change[index]+=26\n        count = [0]*26\n        for index,number in enumerate(count):\n            count[index]+=int(k/26)\n        remaining = k%26\n        i=1\n        for j in range(remaining):\n            count[i]+=1\n            i+=1\n        for number in change:\n            if count[number]==0:\n                return False\n            else:\n                count[number]-=1\n        return True\n            \n", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        a = [k // 26 for _ in range(27)]\n        \n        for i in range(k % 26 + 1):\n            a[i] += 1\n        \n        ns, nt = len(s), len(t)\n        if ns != nt: return False\n        \n        for i in range(ns):\n            if s[i] == t[i]:\n                continue\n            else:\n                d = ord(t[i]) - ord(s[i]) if t[i] > s[i] else ord(t[i]) + 26 - ord(s[i])\n                if a[d] <= 0:\n                    return False\n                a[d] -= 1\n        \n        return True\n                    \n        \n", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        moves = defaultdict(lambda: 0) \n        K_div = k // 26\n        K_mod = k % 26\n        \n        if len(s) != len(t):\n            return False\n        \n        for cs, ct in zip(s, t):\n            ordc = ord(cs)\n            ordt = ord(ct)\n            \n            move = ordt - ordc \n            if move < 0:\n                move += 26\n            \n            if move == 0:\n                continue\n                \n            numMoves = K_div + (1 if move <= K_mod else 0) \n            \n            if moves[move] == numMoves:\n                return False\n            \n            moves[move] += 1\n            \n        return True", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        if len(s) != len(t):\n            return False\n        l = [0] * 26\n        for i in range(len(s)):\n            if s[i] == t[i]:\n                continue\n            x = (ord(t[i]) - ord(s[i]) + 26) % 26\n            if l[x] * 26 + x > k:\n                return False\n            l[x] += 1\n        return True\n", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        if(s==t):\n            return True\n        if(len(s)!=len(t)):\n            return False\n        has={}\n        for i in range(1,27):\n            num=26+i\n            if(i<=k):\n                has[i]=1\n                x=(k-i)//26\n                has[i]+=x\n        n=len(s)\n        print(has)\n       \n        count=0\n        for i in range(n):\n            if(s[i]==t[i]):\n                count+=1\n                continue\n            diff=(ord(t[i])-ord(s[i]))%26\n\n            if(diff in has):\n                count+=1\n                has[diff]-=1\n                if(has[diff]==0):\n                    del has[diff]\n            else:\n                return False\n        # print(has2)\n        if(count==n):\n            return True\n        return False\n                \n            \n            \n            \n            \n", "class Solution:\n    \n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        n = len(s)\n        m = len(t)\n        \n        if m!=n:\n            return False\n        \n        if s==t:\n            return True\n        \n        shift = {}\n        \n        shift[0] = 0\n        \n        for i in range(n):\n            move = (ord(t[i])-ord(s[i]))%26\n\n            if move>0:\n                \n                if move in shift:\n                    new_move = 26*shift[move] + move\n                    shift[move] = shift[move] + 1\n                    move = new_move\n                \n                else:\n                    shift[move] = 1\n                \n                if move>k:\n                    return False\n            \n            else:\n                shift[0] = shift[0] + 1\n        \n        return True\n                \n            \n            \n", "import collections\nclass Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        # check lengths\n        n1 = len(s)\n        n2 = len(t)\n        if n1 != n2:\n            return False\n        n = n1\n        \n        # find diffArray\n        diffArray = [(ord(t[i])-ord(s[i]))%26 for i in range(n)]\n       \n        # frequency of difference\n        cda = collections.Counter(diffArray)\n        print(cda)\n        \n        # delete 0\n        del cda[0]\n        elements = sorted(list(cda.items()), key=lambda x: (x[1], x[0]), reverse=True)\n        minK = 0\n        try:\n            key = elements[0]\n            minK = (key[1] - 1) *26 + key[0]\n        except IndexError:\n            pass\n        print(minK)\n        return k >= minK\n    \n", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        if len(s) != len(t):\n            return 0\n        aux = dict()\n        for i in range(len(s)):\n            if s[i] != t[i]:\n                val1, val2 = ord(s[i]), ord(t[i])\n                if val1 < val2:\n                    if val2 - val1 in aux:\n                        aux[val2 - val1] += 1\n                    else:   aux[val2 - val1] = 1\n                else:\n                    if 26 - val1 + val2 in aux:\n                        aux[26 - val1 + val2] += 1\n                    else:   aux[26 - val1 + val2] = 1\n        ans = 0\n        for elem in aux:\n            ans = max(ans, 26 * (aux[elem]-1) + elem)\n        return ans <= k\n        \n                \n", "class Solution:\n     def canConvertString(self, s: str, t: str, k: int) -> bool:        \n        if len(s) != len(t):\n            return False \n        \n        used = {}\n        for i in range(len(s)):\n            diff = ord(s[i]) - ord(t[i])\n            if diff == 0:\n                continue \n\n            i = (26-diff) if diff > 0 else abs(diff)\n            if i > k: \n                return False \n            \n            if i not in used:\n                used[i] = 1\n            else:\n                move = used[i] * 26 + i\n                if move > k:\n                    return False \n                else:\n                    used[i] += 1 \n                \n        return True\n            \n            \n        \n       \n", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        # a, b\n        if len(s) != len(t):\n            return False\n        largest = [0]*26\n        for i in range(len(s)):\n            diff = ord(t[i]) - ord(s[i])\n            if diff == 0:\n                continue\n            elif diff < 0:\n                diff += 26\n            if largest[diff-1] == 0:\n                largest[diff-1] = diff\n            else:\n                largest[diff-1] += 26\n            if largest[diff-1] > k:\n                return False\n        return True", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        \n        \n        if len(s) != len(t):\n            return False\n        \n        d = defaultdict(int)\n        \n        for sc, tc in zip(s,t):\n            \n            diff = ( ord(tc) - ord(sc) ) % 26\n            \n            if diff == 0:\n                continue\n            \n            if diff > k:\n                return False\n            \n            d[diff] += 1\n            \n            if ((d[diff] - 1) * 26) + diff > k:\n                return False\n            \n        \n        return True", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        if len(s) != len(t):\n            return False\n        maps = {} # or maybe use array\n        for i in range(len(s)):\n            if s[i] != t[i]:\n                diff = (ord(t[i]) - ord(s[i]) ) % 26\n                if diff not in list(maps.keys()):\n                    maps[diff] = 1\n                else:\n                    maps[diff] += 1\n                if ((maps[diff] - 1) * 26 + diff) > k:\n                    return False\n        return True\n                \n        \n", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        if len(s) != len(t):\n            return False\n        \n        alreadySeen = {}\n        \n        for i in range(len(s)):\n            if s[i] != t[i]:\n                difference = (ord(t[i]) - ord(s[i])) % 26\n                \n                if difference > k:\n                    return False\n                \n                if difference not in alreadySeen:\n                    alreadySeen[difference] = 1\n                else:\n                    newDifference = difference + alreadySeen[difference] * 26\n\n                    if newDifference > k:\n                        return False\n                    else:\n                        alreadySeen[difference] += 1\n        \n        return True\n", "class Solution:\n    def dist(self, a,b):\n        return (ord(b)-ord(a)) % 26\n    \n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        if len(s) != len(t): \n            return False\n        seen = {}\n        for x, y in zip(s, t):\n            if x == y: \n                continue\n            d = self.dist(x,y)            \n            if d  > k: \n                return False\n            if d not in seen: \n                seen[d] = d\n            else:\n                last = seen[d]\n                if last + 26 > k: \n                    return False\n                seen[d] = last + 26\n        return True\n", "from collections import Counter\n\n\nclass Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        if len(s) != len(t):\n            return False\n        ans = Counter()\n        for i in range(len(s)):\n            key = (ord(t[i]) - ord(s[i])) % 26\n            if key != 0 and ans[key] * 26 + key > k:\n                return False\n            ans[key] += 1\n        return True", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        if len(s) != len(t):\n            return False\n        \n        cnt = collections.defaultdict(int)\n        for i in range(len(s)):\n            if s[i] == t[i]:\n                continue\n            \n            shift = 0\n            if ord(t[i]) < ord(s[i]):\n                shift = ord(t[i]) - ord(s[i]) + 26\n            else:\n                shift = ord(t[i]) - ord(s[i])\n            \n            cnt[shift] += 1\n        \n        for r in cnt:\n            # We have cnt[r] letters in s that will need to be shifted r letters to line up with t.\n            # We then simply need to check that k is large enough so that there are enough instances\n            # of i, 1 <= i <= k, such that i % 26 == r.\n            # How do we check? Well if x * 26 + r <= k, then we have (0*26 + r) % 26 == r,\n            # (1*26 + r) % 26 == r, (2*26 + r) % 26 == r, ..., (x*26 + r) % 26 == r, i.e there are x + 1 \n            # instances of i such that i % 26 == r.\n            # Given cnt[r] letters that need to be shifted, we only need to make sure that:\n            #   (cnt[r]-1)*26 +r <= k\n            #\n            if (cnt[r] - 1) * 26 + r > k:\n                return False\n        return True\n", "def no_of_shifts_away(a, b):\n    return (ord(b) - ord(a)) % 26\n\n\nclass Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        in1_len = len(s)\n        freq = {}\n        in2_len = len(t)\n        max_duplicates_in_shift = []\n        for i in range(26):\n            max_duplicates_in_shift.append(max(0, 1 + ((k - i) // 26)))\n        if in1_len != in2_len:\n            return False\n        for i in range(in1_len):\n            shifts_required = no_of_shifts_away(s[i], t[i])\n            if shifts_required > k:\n                return False\n            if shifts_required != 0:\n                if shifts_required in freq:\n                    freq[shifts_required] += 1\n                    if freq[shifts_required] > max_duplicates_in_shift[shifts_required]:\n                        return False\n                else:\n                    freq[shifts_required] = 1\n        return True", "class Solution:\n    \n    \n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        \n\n        if len(s) != len(t):\n            return False\n        \n        d = {}\n        \n        \n        for i in range(len(s)):\n            \n            if s[i] == t[i]:\n                continue\n                \n            diff = (ord(t[i]) - ord(s[i])) % 26\n            \n            if diff not in d:                \n                d[diff] = 1\n            else:\n                d[diff] += 1\n            \n            \n                \n            if (26 * (d[diff]-1)) + diff > k:\n                return False\n        \n        \n        return True", "class Solution:\n    def getMoves(self, cFrom, cTo):\n        return (ord(cTo) - ord(cFrom)) % 26 \n    \n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        if len(s) != len(t):\n            return False\n        \n        usedDict = {}\n        \n        for cFrom, cTo in zip(s, t):\n            if cFrom == cTo:\n                continue\n            \n            moves = self.getMoves(cFrom, cTo)\n            \n            if moves > k:\n                return False\n            \n            if moves not in usedDict:\n                usedDict[moves] = 1\n            else:\n                if moves + (26 * usedDict[moves]) <= k:\n                    usedDict[moves] += 1\n                else:\n                    return False\n                \n        return True", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        if len(s) != len(t): return False\n        \n        isUsed = dict()\n        for i in range(len(s)):\n            ch1, ch2 = ord(s[i]), ord(t[i])\n            if ch1 < ch2:\n                shift = ch2-ch1\n            elif ch1 > ch2:\n                shift = 26-(ch1-ch2)\n            else:\n                continue\n                \n            initShift = shift\n            while 1 <= shift <= k:\n                \n                if shift not in isUsed:\n                    isUsed[initShift] = shift\n                    break\n                shift = isUsed[initShift]+26\n                \n            else:\n                return False\n            \n        return True\n        \n", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        if len(s) != len(t): return False #edge case \n        \n        visited = {}\n        for ss, tt in zip(s, t):\n            if ss != tt: \n                d = (ord(tt) - ord(ss)) % 26 #distance \n                if d not in visited: \n                    visited[d] = d\n                else: \n                    visited[d] += 26 \n                if visited[d] > k: \n                    return False \n        return True \n", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        from collections import defaultdict\n        if len(s) != len(t): return False\n        i = 0\n        j = defaultdict(int)\n        print((len(s)))\n        while i < len(s):\n            mr = (ord(t[i]) - ord(s[i]))%26\n            if mr == 0:\n                pass\n            else:\n                if mr + j.get(mr,0) * 26 > k:\n                    return False\n                j[mr] += 1\n            i += 1\n        return True\n        \n        \n", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        if len(s)!=len(t):\n            return False\n        \n        hash_map = {}\n        for i in range(len(s)):\n            if s[i]!=t[i]:\n                diff = -1*(ord(s[i])-ord(t[i]))\n                if diff<0:\n                    diff = 26+diff\n                if diff in hash_map:\n                    hash_map[diff]+=1\n                    diff += (hash_map[diff]-1)*26\n                else:\n                    hash_map[diff] = 1\n                if diff>k:\n                   return False\n        return True\n                    \n", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        if len(s) != len(t):\n            return False\n        \n        available, maxi = [0 if k < i else 1 + (k - i) // 26 for i in range(26)], 0\n        for a, b in zip(s, t):\n            if a == b:\n                continue\n            require = (26 + (ord(b) - ord('a')) - (ord(a) - ord('a'))) % 26\n            if not available[require]:\n                return False\n            available[require] -= 1\n            \n            maxi = max(maxi, require)\n            \n        return maxi <= k", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        if len(s) != len(t):\n            return False\n        \n        counts = [0] * 26\n        for si, ti in zip(s, t):\n            difference = ord(ti) - ord(si)\n            if difference < 0:\n                difference += 26\n            counts[difference] += 1\n        \n        for i, count in enumerate(counts[1:], 1):\n            maxConvert = i + 26 * (counts[i] - 1)\n            if maxConvert > k:\n                return False\n        \n        return True\n", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        if len(s) != len(t):\n            return False\n        n = len(s)\n        occ = {}\n        for i in range(n):\n            l = (ord(t[i]) - ord(s[i]))%26\n            if not l:\n                continue\n            try:\n                if occ[l]:\n                    occ[l] += 1\n                    l = (occ[l]-1)*26 + l\n                    if l > k:\n                        return False\n            except: \n                if l > k:\n                    return False\n                occ[l] = 1\n        \n        return True", "from collections import defaultdict\nclass Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        if len(s) != len(t):\n            return False\n        cnt = defaultdict(int)\n        res = 0\n        for i in range(len(s)):\n            j = (ord(t[i]) - ord(s[i]) + 26) % 26\n            if j:\n                res = max(res, 26 * cnt[j] + j)\n                cnt[j] += 1\n        return res <= k", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        if len(s) != len(t):\n            return False\n        \n        shift_needed = collections.defaultdict(int)\n        for sc, tc in zip(s, t):\n            if sc > tc:\n                shift_needed[ord('z')-ord(sc)+ord(tc)-ord('a')+1] += 1\n            elif sc < tc:\n                shift_needed[ord(tc)-ord(sc)] += 1\n                \n        min_move_needed = 0\n        for shift, v in list(shift_needed.items()):\n            min_move_needed = max(min_move_needed, 26*(v-1)+shift)\n        #print(shift_needed, min_move_needed)\n        return min_move_needed <= k\n", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        d = {}\n        if(len(s)!= len(t)):\n            return False\n        for i in range(len(s)):\n            if(s[i]!= t[i]):\n                if(ord(s[i])<ord(t[i])):\n                    val = ord(t[i])-ord(s[i])\n                else:\n                    val = (ord('z')-ord(s[i]))+(ord(t[i])-ord('a'))+1\n                if(val in d):\n                    d[val]+=1\n                elif(val not in d):\n                    d[val] = 1\n        for x in d:\n            if(((d[x]-1)*26+x)>k):\n                return False\n        return True", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        if len(s) != len(t):\n            return False\n        maps = {}\n        for i in range(len(s)):\n            if s[i] != t[i]:\n                diff = (ord(t[i]) - ord(s[i]) ) % 26\n                if diff not in list(maps.keys()):\n                    maps[diff] = 1\n                else:\n                    maps[diff] += 1\n                if ((maps[diff] - 1) * 26 + diff) > k:\n                    return False\n        return True\n                \n        \n", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        if len(s) != len(t) or len(s) == 0:\n            return False\n\n        dists = [(26 + ord(b) - ord(a)) % 26 for a, b in zip(s, t)]\n        counter = Counter(dists)\n        print((dists, counter))\n        for i in range(1, 26):\n            if counter[i] > (k - i) // 26 + 1:\n                return False\n        \n        return True\n            \n", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        if(len(s) != len(t)):\n            return False\n        idx_set = {0}\n        idx_list = []\n        idx_dict = {}\n        for i in range(1, 26):\n            idx_dict[i] = 0\n        \n        for idx, sc in enumerate(s):\n            tc = t[idx]\n            \n            if(sc == tc):\n                # idx_list.append(0)\n                continue\n            \n            sasc = ord(sc)\n            tasc = ord(tc)\n            \n            if(sasc < tasc):\n                movei = tasc - sasc\n            else:\n                movei = 26 - sasc + tasc\n            # while(movei in idx_set):\n            #         movei = movei + 26\n            origini = movei\n            movei = movei + 26 * idx_dict[movei]\n            idx_dict[origini] += 1\n            if(movei > k):\n                return False\n            # idx_list.append(movei)\n            # idx_set.add(movei)\n        #print(idx_list)\n        return True\n", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        \n        if len(s) != len(t):\n            return False\n        \n        def aIntoB(a,b)->int:\n            return (ord(b)-ord(a)) % 26\n        \n        moves = [k//26]*26\n        for i in range((k % 26) + 1):\n            moves[i] += 1\n            \n        for a, b in zip(s, t):\n            if a == b:\n                continue\n                \n            moves[aIntoB(a,b)] -= 1\n            if moves[aIntoB(a,b)] < 0:\n                return False\n            \n        return True\n        \n#         3 ->\n#         1 1 1 0 0 0 ...\n        \n#         29 ->\n#         2 2 2 1 1 1 ...\n        \n#         27 ->\n#         2 1 1 1 1 1 ...\n", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        if len(s) != len(t): \n            return False\n        diff = [(ord(c2)-ord(c1)) % 26 for c1, c2 in zip(s, t)]\n        ctr = sorted((v, k) for k, v in list(collections.Counter(diff).items()) if k)\n        return not ctr or (ctr[-1][0]-1) * 26 + ctr[-1][1] <= k\n        \n", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        if len(s) != len(t):\n            return False\n        \n        count = {}\n        for x,y in zip(s,t):\n            change = 0\n            if ord(y) - ord(x) > 0:\n                change = ord(y) - ord(x)\n            elif ord(y) - ord(x) < 0:\n                change = (ord(y) - ord(x)) + 26\n                \n            if change == 0:\n                continue\n                \n            if change not in count:\n                count[change] = 1\n            else:\n                count[change] += 1\n            \n            \n            if (count[change] - 1) * 26 + change > k:\n                return False\n        \n        \n                    \n        return True\n        \n", "class Solution:\n    def canConvertString(self, S: str, T: str, k: int) -> bool:\n        if len(S) != len(T):\n            return False\n        dic = {}\n        for s, t in zip(S, T):\n            shift = (ord(t) - ord(s))%26\n            if not shift:\n                continue\n            if shift not in dic:dic[shift] = 0\n            dic[shift] += 1\n            if shift + 26*(dic[shift] - 1) > k:\n                return False\n        return True", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        # convert s to t in k moves or less\n        # so the ith move is 1 <= i <= k\n        # pick a character at j (1-indexed) in the string and shift it i times\n        # or you can do nothing in the move.\n        # 'shifting' the character means to replace it to the next letter in the alphabet\n        alpha = 'abcdefghijklmnopqrstuvwxyz'\n        # any index j can be picked at most ONCE\n        # for each x  [1..k] you have an opportunity to shift a character in s, i times.\n        # the answer is false if there is a character that needs more shifts than we are able to supply\n        # can create a list of deltas, sorted descending, and see if we have enough space to work with\n        deltas = []\n        if len(s) != len(t): return False\n        for i,c in enumerate(s):\n            t_index = ord(t[i]) - ord('a')\n            s_index = ord(s[i]) - ord('a')\n            deltas.append((t_index - s_index)%26)\n        m = collections.defaultdict(int)\n        while k%26 != 0:\n            m[k%26] += 1\n            k -= 1\n        for i in range(1,26):\n            m[i] += k//26\n        #print(sorted(deltas, reverse=True))\n        for d in sorted(deltas, reverse=True):\n            if not d:\n                continue\n            if not m[d]:\n                return False\n            m[d] -= 1\n            # take the highest available k that will satisfy that delta\n            # ie, take the highest number x such that x%26 == d %26\n            # or you can have a count of all the numbers that land in each class\n        return True", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        if len(s) != len(t):\n            return False\n        valid = {}\n        moves = []\n        for a,b in zip(s,t):\n            if a != b:\n                diff = ord(b) - ord(a)\n                if diff < 0:\n                    diff += 26\n                if diff in valid:\n                    valid[diff].append(valid[diff][-1]+26)\n                else:\n                    valid.setdefault(diff,[diff])\n                moves.append(diff)\n        for d in moves:\n            num = valid[d]\n            if num[-1] > k:\n                return False\n            else:\n                num.pop()\n        return True\n", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        n = len(s)\n        m = len(t)\n        if(n!=m):\n            return False\n        else:\n            diff = {}\n            d = {}\n            for i in range(n):\n                if(s[i]!=t[i]):\n                    if(t[i]>s[i]):\n                        value = ord(t[i])-ord(s[i])\n                    else:\n                        value = (26-ord(s[i]))+ord(t[i])\n                    if value not in diff:\n                        start = value\n                    else:\n                        start = diff[value]+26 \n                    flag = 0\n                    while(start<=k):\n                        if start not in d:\n                            d[start] = 1\n                            diff[value] = start\n                            flag = 1\n                            break\n                        start+=26\n                    if(flag==0):\n                        return False \n            return True", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        if len(s)!=len(t):\n            return False\n        hash={}\n\n        n=len(s)\n\n        for i in range(n):\n            x=ord(t[i])-ord(s[i])\n            if x==0:\n                continue\n            if x>0:\n                if x in hash:\n                    hash[x]+=[x+26*(len(hash[x]))]\n                else:\n                    hash[x]=[x]\n            elif x<0:\n                if 26+x in hash:\n                    hash[26+x]+=[26+x+26*(len(hash[26+x]))]\n                else:\n                    hash[26+x]=[26+x]\n        for a in hash:\n            if a>k:\n                return False\n            for i in hash[a]:\n                if i>k:\n                    return False\n        return True                ", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        \n        if len(s) != len(t):\n            return False\n        \n        \n        C = Counter()\n        seen = set()\n        for i in range(len(s)):\n            if s[i] != t[i]:\n                dist = (ord(t[i]) + 26 - ord(s[i])) % 26\n                if dist not in C.keys():\n                    C[dist] = 0\n                else:\n                    C[dist] += 1\n                    dist += 26 * (C[dist]) \n                if dist > k:\n                    return False\n        return True", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        if len(s) != len(t):\n            return False\n        n = len(s)\n        g = [0 for i in range(26)]\n        for i in range(n):\n            g[(ord(t[i]) - ord(s[i])) % 26] += 1\n        for i in range(1, 26):\n            index = i + (g[i]-1) * 26\n            if index > k:\n                return False\n        return True", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        def getScore(sc, tc):\n            if ord(sc) <= ord(tc):\n                return ord(tc) - ord(sc)\n            return ord('z') - ord(sc) + 1 + ord(tc) - ord('a') \n        \n        if len(s) != len(t):\n            return False\n        \n        score_ref = dict()\n        for idx in range(len(s)):\n            score = getScore(s[idx], t[idx])\n            if score == 0:\n                continue\n            score_ref[score] = score if score_ref.get(score, 0) == 0 else score_ref[score] + 26\n        \n        return all([score_ref[score] <= k for score in score_ref])", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        n,m = len(s), len(t)\n        if n != m:\n            return False\n        ls = [ord(j)-ord(i) for i, j in zip(s,t)]\n        for i in range(n):\n            if ls[i] < 0:\n                ls[i] = 26 + ls[i]\n        d = {}\n        ans = 0\n        # print(ls)\n        for i in ls:\n            if i == 0:\n                continue\n            if i not in d:\n                ans = max(ans,i)\n                d[i] = 1\n            else:\n                ans = max(26*d[i]+i, ans)\n                d[i] += 1\n            if ans > k:\n                # print(ans, k, d)\n                return False\n        return True\n        \n", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n\n        if len(s) != len(t): return False\n        mp = {}\n        for i in range(len(s)): \n            v =  ord(t[i]) - ord(s[i])\n            if v == 0: \n                continue\n            if v < 0: \n                v += 26 # shift backward\n            if v > k: \n                return False\n            if v in mp: \n                # the highest number\n                high_v = mp[v] + 26\n                if high_v > k: \n                    return False\n                mp[v] = high_v\n            else:\n                mp[v] = v\n            \n        return True", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        if len(s) != len(t):\n            return False\n        cnt = [0] * 26\n        for cs, ct in zip(s, t):\n            diff = (ord(ct) - ord(cs)) % 26\n            if diff > 0 and cnt[diff] * 26 + diff > k:\n                return False\n            cnt[diff] += 1\n        return True\n                    \n", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        b=0\n        flag=0\n        lis=[]\n        if(len(s)==len(t)):\n            for i in range(len(s)):\n                if(s[i]!=t[i]):\n                    if(s[i]<t[i]):\n                        lis.append(ord(t[i])-ord(s[i]))\n                    else:\n                        lis.append(26-(ord(s[i])-ord(t[i])))\n            lis.sort()\n            i=0\n            c=0\n            while(i<len(lis)-1):\n                if(lis[i]==lis[i+1]):\n                    c=c+1\n                else:\n                    if(lis[i]+(c*26)>k):\n                        flag=1\n                        break\n                    else:\n                        c=0\n                i=i+1\n            if(len(lis)>1):\n                if(lis[-1]!=lis[-2]):\n                    if(lis[-1]>k):\n                        flag=1\n            if(len(lis)>0):\n                    if(lis[i-1]+(c*26)>k):\n                        flag=1\n            if(flag==0):\n                b=1\n        return(b)", "class Solution:\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\n        if len(s) != len(t):\n            return False\n        count = {}\n        total = [0]\n        # print(count)\n        for i in range(len(s)):\n            if ord(s[i]) > ord(t[i]):\n                # print('case {} {}'.format(s[i], t[i]))\n                x = 122 - ord(s[i]) + ord(t[i]) - 96\n            else:\n                x = ord(t[i]) - ord(s[i])\n            # print(\\\"({} {})\\\".format(x,i))\n            if x != 0:\n                if x not in count:\n                    count[x] = 0\n                if count[x] * 26 + x:\n                    max = count[x] * 26 + x\n                    if max > k:\n                        return False\n                count[x] += 1\n        # print(max(total))\n        return True"]