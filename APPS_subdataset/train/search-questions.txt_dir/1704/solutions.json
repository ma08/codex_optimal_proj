["class PokerHand(object):\n    CARD = \"23456789TJQKA\"\n    RESULT = [\"Loss\", \"Tie\", \"Win\"]\n\n    def __init__(self, hand):\n        values = ''.join(sorted(hand[::3], key=self.CARD.index))\n        suits = set(hand[1::3])\n        is_straight = values in self.CARD\n        is_flush = len(suits) == 1\n        self.score = (2 * sum(values.count(card) for card in values)\n                      + 13 * is_straight + 15 * is_flush,\n                      [self.CARD.index(card) for card in values[::-1]])\n        \n    def compare_with(self, other):\n        return self.RESULT[(self.score > other.score) - (self.score < other.score) + 1]", "from collections import Counter\n\n\nclass Card(object):\n\n    def __init__(self, card):\n        if card[0] in '23456789':\n            self.rank = int(card[0])\n        else:\n            self.rank = {'T': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14}.get(card[0])\n        self.suit = card[1]\n\n\nclass PokerHand(object):\n\n    def __init__(self, hand):\n        self.hand = [Card(card) for card in hand.split()]\n        self.rank_counts = Counter(card.rank for card in self.hand)\n\n    def compare_with(self, other):\n        return \"Win\" if self.score > other.score else \"Loss\" if self.score < other.score else \"Tie\"\n\n    @property\n    def score(self):\n\n        def is_flush():\n            return len({card.suit for card in self.hand}) == 1\n\n        def is_straight():\n            def is_sequential(arr):\n                return all(a + 1 == b for a, b in zip(arr, arr[1:]))\n            arr = sorted(card.rank for card in self.hand)\n            return is_sequential(arr) or (is_sequential(arr[:4]) and arr[0] == 2 and arr[-1] == 14)\n\n        def is_straight_flush():\n            return is_flush() and is_straight()\n\n        def is_n_of_kind(n):\n            return n in list(self.rank_counts.values())\n\n        def is_full_house():\n            return is_n_of_kind(3) and is_n_of_kind(2)\n\n        def is_2_pair():\n            return list(self.rank_counts.values()).count(2) == 2\n\n        def get_by_count(n):\n            return tuple(rank for rank, count in sorted(list(self.rank_counts.items()), key=lambda x: (x[1], -x[0])) if count == n)\n\n        if is_straight_flush():\n            return (9, get_by_count(1))\n        elif is_n_of_kind(4):\n            return (8, get_by_count(4), get_by_count(1))\n        elif is_full_house():\n            return (7, get_by_count(3), get_by_count(2))\n        elif is_flush():\n            return (6, get_by_count(1))\n        elif is_straight():\n            return (5, get_by_count(1))\n        elif is_n_of_kind(3):\n            return (4, get_by_count(3), get_by_count(1))\n        elif is_2_pair():\n            return (3, get_by_count(2), get_by_count(1))\n        elif is_n_of_kind(2):\n            return (2, get_by_count(2), get_by_count(1))\n        else:\n            return (1, get_by_count(1))\n", "class PokerHand():\n    \n    def __init__(self, hand):\n        hand = hand.split()\n        # get card values\n        values = sorted('__23456789TJQKA'.index(card[0]) for card in hand)[::-1]\n        # check if same suit\n        same_suit = len({card[1] for card in hand}) == 1\n        # check if straight\n        straight = [values[0]-i for i in range(5)] == values\n        # check n of a kind\n        kinds = {i: [] for i in range(1, 5)}\n        for value in sorted(set(values))[::-1]:\n            how_many = values.count(value)\n            kinds[how_many].append(value)\n        \n        # calculate rank\n        if same_suit and straight:    self.rank = 8, values                # royal/straight flush\n        elif kinds[4]:                self.rank = 7, kinds[4], kinds[1]    # four of a kind\n        elif kinds[3] and kinds[2]:   self.rank = 6, kinds[3], kinds[2]    # full house\n        elif same_suit:               self.rank = 5, values                # flush\n        elif straight:                self.rank = 4, values                # straight\n        elif kinds[3]:                self.rank = 3, kinds[3], kinds[1]    # three of a kind\n        elif len(kinds[2]) == 2:      self.rank = 2, kinds[2], kinds[1]    # two pairs\n        elif kinds[2]:                self.rank = 1, kinds[2], kinds[1]    # one pair\n        else:                         self.rank = 0, values                # high card\n    \n    def compare_with(self, other):\n        return ( \"Win\"  if self.rank > other.rank else\n                 \"Loss\" if self.rank < other.rank else\n                 \"Tie\" )", "from collections import Counter\n\nRESULT      = [\"Loss\", \"Tie\", \"Win\"]\nHEX_CARDS   = \"23456789ABCDE\"\nCARD_TO_HEX = str.maketrans(\"TJQKA\", \"ABCDE\")\nMAIN_RANK   = [lambda colC, valC, isS:  5 in colC.values() and isS,                    # Straight Flush\n               lambda colC, valC, isS:  4 in valC.values(),                            # Square\n               lambda colC, valC, isS:  3 in valC.values() and 2 in valC.values(),     # Full house\n               lambda colC, valC, isS:  5 in colC.values(),                            # Flush\n               lambda colC, valC, isS:  isS,                                           # Straight\n               lambda colC, valC, isS:  3 in valC.values(),                            # Three of a kind\n               lambda colC, valC, isS:  2 in valC.values() and len(valC.keys()) == 3,  # 2 pairs\n               lambda colC, valC, isS:  2 in valC.values() and len(valC.keys()) == 4,  # 1 pair,\n               lambda colC, valC, isS:  True]                                          # 1 card\n\n\nclass PokerHand(object):\n\n    def __init__(self, hand):\n        hand         = hand.translate(CARD_TO_HEX)\n        valCount     = Counter( hand[n] for n in range(0, len(hand), 3) )\n        colorCount   = Counter( hand[n] for n in range(1, len(hand), 3) )\n        \n        minCardIdx   = int(min(valCount.keys()), 16) - 2\n        isStraight   = valCount.keys() == set(HEX_CARDS[minCardIdx:minCardIdx+5])\n        hashSameRank = int(''.join(sorted(valCount.keys(), key = lambda k: (valCount[k], k), reverse = True)), 16)\n        \n        for i,func in enumerate(MAIN_RANK):\n            if func(colorCount, valCount, isStraight):\n                self.handValue = (len(MAIN_RANK) - i) * 16**5 + hashSameRank\n                break\n                \n        \n    def compare_with(self, other):\n        return RESULT[ (self.handValue >= other.handValue) + (self.handValue > other.handValue) ]", "class PokerHand(object):\n    FACE_VALUE = {\"2\":2,\"3\":3,\"4\":4,\"5\":5,\"6\":6,\"7\":7,\"8\":8,\"9\":9,\"T\":10, \"J\":11, \"Q\":12,\"K\":13, \"A\": 14}\n\n    def __init__(self, hand):\n        self.suits = {\"S\":0, \"H\":0, \"D\":0, \"C\":0}\n        self.values = {}\n        self.flush = False\n        for card in hand.split():\n            card_val = self.FACE_VALUE.get(card[0])\n            self.values[card_val] = self.values.get(card_val,0) + 1\n            self.suits[card[1]] += 1\n            if self.suits[card[1]] == 5: self.flush = True\n        self.high_low = self.high_low()\n        self.straight = self.look_for_straight()\n        self.rank_high_low = [self.rank()] + self.high_low[:]\n        \n    def high_low(self):\n        high_low = []\n        for i in range(1,5):\n            high_low += sorted([k for k,v in self.values.items() if v == i])\n        return high_low[::-1]\n        \n    def look_for_straight(self):\n        val_array = self.high_low[:]\n        if 14 in val_array: val_array[val_array.index(14)] = 1 if 2 in val_array else 14\n        return val_array == list(range(val_array[0],val_array[0] - 5,-1))\n        \n    def rank(self):\n        num_vals = list(self.values.values())\n        if self.flush: return 9 if self.straight else 6\n        if num_vals.count(4) == 1: return 8\n        if num_vals.count(3) == 1: return 7 if num_vals.count(2) == 1 else 4\n        if self.straight: return 5\n        if num_vals.count(2) > 0: return 3 if num_vals.count(2) == 2 else 2\n        return 1\n        \n    def compare_with(self, other):\n        for i in range(len(self.rank_high_low)):\n            if self.rank_high_low[i] > other.rank_high_low[i]: return \"Win\"\n            if self.rank_high_low[i] < other.rank_high_low[i]: return \"Loss\"   \n        return \"Tie\"", "from collections import Counter\n\n\nclass CardValue(str):\n    ORDER = \"23456789TJQKA\"\n\n    def __lt__(self, other):\n        return self.ORDER.index(self) < self.ORDER.index(other)\n\n    def __gt__(self, other):\n        return self.ORDER.index(self) > self.ORDER.index(other)\n\n\nclass Card():\n    ORDER = CardValue.ORDER\n\n    def __init__(self, card_str):\n        self.value = CardValue(card_str[0])\n        self.color = card_str[1]\n\n    def __lt__(self, other):\n        return self.value < other.value\n\n    def __str__(self):\n        return \"\".join((self.value, self.color))\n\n\nclass HandValue():\n    def __init__(self, poker_hand):\n        self.poker_hand = poker_hand\n\n    def compare(self, other):\n        return 'Tie'\n\n    def __str__(self):\n        return self.__class__.__name__\n\n    @property\n    def pretty_string(self):\n        return \"{} is {}\".format(self.poker_hand, self)\n\n\nclass RoyalFlush(HandValue):\n    @staticmethod\n    def is_valid(poker_hand):\n        if poker_hand.is_same_color:\n            if {card.value for card in poker_hand.cards} == {'A', 'K', 'Q', 'J', 'T'}:\n                return True\n        return False\n\n\nclass HighCard(HandValue):\n    def compare(self, other):\n        self_value_remaining = sorted(self.poker_hand.card_values, reverse=True)\n        other_value_remaining = sorted(other.poker_hand.card_values, reverse=True)\n        for i in range(5):\n            if self_value_remaining[i] > other_value_remaining[i]:\n                return 'Win'\n            if self_value_remaining[i] < other_value_remaining[i]:\n                return 'Loss'\n        return 'Tie'\n\n    @staticmethod\n    def is_valid(poker_hand):\n        return True\n\n\nclass Pairs(HandValue):\n    def compare(self, other):\n        counter_self_values = Counter(self.poker_hand.card_values)\n        counter_other_values = Counter(other.poker_hand.card_values)\n\n        # Check the pair\n        self_value_2 = next(value for value, nb_repet in counter_self_values.items() if nb_repet == 2)\n        other_value_2 = next(value for value, nb_repet in counter_other_values.items() if nb_repet == 2)\n        if self_value_2 > other_value_2:\n            return 'Win'\n        if self_value_2 < other_value_2:\n            return 'Loss'\n\n        # Check the remaining solo cards\n        self_value_remaining = sorted((value for value, nb_repet in counter_self_values.items() if nb_repet == 1), reverse=True)\n        other_value_remaining = sorted((value for value, nb_repet in counter_other_values.items() if nb_repet == 1), reverse=True)\n        for i in range(3):\n            if self_value_remaining[i] > other_value_remaining[i]:\n                return 'Win'\n            if self_value_remaining[i] < other_value_remaining[i]:\n                return 'Loss'\n        return 'Tie'\n\n    @staticmethod\n    def is_valid(poker_hand):\n        counter_values = Counter(poker_hand.card_values)\n        return 2 in counter_values.values()\n\n\nclass TwoPairs(HandValue):\n    def compare(self, other):\n        counter_self_values = Counter(self.poker_hand.card_values)\n        counter_other_values = Counter(other.poker_hand.card_values)\n\n        # Check the highest pair\n        max_self_value_2 = max([value for value, nb_repet in counter_self_values.items() if nb_repet == 2])\n        max_other_value_2 = max([value for value, nb_repet in counter_other_values.items() if nb_repet == 2])\n        if max_self_value_2 > max_other_value_2:\n            return 'Win'\n        if max_self_value_2 < max_other_value_2:\n            return 'Loss'\n\n        # Check the lowest pair\n        min_self_value_2 = min([value for value, nb_repet in counter_self_values.items() if nb_repet == 2])\n        min_other_value_2 = min([value for value, nb_repet in counter_other_values.items() if nb_repet == 2])\n        if min_self_value_2 > min_other_value_2:\n            return 'Win'\n        if min_self_value_2 < min_other_value_2:\n            return 'Loss'\n\n        # Otherwise check the lowest remaining value\n        self_value_1 = next(value for value, nb_repet in counter_self_values.items() if nb_repet == 1)\n        other_value_1 = next(value for value, nb_repet in counter_other_values.items() if nb_repet == 1)\n        if self_value_1 > other_value_1:\n            return 'Win'\n        if self_value_1 < other_value_1:\n            return 'Loss'\n        return 'Tie'\n\n    @staticmethod\n    def is_valid(poker_hand):\n        counter_values = Counter(poker_hand.card_values)\n        return list(counter_values.values()).count(2) == 2\n\n\nclass ThreeOfAKind(HandValue):\n    def compare(self, other):\n        counter_self_values = Counter(self.poker_hand.card_values)\n        counter_other_values = Counter(other.poker_hand.card_values)\n\n        # Check the value of the 3 of a kind\n        max_self_value_3 = [value for value, nb_repet in counter_self_values.items() if nb_repet == 3][0]\n        max_other_value_3 = [value for value, nb_repet in counter_other_values.items() if nb_repet == 3][0]\n        if max_self_value_3 > max_other_value_3:\n            return 'Win'\n        if max_self_value_3 < max_other_value_3:\n            return 'Loss'\n\n        # Check the highest remaining value\n        max_self_value_2 = max(value for value, nb_repet in counter_self_values.items() if nb_repet == 1)\n        max_other_value_2 = max(value for value, nb_repet in counter_other_values.items() if nb_repet == 1)\n        if max_self_value_2 > max_other_value_2:\n            return 'Win'\n        if max_self_value_2 < max_other_value_2:\n            return 'Loss'\n\n        # Otherwise check the lowest remaining value\n        min_self_value_2 = min(value for value, nb_repet in counter_self_values.items() if nb_repet == 1)\n        min_other_value_2 = min(value for value, nb_repet in counter_other_values.items() if nb_repet == 1)\n        if min_self_value_2 > min_other_value_2:\n            return 'Win'\n        if min_self_value_2 < min_other_value_2:\n            return 'Loss'\n        return 'Tie'\n\n    @staticmethod\n    def is_valid(poker_hand):\n        counter_self_values = Counter(poker_hand.card_values)\n        return 3 in counter_self_values.values()\n\n\nclass FullHouse(HandValue):\n    def compare(self, other):\n        counter_self_values = Counter(self.poker_hand.card_values)\n        counter_other_values = Counter(other.poker_hand.card_values)\n\n        # Check the value of the 3 of a kind\n        max_self_value_3 = [value for value, nb_repet in counter_self_values.items() if nb_repet == 3][0]\n        max_other_value_3 = [value for value, nb_repet in counter_other_values.items() if nb_repet == 3][0]\n        if max_self_value_3 > max_other_value_3:\n            return 'Win'\n        if max_self_value_3 < max_other_value_3:\n            return 'Loss'\n\n        # Case 3 of a kind value is the same, check pair value\n        max_self_value_2 = [value for value, nb_repet in counter_self_values.items() if nb_repet == 2][0]\n        max_other_value_2 = [value for value, nb_repet in counter_other_values.items() if nb_repet == 2][0]\n        if max_self_value_2 > max_other_value_2:\n            return 'Win'\n        if max_self_value_2 < max_other_value_2:\n            return 'Loss'\n        return 'Tie'\n\n    @staticmethod\n    def is_valid(poker_hand):\n        counter_self_values = Counter(poker_hand.card_values)\n        return set(counter_self_values.values()) == {2, 3}\n\n\nclass FourOfAKind(HandValue):\n    def compare(self, other):\n        counter_self_values = Counter(self.poker_hand.card_values)\n        counter_other_values = Counter(other.poker_hand.card_values)\n        max_self_value = [value for value, nb_repet in counter_self_values.items() if nb_repet == 4][0]\n        max_other_value = [value for value, nb_repet in counter_other_values.items() if nb_repet == 4][0]\n        if max_self_value > max_other_value:\n            return 'Win'\n        if max_self_value < max_other_value:\n            return 'Loss'\n\n        max_self_value = [value for value, nb_repet in counter_self_values.items() if nb_repet == 1][0]\n        max_other_value = [value for value, nb_repet in counter_other_values.items() if nb_repet == 1][0]\n        if max_self_value > max_other_value:\n            return 'Win'\n        if max_self_value < max_other_value:\n            return 'Loss'\n        return 'Tie'\n\n\n    @staticmethod\n    def is_valid(poker_hand):\n        counter_self_values = Counter(poker_hand.card_values)\n        return 4 in counter_self_values.values()\n\n\nclass Straight(HandValue):\n    def compare(self, other):\n        max_self_value = max(self.poker_hand.card_values)\n        max_other_value = max(other.poker_hand.card_values)\n        if max_self_value > max_other_value:\n            return 'Win'\n        if max_self_value < max_other_value:\n            return 'Loss'\n        return 'Tie'\n\n    @staticmethod\n    def is_valid(poker_hand):\n        sorted_values = list(sorted(Card.ORDER.index(card.value) for card in poker_hand.cards))\n        return sorted_values == list(range(sorted_values[0], sorted_values[0] + 5))\n\n\nclass Flush(HandValue):\n    def compare(self, other):\n        return HighCard.compare(self, other)\n\n\n    @staticmethod\n    def is_valid(poker_hand):\n        return poker_hand.is_same_color\n\n\nclass StraightFlush(HandValue):\n    def compare(self, other):\n        max_self_value = max(self.poker_hand.card_values)\n        max_other_value = max(other.poker_hand.card_values)\n        if max_self_value > max_other_value:\n            return 'Win'\n        if max_self_value < max_other_value:\n            return 'Loss'\n        return 'Tie'\n\n    @staticmethod\n    def is_valid(poker_hand):\n        if poker_hand.is_same_color:\n            sorted_values = list(sorted(Card.ORDER.index(card.value) for card in poker_hand.cards))\n            return sorted_values == list(range(sorted_values[0], sorted_values[0] + 5))\n        return False\n\n\nclass PokerHand(object):\n    RESULT = ['Loss', 'Tie', 'Win']\n    HV_ORDER = [HighCard,\n                Pairs,\n                TwoPairs,\n                ThreeOfAKind,\n                Straight,\n                Flush,\n                FullHouse,\n                FourOfAKind,\n                StraightFlush,\n                RoyalFlush]\n\n    def __init__(self, hand):\n        self.cards = tuple(Card(card_str) for card_str in hand.split())\n        self.is_same_color = (len(set(self.card_colors)) == 1)\n        self.hand_value = None\n        for hand_value_cls in reversed(self.HV_ORDER):\n            if hand_value_cls.is_valid(self):\n                # print(\"{} is {}\".format(hand, hand_value_cls.__name__))\n                self.hand_value = hand_value_cls(self)\n                break\n\n    def __str__(self):\n        return \" \".join(map(str, self.cards))\n\n    def compare_with(self, other):\n        print(self.hand_value.pretty_string)\n        print(other.hand_value.pretty_string)\n        if self.HV_ORDER.index(type(self.hand_value)) < self.HV_ORDER.index(type(other.hand_value)):\n            return 'Loss'\n        if self.HV_ORDER.index(type(self.hand_value)) > self.HV_ORDER.index(type(other.hand_value)):\n            return 'Win'\n        return self.hand_value.compare(other.hand_value)\n\n    @property\n    def card_values(self):\n        return tuple(card.value for card in self.cards)\n\n    @property\n    def card_colors(self):\n        return tuple(card.color for card in self.cards)", "class PokerHand(object):\n    def __init__(self, hand):\n        self.hand = hand\n        self.lst = [\"10\" if \"T\" in x else x[0].replace('J', \"11\").replace('Q', \"12\").replace('K', \"13\").replace('A', \"14\") for x in self.hand.split()]\n        \n    def straight(self):\n        return 0 if not ''.join(sorted(self.lst, key=int)) in \"234567891011121314\" else max(list(map(int, self.lst)))\n    \n    def four(self):\n        return 0 if not max([self.lst.count(x) for x in self.lst]) == 4 else [x for x in self.lst if self.lst.count(x) == 4][0]   \n    \n    def full_house(self):\n        return 0 if not len(set(self.lst)) == 2 or self.four() != 0 else [x for x in self.lst if self.lst.count(x) == 3][0]\n    \n    def flush(self):\n        return 0 if not len({x[-1] for x in self.hand.split()}) == 1 or self.full_house() or self.four() else 6\n    \n    def three(self):\n        return 0 if not max([self.lst.count(x) for x in self.lst]) == 3 or self.full_house() else [x for x in self.lst if self.lst.count(x) == 3][0]\n    \n    def two_pair(self):\n        return 0 if not len(set(self.lst)) == 3 or self.three() else max({x for x in self.lst if self.lst.count(x) == 2}, key=int)\n    \n    def pair(self):\n        return 0 if not len(set(self.lst)) == 4 else max({x for x in self.lst if self.lst.count(x) == 2}, key=int)\n     \n    def high(self):\n        return sum(map(int,self.lst))\n    \n    def score(self):\n        out = list(map(int, [min(self.straight(), self.flush()), self.four(), self.full_house(), self.flush(), self.straight(), self.three(), self.two_pair(), self.pair(), self.high()]))\n        b = 14\n        return out[0]*b**8 + out[1]*b**7 + out[2]*b**6 + out[3]*b**5 + out[4]*b**4 + out[5]*b**3 + out[6]*b**2 + out[7]*b**1 + out[8]\n    \n    def final_check(self, other):\n        one, two = [sorted(x, key=int, reverse=True) for x in (self.lst, other.lst)]\n        for i in range(5):\n            if int(one[i])>int(two[i]):\n                return 1\n            if int(two[i])>int(one[i]):\n                return -1\n        return 0\n    \n    \n    def compare_with(self, other):\n        RESULT = [\"Loss\", \"Win\"]\n        if self.score() == other.score() and not self.final_check(other):\n            return \"Tie\"\n        if not self.straight() and not self.flush() and not self.four() and not self.full_house() and not self.flush() and not self.straight() and not self.three() and not self.two_pair() and not self.pair() and not other.straight() and not other.flush() and not other.four() and not other.full_house() and not other.flush() and not other.straight() and not other.three() and not other.two_pair() and not other.pair():\n            return RESULT[self.final_check(other) > 0]\n        return RESULT[self.score() > other.score()]\n", "from collections import Counter\n\nclass PokerHand(object):\n\n    def __init__(self, hand):\n        self.hand = ''.join(hand.split())    \n\n    def evaluate(self):\n\n        HIERARCHY = {'highcard':1, 'pair':2, 'two_pairs':3, 'three_of_aKind':4,\n                    'straight':5, 'flush':6, 'full_house':7, 'four_of_aKind':8,\n                    'straight_flush':9, 'royal_flush':10}\n    \n        PRECEDENCE = {'1':1, '2':2, '3':3, '4':4, '5':5, '6':6, '7':7,\n                    '8':8, '9':9, 'T':10,'J':11, 'Q':12, 'K':13, 'A':14}\n        \n        value = sorted(PRECEDENCE[x] for x in self.hand[::2])\n        shape = self.hand[1::2]\n        \n\n        #royal flush\n        if len(set(shape)) == 1 and value == [10,11,12,13,14]:\n            return HIERARCHY['royal_flush'], value, 'royal_flush'\n        \n        #straight_flush\n        elif len(set(shape)) == 1 and all(abs(value[i] - value[i+1])==1 for i in range(len(value)-1)):\n            return HIERARCHY['straight_flush'], value, 'straight_flush'\n\n        #four of a kind\n        elif any(value.count(x)==4 for x in set(value)):\n            return HIERARCHY['four_of_aKind'], value, 'four_of_aKind'\n        \n        #full house\n        elif any(value.count(x)==3 for x in set(value)) \\\n                            and                         \\\n            any(value.count(x)==2 for x in set(value)):\n            return HIERARCHY['full_house'], value, 'full_house'\n        \n        #flush\n        elif len(set(shape))==1:\n            return HIERARCHY['flush'], value, 'flush'\n        \n\n        #straight\n        elif all(abs(value[i] - value[i+1])==1 for i in range(len(value)-1)):\n            return HIERARCHY['straight'], value, 'straight'\n        \n        #three of a kind\n        elif any(value.count(x)==3 for x in set(value)):\n            return HIERARCHY['three_of_aKind'], value, 'three_of_aKind'\n        \n        #two pairs\n        elif Counter(value).most_common(2)[-1][-1] == 2:\n            return HIERARCHY['two_pairs'], value, 'two_pairs'\n        \n        #pair\n        elif any(value.count(x)==2 for x in set(value)):\n            return HIERARCHY['pair'], value, 'pair'\n        \n        #high Card\n        else:\n            return HIERARCHY['highcard'], value, 'highcard'\n\n\n        \n    def compare_with(self, other):\n        rank, cards, combo = self.evaluate()\n        other_rank, other_cards, other_combo = other.evaluate()\n\n        if rank > other_rank:\n            return 'Win'\n        \n        \n        elif rank == other_rank:\n            if cards == other_cards:\n                return 'Tie'\n            \n\n            elif combo == 'straight_flush' or combo == 'straight':\n                if cards.pop() > other_cards.pop():\n                    return 'Win'\n                else:\n                    return 'Loss'\n\n            \n            elif combo == 'four_of_aKind' or combo == 'full_house':\n                c1, c2 = Counter(cards), Counter(other_cards)\n\n                if c1.most_common()[0][0] > c2.most_common()[0][0]:\n                    return 'Win'\n                elif c1.most_common()[0][0] < c2.most_common()[0][0]:\n                    return 'Loss'\n                else:\n                    if c1.most_common()[-1][0] > c2.most_common()[-1][0]:\n                        return 'Win'\n                    else:\n                        return 'Loss'\n\n            \n\n            elif combo == 'flush':\n                for i in range(4, -1, -1):\n                    if cards[i] < other_cards[i]:\n                        return 'Loss'\n                    else:\n                        if cards[i] != other_cards[i]:\n                            return 'Win'\n            \n\n            elif combo == 'three_of_aKind':\n                for i in range(1,-1,-1):\n                    if cards[i] < other_cards[i]:\n                        return 'Loss'\n                    else:\n                        if cards[i] != other_cards[i]:\n                            return 'Win'\n            \n            elif combo == 'two_pairs' or combo == 'pair':\n                c1,c2 = Counter(cards), Counter(other_cards)\n                sorted_c1 = sorted(c1.most_common(),key=lambda x:(x[1],x))\n                sorted_c2 = sorted(c2.most_common(),key=lambda x:(x[1],x))\n\n                for i in range(len(sorted_c1)-1,-1,-1):\n                    if sorted_c1[i][0] < sorted_c2[i][0]:\n                        return 'Loss'\n                    else:\n                        if sorted_c1[i][0] != sorted_c2[i][0]:\n                            return 'Win'\n            \n            else:\n                for i in range(4,-1,-1):\n                    if cards[i] < other_cards[i]:\n                        return 'Loss'\n                    else:\n                        if cards[i] != other_cards[i]:\n                            return 'Win'\n\n        else:\n            return 'Loss'", "class PokerHand(object):\n\n    def __init__(self, hand):\n        self.hand = hand\n        pass\n    \n    def handProcess(self, handList):\n        suit = handList[0][1]\n        isHandFlush = True\n        \n        seenCards = []\n        seenPairs = []\n        seenTriple = []\n        seenFour = []\n        \n        for card in handList:\n            # Detect flush hand\n            if suit not in card:\n                isHandFlush = False\n            \n            # Replace cards denomination by real value\n            if card[0] == \"T\":\n                handList[handList.index(card)], card = 10, 10\n            elif card[0] == \"J\":\n                handList[handList.index(card)], card = 11, 11\n            elif card[0] == \"Q\":\n                handList[handList.index(card)], card = 12, 12\n            elif card[0] == \"K\":\n                handList[handList.index(card)], card = 13, 13\n            elif card[0] == \"A\":\n                handList[handList.index(card)], card = 14, 14\n            else:\n                 handList[handList.index(card)], card = int(card[0]), int(card[0])\n            \n            # Check pairs, triple and four of a kind\n            if card in seenCards:\n                if card in seenTriple:\n                    seenFour.append(card)\n                    del seenTriple[seenTriple.index(card)]\n                elif card in seenPairs:\n                    seenTriple.append(card)\n                    del seenPairs[seenPairs.index(card)]\n                else:\n                    seenPairs.append(card)\n            seenCards.append(card)\n            \n            \n        # Check if hand is straight\n        handList = sorted(handList)\n        if sum(handList) == (handList[-1]*(handList[-1]+1))/2-((handList[0]-1)*(handList[0])/2):\n            isHandStraight = True\n        else:\n            isHandStraight = False\n                \n        # Store highest card\n        highestCard = handList[-1]\n        \n        # Store highest hand value\n        highestValue = 0\n        \n        # Store highest value after a match\n        cardsOutsideCombination = []\n        \n        # Calculate hand score\n        handScore = 0\n        if highestCard == 14 and isHandStraight and isHandFlush:\n            handScore = 9 # Royal Flush\n        elif isHandStraight and isHandFlush:\n            handScore = 8 # Straight Flush\n            highestValue = highestCard\n        elif len(seenFour) == 1:\n            handScore = 7 # Four of a kind\n            highestValue = seenFour[0]\n            for card in handList:\n                if card not in seenFour:\n                    cardsOutsideCombination.append(card)\n        elif len(seenTriple) == 1 and len(seenPairs) == 1:\n            handScore = 6 # Full House\n            highestValue = seenTriple[0]\n        elif isHandFlush:\n            handScore = 5 # Flush\n        elif isHandStraight:\n            handScore = 4 # Straight\n        elif len(seenTriple) == 1:\n            handScore = 3 # Three of a kind\n            highestValue = seenTriple[0]\n            for card in handList:\n                if card not in seenTriple:\n                    cardsOutsideCombination.append(card)\n        elif len(seenPairs) == 2:\n            handScore = 2 # Two pairs\n            highestValue = sorted(seenPairs)[-1]\n            for card in handList:\n                if card not in seenPairs:\n                    cardsOutsideCombination.append(card)\n        elif len(seenPairs) == 1:\n            handScore = 1 # Pair\n            highestValue = seenPairs[0]\n            for card in handList:\n                if card not in seenPairs:\n                    cardsOutsideCombination.append(card)\n        \n        \n        return (handScore, highestValue, highestCard, cardsOutsideCombination, handList)\n        \n        \n    def compare_with(self, other):\n        hand1 = self.handProcess(self.hand.split())\n        hand2 = self.handProcess(other.hand.split())\n        \n        # Check winner by hand combination score\n        # Then by the value of the card of the combination\n        # Then by the highest card of the hand\n        # Then, iteratively, by the value of the highest card outside the combination\n        # Then, iteratively, by the highest card of the hand when not entirely equal\n        # Else, it's a tie !\n        if hand1[0] > hand2[0]:\n            return \"Win\"\n        elif hand1[0] < hand2[0]:\n            return \"Loss\"\n        elif hand1[1] > hand2[1]:\n            return \"Win\"\n        elif hand1[1] < hand2[1]:\n            return \"Loss\"\n        else:\n            if hand1[2] > hand2[2]:\n                return \"Win\"\n            elif hand1[2] < hand2[2]:\n                return \"Loss\"\n            for card in range(0, len(hand1[3])):\n                if hand1[3][card] > hand2[3][card]:\n                    return \"Win\"\n                elif hand1[3][card] < hand2[3][card]:\n                    return \"Loss\"\n            for card in range(len(hand1[4])-1, -1, -1):\n                if hand1[4][card] > hand2[4][card]:\n                    return \"Win\"\n                elif hand1[4][card] < hand2[4][card]:\n                    return \"Loss\"\n            return \"Tie\"", "class PokerHand(object):\n\n    def __init__(self, hand):\n        self.st = ['2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A']\n        self.h = sorted(hand.split(), key=lambda x: self.st.index(x[0]))\n        self.v=lambda i,j :\"Win\" if self.st.index(i) > self.st.index(j) else 'Loss'\n    \n    def compare_with(self, o):\n        o = sorted(o.h, key=lambda x: self.st.index(x[0]))\n        if o == self.h : return 'Tie'\n        s,s1 = [i[0] for i in o],[i[0] for i in self.h]\n        a = [self.straight_flush, self.four_of_kind, self.full_house, self.flush, self.straight, self.three_of_kind,self.two_pair, self.one_pair]\n        b = [0, 1, 2, self.flush_, self.straight_,5,6, 7]\n        for u, j in enumerate(zip(a, b)):\n            k,l = j[0],j[1]\n            i,j = k(self.h),k(o)\n            if i != j : return 'Win' if i else 'Loss'\n            elif i == j == 1 : \n                if u in [3,4] : return l(s1,s) \n                return self.common(s1, s)\n        for i, j in zip(s1[::-1], s[::-1]):\n            if i != j : return self.v(i,j)\n        return 'Tie'\n    \n    def straight_flush(self, p):\n        return len(set([i[1] for i in p])) == 1 and all(abs(self.st.index(p[i][0]) - self.st.index(p[i + 1][0])) == 1 for i in range(len(p) - 1))\n\n    def four_of_kind(self, p):\n        p = [i[0] for i in p]\n        return any(p.count(i) == 4 for i in p)\n\n    def full_house(self, p):\n        p = [i[0] for i in p]\n        return any(p.count(i) == 3 for i in p) and any(p.count(i) == 2 for i in p)\n\n    def flush(self, p):\n        return len(set([i[1] for i in p])) == 1\n\n    def straight(self, p):\n        return all(abs(self.st.index(p[i][0]) - self.st.index(p[i + 1][0])) == 1 for i in range(len(p) - 1))\n\n    def three_of_kind(self, p):\n        p = [i[0] for i in p]\n        return any(p.count(i) == 3 for i in p)\n\n    def two_pair(self, p):\n        p = [i[0] for i in p]\n        return [p.count(i) for i in set(p)].count(2) == 2\n\n    def one_pair(self, p):\n        p = [i[0] for i in p]\n        return [p.count(i) for i in set(p)].count(2) == 1\n\n    def high_card(self, p):\n        p = [i[0] for i in p]\n        return max(p, key=lambda x: self.st.index(x))\n\n    def straight_flush_(self, i, j):\n        return 'Win' if self.v(i[-1],j[-1]) else 'Loss'\n\n    def common(self,i,j):\n        findi = sorted([k for k in set(i)], key=lambda x: (-i.count(x), -self.st.index(x)))\n        findj = sorted([k for k in set(j)], key=lambda x: (-j.count(x), -self.st.index(x)))\n        for k, l in zip(findi, findj):\n            if k != l : return 'Win' if self.st.index(k) > self.st.index(l) else 'Loss'\n                \n    def flush_(self, i, j):\n        for k, l in zip(i[::-1], j[::-1]):\n            if k != l : return 'Win' if self.st.index(k) > self.st.index(l) else 'Loss'\n\n    def straight_(self, i, j):\n        return 'Tie' if self.st.index(i[-1]) == self.st.index(j[-1]) else 'Win' if self.st.index(i[-1]) > self.st.index(j[-1]) else 'Loss'"]