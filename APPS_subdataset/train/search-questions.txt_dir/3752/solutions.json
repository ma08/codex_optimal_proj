["from functools import reduce\nfrom math import factorial\n\n\ndef value_at(poly, x):\n    return round(sum(n * aCb(x, i) for i, n in enumerate(poly[::-1])), 2)\n\ndef aCb(a, b):\n    return reduce(lambda x, y: x * y, (a - i for i in range(b)), 1) / factorial(b)\n", "def aCb(a, b):\n    result = 1.0\n    for i in range(b):\n        result = result * (a - i) / (i + 1)\n    return result\n\ndef value_at(poly_spec, x):\n    answer = 0\n    l = len(poly_spec)\n    for i, coeff in enumerate(poly_spec):\n        answer += coeff * aCb(x, l - i - 1)\n    return round(answer, 2)", "from math import factorial\nfrom functools import reduce\n\ndef product(seq):\n    return reduce(lambda x,y:x*y, seq) if seq else 1\n\ndef comb(x, r):\n    return product([x - i for i in range(r)]) / factorial(r)\n\ndef value_at(p, x):\n    result = sum(a*comb(x, i) for i, a in enumerate(p[::-1]))\n    \n    return result if isinstance(x, int) else round(result, 2)\n", "def binom(x, k):\n    r = 1\n    for i in range(1, k + 1):\n        r *= (x - i + 1) / i\n    return r\n\ndef value_at(poly_spec, x):\n    r = 0\n    for k, c in enumerate(poly_spec[::-1]):\n        r += c * binom(x, k)\n    return round(r, 2)", "from math import factorial\nfrom functools import lru_cache\n\nfactorial = lru_cache(maxsize=None)(factorial)\n\ndef comb(a, b):\n    if isinstance(a, int):\n        return int(factorial(a) / factorial(b) / factorial(max(0, a - b)))\n    r = 1\n    for i in range(b):\n        r *= a - i\n    return r / factorial(b)\n\ndef value_at(a, n):\n    return round(sum(x * comb(n, i) for i, x in enumerate(a[::-1])), 2)", "def value_at(poly_spec, x):\n    leng = len(poly_spec)\n    ans = 0\n    for i, e in enumerate(poly_spec):\n        temp = 1\n        for j in range(leng-i-1):\n            temp *= (x-j)/(j+1)\n        ans += e*temp\n    return round(ans, 2)", "value_at=lambda p, x: round(sum(map(lambda e: e[1]*c(x,e[0]), enumerate(p[::-1]))), 2)\nc=lambda x,b: 1 if x==b or b<1 else x if b<2 else x*c(x-1,b-1)/b", "def value_at(poly_spec, x):\n    if len(poly_spec) < 2: return poly_spec[0] if poly_spec else 0\n    l = len(poly_spec) - 1\n    m = [co * binomial(x, l - i) for i, co in enumerate(poly_spec[:-1])]\n    return round(float(sum(m) + poly_spec[l]), 2)\n    \ndef factorial(n):\n    return 1 if n < 2 else n * factorial(n - 1)\n    \ndef binomial(a, b): \n    res = 1.0\n    for k in range(b): res *= (a - k)\n    return res / factorial(b)", "def comb(a,b):\n    r=1\n    s=1\n    for i in range(1,b+1):\n        r*=(a-i+1)\n        s*=i\n    return r/s\n\ndef value_at(poly_spec, x):\n    r=0\n    for i,c in enumerate(poly_spec[::-1]):\n        r+=c*comb(x,i)\n    return round(r,2)", "def value_at(p, x):\n    return round(sum(c * choose(x,len(p)-1-i) for i,c in enumerate(p)), 2)\n    \ndef choose(x, k):\n    n,d = 1,1\n    for i in range(k): n, d = n*(x-i), d*(i+1)\n    return n / d"]